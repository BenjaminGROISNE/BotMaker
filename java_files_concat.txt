=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\Main.java
=================================================================================

package com.botmaker;

import com.botmaker.config.ApplicationConfig;
import com.botmaker.di.DependencyContainer;
import com.botmaker.init.AppDependencyConfigurator;
import com.botmaker.init.AppServiceInitializer;
import com.botmaker.project.LibraryManager;
import com.botmaker.project.ProjectConfig;
import com.botmaker.services.CodeEditorService;
import com.botmaker.services.LanguageServerService;
import com.botmaker.ui.ProjectSelectionScreen;
import com.botmaker.ui.UIManager;
import javafx.application.Application;
import javafx.application.Platform;
import javafx.scene.control.Alert;
import javafx.stage.Stage;

import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class Main extends Application {

    private DependencyContainer container;
    private LanguageServerService languageServerService;

    @Override
    public void start(Stage primaryStage) {
        String lastProject = ProjectConfig.getLastOpened();

        // Check if last project exists and auto-load
        if (lastProject != null && projectExists(lastProject)) {
            System.out.println("Auto-loading last project: " + lastProject);
            openProject(primaryStage, lastProject, false);
        } else {
            showProjectSelection(primaryStage);
        }
    }

    private void showProjectSelection(Stage primaryStage) {
        ProjectSelectionScreen selectionScreen = new ProjectSelectionScreen(
                primaryStage,
                (projectName, clearCache) -> openProject(primaryStage, projectName, clearCache)
        );

        primaryStage.setScene(selectionScreen.createScene());
        primaryStage.setTitle("BotMaker - Select Project");
        primaryStage.show();
    }

    private void openProject(Stage primaryStage, String projectName, boolean clearCache) {
        try {
            // 0. Verify Library Integrity
            Path projectPath = Paths.get("projects", projectName);
            LibraryManager libManager = new LibraryManager();
           // boolean repaired = libManager.verifyAndRepair(projectPath);
/*
            if (repaired) {
                System.out.println("Project libraries were repaired/updated.");
            }
*/
            ProjectConfig.updateLastOpened(projectName);
            ApplicationConfig config = ApplicationConfig.forProject(projectName);

            // 1. Configure Container
            container = new DependencyContainer();
            AppDependencyConfigurator.configure(container, config, primaryStage);

            // 2. Handle Cache Flag
            if (clearCache) {
                container.resolve(LanguageServerService.class).setShouldClearCache(true);
            }

            // 3. Initialize Services & Wiring
            AppServiceInitializer.initialize(container);

            // 4. Keep reference for shutdown
            this.languageServerService = container.resolve(LanguageServerService.class);

            // 5. Setup UI
            UIManager uiManager = container.resolve(UIManager.class);
            uiManager.setOnSelectProject(v -> shutdownAndShowSelector(primaryStage));

            primaryStage.setScene(uiManager.createScene());
            primaryStage.setTitle("BotMaker Blocks - " + projectName);

            // 6. Load Code
            container.resolve(CodeEditorService.class).loadInitialCode();

            primaryStage.setOnCloseRequest(e -> {
                e.consume();
                performShutdown();
            });

            primaryStage.show();

        } catch (Exception e) {
            e.printStackTrace();
            showErrorDialog("Error opening project: " + e.getMessage());
            showProjectSelection(primaryStage);
        }
    }

    private void shutdownAndShowSelector(Stage primaryStage) {
        // Non-terminal shutdown (just stop LSP, keep JVM alive)
        if (languageServerService != null) {
            languageServerService.shutdown();
            languageServerService = null;
        }
        showProjectSelection(primaryStage);
    }

    private void performShutdown() {
        new Thread(() -> {
            try {
                if (languageServerService != null) {
                    System.out.println("Shutting down Language Server...");
                    languageServerService.shutdown();
                }
            } catch (Exception ex) {
                System.err.println("Error during shutdown: " + ex.getMessage());
            } finally {
                Platform.runLater(() -> {
                    Platform.exit();
                    System.exit(0);
                });
            }
        }).start();
    }

    private boolean projectExists(String projectName) {
        return Files.exists(Paths.get("projects", projectName)) &&
                Files.exists(Paths.get("projects", projectName, "build.gradle"));
    }

    private void showErrorDialog(String message) {
        Alert alert = new Alert(Alert.AlertType.ERROR);
        alert.setTitle("Error");
        alert.setHeaderText("Failed to open project");
        alert.setContentText(message);
        alert.showAndWait();
    }

    public static void main(String[] args) {
        launch(args);
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\blocks\AssignmentBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractStatementBlock;
import com.botmaker.core.ExpressionBlock;
import com.botmaker.lsp.CompletionContext;
import com.botmaker.ui.builders.BlockLayout;
import com.botmaker.ui.components.SelectorComponents;
import com.botmaker.util.TypeInfo;
import javafx.scene.Node;
import org.eclipse.jdt.core.dom.*;

public class AssignmentBlock extends AbstractStatementBlock {

    private ExpressionBlock leftHandSide;
    private ExpressionBlock rightHandSide;
    private String operator;

    private static final String[] OPERATOR_NAMES = {
            "set to", "add", "subtract", "multiply by", "divide by", "increment", "decrement"
    };

    private static final String[] OPERATOR_SYMBOLS = {
            "=", "+=", "-=", "*=", "/=", "++", "--"
    };

    public AssignmentBlock(String id, ExpressionStatement astNode) {
        super(id, astNode);
        initializeOperator(astNode);
    }

    private void initializeOperator(ExpressionStatement astNode) {
        if (astNode.getExpression() instanceof Assignment) {
            this.operator = ((Assignment) astNode.getExpression()).getOperator().toString();
        } else if (astNode.getExpression() instanceof PostfixExpression) {
            this.operator = ((PostfixExpression) astNode.getExpression()).getOperator().toString();
        } else if (astNode.getExpression() instanceof PrefixExpression) {
            this.operator = ((PrefixExpression) astNode.getExpression()).getOperator().toString();
        } else {
            this.operator = "=";
        }
    }

    public void setLeftHandSide(ExpressionBlock leftHandSide) { this.leftHandSide = leftHandSide; }
    public void setRightHandSide(ExpressionBlock rightHandSide) { this.rightHandSide = rightHandSide; }

    @Override
    protected Node createUINode(CompletionContext context) {
        var sentenceBuilder = BlockLayout.sentence()
                .addNode(leftHandSide != null ? leftHandSide.getUINode(context) : createExpressionDropZone(context))
                .addOperatorSelector(
                        OPERATOR_NAMES,
                        OPERATOR_SYMBOLS,
                        operator,
                        newOperator -> {
                            this.operator = newOperator;
                            if (this.astNode instanceof ExpressionStatement) {
                                Expression expr = ((ExpressionStatement) this.astNode).getExpression();
                                context.codeEditor().updateAssignmentOperator(expr, newOperator);
                            }
                        }
                );

        // Right hand side (only for non-increment/decrement)
        if (!operator.equals("++") && !operator.equals("--")) {
            sentenceBuilder
                    .addNode(rightHandSide != null ? rightHandSide.getUINode(context) : createExpressionDropZone(context))
                    .addNode(createAddButton(e -> showExpressionMenu((javafx.scene.control.Button) e.getSource(), context)));
        }

        return BlockLayout.header()
                .withCustomNode(sentenceBuilder.build())
                .withDeleteButton(() -> context.codeEditor().deleteStatement((Statement) this.astNode))
                .build();
    }

    private void showExpressionMenu(javafx.scene.control.Button button, CompletionContext context) {
        // UPDATED: Use TypeInfo instead of string types
        TypeInfo targetType = TypeInfo.UNKNOWN;

        if (leftHandSide != null && leftHandSide.getAstNode() != null) {
            Expression lhsExpr = (org.eclipse.jdt.core.dom.Expression) leftHandSide.getAstNode();
            org.eclipse.jdt.core.dom.ITypeBinding binding = lhsExpr.resolveTypeBinding();
            if (binding != null) {
                targetType = TypeInfo.from(binding);
            }
        }

        org.eclipse.jdt.core.dom.Expression toReplace = null;
        if (rightHandSide != null) {
            toReplace = (org.eclipse.jdt.core.dom.Expression) rightHandSide.getAstNode();
        }

        showExpressionMenuAndReplace(button, context, targetType, toReplace);
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\blocks\BinaryExpressionBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractExpressionBlock;
import com.botmaker.core.ExpressionBlock;
import com.botmaker.lsp.CompletionContext;
import com.botmaker.util.TypeInfo;
import javafx.scene.Node;
import javafx.scene.control.Button;
import javafx.scene.layout.HBox;
import org.eclipse.jdt.core.dom.ITypeBinding;
import org.eclipse.jdt.core.dom.InfixExpression;
import org.eclipse.jdt.core.dom.Expression;

import static com.botmaker.ui.components.BlockUIComponents.createChangeButton;

public class BinaryExpressionBlock extends AbstractExpressionBlock {

    private ExpressionBlock leftOperand;
    private ExpressionBlock rightOperand;
    private String operator;
    private final ITypeBinding returnType;

    private static final String[] MATH_OPERATOR_NAMES = { "plus", "minus", "times", "divided by", "modulo" };
    private static final String[] MATH_OPERATOR_SYMBOLS = { "+", "-", "*", "/", "%" };

    public BinaryExpressionBlock(String id, InfixExpression astNode) {
        super(id, astNode);
        this.operator = astNode.getOperator().toString();
        this.returnType = astNode.resolveTypeBinding();
    }

    public void setLeftOperand(ExpressionBlock leftOperand) { this.leftOperand = leftOperand; }
    public void setRightOperand(ExpressionBlock rightOperand) { this.rightOperand = rightOperand; }

    @Override
    protected Node createUINode(CompletionContext context) {
        HBox container = new HBox(5);
        container.setAlignment(javafx.geometry.Pos.CENTER_LEFT);

        HBox expressionBox = new HBox(5);
        expressionBox.setAlignment(javafx.geometry.Pos.CENTER_LEFT);

        // Left operand + Change Button
        if (leftOperand != null) {
            expressionBox.getChildren().add(leftOperand.getUINode(context));
            javafx.scene.control.Button changeLeft = createChangeButton(e ->
                    showExpressionMenuAndReplace((Button)e.getSource(), context, TypeInfo.INT,
                            (Expression) leftOperand.getAstNode())
            );
            changeLeft.setStyle("-fx-font-size: 8px; -fx-padding: 1px 3px;");
            expressionBox.getChildren().add(changeLeft);
        }

        // Operator Selector
        if (isMathOperator(operator)) {
            javafx.scene.control.ComboBox<String> selector = createOperatorSelector(
                    MATH_OPERATOR_NAMES,
                    MATH_OPERATOR_SYMBOLS,
                    operator,
                    newOp -> {
                        this.operator = newOp;
                        context.codeEditor().updateBinaryOperator((InfixExpression) this.astNode, newOp);
                    }
            );
            expressionBox.getChildren().add(selector);
        } else {
            expressionBox.getChildren().add(createOperatorLabel(operator));
        }

        // Right operand + Change Button
        if (rightOperand != null) {
            expressionBox.getChildren().add(rightOperand.getUINode(context));
            javafx.scene.control.Button changeRight = createChangeButton(e ->
                    showExpressionMenuAndReplace((Button)e.getSource(), context, TypeInfo.INT,
                            (Expression) rightOperand.getAstNode())
            );
            changeRight.setStyle("-fx-font-size: 8px; -fx-padding: 1px 3px;");
            expressionBox.getChildren().add(changeRight);
        }

        container.getChildren().add(expressionBox);

        // Type indicator
        String typeName = (returnType != null) ? returnType.getName() : "unknown";
        javafx.scene.control.Label typeLabel = new javafx.scene.control.Label("→ " + typeName);
        typeLabel.setStyle("-fx-font-style: italic; -fx-text-fill: #999; -fx-font-size: 10px;");
        container.getChildren().add(typeLabel);

        return container;
    }

    private boolean isMathOperator(String op) {
        for (String mathOp : MATH_OPERATOR_SYMBOLS) {
            if (mathOp.equals(op)) return true;
        }
        return false;
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\blocks\BooleanLiteralBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractExpressionBlock;
import com.botmaker.lsp.CompletionContext;
import com.botmaker.ui.theme.StyleBuilder;
import javafx.geometry.Pos;
import javafx.scene.Node;
import javafx.scene.control.Label;
import javafx.scene.layout.StackPane;
import org.eclipse.jdt.core.dom.BooleanLiteral;
import org.eclipse.jdt.core.dom.Expression;

/**
 * Block for true/false values with toggle switch style UI.
 * Directly toggles on click.
 */
public class BooleanLiteralBlock extends AbstractExpressionBlock {

    private boolean value;

    public BooleanLiteralBlock(String id, BooleanLiteral astNode) {
        super(id, astNode);
        this.value = astNode.booleanValue();
    }

    public boolean getValue() {
        return value;
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        StackPane root = new StackPane();
        root.getStyleClass().add("boolean-literal-block");

        // Visible pill label
        Label displayLabel = new Label(value ? "TRUE" : "FALSE");

        // Apply initial styles
        updateLabelStyle(displayLabel, value);

        StackPane.setAlignment(displayLabel, Pos.CENTER);

        // Handle toggle on click
        root.setOnMouseClicked(e -> {
            boolean newValue = !value;
            this.value = newValue;

            // Immediate UI feedback
            displayLabel.setText(newValue ? "TRUE" : "FALSE");
            updateLabelStyle(displayLabel, newValue);

            // Update AST
            context.codeEditor().replaceLiteralValue(
                    (Expression) this.astNode,
                    String.valueOf(newValue)
            );
        });

        root.getChildren().add(displayLabel);
        root.setMinWidth(60);
        root.setMaxHeight(24);

        // Show hand cursor to indicate interactivity
        root.setCursor(javafx.scene.Cursor.HAND);

        return root;
    }

    private void updateLabelStyle(Label label, boolean val) {
        String trueColor = "#2ecc71";  // Emerald Green
        String falseColor = "#e74c3c"; // Alizarin Red
        String color = val ? trueColor : falseColor;

        StyleBuilder.create()
                .textColor("white")
                .fontWeight("bold")
                .fontSize(11)
                .fontFamily("'Segoe UI', sans-serif")
                .padding(3, 10, 3, 10)
                .backgroundColor(color)
                .backgroundRadius(12)
                .cursor("hand")
                .applyTo(label);
    }

    @Override
    public String getDetails() {
        return "Boolean: " + value;
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\blocks\BreakBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractStatementBlock;
import com.botmaker.lsp.CompletionContext;
import com.botmaker.ui.builders.BlockLayout;
import javafx.scene.Node;
import org.eclipse.jdt.core.dom.BreakStatement;

public class BreakBlock extends AbstractStatementBlock {

    public BreakBlock(String id, BreakStatement astNode) {
        super(id, astNode);
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        return BlockLayout.header()
                .withKeyword("break")
                .withDeleteButton(() -> context.codeEditor().deleteStatement((org.eclipse.jdt.core.dom.Statement) this.astNode))
                .build();
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\blocks\ClassBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractCodeBlock;
import com.botmaker.core.BlockWithChildren;
import com.botmaker.core.CodeBlock;
import com.botmaker.lsp.CompletionContext;
import com.botmaker.ui.BlockDragAndDropManager;
import com.botmaker.parser.BlockIdPrefix;
import javafx.geometry.Insets;
import javafx.scene.Node;
import javafx.scene.control.Label;
import javafx.scene.layout.Region;
import javafx.scene.layout.VBox;
import org.eclipse.jdt.core.dom.*;

import java.util.ArrayList;
import java.util.List;

public class ClassBlock extends AbstractCodeBlock implements BlockWithChildren {

    private final String className;
    // Changed from List<MethodDeclarationBlock> to generic CodeBlock to hold Enums too
    private final List<CodeBlock> bodyDeclarations = new ArrayList<>();
    private final BlockDragAndDropManager dragAndDropManager;

    public ClassBlock(String id, TypeDeclaration astNode, BlockDragAndDropManager manager) {
        super(id, astNode);
        this.className = astNode.getName().getIdentifier();
        this.dragAndDropManager = manager;
    }

    public void addBodyDeclaration(CodeBlock block) {
        bodyDeclarations.add(block);
    }

    @Override
    public List<CodeBlock> getChildren() {
        return new ArrayList<>(bodyDeclarations);
    }

    // ClassBlock.java - keep mostly as is, use sentence for separators
    @Override
    protected Node createUINode(CompletionContext context) {
        VBox container = new VBox(10);
        container.setPadding(new Insets(15));

        container.setStyle(
                "-fx-background-color: linear-gradient(to bottom, #ecf0f1 0%, #bdc3c7 100%);" +
                        "-fx-border-color: #34495e;" +
                        "-fx-border-width: 3px;" +
                        "-fx-border-radius: 10px;" +
                        "-fx-background-radius: 10px;"
        );

        Label header = new Label("Class: " + className);
        header.setStyle("-fx-font-size: 20px; -fx-font-weight: bold; -fx-text-fill: #2c3e50; -fx-padding: 0 0 15 0;");
        container.getChildren().add(header);

        // Top separator
        container.getChildren().add(createClassMemberSeparator(context, 0));

        for (int i = 0; i < bodyDeclarations.size(); i++) {
            CodeBlock block = bodyDeclarations.get(i);
            container.getChildren().add(block.getUINode(context));
            container.getChildren().add(createClassMemberSeparator(context, i + 1));
        }

        return container;
    }

    private Region createClassMemberSeparator(CompletionContext context, int insertIndex) {
        Region separator = new Region();
        separator.setMinHeight(30);
        separator.setMaxHeight(30);

        separator.setStyle(
                "-fx-background-color: rgba(52, 73, 94, 0.15);" +
                        "-fx-border-color: rgba(52, 73, 94, 0.4);" +
                        "-fx-border-width: 2px 0 2px 0;" +
                        "-fx-border-style: dashed;" +
                        "-fx-cursor: hand;"
        );

        context.dragAndDropManager().addClassMemberDropHandlers(separator, this, insertIndex);

        separator.setOnMouseEntered(e -> separator.setStyle("-fx-background-color: rgba(142, 68, 173, 0.3); -fx-border-color: #8E44AD; -fx-border-width: 3px 0 3px 0; -fx-border-style: solid;"));
        separator.setOnMouseExited(e -> separator.setStyle("-fx-background-color: rgba(52, 73, 94, 0.15); -fx-border-color: rgba(52, 73, 94, 0.4); -fx-border-width: 2px 0 2px 0; -fx-border-style: dashed;"));

        return separator;
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\blocks\CommentBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractStatementBlock;
import com.botmaker.lsp.CompletionContext;
import com.botmaker.ui.builders.BlockLayout;
import com.botmaker.ui.components.TextFieldComponents;
import javafx.scene.Node;
import javafx.scene.control.Label;
import javafx.scene.control.TextField;
import org.eclipse.jdt.core.dom.Comment;

public class CommentBlock extends AbstractStatementBlock {

    private String commentText;

    public CommentBlock(String id, Comment astNode, String commentText) {
        super(id, astNode);
        this.commentText = commentText;
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        Label commentLabel = new Label("Comment:");
        commentLabel.getStyleClass().add("comment-indicator");

        TextField commentField = TextFieldComponents.createCommentField(
                commentText,
                "Write your note here...",
                newText -> {
                    if (!newText.equals(commentText)) {
                        this.commentText = newText;
                        javafx.application.Platform.runLater(() -> {
                            context.codeEditor().updateComment((Comment) this.astNode, this.commentText);
                        });
                    }
                }
        );

        var sentence = BlockLayout.sentence()
                .addNode(commentLabel)
                .addNode(commentField)
                .build();

        return BlockLayout.header()
                .withCustomNode(sentence)
                .withDeleteButton(() -> context.codeEditor().deleteStatement((org.eclipse.jdt.core.dom.Statement) this.astNode))
                .build();
    }

    @Override
    public String getDetails() {
        return "Comment: " + (commentText != null ? commentText : "");
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\blocks\ComparisonExpressionBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractExpressionBlock;
import com.botmaker.core.ExpressionBlock;
import com.botmaker.lsp.CompletionContext;
import com.botmaker.ui.builders.BlockLayout;
import com.botmaker.ui.components.BlockUIComponents;
import com.botmaker.util.TypeInfo;
import javafx.scene.Node;
import javafx.scene.control.Button;
import org.eclipse.jdt.core.dom.Expression;
import org.eclipse.jdt.core.dom.ITypeBinding;
import org.eclipse.jdt.core.dom.InfixExpression;

public class ComparisonExpressionBlock extends AbstractExpressionBlock {

    private ExpressionBlock leftOperand;
    private ExpressionBlock rightOperand;
    private String operator;
    private final ITypeBinding returnType;

    // Operator display names
    private static final String[] OPERATOR_NAMES = {
            "less than", "less than or equal", "greater than", "greater than or equal",
            "equal to", "not equal to", "AND (&&)", "OR (||)"
    };

    // Java operators
    private static final String[] OPERATOR_SYMBOLS = {
            "<", "<=", ">", ">=", "==", "!=", "&&", "||"
    };

    public ComparisonExpressionBlock(String id, InfixExpression astNode) {
        super(id, astNode);
        this.operator = astNode.getOperator().toString();
        this.returnType = astNode.resolveTypeBinding();
    }

    public void setLeftOperand(ExpressionBlock leftOperand) { this.leftOperand = leftOperand; }
    public void setRightOperand(ExpressionBlock rightOperand) { this.rightOperand = rightOperand; }

    @Override
    protected Node createUINode(CompletionContext context) {
        // 1. Determine Input Types based on Operator
        TypeInfo operandType;
        if ("&&".equals(operator) || "||".equals(operator)) {
            operandType = TypeInfo.BOOLEAN;
        } else if ("==".equals(operator) || "!=".equals(operator)) {
            operandType = TypeInfo.UNKNOWN; // Equality checks anything
        } else {
            operandType = TypeInfo.INT;     // Comparison (<, >) requires numbers (defaulting to INT context)
        }

        final TypeInfo targetType = operandType;

        // 2. Build Sentence with explicit Change Buttons
        var sentence = BlockLayout.sentence();

        // Left Operand
        sentence.addExpressionSlot(leftOperand, context, targetType);
        sentence.addNode(BlockUIComponents.createChangeButton(e ->
                showExpressionMenuAndReplace((Button)e.getSource(), context, targetType,
                        leftOperand != null ? (Expression) leftOperand.getAstNode() : null)
        ));

        // Operator
        sentence.addOperatorSelector(OPERATOR_NAMES, OPERATOR_SYMBOLS, operator, newOp -> {
            this.operator = newOp;
            if (this.astNode instanceof InfixExpression) {
                context.codeEditor().updateBinaryOperator((InfixExpression) this.astNode, newOp);
            }
        });

        // Right Operand
        sentence.addExpressionSlot(rightOperand, context, targetType);
        sentence.addNode(BlockUIComponents.createChangeButton(e ->
                showExpressionMenuAndReplace((Button)e.getSource(), context, targetType,
                        rightOperand != null ? (Expression) rightOperand.getAstNode() : null)
        ));

        Node root = sentence.build();

        // 3. Styling
        if ("&&".equals(operator) || "||".equals(operator)) {
            root.getStyleClass().add("logic-expression-block");
        } else {
            root.getStyleClass().add("comparison-expression-block");
        }

        return root;
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\blocks\ContinueBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractStatementBlock;
import com.botmaker.lsp.CompletionContext;
import com.botmaker.ui.builders.BlockLayout;
import javafx.scene.Node;
import org.eclipse.jdt.core.dom.ContinueStatement;

public class ContinueBlock extends AbstractStatementBlock {

    public ContinueBlock(String id, ContinueStatement astNode) {
        super(id, astNode);
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        return BlockLayout.header()
                .withKeyword("continue")
                .withDeleteButton(() -> context.codeEditor().deleteStatement((org.eclipse.jdt.core.dom.Statement) this.astNode))
                .build();
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\blocks\DeclareClassVariableBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractStatementBlock;
import com.botmaker.core.ExpressionBlock;
import com.botmaker.lsp.CompletionContext;
import com.botmaker.ui.builders.BlockLayout;
import com.botmaker.ui.components.BlockUIComponents;
import com.botmaker.ui.components.TextFieldComponents;
import com.botmaker.util.TypeInfo;
import com.botmaker.util.TypeManager;
import javafx.geometry.Pos;
import javafx.scene.Cursor;
import javafx.scene.Node;
import javafx.scene.control.*;
import javafx.scene.layout.HBox;
import javafx.scene.layout.VBox;
import org.eclipse.jdt.core.dom.*;

import java.util.ArrayList;
import java.util.List;

import static com.botmaker.ui.components.BlockUIComponents.createTypeLabel;

/**
 * Represents a class-level field declaration (instance or static variable).
 *
 * UPDATED: Uses TypeInfo for type operations
 */
public class DeclareClassVariableBlock extends AbstractStatementBlock {

    private final String variableName;
    private final Type variableType;
    private final boolean isStatic;
    private final boolean isPrivate;
    private ExpressionBlock initializer;

    public DeclareClassVariableBlock(String id, FieldDeclaration astNode) {
        super(id, astNode);
        VariableDeclarationFragment fragment = (VariableDeclarationFragment) astNode.fragments().get(0);
        this.variableName = fragment.getName().getIdentifier();
        this.variableType = astNode.getType();
        this.isStatic = Modifier.isStatic(astNode.getModifiers());
        this.isPrivate = Modifier.isPrivate(astNode.getModifiers());
        this.initializer = null;
    }

    public void setInitializer(ExpressionBlock initializer) {
        this.initializer = initializer;
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        VBox container = new VBox(5);
        container.setStyle(
                "-fx-background-color: linear-gradient(to right, #F39C12 0%, #E67E22 100%);" +
                        "-fx-background-radius: 6;" +
                        "-fx-padding: 10;" +
                        "-fx-border-color: rgba(0,0,0,0.1);" +
                        "-fx-border-width: 1;" +
                        "-fx-border-radius: 6;"
        );

        Label modifiersLabel = new Label((isPrivate ? "Private" : "Public") + (isStatic ? " Static" : "") + " Field");
        modifiersLabel.setStyle("-fx-text-fill: white; -fx-font-weight: bold; -fx-font-size: 10px;");

        Label typeLabel = createTypeLabel(variableType.toString());
        typeLabel.setCursor(Cursor.HAND);
        Tooltip.install(typeLabel, new Tooltip("Click to change type"));
        typeLabel.setOnMouseClicked(e -> showTypeMenu(typeLabel, context));

        TextField nameField = TextFieldComponents.createVariableNameField(variableName, newName -> {
            FieldDeclaration fieldDecl = (FieldDeclaration) this.astNode;
            VariableDeclarationFragment fragment = (VariableDeclarationFragment) fieldDecl.fragments().get(0);
            if (!newName.equals(variableName) && !newName.isEmpty()) {
                context.codeEditor().replaceSimpleName(fragment.getName(), newName);
            }
        });

        // UPDATED: Use TypeInfo instead of determineUiType
        TypeInfo fieldType = TypeInfo.from(variableType);

        var mainRowBuilder = BlockLayout.sentence()
                .addNode(typeLabel)
                .addNode(nameField);

        if (initializer == null) {
            Button setValueBtn = new Button("Set Value");
            setValueBtn.setStyle(
                    "-fx-background-color: rgba(255,255,255,0.3);" +
                            "-fx-text-fill: white;" +
                            "-fx-font-weight: bold;" +
                            "-fx-font-size: 11px;" +
                            "-fx-padding: 4 12 4 12;" +
                            "-fx-background-radius: 4;" +
                            "-fx-cursor: hand;"
            );
            setValueBtn.setOnAction(e -> {
                context.codeEditor().setFieldInitializerToDefault(
                        (FieldDeclaration) this.astNode, fieldType);
            });
            mainRowBuilder.addNode(setValueBtn);
        } else {
            Node initNode = (initializer instanceof ListBlock) ?
                    initializer.getUINode(context) :
                    (initializer.getAstNode() instanceof org.eclipse.jdt.core.dom.ArrayInitializer) ?
                            createListDisplay(context) : initializer.getUINode(context);

            Button addButton = createAddButton(e -> {
                Expression currentInitializer = (Expression) initializer.getAstNode();
                ContextMenu menu = BlockUIComponents.createExpressionTypeMenu(fieldType, type -> {
                    context.codeEditor().replaceExpression(currentInitializer, type);
                });
                menu.show((Button)e.getSource(), javafx.geometry.Side.BOTTOM, 0, 0);
            });

            mainRowBuilder
                    .addKeyword("=")
                    .addNode(initNode)
                    .addNode(addButton);
        }

        HBox mainRow = mainRowBuilder.build();

        Button deleteBtn = createDeleteButton(context);
        deleteBtn.setStyle("-fx-background-color: transparent; -fx-text-fill: white; -fx-font-size: 14px; -fx-padding: 0; -fx-cursor: hand;");

        HBox headerRow = new HBox(10);
        headerRow.setAlignment(Pos.CENTER_LEFT);
        headerRow.getChildren().addAll(modifiersLabel, BlockUIComponents.createSpacer(), deleteBtn);

        container.getChildren().addAll(headerRow, mainRow);

        return container;
    }

    private void showTypeMenu(Node anchor, CompletionContext context) {
        ContextMenu menu = new ContextMenu();
        String currentStr = variableType.toString();
        boolean isArray = variableType.isArrayType();

        // 1. Add/Remove Dimension Logic
        MenuItem addDim = new MenuItem("Add Dimension []");
        addDim.setOnAction(e -> {
            String newType = currentStr + "[]";
            context.codeEditor().replaceFieldType((FieldDeclaration) this.astNode, newType);
        });
        menu.getItems().add(addDim);

        if (isArray) {
            MenuItem removeDim = new MenuItem("Remove Dimension []");
            removeDim.setOnAction(e -> {
                if (currentStr.endsWith("[]")) {
                    String newType = currentStr.substring(0, currentStr.length() - 2);
                    context.codeEditor().replaceFieldType((FieldDeclaration) this.astNode, newType);
                }
            });
            menu.getItems().add(removeDim);
        }

        menu.getItems().add(new SeparatorMenuItem());

        // 2. Change Base Type
        Menu changeBaseMenu = new Menu("Change Base Type");

        for (String type : TypeManager.getFundamentalTypeNames()) {
            MenuItem item = new MenuItem(type);
            item.setOnAction(e -> {
                String newType = preserveDimensions(currentStr, type);
                context.codeEditor().replaceFieldType((FieldDeclaration) this.astNode, newType);
            });
            changeBaseMenu.getItems().add(item);
        }

        List<String> availableEnums = getAvailableEnums(context);
        if (!availableEnums.isEmpty()) {
            changeBaseMenu.getItems().add(new SeparatorMenuItem());
            for (String enumName : availableEnums) {
                MenuItem item = new MenuItem(enumName);
                item.setOnAction(e -> {
                    String newType = preserveDimensions(currentStr, enumName);
                    context.codeEditor().replaceFieldType((FieldDeclaration) this.astNode, newType);
                });
                changeBaseMenu.getItems().add(item);
            }
        }
        menu.getItems().add(changeBaseMenu);

        menu.show(anchor, javafx.geometry.Side.BOTTOM, 0, 0);
    }

    private String preserveDimensions(String oldType, String newBase) {
        // UPDATED: Use TypeInfo for dimension counting
        TypeInfo type = TypeInfo.from(oldType);
        int dims = type.getArrayDimensions();
        return newBase + "[]".repeat(dims);
    }

    private HBox createListDisplay(CompletionContext context) {
        HBox listBox = new HBox(3);
        listBox.setAlignment(Pos.CENTER_LEFT);
        listBox.getStyleClass().add("inline-list-display");

        Label open = new Label("["); open.setStyle("-fx-font-weight: bold; -fx-font-size: 14px; -fx-text-fill: white;");
        Label close = new Label("]"); close.setStyle("-fx-font-weight: bold; -fx-font-size: 14px; -fx-text-fill: white;");

        listBox.getChildren().addAll(open, initializer.getUINode(context), close);
        return listBox;
    }

    private List<String> getAvailableEnums(CompletionContext context) {
        List<String> enumNames = new ArrayList<>();
        CompilationUnit cu = context.applicationState().getCompilationUnit().orElse(null);
        if (cu == null) return enumNames;

        if (!cu.types().isEmpty() && cu.types().get(0) instanceof TypeDeclaration) {
            TypeDeclaration typeDecl = (TypeDeclaration) cu.types().get(0);
            for (Object obj : typeDecl.bodyDeclarations()) {
                if (obj instanceof EnumDeclaration) {
                    EnumDeclaration enumDecl = (EnumDeclaration) obj;
                    enumNames.add(enumDecl.getName().getIdentifier());
                }
            }
        }
        return enumNames;
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\blocks\DeclareEnumBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractStatementBlock;
import com.botmaker.lsp.CompletionContext;
import com.botmaker.ui.builders.BlockLayout;
import com.botmaker.ui.components.BlockUIComponents;
import com.botmaker.ui.components.TextFieldComponents;
import javafx.geometry.Pos;
import javafx.scene.Node;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.control.TextField;
import javafx.scene.layout.HBox;
import javafx.scene.layout.VBox;
import org.eclipse.jdt.core.dom.*;

import java.util.ArrayList;
import java.util.List;

public class DeclareEnumBlock extends AbstractStatementBlock {

    private final String enumName;
    private final List<String> constants;
    private final EnumDeclaration enumDeclaration;
    private final boolean isStatement; // True if inside a method, False if inside a class

    // Constructor 1: Inside a Method (Wrapped in TypeDeclarationStatement)
    public DeclareEnumBlock(String id, TypeDeclarationStatement astNode) {
        super(id, astNode);
        if (astNode.getDeclaration() instanceof EnumDeclaration) {
            this.enumDeclaration = (EnumDeclaration) astNode.getDeclaration();
            this.isStatement = true;
        } else {
            throw new IllegalArgumentException("Statement is not an EnumDeclaration");
        }
        this.enumName = enumDeclaration.getName().getIdentifier();
        this.constants = extractConstants(enumDeclaration);
    }

    // Constructor 2: Inside a Class (Raw EnumDeclaration)
    public DeclareEnumBlock(String id, EnumDeclaration astNode) {
        super(id, astNode); // We pass it as ASTNode, AbstractStatementBlock handles generic ASTNode
        this.enumDeclaration = astNode;
        this.isStatement = false;
        this.enumName = astNode.getName().getIdentifier();
        this.constants = extractConstants(astNode);
    }

    private List<String> extractConstants(EnumDeclaration decl) {
        List<String> list = new ArrayList<>();
        for (Object obj : decl.enumConstants()) {
            if (obj instanceof EnumConstantDeclaration) {
                list.add(((EnumConstantDeclaration) obj).getName().getIdentifier());
            }
        }
        return list;
    }

    // DeclareEnumBlock.java
    @Override
    protected Node createUINode(CompletionContext context) {
        VBox container = new VBox(5);
        container.setStyle("-fx-background-color: #d35400; -fx-background-radius: 5; -fx-padding: 5;");

        // --- Header ---
        Label label = BlockUIComponents.createKeywordLabel("Enum");
        label.setStyle("-fx-text-fill: white; -fx-font-weight: bold;");

        TextField nameField = TextFieldComponents.createVariableNameField(enumName, newName -> {
            if (!newName.equals(enumName) && !newName.isEmpty()) {
                context.codeEditor().renameEnum(enumDeclaration, newName);
            }
        });

        Button addConstantBtn = new Button("+ Add Value");
        addConstantBtn.setStyle("-fx-font-size: 10px;");
        addConstantBtn.setOnAction(e -> context.codeEditor().addEnumConstant(enumDeclaration, "NEW_VALUE"));

        var headerSentence = BlockLayout.sentence()
                .addNode(label)
                .addNode(nameField)
                .addNode(addConstantBtn)
                .build();

        Runnable deleteAction = () -> {
            if (isStatement) {
                context.codeEditor().deleteStatement((Statement) this.astNode);
            } else {
                context.codeEditor().deleteEnumFromClass(enumDeclaration);
            }
        };

        HBox headerWrapper = BlockUIComponents.createHeaderRow(deleteAction, headerSentence);
        container.getChildren().add(headerWrapper);

        // --- Constants List ---
        if (!constants.isEmpty()) {
            VBox constantsBox = new VBox(2);
            constantsBox.setStyle("-fx-padding: 5 0 5 20;");

            for (int i = 0; i < constants.size(); i++) {
                String constant = constants.get(i);
                final int index = i;

                TextField constField = new TextField(constant);
                constField.setPrefWidth(120);
                constField.setStyle("-fx-background-color: rgba(255,255,255,0.9);");

                constField.focusedProperty().addListener((obs, oldVal, newVal) -> {
                    if (!newVal) {
                        String val = constField.getText();
                        if (!val.equals(constant) && !val.isEmpty()) {
                            context.codeEditor().renameEnumConstant(enumDeclaration, index, val);
                        }
                    }
                });

                Button deleteBtn = new Button("×");
                deleteBtn.setStyle("-fx-background-color: transparent; -fx-text-fill: white; -fx-font-weight: bold; -fx-cursor: hand;");
                deleteBtn.setOnAction(e -> context.codeEditor().deleteEnumConstant(enumDeclaration, index));

                HBox row = BlockLayout.sentence()
                        .addNode(constField)
                        .addNode(deleteBtn)
                        .build();

                constantsBox.getChildren().add(row);
            }
            container.getChildren().add(constantsBox);
        }

        return container;
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\blocks\DoWhileBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractStatementBlock;
import com.botmaker.core.BodyBlock;
import com.botmaker.core.BlockWithChildren;
import com.botmaker.core.CodeBlock;
import com.botmaker.core.ExpressionBlock;
import com.botmaker.lsp.CompletionContext;
import com.botmaker.ui.BlockDragAndDropManager;
import com.botmaker.ui.builders.BlockLayout;
import com.botmaker.util.TypeInfo;
import javafx.scene.Node;
import javafx.scene.control.Button;
import javafx.scene.layout.HBox;
import javafx.scene.layout.VBox;
import org.eclipse.jdt.core.dom.DoStatement;
import org.eclipse.jdt.core.dom.Expression;
import org.eclipse.jdt.core.dom.Statement;

import java.util.ArrayList;
import java.util.List;

public class DoWhileBlock extends AbstractStatementBlock implements BlockWithChildren {

    private ExpressionBlock condition;
    private BodyBlock body;

    public DoWhileBlock(String id, DoStatement astNode, BlockDragAndDropManager dragAndDropManager) {
        super(id, astNode);
    }

    public void setCondition(ExpressionBlock condition) { this.condition = condition; }
    public void setBody(BodyBlock body) { this.body = body; }

    @Override
    public List<CodeBlock> getChildren() {
        List<CodeBlock> children = new ArrayList<>();
        if (body != null) children.add(body);
        if (condition != null) children.add(condition);
        return children;
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        VBox container = new VBox(5);

        // 1. Header: "do"
        container.getChildren().add(BlockLayout.header()
                .withKeyword("do")
                .withDeleteButton(() -> context.codeEditor().deleteStatement((Statement) this.astNode))
                .build());

        // 2. Body
        container.getChildren().add(createIndentedBody(body, context, "loop-body"));

        // 3. Footer: "while [condition] [+]"
        Button changeBtn = createAddButton(e ->
                showExpressionMenuAndReplace(
                        (Button) e.getSource(),
                        context,
                        TypeInfo.BOOLEAN,
                        condition != null ? (Expression) condition.getAstNode() : null
                )
        );

        HBox footer = BlockLayout.sentence()
                .addKeyword("while")
                .addExpressionSlot(condition, context, TypeInfo.BOOLEAN)
                .addNode(changeBtn)
                .build();

        container.getChildren().add(footer);

        return container;
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\blocks\EnumConstantBlock.java
=================================================================================

// FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\blocks\EnumConstantBlock.java
package com.botmaker.blocks;

import com.botmaker.core.AbstractExpressionBlock;
import com.botmaker.lsp.CompletionContext;
import com.botmaker.parser.helpers.EnumNodeHelper; // Use shared helper
import com.botmaker.ui.builders.BlockLayout;
import javafx.scene.Node;
import javafx.scene.control.ComboBox;
import javafx.scene.control.Label;
import javafx.scene.layout.HBox;
import org.eclipse.jdt.core.dom.*;

import java.util.ArrayList;
import java.util.List;

public class EnumConstantBlock extends AbstractExpressionBlock {

    private final String enumTypeName;
    private final String constantName;

    public EnumConstantBlock(String id, QualifiedName astNode) {
        super(id, astNode);
        this.enumTypeName = astNode.getQualifier().toString();
        this.constantName = astNode.getName().getIdentifier();
    }

    public EnumConstantBlock(String id, SimpleName astNode, String enumTypeName) {
        super(id, astNode);
        this.enumTypeName = enumTypeName;
        this.constantName = astNode.getIdentifier();
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        Label typeLabel = new Label(enumTypeName);
        typeLabel.setStyle("-fx-text-fill: white; -fx-font-weight: bold; -fx-font-size: 11px;");

        Label dot = new Label(".");
        dot.setStyle("-fx-text-fill: rgba(255,255,255,0.7); -fx-font-weight: bold;");

        ComboBox<String> constantSelector = new ComboBox<>();
        constantSelector.setStyle(
                "-fx-background-color: rgba(255,255,255,0.2);" +
                        "-fx-text-fill: white;" +
                        "-fx-font-size: 11px;" +
                        "-fx-background-radius: 4;" +
                        "-fx-padding: 2 6 2 6;"
        );

        List<String> constants = getEnumConstants(enumTypeName, context);
        constantSelector.getItems().addAll(constants);
        constantSelector.setValue(constantName);

        constantSelector.setOnAction(e -> {
            String newConstant = constantSelector.getValue();
            if (newConstant != null && !newConstant.equals(constantName)) {
                updateConstant(newConstant, context);
            }
        });

        HBox container = BlockLayout.sentence()
                .addNode(typeLabel)
                .addNode(dot)
                .addNode(constantSelector)
                .build();

        container.setStyle(
                "-fx-background-color: #d35400;" +
                        "-fx-background-radius: 5;" +
                        "-fx-padding: 4 8 4 8;"
        );

        return container;
    }

    private List<String> getEnumConstants(String enumName, CompletionContext context) {
        CompilationUnit cu = context.applicationState().getCompilationUnit().orElse(null);
        if (cu == null) return new ArrayList<>();

        // Fix: Use EnumNodeHelper to properly scan both top-level and inner enum declarations
        EnumDeclaration enumDecl = EnumNodeHelper.findEnumDeclaration(cu, enumName);

        if (enumDecl != null) {
            return EnumNodeHelper.getAllEnumConstantNames(enumDecl);
        }

        return new ArrayList<>();
    }

    private void updateConstant(String newConstant, CompletionContext context) {
        Expression oldExpr = (Expression) this.astNode;
        if (oldExpr instanceof QualifiedName) {
            QualifiedName qn = (QualifiedName) oldExpr;
            context.codeEditor().replaceSimpleName(qn.getName(), newConstant);
        } else if (oldExpr instanceof SimpleName) {
            context.codeEditor().replaceSimpleName((SimpleName) oldExpr, newConstant);
        }
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\blocks\FieldAccessBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractExpressionBlock;
import com.botmaker.lsp.CompletionContext;
import com.botmaker.util.TypeInfo;
import javafx.application.Platform;
import javafx.geometry.Pos;
import javafx.scene.Cursor;
import javafx.scene.Node;
import javafx.scene.control.ContextMenu;
import javafx.scene.control.MenuItem;
import javafx.scene.control.Tooltip;
import javafx.scene.layout.HBox;
import javafx.scene.text.Text;
import org.eclipse.jdt.core.dom.*;
import org.eclipse.lsp4j.*;

import java.util.List;
import java.util.stream.Collectors;

/**
 * Represents field access expressions like "this.score" or "obj.field"
 *
 * UPDATED: Uses TypeInfo for type operations
 */
public class FieldAccessBlock extends AbstractExpressionBlock {

    private final String qualifier;  // "this", "super", or object name
    private final String fieldName;
    private boolean isUnedited = false;
    private static final String UNEDITED_STYLE_CLASS = "unedited-identifier";

    public FieldAccessBlock(String id, FieldAccess astNode) {
        this(id, astNode, false);
    }

    public FieldAccessBlock(String id, FieldAccess astNode, boolean markAsUnedited) {
        super(id, astNode);
        Expression expr = astNode.getExpression();
        this.qualifier = expr != null ? expr.toString() : "";
        this.fieldName = astNode.getName().getIdentifier();
        this.isUnedited = markAsUnedited;
    }

    // Constructor for QualifiedName (used for this.field)
    public FieldAccessBlock(String id, QualifiedName astNode, boolean markAsUnedited) {
        super(id, astNode);
        this.qualifier = astNode.getQualifier().toString();
        this.fieldName = astNode.getName().getIdentifier();
        this.isUnedited = markAsUnedited;
    }

    public String getQualifier() { return qualifier; }
    public String getFieldName() { return fieldName; }
    public boolean isUnedited() { return isUnedited; }

    public void markAsEdited() {
        this.isUnedited = false;
        if (uiNode != null) {
            uiNode.getStyleClass().remove(UNEDITED_STYLE_CLASS);
        }
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        HBox container = new HBox(3);
        container.setAlignment(Pos.CENTER_LEFT);
        container.getStyleClass().add("field-access-block");

        // Qualifier text (e.g., "this")
        Text qualifierText = new Text(qualifier + ".");
        qualifierText.setStyle("-fx-fill: #8E44AD; -fx-font-weight: bold;");

        // Field name text
        Text fieldText = new Text(fieldName);
        fieldText.setStyle("-fx-fill: #2C3E50;");

        container.getChildren().addAll(qualifierText, fieldText);

        if (isUnedited) {
            container.getStyleClass().add(UNEDITED_STYLE_CLASS);
        }

        container.setCursor(Cursor.HAND);
        String tooltipText = isUnedited ?
                "⚠️ Default field name - Click to choose" :
                "Click to change field";
        Tooltip.install(container, new Tooltip(tooltipText));

        container.setOnMouseClicked(e -> {
            if (e.getClickCount() == 1) {
                requestSuggestions(container, context);
            }
        });

        return container;
    }

    private void requestSuggestions(Node uiNode, CompletionContext context) {
        try {
            Position pos = getPositionFromOffset(context.sourceCode(), this.astNode.getStartPosition());
            CompletionParams params = new CompletionParams(
                    new TextDocumentIdentifier(context.docUri()),
                    pos
            );

            // UPDATED: Use TypeInfo instead of string types
            TypeInfo expectedType = determineExpectedType();

            context.server().getTextDocumentService().completion(params).thenAccept(result -> {
                if (result == null || (result.isLeft() && result.getLeft().isEmpty()) ||
                        (result.isRight() && result.getRight().getItems().isEmpty())) {
                    return;
                }

                List<CompletionItem> items = result.isLeft() ?
                        result.getLeft() :
                        result.getRight().getItems();

                Platform.runLater(() -> {
                    ContextMenu menu = new ContextMenu();
                    menu.setStyle("-fx-control-inner-background: white;");

                    List<CompletionItem> filteredItems = items.stream()
                            .filter(item -> item.getKind() == CompletionItemKind.Field ||
                                    item.getKind() == CompletionItemKind.Variable)
                            .filter(item -> {
                                String typeInfo = item.getDetail();
                                if (typeInfo == null || typeInfo.isBlank()) {
                                    if (item.getLabel().contains(" : ")) {
                                        String[] parts = item.getLabel().split(" : ");
                                        if (parts.length > 1) typeInfo = parts[1].trim();
                                    }
                                }
                                // UPDATED: Use TypeInfo for compatibility checking
                                TypeInfo itemType = TypeInfo.from(typeInfo);
                                return itemType.isCompatibleWith(expectedType);
                            })
                            .collect(Collectors.toList());

                    if (filteredItems.isEmpty()) {
                        MenuItem noFields = new MenuItem("(No compatible fields found)");
                        noFields.setDisable(true);
                        noFields.setStyle("-fx-text-fill: #999;");
                        menu.getItems().add(noFields);
                    } else {
                        for (CompletionItem item : filteredItems) {
                            String label = item.getLabel();
                            String detail = item.getDetail();
                            if (detail == null && label.contains(" : ")) {
                                detail = label.split(" : ")[1].trim();
                            }

                            String display = label;
                            if (!label.contains(":") && detail != null && !detail.isEmpty()) {
                                display += " (" + getSimpleTypeName(detail) + ")";
                            }

                            MenuItem mi = new MenuItem(display);
                            mi.setStyle("-fx-text-fill: black;");
                            mi.setOnAction(event -> {
                                applySuggestion(item, context);
                                markAsEdited();
                            });
                            menu.getItems().add(mi);
                        }
                    }
                    menu.show(uiNode, javafx.geometry.Side.BOTTOM, 0, 0);
                });
            });
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * UPDATED: Returns TypeInfo instead of string type
     */
    private TypeInfo determineExpectedType() {
        if (this.astNode == null) return TypeInfo.UNKNOWN;

        ASTNode child = this.astNode;
        ASTNode parent = this.astNode.getParent();

        while (parent instanceof ParenthesizedExpression) {
            child = parent;
            parent = parent.getParent();
        }

        if (parent == null) return TypeInfo.UNKNOWN;

        // Assignment context
        if (parent instanceof Assignment) {
            Assignment assignment = (Assignment) parent;
            if (assignment.getRightHandSide() == child) {
                Expression lhs = assignment.getLeftHandSide();
                ITypeBinding binding = lhs.resolveTypeBinding();
                if (binding != null) {
                    return TypeInfo.from(binding);
                }
            }
        }

        // Variable declaration
        if (parent instanceof VariableDeclarationFragment) {
            VariableDeclarationFragment frag = (VariableDeclarationFragment) parent;
            if (frag.getInitializer() == child) {
                ASTNode grandParent = frag.getParent();
                if (grandParent instanceof VariableDeclarationStatement) {
                    Type type = ((VariableDeclarationStatement) grandParent).getType();
                    return TypeInfo.from(type);
                } else if (grandParent instanceof FieldDeclaration) {
                    Type type = ((FieldDeclaration) grandParent).getType();
                    return TypeInfo.from(type);
                }
            }
        }

        return TypeInfo.UNKNOWN;
    }

    private String getSimpleTypeName(String detail) {
        if (detail == null) return "";
        // UPDATED: Use TypeInfo for type classification
        TypeInfo type = TypeInfo.from(detail);
        if (type.isNumeric()) return "number";
        if (type.isBoolean()) return "bool";
        return detail;
    }

    private void applySuggestion(CompletionItem item, CompletionContext context) {
        try {
            String insertText = item.getInsertText() != null ? item.getInsertText() : item.getLabel();
            if (insertText.contains(" : ")) {
                insertText = insertText.split(" : ")[0];
            }

            // Replace just the field name, keeping the qualifier
            if (astNode instanceof FieldAccess) {
                FieldAccess fa = (FieldAccess) astNode;
                context.codeEditor().replaceSimpleName(fa.getName(), insertText);
            } else if (astNode instanceof QualifiedName) {
                QualifiedName qn = (QualifiedName) astNode;
                context.codeEditor().replaceSimpleName(qn.getName(), insertText);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private Position getPositionFromOffset(String code, int offset) {
        int line = 0;
        int lastNewline = -1;
        for (int i = 0; i < offset; i++) {
            if (code.charAt(i) == '\n') {
                line++;
                lastNewline = i;
            }
        }
        int character = offset - lastNewline - 1;
        return new Position(line, character);
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\blocks\ForBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractStatementBlock;
import com.botmaker.core.BodyBlock;
import com.botmaker.core.BlockWithChildren;
import com.botmaker.core.CodeBlock;
import com.botmaker.core.ExpressionBlock;
import com.botmaker.lsp.CompletionContext;
import com.botmaker.ui.BlockDragAndDropManager;
import com.botmaker.ui.builders.BlockLayout;
import com.botmaker.ui.components.TextFieldComponents;
import com.botmaker.util.TypeInfo;
import javafx.scene.Node;
import javafx.scene.control.TextField;
import org.eclipse.jdt.core.dom.EnhancedForStatement;
import org.eclipse.jdt.core.dom.SimpleName;

import java.util.ArrayList;
import java.util.List;

public class ForBlock extends AbstractStatementBlock implements BlockWithChildren {

    private ExpressionBlock variable;
    private ExpressionBlock collection;
    private BodyBlock body;

    public ForBlock(String id, EnhancedForStatement astNode, BlockDragAndDropManager dragAndDropManager) {
        super(id, astNode);
    }

    public void setVariable(ExpressionBlock variable) { this.variable = variable; }
    public void setCollection(ExpressionBlock collection) { this.collection = collection; }
    public void setBody(BodyBlock body) { this.body = body; }

    @Override
    public List<CodeBlock> getChildren() {
        List<CodeBlock> children = new ArrayList<>();
        if (variable != null) children.add(variable);
        if (collection != null) children.add(collection);
        if (body != null) children.add(body);
        return children;
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        // Extract variable name safely
        String varName = "";
        if (variable != null && variable.getAstNode() instanceof SimpleName) {
            varName = ((SimpleName) variable.getAstNode()).getIdentifier();
        }

        // Create editable field for the loop variable
        TextField nameField = TextFieldComponents.createVariableNameField(varName, newName -> {
            if (variable != null && variable.getAstNode() instanceof SimpleName) {
                // Reuse the generic replacement logic in CodeEditor
                context.codeEditor().replaceSimpleName((SimpleName) variable.getAstNode(), newName);
            }
        });

        // Build sentence: "for each [nameField] in [collection]"
        var sentence = BlockLayout.sentence()
                .addKeyword("for each")
                .addNode(nameField) // Use the text field directly
                .addKeyword("in")
                .addExpressionSlot(collection, context, TypeInfo.UNKNOWN)
                .build();

        sentence.getStyleClass().add("for-header");

        // Build full structure with header and body
        return BlockLayout.header()
                .withCustomNode(sentence)
                .withDeleteButton(() -> context.codeEditor().deleteStatement((org.eclipse.jdt.core.dom.Statement) this.astNode))
                .andBody()
                .withContent(body, context)
                .withStyleClass("for-block")
                .build();
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\blocks\IdentifierBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractExpressionBlock;
import com.botmaker.lsp.CompletionContext;
import com.botmaker.util.TypeInfo;
import javafx.application.Platform;
import javafx.scene.Cursor;
import javafx.scene.Node;
import javafx.scene.control.ContextMenu;
import javafx.scene.control.MenuItem;
import javafx.scene.layout.HBox;
import javafx.scene.text.Text;
import org.eclipse.jdt.core.dom.*;
import org.eclipse.lsp4j.*;

import java.util.List;
import java.util.stream.Collectors;

/**
 * UPDATED: Uses TypeInfo for all type operations
 */
public class IdentifierBlock extends AbstractExpressionBlock {
    private final String identifier;
    private boolean isUnedited = false;
    private static final String UNEDITED_STYLE_CLASS = "unedited-identifier";

    public IdentifierBlock(String id, SimpleName astNode) {
        this(id, astNode, false);
    }

    public IdentifierBlock(String id, SimpleName astNode, boolean markAsUnedited) {
        super(id, astNode);
        this.identifier = astNode.getIdentifier();
        this.isUnedited = markAsUnedited;
    }

    public String getIdentifier() { return identifier; }
    public boolean isUnedited() { return isUnedited; }

    public void markAsEdited() {
        this.isUnedited = false;
        if (uiNode != null) {
            uiNode.getStyleClass().remove(UNEDITED_STYLE_CLASS);
        }
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        Text text = new Text(identifier);
        HBox container = new HBox(text);
        container.setAlignment(javafx.geometry.Pos.CENTER_LEFT);
        container.getStyleClass().add("identifier-block");

        if (isUnedited) {
            container.getStyleClass().add(UNEDITED_STYLE_CLASS);
        }

        container.setCursor(Cursor.HAND);
        container.setOnMouseClicked(e -> {
            requestSuggestions(container, context);
            e.consume();
        });

        return container;
    }

    private void requestSuggestions(Node uiNode, CompletionContext context) {
        try {
            Position pos = getPositionFromOffset(context.sourceCode(), this.astNode.getStartPosition());
            CompletionParams params = new CompletionParams(new TextDocumentIdentifier(context.docUri()), pos);

            // ✨ NEW: Determine expected type using TypeInfo
            TypeInfo expectedType = determineExpectedType();

            System.out.println("[Debug] Expected TypeInfo: " + expectedType);
            if (expectedType.hasBinding()) {
                System.out.println("[Debug] Binding available: " + expectedType.getQualifiedName());
                System.out.println("[Debug] Is Array: " + expectedType.isArray());
                System.out.println("[Debug] Is Enum: " + expectedType.isEnum());
                if (expectedType.isArray()) {
                    System.out.println("[Debug] Array Dimensions: " + expectedType.getArrayDimensions());
                    System.out.println("[Debug] Leaf Type: " + expectedType.getLeafType().getDisplayName());
                }
            }

            context.server().getTextDocumentService().completion(params).thenAccept(result -> {
                if (result == null || (result.isLeft() && result.getLeft().isEmpty()) ||
                        (result.isRight() && result.getRight().getItems().isEmpty())) {
                    return;
                }

                List<CompletionItem> items = result.isLeft() ? result.getLeft() : result.getRight().getItems();

                Platform.runLater(() -> {
                    ContextMenu menu = new ContextMenu();
                    menu.setStyle("-fx-control-inner-background: white;");

                    // ✨ NEW: Simplified filtering using TypeInfo
                    List<CompletionItem> filteredItems = items.stream()
                            .filter(item -> item.getKind() == CompletionItemKind.Variable ||
                                    item.getKind() == CompletionItemKind.Field)
                            .filter(item -> isUserVariable(item.getLabel()))
                            .filter(item -> isTypeCompatible(item, expectedType))
                            .collect(Collectors.toList());

                    if (filteredItems.isEmpty()) {
                        MenuItem noVars = new MenuItem("(No compatible variables found)");
                        noVars.setDisable(true);
                        noVars.setStyle("-fx-text-fill: #999;");
                        menu.getItems().add(noVars);
                    } else {
                        for (CompletionItem item : filteredItems) {
                            String display = formatCompletionItem(item);
                            MenuItem mi = new MenuItem(display);
                            mi.setStyle("-fx-text-fill: black;");
                            mi.setOnAction(event -> {
                                applySuggestion(item, context);
                                markAsEdited();
                            });
                            menu.getItems().add(mi);
                        }
                    }
                    menu.show(uiNode, javafx.geometry.Side.BOTTOM, 0, 0);
                });
            });
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * ✨ NEW: Determines expected type using TypeInfo wrapper
     * Returns TypeInfo (which may have binding or just string)
     */
    private TypeInfo determineExpectedType() {
        if (this.astNode == null) return TypeInfo.UNKNOWN;

        SimpleName simpleName = (SimpleName) this.astNode;
        ASTNode child = simpleName;
        ASTNode parent = simpleName.getParent();

        // Skip parentheses
        while (parent instanceof ParenthesizedExpression) {
            child = parent;
            parent = parent.getParent();
        }

        if (parent == null) return TypeInfo.UNKNOWN;

        // ✨ Get ITypeBinding from context and wrap in TypeInfo
        ITypeBinding contextBinding = getTypeBindingFromContext(child, parent);
        return contextBinding != null ? TypeInfo.from(contextBinding) : TypeInfo.UNKNOWN;
    }

    /**
     * Gets type binding from the parent context
     * (Same logic as before, just returns ITypeBinding)
     */
    private ITypeBinding getTypeBindingFromContext(ASTNode child, ASTNode parent) {
        System.out.println("[Debug getTypeBindingFromContext] Child: " + child.getClass().getSimpleName() +
                " Parent: " + parent.getClass().getSimpleName());

        // Variable Declaration
        if (parent instanceof VariableDeclarationFragment) {
            VariableDeclarationFragment frag = (VariableDeclarationFragment) parent;
            if (frag.getInitializer() == child) {
                ASTNode grandParent = frag.getParent();
                if (grandParent instanceof VariableDeclarationStatement) {
                    Type type = ((VariableDeclarationStatement) grandParent).getType();
                    return type.resolveBinding();
                } else if (grandParent instanceof FieldDeclaration) {
                    Type type = ((FieldDeclaration) grandParent).getType();
                    return type.resolveBinding();
                }
            }
        }

        // Assignment
        if (parent instanceof Assignment) {
            Assignment assignment = (Assignment) parent;
            if (assignment.getRightHandSide() == child) {
                Expression lhs = assignment.getLeftHandSide();
                return lhs.resolveTypeBinding();
            }
        }

        // Array Initializer
        if (parent instanceof ArrayInitializer) {
            return findArrayTypeForInitializer((ArrayInitializer) parent, (Expression) child);
        }

        // Method Invocation Argument
        if (parent instanceof MethodInvocation) {
            MethodInvocation mi = (MethodInvocation) parent;
            int argIndex = mi.arguments().indexOf(child);
            if (argIndex >= 0) {
                IMethodBinding methodBinding = mi.resolveMethodBinding();
                if (methodBinding != null && argIndex < methodBinding.getParameterTypes().length) {
                    return methodBinding.getParameterTypes()[argIndex];
                }
            }
        }

        // Return Statement
        if (parent instanceof ReturnStatement) {
            ASTNode current = parent;
            while (current != null && !(current instanceof MethodDeclaration)) {
                current = current.getParent();
            }
            if (current instanceof MethodDeclaration) {
                MethodDeclaration method = (MethodDeclaration) current;
                Type returnType = method.getReturnType2();
                if (returnType != null) {
                    return returnType.resolveBinding();
                }
            }
        }

        // For Loop
        if (parent instanceof EnhancedForStatement) {
            EnhancedForStatement forStmt = (EnhancedForStatement) parent;
            if (forStmt.getExpression() == child) {
                SingleVariableDeclaration param = forStmt.getParameter();
                ITypeBinding elementType = param.getType().resolveBinding();
                if (elementType != null) {
                    return elementType.createArrayType(1);
                }
            }
        }

        return null;
    }

    /**
     * ✨ NEW: Simplified type compatibility check using TypeInfo
     */
    private boolean isTypeCompatible(CompletionItem item, TypeInfo expectedType) {
        // If no expected type, show everything
        if (expectedType == null || expectedType.isUnknown()) {
            return true;
        }

        // Extract type from completion item
        String typeStr = extractTypeFromItem(item);

        // Use TypeInfo to wrap the suggestion type
        TypeInfo actualType = TypeInfo.from(typeStr);

        // --- FILTERING FIX ---
        // If strict filtering is needed: An unknown/Object type cannot satisfy a specific requirement (like String).
        // This filters out default variables like "variable (Object)" from "String s = ..."
        if (!expectedType.isUnknown() && !expectedType.getTypeName().equals("Object")) {
            // If expected is specific, but actual is generic Object or Unknown, reject it.
            if (actualType.isUnknown() || actualType.getTypeName().equals("Object")) {
                return false;
            }
        }
        // ---------------------

        boolean compatible = actualType.isCompatibleWith(expectedType);

        System.out.println("[Debug] Checking: " + item.getLabel() +
                " | Actual: " + actualType +
                " | Expected: " + expectedType +
                " | Result: " + (compatible ? "✓" : "✗"));

        return compatible;
    }

    /**
     * Helper to extract type string from CompletionItem
     */
    private String extractTypeFromItem(CompletionItem item) {
        String typeInfo = item.getDetail();
        if (typeInfo == null || typeInfo.isBlank()) {
            if (item.getLabel().contains(" : ")) {
                String[] parts = item.getLabel().split(" : ");
                if (parts.length > 1) typeInfo = parts[1].trim();
            }
        }
        return typeInfo;
    }

    /**
     * Format completion item for display
     */
    private String formatCompletionItem(CompletionItem item) {
        String label = item.getLabel();
        String detail = item.getDetail();

        if (detail == null && label.contains(" : ")) {
            detail = label.split(" : ")[1].trim();
        }

        if (!label.contains(":") && detail != null && !detail.isEmpty()) {
            TypeInfo type = TypeInfo.from(detail);
            return label + " (" + type.getDisplayName() + ")";
        }

        return label;
    }

    /**
     * Helper to check if variable should be shown (filters system variables)
     */
    private boolean isUserVariable(String label) {
        String cleanName = label.split(" ")[0].split(":")[0].trim();
        return !List.of("args", "this", "super", "scanner", "class").contains(cleanName) &&
                !cleanName.startsWith("_");
    }

    /**
     * Finds the expected type for an element inside an array initializer
     * Returns ITypeBinding which will be wrapped in TypeInfo by caller
     */
    private ITypeBinding findArrayTypeForInitializer(ArrayInitializer initializer, Expression element) {
        System.out.println("[Debug findArrayType] Finding type for nested array element");

        // Count nesting depth
        ASTNode current = element.getParent();
        int depth = 0;
        ASTNode rootDefinition = null;

        while (current != null) {
            if (current instanceof ArrayInitializer) {
                depth++;
            } else if (current instanceof MethodInvocation) {
                MethodInvocation mi = (MethodInvocation) current;
                String methodName = mi.getName().getIdentifier();
                if ("asList".equals(methodName) || "of".equals(methodName)) {
                    depth++;
                }
            }

            ASTNode parent = current.getParent();
            if (parent instanceof VariableDeclarationFragment ||
                    parent instanceof VariableDeclarationStatement ||
                    parent instanceof FieldDeclaration ||
                    parent instanceof ArrayCreation) {
                rootDefinition = parent;
                break;
            }
            current = parent;
        }

        if (rootDefinition == null) return null;

        // Get declared type
        ITypeBinding declaredTypeBinding = null;
        if (rootDefinition instanceof VariableDeclarationFragment) {
            VariableDeclarationFragment frag = (VariableDeclarationFragment) rootDefinition;
            ASTNode grandParent = frag.getParent();
            if (grandParent instanceof VariableDeclarationStatement) {
                declaredTypeBinding = ((VariableDeclarationStatement) grandParent).getType().resolveBinding();
            } else if (grandParent instanceof FieldDeclaration) {
                declaredTypeBinding = ((FieldDeclaration) grandParent).getType().resolveBinding();
            }
        } else if (rootDefinition instanceof ArrayCreation) {
            declaredTypeBinding = ((ArrayCreation) rootDefinition).getType().resolveBinding();
        }

        if (declaredTypeBinding == null) return null;

        // ✨ Use TypeInfo to calculate expected type at depth
        TypeInfo rootType = TypeInfo.from(declaredTypeBinding);
        int neededDimensions = rootType.getArrayDimensions() - depth;

        System.out.println("[Debug] Root: " + rootType +
                " | Depth: " + depth +
                " | Needed Dims: " + neededDimensions);

        if (neededDimensions > 0) {
            TypeInfo expectedType = rootType.getLeafType().asArray(neededDimensions);
            return expectedType.getBinding();
        } else if (neededDimensions == 0) {
            return rootType.getLeafType().getBinding();
        }

        return null;
    }

    private void applySuggestion(CompletionItem item, CompletionContext context) {
        try {
            String insertText = item.getInsertText() != null ? item.getInsertText() : item.getLabel();
            if (insertText.contains(" : ")) {
                insertText = insertText.split(" : ")[0];
            }
            context.codeEditor().replaceSimpleName((SimpleName) this.astNode, insertText);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private Position getPositionFromOffset(String code, int offset) {
        int line = 0;
        int lastNewline = -1;
        for (int i = 0; i < offset; i++) {
            if (code.charAt(i) == '\n') {
                line++;
                lastNewline = i;
            }
        }
        int character = offset - lastNewline - 1;
        return new Position(line, character);
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\blocks\IfBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractStatementBlock;
import com.botmaker.core.BodyBlock;
import com.botmaker.core.ExpressionBlock;
import com.botmaker.core.StatementBlock;
import com.botmaker.lsp.CompletionContext;
import com.botmaker.ui.builders.BlockLayout;
import com.botmaker.ui.components.BlockUIComponents;
import com.botmaker.util.TypeInfo;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.Node;
import javafx.scene.control.Button;
import javafx.scene.layout.HBox;
import javafx.scene.layout.VBox;
import org.eclipse.jdt.core.dom.CompilationUnit;
import org.eclipse.jdt.core.dom.Expression;
import org.eclipse.jdt.core.dom.IfStatement;
import org.eclipse.jdt.core.dom.Statement;

public class IfBlock extends AbstractStatementBlock {

    private ExpressionBlock condition;
    private BodyBlock thenBody;
    private StatementBlock elseStatement;

    // Flag to alter rendering if this block is part of an 'else if' chain
    private boolean isElseIf = false;

    public IfBlock(String id, IfStatement astNode) {
        super(id, astNode);
    }

    public void setCondition(ExpressionBlock condition) { this.condition = condition; }
    public void setThenBody(BodyBlock thenBody) { this.thenBody = thenBody; }
    public void setElseStatement(StatementBlock elseStatement) { this.elseStatement = elseStatement; }

    public void setIsElseIf(boolean isElseIf) {
        this.isElseIf = isElseIf;
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        VBox container = new VBox(5);
        container.getStyleClass().add("if-block");

        // Header with condition
        // Change keyword based on context
        String keyword = isElseIf ? "Else If" : "If";

        Button addButton = createAddButton(e ->
                showExpressionMenuAndReplace((Button)e.getSource(), context, TypeInfo.BOOLEAN,
                        condition != null ? (Expression) condition.getAstNode() : null)
        );

        Node headerContent = BlockLayout.sentence()
                .addKeyword(keyword)
                .addExpressionSlot(condition, context, TypeInfo.BOOLEAN)
                .addNode(addButton)
                .build();

        container.getChildren().add(BlockLayout.header()
                .withCustomNode(headerContent)
                .withDeleteButton(() -> context.codeEditor().deleteStatement((Statement) this.astNode))
                .build());

        // Then Body
        if (thenBody != null) {
            VBox thenNode = createIndentedBody(thenBody, context, "if-body");
            container.getChildren().add(thenNode);
        }

        // Else / Else If Logic
        if (elseStatement != null) {
            if (elseStatement instanceof IfBlock) {
                // Else If (Recursive IfBlock)
                // We delegate the "Else If" rendering to the child block itself to keep the hierarchy flat visually
                IfBlock childIf = (IfBlock) elseStatement;
                childIf.setIsElseIf(true);

                Node elseIfNode = childIf.getUINode(context);

                // CRITICAL FIX: The child block comes with its own Gutter (padding).
                // If we just add it, it will be indented relative to this block.
                // We apply a negative margin to pull it back to the left, aligning "Else If" with "If".
                // Assuming standard gutter is around 12px.
                VBox.setMargin(elseIfNode, new Insets(0, 0, 0, -12.0));

                container.getChildren().add(elseIfNode);

            } else if (elseStatement instanceof BodyBlock) {
                // Regular Else
                VBox elseContainer = new VBox(5);

                HBox elseHeader = BlockLayout.sentence()
                        .addKeyword("Else")
                        .addNode(BlockUIComponents.createAddButton(e ->
                                context.codeEditor().convertElseToElseIf((IfStatement) this.astNode)))
                        .addNode(BlockUIComponents.createSpacer())
                        .addNode(BlockUIComponents.createDeleteButton(() ->
                                context.codeEditor().deleteElseFromIfStatement((IfStatement) this.astNode)))
                        .build();

                VBox elseBodyNode = createIndentedBody((BodyBlock) elseStatement, context, "if-body");
                elseContainer.getChildren().addAll(elseHeader, elseBodyNode);
                container.getChildren().add(elseContainer);
            }
        } else {
            // Add Else Button
            Button addElseButton = createAddButton(e ->
                    context.codeEditor().addElseToIfStatement((IfStatement) this.astNode));
            container.getChildren().add(addElseButton);
        }

        return container;
    }

    @Override
    public int getBreakpointLine(CompilationUnit cu) {
        if (condition != null) return condition.getBreakpointLine(cu);
        return super.getBreakpointLine(cu);
    }

    @Override
    public com.botmaker.core.CodeBlock getHighlightTarget() {
        return condition != null ? condition : this;
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\blocks\ListBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractExpressionBlock;
import com.botmaker.core.ExpressionBlock;
import com.botmaker.lsp.CompletionContext;
import com.botmaker.util.TypeInfo;
import com.botmaker.util.TypeManager;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.Node;
import javafx.scene.control.Button;
import javafx.scene.control.ContextMenu;
import javafx.scene.control.Label;
import javafx.scene.control.MenuItem;
import javafx.scene.layout.HBox;
import javafx.scene.layout.VBox;
import org.eclipse.jdt.core.dom.*;

import java.util.ArrayList;
import java.util.List;

/**
 * Visual block for lists.
 * Supports:
 * 1. Array Initializers: {1, 2, 3}
 * 2. List Factories: Arrays.asList(1, 2, 3) or List.of(1, 2, 3)
 *
 * UPDATED: Uses TypeInfo for ALL type operations - this eliminates the multi-dimensional array bugs!
 */
public class ListBlock extends AbstractExpressionBlock {

    private final List<ExpressionBlock> elements = new ArrayList<>();
    private final boolean isFixedArray; // True if it's a {}, False if it's Arrays.asList

    public ListBlock(String id, ASTNode astNode) {
        super(id, astNode);
        this.isFixedArray = (astNode instanceof ArrayInitializer);
    }

    public void addElement(ExpressionBlock element) {
        this.elements.add(element);
    }

    public List<ExpressionBlock> getElements() {
        return elements;
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        VBox container = new VBox(5);
        container.setAlignment(Pos.TOP_LEFT);
        container.getStyleClass().add("list-block");

        boolean isNested = (this.astNode.getParent() instanceof ArrayInitializer) ||
                (this.astNode.getParent() instanceof MethodInvocation);

        if (isNested) {
            container.setStyle("-fx-background-color: rgba(255,255,255,0.08); -fx-background-radius: 6; -fx-border-color: rgba(255,255,255,0.15); -fx-border-width: 1;");
            container.setPadding(new Insets(4, 6, 4, 6));
        } else {
            container.setPadding(new Insets(6, 10, 6, 10));
        }

        // --- Header Row ---
        HBox headerRow = new HBox(8);
        headerRow.setAlignment(Pos.CENTER_LEFT);

        // UPDATED: Use TypeInfo for determining item type
        TypeInfo itemType = determineItemType();

        String typeLabel = isFixedArray ? "Array" : "List";

        // Debug label (optional - can be enabled for verification):
        // Label listLabel = new Label(typeLabel + "<" + itemType.getDisplayName() + "> (" + elements.size() + ")");
        Label listLabel = new Label(typeLabel + " (" + elements.size() + ")");
        listLabel.getStyleClass().add("list-label");

        if (!isFixedArray) {
            listLabel.setStyle("-fx-text-fill: #aaddff;");
        }

        Button addButton = new Button("+");
        addButton.getStyleClass().add("expression-add-button");
        addButton.setStyle("-fx-font-size: 10px; -fx-padding: 2px 8px;");

        addButton.setOnAction(e -> showAddElementMenu(addButton, context, elements.size(), itemType));

        headerRow.getChildren().addAll(listLabel, addButton);
        container.getChildren().add(headerRow);

        // --- Elements ---
        if (elements.isEmpty()) {
            Label emptyLabel = new Label(" (empty) ");
            emptyLabel.setStyle("-fx-font-style: italic; -fx-text-fill: rgba(255,255,255,0.4); -fx-font-size: 10px;");
            container.getChildren().add(emptyLabel);
        } else {
            VBox elementsContainer = new VBox(3);
            elementsContainer.setPadding(new Insets(2, 0, 0, 12));

            for (int i = 0; i < elements.size(); i++) {
                HBox elementRow = createElementRow(i, elements.get(i), context, itemType);
                elementsContainer.getChildren().add(elementRow);
            }
            container.getChildren().add(elementsContainer);
        }

        return container;
    }

    private HBox createElementRow(int index, ExpressionBlock element, CompletionContext context, TypeInfo itemType) {
        HBox row = new HBox(6);
        row.setAlignment(Pos.CENTER_LEFT);

        Label indexLabel = new Label(String.valueOf(index));
        indexLabel.setStyle("-fx-font-family: monospace; -fx-text-fill: #666; -fx-font-size: 9px; -fx-min-width: 10px;");

        Node elementNode = element.getUINode(context);
        if (element instanceof ListBlock) {
            HBox.setHgrow(elementNode, javafx.scene.layout.Priority.ALWAYS);
        }

        Button changeButton = new Button("↻");
        changeButton.getStyleClass().add("icon-button");
        changeButton.setStyle("-fx-font-size: 8px; -fx-padding: 1px 4px; -fx-opacity: 0.3;");
        changeButton.setOnAction(e -> showChangeElementMenu(changeButton, context, index, itemType));

        Button deleteButton = new Button("✕");
        deleteButton.getStyleClass().add("icon-button");
        deleteButton.setStyle("-fx-font-size: 8px; -fx-padding: 1px 4px; -fx-text-fill: #ff5555; -fx-opacity: 0.3;");
        deleteButton.setOnAction(e -> deleteElement(index, context));

        row.setOnMouseEntered(e -> {
            changeButton.setStyle("-fx-font-size: 8px; -fx-padding: 1px 4px; -fx-opacity: 1.0;");
            deleteButton.setStyle("-fx-font-size: 8px; -fx-padding: 1px 4px; -fx-text-fill: #ff5555; -fx-opacity: 1.0;");
        });
        row.setOnMouseExited(e -> {
            changeButton.setStyle("-fx-font-size: 8px; -fx-padding: 1px 4px; -fx-opacity: 0.3;");
            deleteButton.setStyle("-fx-font-size: 8px; -fx-padding: 1px 4px; -fx-text-fill: #ff5555; -fx-opacity: 0.3;");
        });

        row.getChildren().addAll(indexLabel, elementNode, changeButton, deleteButton);
        return row;
    }

    private void showAddElementMenu(Button button, CompletionContext context, int insertIndex, TypeInfo targetType) {
        ContextMenu menu = new ContextMenu();

        // UPDATED: Pass TypeInfo to getForType
        for (com.botmaker.ui.AddableExpression type : com.botmaker.ui.AddableExpression.getForType(targetType)) {
            MenuItem menuItem = new MenuItem(type.getDisplayName());
            menuItem.setOnAction(e -> {
                context.codeEditor().addElementToList(this.astNode, type, insertIndex);
            });
            menu.getItems().add(menuItem);
        }

        if (menu.getItems().isEmpty()) {
            MenuItem noOptions = new MenuItem("(Maximum nesting reached)");
            noOptions.setDisable(true);
            menu.getItems().add(noOptions);
        }

        menu.show(button, javafx.geometry.Side.BOTTOM, 0, 0);
    }

    /**
     * COMPLETELY REWRITTEN: Determine what kind of items this ListBlock should contain.
     * This now uses TypeInfo exclusively and should fix ALL multi-dimensional array issues!
     *
     * Logic:
     * 1. Walk up parent chain to find root declaration (VariableDeclarationStatement, FieldDeclaration, etc.)
     * 2. Count how deep WE are in the nesting (currentDepth)
     * 3. Get the declared type's total dimensions using TypeInfo
     * 4. Calculate: elementDimensions = totalDimensions - currentDepth
     * 5. If elementDimensions > 0: return array TypeInfo
     *    If elementDimensions == 0: return leaf TypeInfo
     */
    private TypeInfo determineItemType() {
        System.out.println("\n[ListBlock.determineItemType] Starting for: " + this.astNode.getClass().getSimpleName());

        // Step 1: Walk up and find root declaration
        ASTNode rootDefinition = null;
        ASTNode current = this.astNode.getParent();
        int currentDepth = 1; // We count as one level of nesting

        System.out.println("  Starting depth at 1 (we are one array initializer)");

        while (current != null) {
            System.out.println("  Checking parent: " + current.getClass().getSimpleName());

            // Count additional array nesting above us
            if (current instanceof ArrayInitializer) {
                currentDepth++;
                System.out.println("    -> Parent is ArrayInitializer, depth now: " + currentDepth);
            }
            else if (current instanceof MethodInvocation) {
                MethodInvocation mi = (MethodInvocation) current;
                String methodName = mi.getName().getIdentifier();
                if ("asList".equals(methodName) || "of".equals(methodName)) {
                    currentDepth++;
                    System.out.println("    -> Parent is " + methodName + ", depth now: " + currentDepth);
                }
            }

            // Found declaration - stop here
            if (current instanceof VariableDeclarationFragment ||
                    current instanceof VariableDeclarationStatement ||
                    current instanceof FieldDeclaration ||
                    current instanceof ArrayCreation) {
                rootDefinition = current;
                System.out.println("  Found root declaration: " + current.getClass().getSimpleName());
                break;
            }

            current = current.getParent();
        }

        if (rootDefinition == null) {
            System.out.println("  ERROR: No root definition found!");
            return TypeInfo.UNKNOWN;
        }

        // Step 2: Get the declared type
        TypeInfo declaredType = extractDeclaredType(rootDefinition);

        if (declaredType == null) {
            System.out.println("  ERROR: Could not extract declared type!");
            return TypeInfo.UNKNOWN;
        }

        System.out.println("  Declared Type: " + declaredType.getTypeName());
        System.out.println("  Total Dimensions: " + declaredType.getArrayDimensions());
        System.out.println("  Current Depth: " + currentDepth);
        System.out.println("  Leaf Type: " + declaredType.getLeafType().getTypeName());

        // Step 3: Calculate what OUR elements should be
        int totalDimensions = declaredType.getArrayDimensions();
        int elementDimensions = totalDimensions - currentDepth;

        System.out.println("  Element Dimensions: " + elementDimensions + " (total - depth)");

        if (elementDimensions > 0) {
            // Our children are arrays
            TypeInfo elementType = declaredType.getLeafType().asArray(elementDimensions);
            System.out.println("  -> Returning ARRAY: " + elementType.getTypeName());
            return elementType;
        } else if (elementDimensions == 0) {
            // Our children are leaf values
            TypeInfo leafType = declaredType.getLeafType();
            System.out.println("  -> Returning LEAF: " + leafType.getTypeName());
            return leafType;
        } else {
            // We're too deep! This shouldn't happen if declarations are correct
            System.out.println("  -> ERROR: Negative element dimensions!");
            return TypeInfo.UNKNOWN;
        }
    }

    /**
     * Helper: Extract TypeInfo from various AST node types
     */
    private TypeInfo extractDeclaredType(ASTNode node) {
        if (node instanceof VariableDeclarationStatement) {
            Type type = ((VariableDeclarationStatement) node).getType();
            return TypeInfo.from(type);
        }

        if (node instanceof VariableDeclarationFragment) {
            ASTNode parent = node.getParent();
            if (parent instanceof VariableDeclarationStatement) {
                Type type = ((VariableDeclarationStatement) parent).getType();
                return TypeInfo.from(type);
            } else if (parent instanceof FieldDeclaration) {
                Type type = ((FieldDeclaration) parent).getType();
                return TypeInfo.from(type);
            }
        }

        if (node instanceof FieldDeclaration) {
            Type type = ((FieldDeclaration) node).getType();
            return TypeInfo.from(type);
        }

        if (node instanceof ArrayCreation) {
            ArrayType type = ((ArrayCreation) node).getType();
            return TypeInfo.from(type);
        }

        return null;
    }

    private void showChangeElementMenu(Button button, CompletionContext context, int elementIndex, TypeInfo targetType) {
        ContextMenu menu = new ContextMenu();

        // UPDATED: Pass TypeInfo to getForType
        for (com.botmaker.ui.AddableExpression type : com.botmaker.ui.AddableExpression.getForType(targetType)) {
            MenuItem menuItem = new MenuItem(type.getDisplayName());
            menuItem.setOnAction(e -> {
                if (elementIndex < elements.size()) {
                    ExpressionBlock oldElement = elements.get(elementIndex);
                    context.codeEditor().replaceExpression(
                            (Expression) oldElement.getAstNode(),
                            type
                    );
                }
            });
            menu.getItems().add(menuItem);
        }
        menu.show(button, javafx.geometry.Side.BOTTOM, 0, 0);
    }

    private void deleteElement(int index, CompletionContext context) {
        if (index >= 0 && index < elements.size()) {
            context.codeEditor().deleteElementFromList(this.astNode, index);
        }
    }

    @Override
    public String getDetails() {
        return (isFixedArray ? "Array" : "List") + " (" + elements.size() + " items)";
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\blocks\LiteralBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractExpressionBlock;
import com.botmaker.lsp.CompletionContext;
import javafx.scene.Cursor;
import javafx.scene.Node;
import javafx.scene.control.TextField;
import javafx.scene.control.TextFormatter;
import javafx.scene.layout.HBox;
import org.eclipse.jdt.core.dom.Expression;
import org.eclipse.jdt.core.dom.MethodInvocation;

import java.math.BigDecimal;
import java.util.function.UnaryOperator;

public class LiteralBlock<T> extends AbstractExpressionBlock {
    private final T value;

    public LiteralBlock(String id, Expression astNode, T value) {
        super(id, astNode);
        this.value = value;
    }

    public T getValue() {
        return value;
    }

    // LiteralBlock.java - already well structured, keep as is
    @Override
    protected Node createUINode(CompletionContext context) {
        String initialText = (value instanceof String) ? (String) value : String.valueOf(value);
        TextField textField = new TextField(initialText);

        if (initialText.isEmpty() && value instanceof String) {
            textField.setPromptText("Type a value...");
        }

        textField.setCursor(Cursor.TEXT);

        UnaryOperator<TextFormatter.Change> filter = createInputFilter();
        if (filter != null) {
            textField.setTextFormatter(new TextFormatter<>(filter));
        }

        textField.focusedProperty().addListener((obs, oldVal, newVal) -> {
            if (!newVal) {
                String newText = textField.getText();
                String oldText = (value instanceof String) ? (String) value : String.valueOf(value);

                if (isNumberType() && !isValidFinalNumber(newText)) {
                    textField.setText(oldText);
                    return;
                }

                String textToSave = normalizeNumberSuffix(newText);

                if (!textToSave.equals(newText)) {
                    textField.setText(textToSave);
                }

                if (!textToSave.equals(oldText)) {
                    if (this.astNode instanceof MethodInvocation) {
                        MethodInvocation mi = (MethodInvocation) this.astNode;
                        context.codeEditor().addStringArgumentToMethodInvocation(mi, textToSave);
                    } else {
                        context.codeEditor().replaceLiteralValue((Expression) this.astNode, textToSave);
                    }
                }
            }
        });

        HBox container = new HBox(textField);
        container.setAlignment(javafx.geometry.Pos.CENTER_LEFT);
        return container;
    }

    /**
     * Automatically appends required Java suffixes (f, L) if missing.
     */
    private String normalizeNumberSuffix(String text) {
        if (value instanceof Float) {
            if (!text.toLowerCase().endsWith("f")) {
                return text + "f";
            }
        } else if (value instanceof Long) {
            if (!text.toLowerCase().endsWith("l")) {
                return text + "L"; // Use Uppercase L to avoid confusion with 1
            }
        }
        return text;
    }

    /**
     * Creates a filter based on the type of the value stored in this block.
     */
    private UnaryOperator<TextFormatter.Change> createInputFilter() {
        return change -> {
            String newText = change.getControlNewText();

            if (newText.isEmpty()) return change;

            // 1. INTEGER Types (Byte, Short, Integer, Long)
            if (value instanceof Integer || value instanceof Short || value instanceof Byte || value instanceof Long) {
                // Allow digits, minus, and L suffix for Longs
                String regex = (value instanceof Long) ? "-?[0-9]*[lL]?" : "-?[0-9]*";

                if (newText.matches(regex)) {
                    if (isWithinRange(newText, value.getClass())) {
                        return change;
                    }
                }
                return null;
            }

            // 2. FLOATING POINT Types (Float, Double)
            else if (value instanceof Double || value instanceof Float) {
                // Allow digits, dot, minus, and f/d suffixes
                if (newText.matches("-?[0-9]*\\.?[0-9]*[dDfF]?")) {
                    if (isWithinRange(newText, value.getClass())) {
                        return change;
                    }
                }
                return null;
            }

            // 3. STRING
            else if (value instanceof String) {
                String input = change.getText();
                if (input.contains("\"") || input.contains("\n") || input.contains("\r")) {
                    return null;
                }
                return change;
            }

            return change;
        };
    }

    /**
     * Checks if the text value fits within the MIN/MAX bounds of the target type.
     */
    private boolean isWithinRange(String text, Class<?> type) {
        // Allow intermediate states
        if (text.equals("-") || text.equals(".") || text.equals("-.")) return true;

        // Strip suffixes for parsing check
        String cleanText = text.replaceAll("[dDfFlL]$", "");
        if (cleanText.isEmpty()) return true;

        try {
            if (type == Byte.class) {
                long val = Long.parseLong(cleanText);
                return val >= Byte.MIN_VALUE && val <= Byte.MAX_VALUE;
            }
            if (type == Short.class) {
                long val = Long.parseLong(cleanText);
                return val >= Short.MIN_VALUE && val <= Short.MAX_VALUE;
            }
            if (type == Integer.class) {
                long val = Long.parseLong(cleanText);
                return val >= Integer.MIN_VALUE && val <= Integer.MAX_VALUE;
            }
            if (type == Long.class) {
                Long.parseLong(cleanText);
                return true;
            }
            if (type == Float.class) {
                double val = Double.parseDouble(cleanText);
                // Float.MAX_VALUE is huge, mostly we check for Infinity overflow
                return !Double.isInfinite(val);
            }
            if (type == Double.class) {
                BigDecimal val = new BigDecimal(cleanText);
                // Check if it fits in a double
                return !Double.isInfinite(val.doubleValue());
            }
        } catch (NumberFormatException e) {
            return false;
        }

        return true;
    }

    private boolean isValidFinalNumber(String text) {
        if (text.equals("-") || text.equals(".") || text.equals("-.")) return false;
        if (text.endsWith(".")) return false;
        return true;
    }

    private boolean isNumberType() {
        return value instanceof Number;
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\blocks\MainBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.lsp.CompletionContext;
import com.botmaker.ui.BlockDragAndDropManager;
import javafx.scene.Node;
import javafx.scene.control.Label;
import javafx.scene.layout.VBox;
import org.eclipse.jdt.core.dom.MethodDeclaration;

/**
 * MainBlock is just a MethodDeclarationBlock that detects if it's the "main" method
 * and adjusts its UI styling accordingly.
 */
public class MainBlock extends MethodDeclarationBlock {

    private final boolean isMainMethod;

    public MainBlock(String id, MethodDeclaration astNode, BlockDragAndDropManager manager) {
        super(id, astNode, manager);
        this.isMainMethod = "main".equals(astNode.getName().getIdentifier()) &&
                org.eclipse.jdt.core.dom.Modifier.isStatic(astNode.getModifiers());

        // Disable delete button for Main method
        this.isDeletable = false;
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        Node standardUI = super.createUINode(context);

        if (isMainMethod) {
            VBox wrapper = new VBox(standardUI);
            wrapper.setStyle("-fx-background-color: #e8f4f8; -fx-border-color: #3498db; -fx-border-width: 2; -fx-border-radius: 8; -fx-padding: 5;");

            Label mainBadge = new Label("⭐ Program Entry Point");
            mainBadge.setStyle("-fx-font-size: 10px; -fx-text-fill: #3498db; -fx-font-weight: bold;");
            wrapper.getChildren().add(0, mainBadge);

            return wrapper;
        }

        return standardUI;
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\blocks\MethodDeclarationBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractStatementBlock;
import com.botmaker.core.BlockWithChildren;
import com.botmaker.core.BodyBlock;
import com.botmaker.core.CodeBlock;
import com.botmaker.lsp.CompletionContext;
import com.botmaker.ui.BlockDragAndDropManager;
import com.botmaker.ui.builders.BlockLayout;
import com.botmaker.ui.components.BlockUIComponents;
import com.botmaker.util.DefaultNames;
import com.botmaker.util.TypeManager;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.Node;
import javafx.scene.control.*;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Priority;
import javafx.scene.layout.Region;
import javafx.scene.layout.VBox;
import org.eclipse.jdt.core.dom.MethodDeclaration;
import org.eclipse.jdt.core.dom.Modifier;
import org.eclipse.jdt.core.dom.SingleVariableDeclaration;

import java.util.Collections;
import java.util.List;

public class MethodDeclarationBlock extends AbstractStatementBlock implements BlockWithChildren {

    private final String methodName;
    private final String returnType;
    private BodyBlock body;
    protected boolean isDeletable = true; // Added flag to control delete button visibility

    public MethodDeclarationBlock(String id, MethodDeclaration astNode, BlockDragAndDropManager manager) {
        super(id, astNode);
        this.methodName = astNode.getName().getIdentifier();
        if (astNode.getReturnType2() != null) {
            this.returnType = astNode.getReturnType2().toString();
        } else {
            this.returnType = "void";
        }
    }

    public void setBody(BodyBlock body) {
        this.body = body;
    }

    @Override
    public List<CodeBlock> getChildren() {
        return body != null ? Collections.singletonList(body) : Collections.emptyList();
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        VBox container = new VBox(0);

        // --- HEADER SECTION ---
        VBox headerBox = new VBox(5);
        headerBox.setStyle(
                "-fx-background-color: #8E44AD; " +
                        "-fx-background-radius: 8 8 0 0; " +
                        "-fx-padding: 8 10 8 10;"
        );

        // Row 1: Function name and return type
        Label funcLabel = new Label("Function");
        funcLabel.setStyle("-fx-text-fill: rgba(255,255,255,0.8); -fx-font-weight: bold; -fx-font-size: 10px;");

        Label nameLabel = new Label(methodName);
        nameLabel.setStyle("-fx-text-fill: white; -fx-font-weight: bold; -fx-font-size: 14px;");

        Label returnsLabel = new Label("returns");
        returnsLabel.setStyle("-fx-text-fill: rgba(255,255,255,0.7); -fx-font-style: italic; -fx-font-size: 11px;");

        ComboBox<String> typeSelector = new ComboBox<>();
        typeSelector.getItems().add("void");
        typeSelector.getItems().addAll(TypeManager.getFundamentalTypeNames());
        typeSelector.setValue(returnType);
        typeSelector.setStyle("-fx-font-size: 11px; -fx-background-color: rgba(255,255,255,0.2); -fx-text-fill: white; -fx-background-radius: 4;");
        typeSelector.setOnAction(e -> {
            String selected = typeSelector.getValue();
            if (!selected.equals(returnType)) {
                context.codeEditor().setMethodReturnType((MethodDeclaration) this.astNode, selected);
            }
        });

        // Use builder to optionally add delete button
        var topRowBuilder = BlockLayout.sentence()
                .addNode(funcLabel)
                .addNode(nameLabel)
                .addNode(BlockUIComponents.createSpacer())
                .addNode(returnsLabel)
                .addNode(typeSelector);

        if (isDeletable) {
            Button deleteBtn = new Button("×");
            deleteBtn.setStyle("-fx-background-color: transparent; -fx-text-fill: #E74C3C; -fx-font-size: 16px; -fx-padding: 0; -fx-cursor: hand;");
            deleteBtn.setOnAction(e -> context.codeEditor().deleteMethod((MethodDeclaration) this.astNode));
            topRowBuilder.addNode(deleteBtn);
        }

        HBox topRow = topRowBuilder.build();

        // Row 2: Parameters
        Label paramsLabel = new Label("Inputs:");
        paramsLabel.setStyle("-fx-text-fill: rgba(255,255,255,0.7); -fx-font-size: 11px;");

        var paramRowBuilder = BlockLayout.sentence()
                .addNode(paramsLabel);

        MethodDeclaration md = (MethodDeclaration) this.astNode;
        List<?> params = md.parameters();

        for (int i = 0; i < params.size(); i++) {
            SingleVariableDeclaration param = (SingleVariableDeclaration) params.get(i);
            paramRowBuilder.addNode(createParamNode(param, i, context));
        }

        MenuButton addParamBtn = new MenuButton("+");
        addParamBtn.setStyle("-fx-font-size: 10px; -fx-padding: 2 6 2 6; -fx-background-color: rgba(255,255,255,0.2); -fx-text-fill: white; -fx-background-radius: 10;");

        for (String type : TypeManager.getFundamentalTypeNames()) {
            MenuItem item = new MenuItem(type);
            item.setOnAction(e -> {
                String defaultName = com.botmaker.util.DefaultNames.forType(type);
                context.codeEditor().addParameterToMethod((MethodDeclaration) this.astNode, type, defaultName);
            });
            addParamBtn.getItems().add(item);
        }
        paramRowBuilder.addNode(addParamBtn);

        HBox paramRow = paramRowBuilder.build();

        headerBox.getChildren().addAll(topRow, paramRow);
        container.getChildren().add(headerBox);

        // --- BODY ---
        VBox bodyWrapper = new VBox();
        bodyWrapper.setStyle("-fx-border-color: #8E44AD; -fx-border-width: 0 0 0 4; -fx-background-color: rgba(142, 68, 173, 0.05);");

        if (body != null) {
            Node bodyNode = body.getUINode(context);
            VBox.setVgrow(bodyNode, javafx.scene.layout.Priority.ALWAYS);
            bodyWrapper.getChildren().add(bodyNode);
        }
        container.getChildren().add(bodyWrapper);

        return container;
    }

    private Node createParamNode(SingleVariableDeclaration param, int index, CompletionContext context) {
        HBox box = new HBox(4);
        box.setAlignment(Pos.CENTER_LEFT);
        box.setStyle("-fx-background-color: rgba(255,255,255,0.9); -fx-background-radius: 12; -fx-padding: 3 8 3 8;");

        Label typeLabel = new Label(param.getType().toString());
        typeLabel.setStyle("-fx-text-fill: #8E44AD; -fx-font-weight: bold; -fx-font-size: 11px;");

        String currentName = param.getName().getIdentifier();
        TextField nameField = new TextField(currentName);

        nameField.setStyle(
                "-fx-background-color: transparent; " +
                        "-fx-padding: 0; " +
                        "-fx-font-size: 11px; " +
                        "-fx-text-fill: #333;"
        );
        nameField.setPrefWidth(Math.max(30, currentName.length() * 7));

        nameField.focusedProperty().addListener((obs, oldVal, newVal) -> {
            if (newVal) {
                nameField.setStyle("-fx-background-color: white; -fx-padding: 0; -fx-font-size: 11px; -fx-text-fill: black; -fx-border-color: #8E44AD; -fx-border-width: 0 0 1 0;");
            } else {
                nameField.setStyle("-fx-background-color: transparent; -fx-padding: 0; -fx-font-size: 11px; -fx-text-fill: #333;");
                String val = nameField.getText().trim();
                if (!val.isEmpty() && !val.equals(currentName)) {
                    context.codeEditor().renameMethodParameter((MethodDeclaration) this.astNode, index, val);
                } else {
                    nameField.setText(currentName);
                }
            }
        });

        nameField.setOnAction(e -> box.requestFocus());

        box.getChildren().addAll(typeLabel, nameField);
        return box;
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\blocks\MethodInvocationBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractExpressionBlock;
import com.botmaker.core.ExpressionBlock;
import com.botmaker.core.StatementBlock;
import com.botmaker.lsp.CompletionContext;
import com.botmaker.project.ProjectFile;
import com.botmaker.ui.AddableExpression;
import com.botmaker.ui.builders.BlockLayout;
import com.botmaker.ui.components.BlockUIComponents;
import com.botmaker.util.TypeInfo;
import javafx.geometry.Pos;
import javafx.scene.Node;
import javafx.scene.control.*;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Priority;
import javafx.scene.layout.Region;
import org.eclipse.jdt.core.dom.*;

import java.util.ArrayList;
import java.util.List;

import static com.botmaker.ui.components.BlockUIComponents.createDeleteButton;

/**
 * UPDATED: Uses TypeInfo for type operations
 */
public class MethodInvocationBlock extends AbstractExpressionBlock implements StatementBlock {

    private String scopeName;
    private String methodName;
    private final List<ExpressionBlock> arguments = new ArrayList<>();
    private boolean isStatementContext = false;

    public MethodInvocationBlock(String id, ASTNode astNode) {
        super(id, resolveExpressionNode(astNode));

        if (astNode instanceof ExpressionStatement) {
            this.isStatementContext = true;
        }

        MethodInvocation mi = (MethodInvocation) this.astNode;
        this.methodName = mi.getName().getIdentifier();
        if (mi.getExpression() != null) {
            this.scopeName = mi.getExpression().toString();
        } else {
            this.scopeName = ""; // Local
        }
    }

    private static MethodInvocation resolveExpressionNode(ASTNode node) {
        if (node instanceof ExpressionStatement) {
            return (MethodInvocation) ((ExpressionStatement) node).getExpression();
        }
        return (MethodInvocation) node;
    }

    public void addArgument(ExpressionBlock arg) {
        arguments.add(arg);
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        String currentFileClass = "";
        if (context.applicationState() != null && context.applicationState().getActiveFile() != null) {
            currentFileClass = context.applicationState().getActiveFile().getClassName();
        }

        // File Selector
        ComboBox<String> fileSelector = new ComboBox<>();
        if (context.applicationState() != null) {
            for (com.botmaker.project.ProjectFile file : context.applicationState().getAllFiles()) {
                fileSelector.getItems().add(file.getClassName());
            }
        }

        String displayValue = scopeName.isEmpty() ? currentFileClass : scopeName;
        if (!fileSelector.getItems().contains(displayValue)) {
            fileSelector.getItems().add(0, displayValue);
        }
        fileSelector.setValue(displayValue);
        fileSelector.setStyle("-fx-font-size: 11px; -fx-pref-width: 100px;");

        // Method Selector
        ComboBox<String> methodSelector = new ComboBox<>();
        methodSelector.setValue(methodName);
        methodSelector.setEditable(false);
        methodSelector.setStyle("-fx-font-size: 11px; -fx-pref-width: 120px; -fx-font-weight: bold;");

        final String finalCurrentFileClass = currentFileClass;

        Runnable populateMethodList = () -> {
            String selectedFile = fileSelector.getValue();
            methodSelector.getItems().clear();

            com.botmaker.project.ProjectFile targetFile = findProjectFile(context, selectedFile);

            if (targetFile != null) {
                ensureAstParsed(targetFile);

                if (targetFile.getAst() != null && !targetFile.getAst().types().isEmpty()) {
                    TypeDeclaration type = (TypeDeclaration) targetFile.getAst().types().get(0);
                    boolean isLocal = selectedFile.equals(finalCurrentFileClass);

                    for (MethodDeclaration md : type.getMethods()) {
                        int mods = md.getModifiers();
                        boolean isStatic = Modifier.isStatic(mods);
                        boolean isPublic = Modifier.isPublic(mods);

                        if (isLocal || (isPublic && isStatic)) {
                            methodSelector.getItems().add(md.getName().getIdentifier());
                        }
                    }
                }

                if (methodSelector.getItems().size() == 1) {
                    methodSelector.getSelectionModel().select(0);
                }
            }
        };

        methodSelector.setOnAction(e -> {
            String newMethodName = methodSelector.getValue();
            if (newMethodName == null) return;

            String newScopeDisplay = fileSelector.getValue();
            String newScopeAST = newScopeDisplay.equals(finalCurrentFileClass) ? "" : newScopeDisplay;

            List<String> paramTypes = findParameterTypes(context, newScopeDisplay, newMethodName);

            context.codeEditor().updateMethodInvocation(
                    (MethodInvocation) this.astNode,
                    newScopeAST,
                    newMethodName,
                    paramTypes
            );
        });

        fileSelector.setOnAction(e -> {
            populateMethodList.run();
            methodSelector.show();
        });

        populateMethodList.run();

        // Build main sentence
        var sentenceBuilder = BlockLayout.sentence()
                .addLabel("Call")
                .addNode(fileSelector)
                .addLabel(".")
                .addNode(methodSelector);

        // Sync button
        int expectedParamCount = findParameterTypes(context, displayValue, methodName).size();
        boolean hasMismatch = arguments.size() != expectedParamCount;

        Button syncBtn = new Button("⟳");
        if (hasMismatch) {
            syncBtn.setStyle("-fx-font-size: 10px; -fx-padding: 2 4 2 4; -fx-background-color: #FFA500; -fx-text-fill: white; -fx-font-weight: bold;");
            syncBtn.setTooltip(new Tooltip("⚠ Arguments don't match! Click to sync"));
        } else {
            syncBtn.setStyle("-fx-font-size: 10px; -fx-padding: 2 4 2 4; -fx-background-color: rgba(255,255,255,0.2); -fx-text-fill: #90EE90;");
            syncBtn.setTooltip(new Tooltip("Arguments match signature ✓"));
        }
        syncBtn.setOnAction(e -> {
            String currentScope = fileSelector.getValue();
            String currentMethod = methodSelector.getValue();
            String scopeForAST = currentScope.equals(finalCurrentFileClass) ? "" : currentScope;
            List<String> paramTypes = findParameterTypes(context, currentScope, currentMethod);
            context.codeEditor().updateMethodInvocation(
                    (MethodInvocation) this.astNode, scopeForAST, currentMethod, paramTypes);
        });

        sentenceBuilder.addNode(syncBtn);

        // Arguments
        sentenceBuilder.addLabel("(");

        List<String> paramNames = findParameterNames(context, displayValue, methodName);

        for (int i = 0; i < arguments.size(); i++) {
            ExpressionBlock arg = arguments.get(i);
            HBox argBox = new HBox(2);
            argBox.setAlignment(Pos.CENTER_LEFT);
            argBox.setStyle("-fx-background-color: rgba(255,255,255,0.1); -fx-background-radius: 4; -fx-padding: 2;");

            if (i < paramNames.size()) {
                Label paramNameLabel = new Label(paramNames.get(i) + ":");
                paramNameLabel.setStyle("-fx-text-fill: #aaa; -fx-font-size: 9px; -fx-padding: 0 4 0 2;");
                argBox.getChildren().add(paramNameLabel);
            }

            argBox.getChildren().add(arg.getUINode(context));

            Button delBtn = new Button("×");
            delBtn.setStyle("-fx-background-color: transparent; -fx-text-fill: #E74C3C; -fx-font-size: 10px; -fx-padding: 0 0 0 2; -fx-cursor: hand;");
            int index = i;
            delBtn.setOnAction(e -> context.codeEditor().deleteElementFromList(this.astNode, index));
            argBox.getChildren().add(delBtn);

            sentenceBuilder.addNode(argBox);
        }

        if (arguments.size() < expectedParamCount) {
            MenuButton addArgBtn = new MenuButton("+");
            addArgBtn.setStyle("-fx-font-size: 9px; -fx-padding: 2 4 2 4;");

            // UPDATED: Get TypeInfo for parameter and pass to getForType
            TypeInfo nextParamType = getParameterTypeInfoAt(context, displayValue, methodName, arguments.size());
            List<com.botmaker.ui.AddableExpression> availableTypes =
                    com.botmaker.ui.AddableExpression.getForType(nextParamType);

            for (com.botmaker.ui.AddableExpression type : availableTypes) {
                MenuItem item = new MenuItem(type.getDisplayName());
                item.setOnAction(e -> context.codeEditor().addArgumentToMethodInvocation(
                        (MethodInvocation) this.astNode, type));
                addArgBtn.getItems().add(item);
            }
            sentenceBuilder.addNode(addArgBtn);
        } else if (arguments.size() > expectedParamCount) {
            Label warningLabel = new Label("⚠ Too many");
            warningLabel.setStyle("-fx-text-fill: #FFA500; -fx-font-size: 9px; -fx-font-weight: bold;");
            sentenceBuilder.addNode(warningLabel);
        }

        sentenceBuilder.addLabel(")");

        HBox container = sentenceBuilder.build();
        container.setStyle("-fx-background-color: #34495E; -fx-background-radius: " +
                (isStatementContext ? "4" : "12") + "; -fx-padding: " +
                (isStatementContext ? "5 10 5 10" : "3 8 3 8") + ";");

        if (isStatementContext) {
            container.getChildren().addAll(
                    BlockUIComponents.createSpacer(),
                    BlockUIComponents.createDeleteButton(() ->
                            context.codeEditor().deleteStatement((Statement) this.astNode.getParent()))
            );
        }

        return container;
    }

    // --- Helpers ---

    private ProjectFile findProjectFile(CompletionContext context, String className) {
        if (context.applicationState() == null) return null;
        for (ProjectFile file : context.applicationState().getAllFiles()) {
            if (file.getClassName().equals(className)) {
                return file;
            }
        }
        return null;
    }

    private void ensureAstParsed(ProjectFile file) {
        if (file.getAst() == null) {
            try {
                ASTParser parser = ASTParser.newParser(AST.getJLSLatest());
                parser.setSource(file.getContent().toCharArray());
                parser.setKind(ASTParser.K_COMPILATION_UNIT);
                CompilationUnit cu = (CompilationUnit) parser.createAST(null);
                file.setAst(cu);
            } catch (Exception ignored) {}
        }
    }

    private List<String> findParameterTypes(CompletionContext context, String className, String methodName) {
        List<String> types = new ArrayList<>();
        ProjectFile targetFile = findProjectFile(context, className);

        if (targetFile != null) {
            ensureAstParsed(targetFile);
            if (targetFile.getAst() != null && !targetFile.getAst().types().isEmpty()) {
                TypeDeclaration type = (TypeDeclaration) targetFile.getAst().types().get(0);
                for (MethodDeclaration md : type.getMethods()) {
                    if (md.getName().getIdentifier().equals(methodName)) {
                        for (Object p : md.parameters()) {
                            SingleVariableDeclaration param = (SingleVariableDeclaration) p;
                            types.add(param.getType().toString());
                        }
                        return types;
                    }
                }
            }
        }
        return types;
    }

    private List<String> findParameterNames(CompletionContext context, String className, String methodName) {
        List<String> names = new ArrayList<>();
        ProjectFile targetFile = findProjectFile(context, className);

        if (targetFile != null) {
            ensureAstParsed(targetFile);
            if (targetFile.getAst() != null && !targetFile.getAst().types().isEmpty()) {
                TypeDeclaration type = (TypeDeclaration) targetFile.getAst().types().get(0);
                for (MethodDeclaration md : type.getMethods()) {
                    if (md.getName().getIdentifier().equals(methodName)) {
                        for (Object p : md.parameters()) {
                            SingleVariableDeclaration param = (SingleVariableDeclaration) p;
                            names.add(param.getName().getIdentifier());
                        }
                        return names;
                    }
                }
            }
        }
        return names;
    }

    /**
     * UPDATED: Returns TypeInfo instead of string type
     */
    private TypeInfo getParameterTypeInfoAt(CompletionContext context, String className, String methodName, int index) {
        List<String> types = findParameterTypes(context, className, methodName);
        if (index >= 0 && index < types.size()) {
            return TypeInfo.from(types.get(index));
        }
        return TypeInfo.UNKNOWN;
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\blocks\NotOperatorBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractExpressionBlock;
import com.botmaker.core.ExpressionBlock;
import com.botmaker.lsp.CompletionContext;
import com.botmaker.ui.builders.BlockLayout;
import com.botmaker.ui.components.BlockUIComponents;
import com.botmaker.util.TypeInfo;
import javafx.scene.Node;
import javafx.scene.control.Button;
import org.eclipse.jdt.core.dom.Expression;
import org.eclipse.jdt.core.dom.PrefixExpression;

public class NotOperatorBlock extends AbstractExpressionBlock {

    private ExpressionBlock operand;

    public NotOperatorBlock(String id, PrefixExpression astNode) {
        super(id, astNode);
    }

    public void setOperand(ExpressionBlock operand) {
        this.operand = operand;
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        // "!" [Expression] [Change]
        var sentence = BlockLayout.sentence()
                .addLabel("!")
                .addExpressionSlot(operand, context, TypeInfo.BOOLEAN)
                .addNode(BlockUIComponents.createChangeButton(e ->
                        showExpressionMenuAndReplace((Button)e.getSource(), context, TypeInfo.BOOLEAN,
                                operand != null ? (Expression) operand.getAstNode() : null)
                ));

        Node root = sentence.build();
        root.getStyleClass().add("logic-expression-block");
        return root;
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\blocks\PrintBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractStatementBlock;
import com.botmaker.core.ExpressionBlock;
import com.botmaker.lsp.CompletionContext;
import com.botmaker.ui.builders.BlockLayout;
import com.botmaker.util.TypeInfo;
import javafx.scene.Node;
import javafx.scene.control.Button;
import org.eclipse.jdt.core.dom.ExpressionStatement;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

public class PrintBlock extends AbstractStatementBlock {

    private final List<ExpressionBlock> arguments = new ArrayList<>();

    public PrintBlock(String id, ExpressionStatement astNode) {
        super(id, astNode);
    }

    public void addArgument(ExpressionBlock argument) { this.arguments.add(argument); }

    @Override
    protected Node createUINode(CompletionContext context) {
        var sentenceBuilder = BlockLayout.sentence()
                .addLabel("Print:");

        if (arguments.isEmpty()) {
            sentenceBuilder.addNode(createExpressionDropZone(context));
        } else {
            for (ExpressionBlock arg : arguments) {
                sentenceBuilder.addNode(arg.getUINode(context));
            }
        }

        // Add Button
        Button addButton = createAddButton(e -> {
            org.eclipse.jdt.core.dom.Expression toReplace = !arguments.isEmpty() ?
                    (org.eclipse.jdt.core.dom.Expression) arguments.get(0).getAstNode() : null;
            showExpressionMenuAndReplace((Button)e.getSource(), context, TypeInfo.UNKNOWN, toReplace);
        });

        sentenceBuilder.addNode(addButton);

        return BlockLayout.header()
                .withCustomNode(sentenceBuilder.build())
                .withDeleteButton(() -> context.codeEditor().deleteStatement((org.eclipse.jdt.core.dom.Statement) this.astNode))
                .build();
    }

    @Override
    public String getDetails() {
        String argsString = arguments.stream().map(ExpressionBlock::getDetails).collect(Collectors.joining(", "));
        return "Print Statement: " + argsString;
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\blocks\ReadInputBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractStatementBlock;
import com.botmaker.core.ExpressionBlock;
import com.botmaker.lsp.CompletionContext;
import com.botmaker.ui.builders.BlockLayout;
import com.botmaker.ui.components.BlockUIComponents;
import javafx.scene.Node;
import javafx.scene.control.Label;
import org.eclipse.jdt.core.dom.VariableDeclarationStatement;

public class ReadInputBlock extends AbstractStatementBlock {

    private ExpressionBlock variableName;
    private String inputType;

    public ReadInputBlock(String id, VariableDeclarationStatement astNode, String inputType) {
        super(id, astNode);
        this.inputType = inputType;
    }

    public void setVariableName(ExpressionBlock variableName) { this.variableName = variableName; }

    @Override
    protected Node createUINode(CompletionContext context) {
        Label scannerLabel = new Label("scanner." + inputType + "()");
        scannerLabel.getStyleClass().add("method-call-label");

        var sentence = BlockLayout.sentence()
                .addNode(BlockUIComponents.createTypeLabel(getTypeDisplayName()))
                .addNode(variableName != null ? variableName.getUINode(context) : createExpressionDropZone(context))
                .addKeyword("=")
                .addNode(scannerLabel)
                .build();

        return BlockLayout.header()
                .withCustomNode(sentence)
                .withDeleteButton(() -> context.codeEditor().deleteStatement((org.eclipse.jdt.core.dom.Statement) this.astNode))
                .build();
    }

    private String getTypeDisplayName() {
        switch (inputType) {
            case "nextLine": return "String";
            case "nextInt": return "int";
            case "nextDouble": return "double";
            case "nextBoolean": return "boolean";
            default: return "var";
        }
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\blocks\ReturnBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractStatementBlock;
import com.botmaker.core.ExpressionBlock;
import com.botmaker.lsp.CompletionContext;
import com.botmaker.ui.builders.BlockLayout;
import com.botmaker.ui.components.BlockUIComponents;
import com.botmaker.ui.theme.StyleBuilder;
import com.botmaker.util.TypeInfo;
import javafx.scene.Node;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import org.eclipse.jdt.core.dom.ASTNode;
import org.eclipse.jdt.core.dom.MethodDeclaration;
import org.eclipse.jdt.core.dom.ReturnStatement;

public class ReturnBlock extends AbstractStatementBlock {

    private ExpressionBlock expression;

    public ReturnBlock(String id, ReturnStatement astNode) {
        super(id, astNode);
    }

    public void setExpression(ExpressionBlock expression) {
        this.expression = expression;
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        String methodReturnType = findParentMethodReturnType();
        boolean isVoid = "void".equals(methodReturnType);

        var sentenceBuilder = BlockLayout.sentence().addKeyword("return");

        if (expression != null) {
            sentenceBuilder
                    .addNode(expression.getUINode(context))
                    .addNode(BlockUIComponents.createChangeButton(e ->
                            showExpressionMenuAndReplace((Button)e.getSource(), context, TypeInfo.from(methodReturnType),
                                    (org.eclipse.jdt.core.dom.Expression)expression.getAstNode())
                    ));
        } else if (!isVoid) {
            sentenceBuilder.addNode(createAddButton(e ->
                    BlockUIComponents.createExpressionTypeMenu(TypeInfo.from(methodReturnType), type ->
                            context.codeEditor().setReturnExpression((ReturnStatement) this.astNode, type)
                    ).show((Button)e.getSource(), javafx.geometry.Side.BOTTOM, 0, 0)
            ));
        } else {
            Label voidLabel = new Label("(void)");
            StyleBuilder.create()
                    .textColor("#aaa")
                    .fontSize(10)
                    .build();
            sentenceBuilder.addNode(voidLabel);
        }

        return BlockLayout.header()
                .withCustomNode(sentenceBuilder.build())
                .withDeleteButton(() -> context.codeEditor().deleteStatement((org.eclipse.jdt.core.dom.Statement) this.astNode))
                .build();
    }

    private String findParentMethodReturnType() {
        ASTNode current = this.astNode.getParent();
        while (current != null) {
            if (current instanceof MethodDeclaration) {
                MethodDeclaration md = (MethodDeclaration) current;
                if (md.getReturnType2() != null) {
                    return md.getReturnType2().toString();
                }
                return "void";
            }
            current = current.getParent();
        }
        return "void";
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\blocks\SwitchBlock.java
=================================================================================

// FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\blocks\SwitchBlock.java
package com.botmaker.blocks;

import com.botmaker.core.AbstractStatementBlock;
import com.botmaker.core.BodyBlock;
import com.botmaker.core.BlockWithChildren;
import com.botmaker.core.CodeBlock;
import com.botmaker.core.ExpressionBlock;
import com.botmaker.lsp.CompletionContext;
import com.botmaker.ui.BlockDragAndDropManager;
import com.botmaker.ui.builders.BlockLayout;
import com.botmaker.ui.components.BlockUIComponents;
import com.botmaker.util.TypeInfo;
import javafx.geometry.Insets;
import javafx.scene.Node;
import javafx.scene.control.Button;
import javafx.scene.control.ContextMenu;
import javafx.scene.layout.HBox;
import javafx.scene.layout.VBox;
import org.eclipse.jdt.core.dom.*;

import java.util.ArrayList;
import java.util.List;

public class SwitchBlock extends AbstractStatementBlock implements BlockWithChildren {

    private ExpressionBlock expression;
    private final List<SwitchCaseBlock> cases = new ArrayList<>();
    private final BlockDragAndDropManager dragAndDropManager;

    public SwitchBlock(String id, SwitchStatement astNode, BlockDragAndDropManager dragAndDropManager) {
        super(id, astNode);
        this.dragAndDropManager = dragAndDropManager;
    }

    public void setExpression(ExpressionBlock expression) { this.expression = expression; }
    public void addCase(SwitchCaseBlock caseBlock) { this.cases.add(caseBlock); }

    @Override
    public List<CodeBlock> getChildren() {
        List<CodeBlock> children = new ArrayList<>();
        if (expression != null) children.add(expression);
        children.addAll(cases);
        return children;
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        VBox mainContainer = new VBox(5);

        TypeInfo switchType = TypeInfo.UNKNOWN;
        if (expression != null && expression.getAstNode() != null) {
            Expression expr = (Expression) expression.getAstNode();
            ITypeBinding binding = expr.resolveTypeBinding();
            if (binding != null) {
                switchType = TypeInfo.from(binding);
            }
        }

        TypeInfo finalSwitchType = switchType;
        Button changeSwitchExprBtn = BlockUIComponents.createChangeButton(e ->
                showExpressionMenuAndReplace((Button)e.getSource(), context, finalSwitchType,
                        expression != null ? (Expression) expression.getAstNode() : null)
        );

        var headerSentence = BlockLayout.sentence()
                .addKeyword("switch")
                .addExpressionSlot(expression, context, switchType)
                .addNode(changeSwitchExprBtn)
                .build();

        mainContainer.getChildren().add(BlockLayout.header()
                .withCustomNode(headerSentence)
                .withDeleteButton(() -> context.codeEditor().deleteStatement((org.eclipse.jdt.core.dom.Statement) this.astNode))
                .build());

        VBox casesContainer = new VBox(5);
        casesContainer.setPadding(new javafx.geometry.Insets(5, 0, 0, 20));

        for (int i = 0; i < cases.size(); i++) {
            SwitchCaseBlock caseBlock = cases.get(i);
            casesContainer.getChildren().add(caseBlock.createUINode(context, i, cases.size()));
        }

        mainContainer.getChildren().add(casesContainer);

        Button addCaseButton = new Button("+ Add Case");
        addCaseButton.setOnAction(e -> context.codeEditor().addCaseToSwitch((SwitchStatement) this.astNode));
        mainContainer.getChildren().add(addCaseButton);

        return mainContainer;
    }

    public static class SwitchCaseBlock extends AbstractStatementBlock implements BlockWithChildren {
        private ExpressionBlock caseExpression;
        private BodyBlock body;

        public SwitchCaseBlock(String id, SwitchCase astNode) {
            super(id, astNode);
        }

        public void setCaseExpression(ExpressionBlock caseExpression) { this.caseExpression = caseExpression; }
        public void setBody(BodyBlock body) { this.body = body; }
        public boolean isDefault() { return caseExpression == null; }

        @Override
        public List<CodeBlock> getChildren() {
            List<CodeBlock> children = new ArrayList<>();
            if (caseExpression != null) children.add(caseExpression);
            if (body != null) children.add(body);
            return children;
        }

        @Override
        protected Node createUINode(CompletionContext context) {
            return createUINode(context, -1, -1);
        }
        private TypeInfo getSwitchExpressionType() {
            // Get the parent SwitchStatement
            ASTNode parent = this.astNode.getParent();
            if (parent instanceof SwitchStatement) {
                SwitchStatement switchStmt = (SwitchStatement) parent;
                Expression switchExpr = switchStmt.getExpression();
                if (switchExpr != null) {
                    ITypeBinding binding = switchExpr.resolveTypeBinding();
                    if (binding != null) {
                        return TypeInfo.from(binding);
                    }
                }
            }
            return TypeInfo.UNKNOWN;
        }
        public Node createUINode(CompletionContext context, int index, int totalCases) {
            VBox container = new VBox(5);
            var caseHeaderBuilder = BlockLayout.sentence();

            if (isDefault()) {
                caseHeaderBuilder.addKeyword("default:");
            } else {
                TypeInfo switchType = getSwitchExpressionType();

                // FIX: Filter menu for constants only
                Button changeBtn = BlockUIComponents.createChangeButton(e -> {
                    ContextMenu menu = BlockUIComponents.createExpressionTypeMenu(
                            switchType,
                            true, // constantOnly = true
                            type -> context.codeEditor().replaceExpression(
                                    (Expression) caseExpression.getAstNode(), type)
                    );
                    menu.show((Button)e.getSource(), javafx.geometry.Side.BOTTOM, 0, 0);
                });

                caseHeaderBuilder
                        .addKeyword("case")
                        .addExpressionSlot(caseExpression, context, switchType)
                        .addNode(changeBtn)
                        .addKeyword(":");
            }

            if (index >= 0) {
                Button upBtn = new Button("▲");
                upBtn.setStyle("-fx-font-size: 9px; -fx-padding: 2 4 2 4;");
                upBtn.setDisable(index == 0);
                upBtn.setOnAction(e -> context.codeEditor().moveSwitchCase((SwitchCase) this.astNode, true));

                Button downBtn = new Button("▼");
                downBtn.setStyle("-fx-font-size: 9px; -fx-padding: 2 4 2 4;");
                downBtn.setDisable(index == totalCases - 1);
                downBtn.setOnAction(e -> context.codeEditor().moveSwitchCase((SwitchCase) this.astNode, false));

                caseHeaderBuilder
                        .addNode(BlockUIComponents.createSpacer())
                        .addNode(upBtn)
                        .addNode(downBtn);
            }

            HBox caseHeader = caseHeaderBuilder.build();
            caseHeader.getChildren().add(createDeleteButton(context));

            container.getChildren().add(caseHeader);

            VBox bodyNode = createIndentedBody(body, context, "switch-case-body");
            if (bodyNode != null) container.getChildren().add(bodyNode);

            return container;
        }
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\blocks\VariableDeclarationBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractStatementBlock;
import com.botmaker.core.ExpressionBlock;
import com.botmaker.lsp.CompletionContext;
import com.botmaker.ui.AddableExpression;
import com.botmaker.ui.builders.BlockLayout;
import com.botmaker.ui.components.BlockUIComponents;
import com.botmaker.ui.components.TextFieldComponents;
import com.botmaker.util.TypeInfo;
import com.botmaker.util.TypeManager;
import javafx.geometry.Pos;
import javafx.scene.Cursor;
import javafx.scene.Node;
import javafx.scene.control.*;
import javafx.scene.layout.HBox;
import org.eclipse.jdt.core.dom.*;

import java.util.ArrayList;
import java.util.List;

import static com.botmaker.ui.components.BlockUIComponents.createTypeLabel;

/**
 * UPDATED: Uses TypeInfo for type operations
 */
public class VariableDeclarationBlock extends AbstractStatementBlock {

    private final String variableName;
    private final Type variableType;
    private ExpressionBlock initializer;

    public VariableDeclarationBlock(String id, VariableDeclarationStatement astNode) {
        super(id, astNode);
        VariableDeclarationFragment fragment = (VariableDeclarationFragment) astNode.fragments().get(0);
        this.variableName = fragment.getName().getIdentifier();
        this.variableType = astNode.getType();
        this.initializer = null;
    }

    public void setInitializer(ExpressionBlock initializer) { this.initializer = initializer; }

    @Override
    protected Node createUINode(CompletionContext context) {
        // UPDATED: Use TypeInfo instead of determineUiType
        TypeInfo varType = TypeInfo.from(variableType);

        Label typeLabel = createTypeLabel(getDisplayTypeName(variableType));
        typeLabel.setCursor(Cursor.HAND);
        Tooltip.install(typeLabel, new Tooltip("Click to change type"));
        typeLabel.setOnMouseClicked(e -> showTypeMenu(typeLabel, context));

        TextField nameField = TextFieldComponents.createVariableNameField(variableName, newName -> {
            VariableDeclarationFragment fragment = (VariableDeclarationFragment)
                    ((VariableDeclarationStatement) this.astNode).fragments().get(0);
            if (!newName.equals(variableName) && !newName.isEmpty()) {
                context.codeEditor().replaceSimpleName(fragment.getName(), newName);
            }
        });

        Node initNode;
        if (initializer != null) {
            if (initializer instanceof ListBlock) {
                initNode = initializer.getUINode(context);
            } else if (initializer.getAstNode() instanceof org.eclipse.jdt.core.dom.ArrayInitializer) {
                initNode = createListDisplay(context);
            } else {
                initNode = initializer.getUINode(context);
            }
        } else {
            initNode = createExpressionDropZone(context);
        }

        Button addButton = createAddButton(e -> {
            Expression currentInitializer = initializer != null ?
                    (Expression) initializer.getAstNode() : null;

            ContextMenu menu = BlockUIComponents.createExpressionTypeMenu(varType, type -> {
                if (currentInitializer != null) {
                    context.codeEditor().replaceExpression(currentInitializer, type);
                } else {
                    context.codeEditor().setVariableInitializer(
                            (VariableDeclarationStatement) this.astNode, type);
                }
            });
            menu.show((Button)e.getSource(), javafx.geometry.Side.BOTTOM, 0, 0);
        });

        var sentence = BlockLayout.sentence()
                .addNode(typeLabel)
                .addNode(nameField)
                .addKeyword("=")
                .addNode(initNode)
                .addNode(addButton)
                .build();

        return BlockLayout.header()
                .withCustomNode(sentence)
                .withDeleteButton(() -> context.codeEditor().deleteStatement(
                        (org.eclipse.jdt.core.dom.Statement) this.astNode))
                .build();
    }

    private void showTypeMenu(Node anchor, CompletionContext context) {
        ContextMenu menu = new ContextMenu();
        String currentStr = variableType.toString();
        boolean isArray = variableType.isArrayType();

        // 1. Add/Remove Dimension Logic
        MenuItem addDim = new MenuItem("Add Dimension []");
        addDim.setOnAction(e -> {
            String newType = currentStr + "[]";
            context.codeEditor().replaceVariableType((VariableDeclarationStatement) this.astNode, newType);
        });
        menu.getItems().add(addDim);

        if (isArray) {
            MenuItem removeDim = new MenuItem("Remove Dimension []");
            removeDim.setOnAction(e -> {
                if (currentStr.endsWith("[]")) {
                    String newType = currentStr.substring(0, currentStr.length() - 2);
                    context.codeEditor().replaceVariableType((VariableDeclarationStatement) this.astNode, newType);
                }
            });
            menu.getItems().add(removeDim);
        }

        menu.getItems().add(new SeparatorMenuItem());

        // 2. Change Base Type
        Menu changeBaseMenu = new Menu("Change Base Type");

        // Primitive Types
        for (String type : TypeManager.getFundamentalTypeNames()) {
            MenuItem item = new MenuItem(type);
            item.setOnAction(e -> {
                // Preserve dimensions when changing base type
                String newType = preserveDimensions(currentStr, type);
                context.codeEditor().replaceVariableType((VariableDeclarationStatement) this.astNode, newType);
            });
            changeBaseMenu.getItems().add(item);
        }

        // Enum Types
        List<String> availableEnums = getAvailableEnums(context);
        if (!availableEnums.isEmpty()) {
            changeBaseMenu.getItems().add(new SeparatorMenuItem());
            for (String enumName : availableEnums) {
                MenuItem item = new MenuItem(enumName);
                item.setOnAction(e -> {
                    String newType = preserveDimensions(currentStr, enumName);
                    context.codeEditor().replaceVariableType((VariableDeclarationStatement) this.astNode, newType);
                });
                changeBaseMenu.getItems().add(item);
            }
        }
        menu.getItems().add(changeBaseMenu);

        menu.show(anchor, javafx.geometry.Side.BOTTOM, 0, 0);
    }

    private String preserveDimensions(String oldType, String newBase) {
        // UPDATED: Use TypeInfo for dimension counting
        TypeInfo type = TypeInfo.from(oldType);
        int dims = type.getArrayDimensions();
        return newBase + "[]".repeat(dims);
    }

    private HBox createListDisplay(CompletionContext context) {
        HBox listBox = new HBox(3);
        listBox.setAlignment(Pos.CENTER_LEFT);
        listBox.getStyleClass().add("inline-list-display");

        Label open = new Label("{"); open.setStyle("-fx-font-weight: bold; -fx-font-size: 14px;");
        Label close = new Label("}"); close.setStyle("-fx-font-weight: bold; -fx-font-size: 14px;");

        listBox.getChildren().addAll(open, initializer.getUINode(context), close);
        return listBox;
    }

    private String getDisplayTypeName(Type type) {
        String typeName = type.toString();
        return typeName;
    }

    // Get all available enum types from the compilation unit
    private List<String> getAvailableEnums(CompletionContext context) {
        List<String> enumNames = new ArrayList<>();

        CompilationUnit cu = context.applicationState().getCompilationUnit().orElse(null);
        if (cu == null) return enumNames;

        if (!cu.types().isEmpty() && cu.types().get(0) instanceof TypeDeclaration) {
            TypeDeclaration typeDecl = (TypeDeclaration) cu.types().get(0);

            for (Object obj : typeDecl.bodyDeclarations()) {
                if (obj instanceof EnumDeclaration) {
                    EnumDeclaration enumDecl = (EnumDeclaration) obj;
                    enumNames.add(enumDecl.getName().getIdentifier());
                }
                else if (obj instanceof MethodDeclaration) {
                    MethodDeclaration method = (MethodDeclaration) obj;
                    if (method.getBody() != null) {
                        findLocalEnums(method.getBody(), enumNames);
                    }
                }
            }
        }
        else if (!cu.types().isEmpty() && cu.types().get(0) instanceof EnumDeclaration) {
            EnumDeclaration enumDecl = (EnumDeclaration) cu.types().get(0);
            enumNames.add(enumDecl.getName().getIdentifier());
        }

        return enumNames;
    }

    private void findLocalEnums(ASTNode node, List<String> enumNames) {
        if (node instanceof TypeDeclarationStatement) {
            TypeDeclarationStatement tds = (TypeDeclarationStatement) node;
            if (tds.getDeclaration() instanceof EnumDeclaration) {
                EnumDeclaration enumDecl = (EnumDeclaration) tds.getDeclaration();
                enumNames.add(enumDecl.getName().getIdentifier());
            }
        }
        if (node instanceof Block) {
            for (Object stmt : ((Block) node).statements()) {
                findLocalEnums((ASTNode) stmt, enumNames);
            }
        }
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\blocks\WaitBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractStatementBlock;
import com.botmaker.core.ExpressionBlock;
import com.botmaker.lsp.CompletionContext;
import com.botmaker.ui.builders.BlockLayout;
import com.botmaker.util.TypeInfo;
import javafx.scene.Node;
import org.eclipse.jdt.core.dom.Statement;

public class WaitBlock extends AbstractStatementBlock {

    private ExpressionBlock duration;

    public WaitBlock(String id, Statement astNode) {
        super(id, astNode);
    }

    public void setDuration(ExpressionBlock duration) {
        this.duration = duration;
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        var sentence = BlockLayout.sentence()
                .addKeyword("Wait")
                .addExpressionSlot(duration, context, TypeInfo.INT)
                .addKeyword("ms")
                .build();

        return BlockLayout.header()
                .withCustomNode(sentence)
                .withDeleteButton(() -> context.codeEditor().deleteStatement((Statement) this.astNode))
                .build();
    }

    @Override
    public String getDetails() {
        return "Wait: " + (duration != null ? duration.getDetails() : "...");
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\blocks\WhileBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractStatementBlock;
import com.botmaker.core.BodyBlock;
import com.botmaker.core.BlockWithChildren;
import com.botmaker.core.CodeBlock;
import com.botmaker.core.ExpressionBlock;
import com.botmaker.lsp.CompletionContext;
import com.botmaker.ui.BlockDragAndDropManager;
import com.botmaker.ui.builders.BlockLayout;
import com.botmaker.util.TypeInfo;
import javafx.scene.Node;
import javafx.scene.control.Button;
import javafx.scene.layout.VBox;
import org.eclipse.jdt.core.dom.Expression;
import org.eclipse.jdt.core.dom.Statement;
import org.eclipse.jdt.core.dom.WhileStatement;

import java.util.ArrayList;
import java.util.List;

public class WhileBlock extends AbstractStatementBlock implements BlockWithChildren {

    private ExpressionBlock condition;
    private BodyBlock body;

    public WhileBlock(String id, WhileStatement astNode, BlockDragAndDropManager dragAndDropManager) {
        super(id, astNode);
    }

    public void setCondition(ExpressionBlock condition) { this.condition = condition; }
    public void setBody(BodyBlock body) { this.body = body; }

    @Override
    public List<CodeBlock> getChildren() {
        List<CodeBlock> children = new ArrayList<>();
        if (condition != null) children.add(condition);
        if (body != null) children.add(body);
        return children;
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        VBox container = new VBox(5);

        // 1. Create the Add/Change Button
        // We do this manually to capture the event source (the button itself)
        Button changeBtn = createAddButton(e ->
                showExpressionMenuAndReplace(
                        (Button) e.getSource(),
                        context,
                        TypeInfo.BOOLEAN,
                        condition != null ? (Expression) condition.getAstNode() : null
                )
        );

        // 2. Build Header: "while [condition] [+]"
        Node headerContent = BlockLayout.sentence()
                .addKeyword("while")
                .addExpressionSlot(condition, context, TypeInfo.BOOLEAN)
                .addNode(changeBtn)
                .build();

        container.getChildren().add(BlockLayout.header()
                .withCustomNode(headerContent)
                .withDeleteButton(() -> context.codeEditor().deleteStatement((Statement) this.astNode))
                .build());

        // 3. Body
        container.getChildren().add(createIndentedBody(body, context, "loop-body"));

        return container;
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\config\ApplicationConfig.java
=================================================================================

package com.botmaker.config;

import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Locale;

public class ApplicationConfig {

    // ... [Existing Fields remain same] ...
    private final Path jdtServerPath;
    private final Path projectPath;
    private final Path workspaceDataPath;
    private final Path sourceFilePath;
    private final Path compiledOutputPath;
    private final String mainClassName;
    private final String javaHome;
    private final String javaExecutable;
    private final String javacExecutable;
    private final int initialWidth;
    private final int initialHeight;
    private final boolean enableEventLogging;

    private ApplicationConfig(Builder builder) {
        this.jdtServerPath = builder.jdtServerPath;
        this.projectPath = builder.projectPath;
        this.workspaceDataPath = builder.workspaceDataPath;
        this.sourceFilePath = builder.sourceFilePath;
        this.compiledOutputPath = builder.compiledOutputPath;
        this.mainClassName = builder.mainClassName;
        this.javaHome = builder.javaHome;
        this.javaExecutable = builder.javaExecutable;
        this.javacExecutable = builder.javacExecutable;
        this.initialWidth = builder.initialWidth;
        this.initialHeight = builder.initialHeight;
        this.enableEventLogging = builder.enableEventLogging;
    }

    // ... [Getters remain same] ...
    public Path getJdtServerPath() { return jdtServerPath; }
    public Path getProjectPath() { return projectPath; }
    public Path getWorkspaceDataPath() { return workspaceDataPath; }
    public Path getSourceFilePath() { return sourceFilePath; }
    public Path getCompiledOutputPath() { return compiledOutputPath; }
    public String getMainClassName() { return mainClassName; }
    public String getJavaHome() { return javaHome; }
    public String getJavaExecutable() { return javaExecutable; }
    public String getJavacExecutable() { return javacExecutable; }
    public int getInitialWidth() { return initialWidth; }
    public int getInitialHeight() { return initialHeight; }
    public boolean isEnableEventLogging() { return enableEventLogging; }

    public static ApplicationConfig forProject(String projectName) {
        String javaHome = System.getProperty("java.home");
        String packageName = projectName.toLowerCase();
        String mainClassName = projectName;

        // --- FIX: OS Detection for Executables ---
        boolean isWindows = System.getProperty("os.name").toLowerCase(Locale.ROOT).contains("win");
        String javaBin = isWindows ? "java.exe" : "java";
        String javacBin = isWindows ? "javac.exe" : "javac";

        return new Builder()
                .jdtServerPath(Paths.get("tools", "jdt-language-server")) // Use varargs for separator safety
                .projectPath(Paths.get("projects", projectName))
                .workspaceDataPath(Paths.get(System.getProperty("user.home"), ".jdtls-workspace", projectName))
                .sourceFilePath(Paths.get("projects", projectName, "src", "main", "java", "com", packageName, mainClassName + ".java"))
                .compiledOutputPath(Paths.get("projects", projectName, "build", "classes", "java", "main"))
                .mainClassName("com." + packageName + "." + mainClassName)
                .javaHome(javaHome)
                .javaExecutable(Paths.get(javaHome, "bin", javaBin).toString())
                .javacExecutable(Paths.get(javaHome, "bin", javacBin).toString())
                .initialWidth(600)
                .initialHeight(800)
                .enableEventLogging(false)
                .build();
    }

    // ... [Builder Class remains same] ...
    public static class Builder {
        private Path jdtServerPath;
        private Path projectPath;
        private Path workspaceDataPath;
        private Path sourceFilePath;
        private Path compiledOutputPath;
        private String mainClassName;
        private String javaHome;
        private String javaExecutable;
        private String javacExecutable;
        private int initialWidth = 600;
        private int initialHeight = 800;
        private boolean enableEventLogging = false;

        public Builder jdtServerPath(Path jdtServerPath) { this.jdtServerPath = jdtServerPath; return this; }
        public Builder projectPath(Path projectPath) { this.projectPath = projectPath; return this; }
        public Builder workspaceDataPath(Path workspaceDataPath) { this.workspaceDataPath = workspaceDataPath; return this; }
        public Builder sourceFilePath(Path sourceFilePath) { this.sourceFilePath = sourceFilePath; return this; }
        public Builder compiledOutputPath(Path compiledOutputPath) { this.compiledOutputPath = compiledOutputPath; return this; }
        public Builder mainClassName(String mainClassName) { this.mainClassName = mainClassName; return this; }
        public Builder javaHome(String javaHome) { this.javaHome = javaHome; return this; }
        public Builder javaExecutable(String javaExecutable) { this.javaExecutable = javaExecutable; return this; }
        public Builder javacExecutable(String javacExecutable) { this.javacExecutable = javacExecutable; return this; }
        public Builder initialWidth(int initialWidth) { this.initialWidth = initialWidth; return this; }
        public Builder initialHeight(int initialHeight) { this.initialHeight = initialHeight; return this; }
        public Builder enableEventLogging(boolean enableEventLogging) { this.enableEventLogging = enableEventLogging; return this; }

        public ApplicationConfig build() {
            if (jdtServerPath == null) throw new IllegalStateException("jdtServerPath is required");
            if (projectPath == null) throw new IllegalStateException("projectPath is required");
            if (mainClassName == null) throw new IllegalStateException("mainClassName is required");
            return new ApplicationConfig(this);
        }
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\config\Constants.java
=================================================================================

package com.botmaker.config;

/**
 * Application-wide constants
 */
public class Constants {

    // Debugger Configuration
    public static final int DEBUGGER_MAX_CONNECT_RETRIES = 10;
    public static final int DEBUGGER_RETRY_DELAY_MS = 250;
    public static final int DEBUGGER_SHUTDOWN_TIMEOUT_SECONDS = 2;
    public static final int DEBUGGER_EXIT_DELAY_MS = 500;

    // Thread Sleep Times
    public static final int SHORT_SLEEP_MS = 500;

    // JVM Options
    public static final String JVM_MAX_HEAP = "-Xmx1G";
    public static final String JVM_ENTITY_SIZE_LIMIT = "-Djdk.xml.maxGeneralEntitySizeLimit=0";
    public static final String JVM_TOTAL_ENTITY_SIZE_LIMIT = "-Djdk.xml.totalEntitySizeLimit=0";

    // LSP Configuration
    public static final String LSP_DETECT_VM_DISABLED = "-DDetectVMInstallationsJob.disabled=true";
    public static final String LSP_FILE_ENCODING = "-Dfile.encoding=UTF-8";
    public static final String LSP_LOG_DISABLE = "-Xlog:disable";
    public static final String LSP_DEPENDENCY_COLLECTOR = "-Daether.dependencyCollector.impl=bf";

    // Debug Flags (disable for production)
    public static final boolean LSP_LOG_PROTOCOL = true;
    public static final String LSP_LOG_LEVEL = "ALL";

    private Constants() {} // Prevent instantiation
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\core\AbstractCodeBlock.java
=================================================================================

package com.botmaker.core;

import com.botmaker.lsp.CompletionContext;
import javafx.beans.binding.Bindings;
import javafx.geometry.Insets;
import javafx.scene.Node;
import javafx.scene.control.ContextMenu;
import javafx.scene.control.MenuItem;
import javafx.scene.control.Tooltip;
import javafx.scene.layout.Pane;
import javafx.scene.layout.Region;
import javafx.scene.paint.Color;
import javafx.scene.shape.Circle;
import org.eclipse.jdt.core.dom.ASTNode;
import org.eclipse.jdt.core.dom.CompilationUnit;

public abstract class AbstractCodeBlock implements CodeBlock {
    protected final String id;
    protected final ASTNode astNode;

    protected Node uiNode;
    private javafx.scene.control.Tooltip errorTooltip;

    // Breakpoint State
    protected boolean isBreakpoint = false;
    private Circle breakpointCircle;

    // Constants
    private static final double GUTTER_PADDING = 12.0; // Space reserved on the left
    private static final double CIRCLE_RADIUS = 4.0;

    public AbstractCodeBlock(String id, ASTNode astNode) {
        this.id = id;
        this.astNode = astNode;
    }

    @Override
    public String getId() { return id; }

    @Override
    public ASTNode getAstNode() { return astNode; }

    @Override
    public Node getUINode(CompletionContext context) {
        if (uiNode == null) {
            // 1. Create the standard UI
            this.uiNode = createUINode(context);

            // 2. Inject the visual Gutter (Padding + Circle)
            if (uiNode instanceof Region) {
                Region region = (Region) uiNode;

                // Add left padding to make room for the circle
                Insets existing = region.getPadding();
                region.setPadding(new Insets(
                        existing.getTop(),
                        existing.getRight(),
                        existing.getBottom(),
                        existing.getLeft() + GUTTER_PADDING
                ));

                // If the UI node allows children (Pane), add the floating circle
                if (uiNode instanceof Pane) {
                    Pane pane = (Pane) uiNode;

                    breakpointCircle = new Circle(CIRCLE_RADIUS, Color.RED);
                    breakpointCircle.setManaged(false); // Don't affect flow layout
                    breakpointCircle.setVisible(false); // Hidden by default

                    // Position: Center vertically, placed inside the left padding
                    // x = (Padding / 2) roughly centers it in the gutter
                    breakpointCircle.setLayoutX(GUTTER_PADDING / 2 + existing.getLeft());
                    breakpointCircle.centerYProperty().bind(pane.heightProperty().divide(2));

                    pane.getChildren().add(breakpointCircle);
                }
            }

            // 3. Setup Interaction
            setupBreakpointInteraction();

            // 4. Discovery Tooltip
            Tooltip tip = new Tooltip("Right-click to toggle breakpoint");
            Tooltip.install(uiNode, tip);
        }

        updateBreakpointVisuals();
        return uiNode;
    }

    private void setupBreakpointInteraction() {
        if (uiNode == null) return;

        ContextMenu contextMenu = new ContextMenu();
        MenuItem toggleBpItem = new MenuItem("Toggle Breakpoint");
        toggleBpItem.setOnAction(ev -> toggleBreakpoint());
        contextMenu.getItems().add(toggleBpItem);

        uiNode.setOnContextMenuRequested(e -> {
            toggleBpItem.setText(isBreakpoint ? "Remove Breakpoint 🔴" : "Add Breakpoint ⚪");
            contextMenu.show(uiNode, e.getScreenX(), e.getScreenY());
            e.consume();
        });
    }

    @Override
    public Node getUINode() { return uiNode; }

    @Override
    public void highlight() {
        if (uiNode != null && !uiNode.getStyleClass().contains("highlighted")) {
            uiNode.getStyleClass().add("highlighted");
        }
    }

    @Override
    public void unhighlight() {
        if (uiNode != null) {
            uiNode.getStyleClass().remove("highlighted");
        }
    }

    @Override
    public void setError(String message) {
        if (uiNode != null) {
            if (!uiNode.getStyleClass().contains("error-block")) {
                uiNode.getStyleClass().add("error-block");
            }
            if (errorTooltip == null) {
                errorTooltip = new Tooltip(message);
                Tooltip.install(uiNode, errorTooltip);
            } else {
                errorTooltip.setText(message);
            }
        }
    }

    @Override
    public void clearError() {
        if (uiNode != null) {
            uiNode.getStyleClass().remove("error-block");
            if (errorTooltip != null) {
                Tooltip.uninstall(uiNode, errorTooltip);
                errorTooltip = null;
            }
        }
    }

    @Override
    public int getBreakpointLine(CompilationUnit cu) {
        if (cu == null || astNode == null) return -1;
        return cu.getLineNumber(astNode.getStartPosition());
    }

    @Override
    public CodeBlock getHighlightTarget() { return this; }

    @Override
    public String getDetails() {
        return this.getClass().getSimpleName() + " (ID: " + this.getId() + ")";
    }

    @Override
    public boolean isBreakpoint() { return isBreakpoint; }

    @Override
    public void setBreakpoint(boolean enabled) {
        this.isBreakpoint = enabled;
        updateBreakpointVisuals();
    }

    @Override
    public void toggleBreakpoint() {
        setBreakpoint(!isBreakpoint);
        if (uiNode != null) {
            uiNode.fireEvent(new com.botmaker.ui.BlockEvent.BreakpointToggleEvent(this, isBreakpoint));
        }
    }

    private void updateBreakpointVisuals() {
        // Update the circle visibility
        if (breakpointCircle != null) {
            breakpointCircle.setVisible(isBreakpoint);
        }

        // Optional: Keep the red border as secondary reinforcement, or remove if circle is enough
        if (uiNode != null) {
            String style = uiNode.getStyle();
            String borderStyle = "-fx-border-color: #e74c3c; -fx-border-width: 0 0 0 2; -fx-border-style: solid;";

            if (isBreakpoint) {
                if (!style.contains("-fx-border-color: #e74c3c")) {
                    uiNode.setStyle(style + borderStyle);
                }
            } else {
                uiNode.setStyle(style.replace(borderStyle, ""));
            }
        }
    }

    protected Node createExpressionDropZone(CompletionContext context) {
        Region dropZone = new Region();
        context.dragAndDropManager().addExpressionDropHandlers(dropZone);
        return dropZone;
    }

    protected abstract Node createUINode(CompletionContext context);
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\core\AbstractExpressionBlock.java
=================================================================================

package com.botmaker.core;

import com.botmaker.lsp.CompletionContext;
import com.botmaker.ui.components.BlockUIComponents;
import com.botmaker.ui.components.SelectorComponents;
import com.botmaker.util.TypeInfo;
import javafx.scene.control.Button;
import javafx.scene.control.ComboBox;
import javafx.scene.control.ContextMenu;
import javafx.scene.control.Label;
import org.eclipse.jdt.core.dom.ASTNode;
import org.eclipse.jdt.core.dom.Expression;

import java.util.function.Consumer;

public abstract class AbstractExpressionBlock extends AbstractCodeBlock implements ExpressionBlock {
    public AbstractExpressionBlock(String id, ASTNode astNode) {
        super(id, astNode);
    }

    // --- HELPER METHODS ---

    protected Label createKeywordLabel(String text) {
        return BlockUIComponents.createKeywordLabel(text);
    }

    protected Label createOperatorLabel(String text) {
        return BlockUIComponents.createOperatorLabel(text);
    }

    protected ComboBox<String> createOperatorSelector(String[] names, String[] symbols, String currentSymbol, Consumer<String> onSymbolChange) {
        return SelectorComponents.createOperatorSelector(names, symbols, currentSymbol, onSymbolChange);
    }

    /**
     * Legacy helper: accepts String targetType.
     * Delegates to TypeInfo version.
     */
    protected void showExpressionMenuAndReplace(Button button, CompletionContext context,
                                                String targetType, Expression toReplace) {
        showExpressionMenuAndReplace(button, context, TypeInfo.from(targetType), toReplace);
    }

    /**
     * Helper to show the expression type menu and replace the current expression node upon selection.
     */
    protected void showExpressionMenuAndReplace(Button button, CompletionContext context,
                                                TypeInfo targetType, Expression toReplace) {
        ContextMenu menu = BlockUIComponents.createExpressionTypeMenu(targetType, type -> {
            if (toReplace != null) {
                context.codeEditor().replaceExpression(toReplace, type);
            }
        });
        menu.show(button, javafx.geometry.Side.BOTTOM, 0, 0);
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\core\AbstractStatementBlock.java
=================================================================================

package com.botmaker.core;

import com.botmaker.lsp.CompletionContext;
import com.botmaker.ui.components.BlockUIComponents;
import com.botmaker.ui.components.LayoutComponents;
import com.botmaker.ui.components.PlaceholderComponents;
import com.botmaker.util.TypeInfo;
import javafx.scene.Node;
import javafx.scene.control.Button;
import javafx.scene.control.ContextMenu;
import javafx.scene.control.Label;
import javafx.scene.layout.HBox;
import org.eclipse.jdt.core.dom.ASTNode;
import org.eclipse.jdt.core.dom.Expression;
import org.eclipse.jdt.core.dom.Statement;

public abstract class AbstractStatementBlock extends AbstractCodeBlock implements StatementBlock {
    public AbstractStatementBlock(String id, ASTNode astNode) {
        super(id, astNode);
    }

    // --- HELPER METHODS ---

    protected Button createDeleteButton(CompletionContext context) {
        return BlockUIComponents.createDeleteButton(() ->
                context.codeEditor().deleteStatement((Statement) this.astNode)
        );
    }

    protected Label createKeywordLabel(String text) {
        return BlockUIComponents.createKeywordLabel(text);
    }

    protected HBox createStandardHeader(CompletionContext context, Node... content) {
        HBox container = BlockUIComponents.createHeaderRow(
                () -> context.codeEditor().deleteStatement((Statement) this.astNode),
                content
        );
        container.getStyleClass().add("statement-block-header");
        return container;
    }

    protected Button createAddButton(javafx.event.EventHandler<javafx.event.ActionEvent> handler) {
        return BlockUIComponents.createAddButton(handler);
    }

    /**
     * Creates an indented body VBox for nested statements.
     */
    protected javafx.scene.layout.VBox createIndentedBody(com.botmaker.core.BodyBlock body, CompletionContext context, String styleClass) {
        Node bodyNode = (body != null) ? body.getUINode(context) : null;
        return LayoutComponents.createIndentedBody(bodyNode, styleClass);
    }

    /**
     * Helper to render an expression or a drop zone if null.
     */
    protected Node getOrDropZone(com.botmaker.core.ExpressionBlock expr, CompletionContext context) {
        return PlaceholderComponents.createExpressionOrDropZone(
                expr,
                context,
                () -> createExpressionDropZone(context) // Defined in AbstractCodeBlock
        );
    }

    /**
     * Helper to create a sentence row (e.g. for loops).
     */
    protected javafx.scene.layout.HBox createSentence(Node... nodes) {
        return LayoutComponents.createSentenceRow(nodes);
    }

    /**
     * Legacy helper: accepts String targetType.
     * Delegates to TypeInfo version.
     */
    protected void showExpressionMenuAndReplace(Button button, CompletionContext context,
                                                String targetType, Expression toReplace) {
        showExpressionMenuAndReplace(button, context, TypeInfo.from(targetType), toReplace);
    }

    /**
     * Helper to show the expression type menu and replace the current expression node upon selection.
     */
    protected void showExpressionMenuAndReplace(Button button,
                                                CompletionContext context,
                                                TypeInfo expectedType,
                                                Expression toReplace) {
        ContextMenu menu = BlockUIComponents.createExpressionTypeMenu(
                expectedType,
                type -> {
                    if (toReplace != null) {
                        context.codeEditor().replaceExpression(toReplace, type);
                    }
                }
        );
        menu.show(button, javafx.geometry.Side.BOTTOM, 0, 0);
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\core\BlockWithChildren.java
=================================================================================

package com.botmaker.core;

import java.util.List;

public interface BlockWithChildren {
    List<CodeBlock> getChildren();
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\core\BodyBlock.java
=================================================================================

package com.botmaker.core;

import com.botmaker.core.AbstractStatementBlock;
import com.botmaker.lsp.CompletionContext;
import com.botmaker.ui.BlockDragAndDropManager;
import javafx.scene.Cursor;
import javafx.scene.Node;
import javafx.scene.layout.Priority;
import javafx.scene.layout.VBox;
import org.eclipse.jdt.core.dom.Block;
import org.eclipse.jdt.core.dom.Statement; // Changed from Block

import java.util.ArrayList;
import java.util.List;

public class BodyBlock extends AbstractStatementBlock implements BlockWithChildren {
    private final List<StatementBlock> statements = new ArrayList<>();
    private final BlockDragAndDropManager dragAndDropManager;

    // FIX: Changed parameter from Block to Statement to allow SwitchCase
    public BodyBlock(String id, Statement astNode, BlockDragAndDropManager dragAndDropManager) {
        super(id, astNode);
        this.dragAndDropManager = dragAndDropManager;
    }

    public void addStatement(StatementBlock statement) {
        statements.add(statement);
    }

    public List<StatementBlock> getStatements() {
        return new ArrayList<>(statements);
    }

    public void removeStatement(StatementBlock statement) {
        statements.remove(statement);
    }

    public void insertStatement(int index, StatementBlock statement) {
        if (index < 0 || index > statements.size()) {
            throw new IndexOutOfBoundsException("Index: " + index + ", Size: " + statements.size());
        }
        statements.add(index, statement);
    }

    @Override
    public List<CodeBlock> getChildren() {
        return new ArrayList<>(statements);
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        VBox container = new VBox();
        container.getStyleClass().add("body-block");
        VBox.setVgrow(container, Priority.ALWAYS);

        if (statements.isEmpty()) {
            javafx.scene.control.Label placeholder = new javafx.scene.control.Label("Drag block here");
            placeholder.getStyleClass().add("empty-body-placeholder");
            placeholder.setMouseTransparent(true);
            container.getChildren().add(placeholder);
            container.setAlignment(javafx.geometry.Pos.CENTER);
            container.setMinHeight(30);
            dragAndDropManager.addEmptyBodyDropHandlers(container, this);
        } else {
            container.getChildren().add(createSeparatorWithHandlers(this, 0));

            for (int i = 0; i < statements.size(); i++) {
                StatementBlock statement = statements.get(i);
                Node statementNode = statement.getUINode(context);
                makeStatementDraggable(statementNode, statement);
                container.getChildren().add(statementNode);
                container.getChildren().add(createSeparatorWithHandlers(this, i + 1));
            }
        }
        return container;
    }

    private void makeStatementDraggable(Node statementNode, StatementBlock statement) {
        statementNode.setOnMouseEntered(e -> statementNode.setCursor(Cursor.OPEN_HAND));
        statementNode.setOnMouseExited(e -> statementNode.setCursor(Cursor.DEFAULT));
        dragAndDropManager.makeBlockMovable(statementNode, statement, this);
    }

    private Node createSeparatorWithHandlers(BodyBlock targetBody, int insertionIndex) {
        javafx.scene.layout.Region separator = dragAndDropManager.createSeparator();
        separator.getStyleClass().add("body-block-separator");
        StatementBlock adjacentBlock = (insertionIndex < statements.size()) ? statements.get(insertionIndex) : null;
        dragAndDropManager.addSeparatorDragHandlers(separator, targetBody, insertionIndex, adjacentBlock);
        return separator;
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\core\CodeBlock.java
=================================================================================

package com.botmaker.core;

import com.botmaker.lsp.CompletionContext;
import javafx.scene.Node;
import org.eclipse.jdt.core.dom.ASTNode;
import org.eclipse.jdt.core.dom.CompilationUnit;

public interface CodeBlock {
    String getId();
    ASTNode getAstNode();
    Node getUINode(CompletionContext context);
    Node getUINode();

    // Visual State
    void highlight();
    void unhighlight();
    void setError(String message);
    void clearError();

    // Breakpoint Logic
    void setBreakpoint(boolean enabled);
    boolean isBreakpoint();
    void toggleBreakpoint();

    // Debugging
    int getBreakpointLine(CompilationUnit cu);
    CodeBlock getHighlightTarget();
    String getDetails();
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\core\ExpressionBlock.java
=================================================================================

package com.botmaker.core;

/**
 * A block that represents a value that can be evaluated.
 * Examples: a literal "hello", a variable `x`, a calculation `2 + 2`.
 */
public interface ExpressionBlock extends CodeBlock {
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\core\StatementBlock.java
=================================================================================

package com.botmaker.core;

/**
 * A block that represents a complete action or step in execution.
 * Examples: a variable declaration, an if-statement, a method call.
 */
public interface StatementBlock extends CodeBlock {
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\di\DependencyContainer.java
=================================================================================

package com.botmaker.di;

import java.util.HashMap;
import java.util.Map;
import java.util.function.Supplier;

/**
 * Simple dependency injection container.
 * Manages service lifecycle and provides dependency resolution.
 * Phase 3: Fixed ConcurrentModificationException
 */
public class DependencyContainer {

    private final Map<Class<?>, Object> singletons = new HashMap<>();
    private final Map<Class<?>, Supplier<?>> factories = new HashMap<>();

    /**
     * Register a singleton instance
     */
    public <T> void registerSingleton(Class<T> type, T instance) {
        if (instance == null) {
            throw new IllegalArgumentException("Instance cannot be null");
        }
        singletons.put(type, instance);
    }

    /**
     * Register a factory for creating instances
     */
    public <T> void registerFactory(Class<T> type, Supplier<T> factory) {
        if (factory == null) {
            throw new IllegalArgumentException("Factory cannot be null");
        }
        factories.put(type, factory);
    }

    /**
     * Register a lazy singleton using a factory
     * The instance will be created on first access and cached
     */
    public <T> void registerLazySingleton(Class<T> type, Supplier<T> factory) {
        if (factory == null) {
            throw new IllegalArgumentException("Factory cannot be null");
        }
        factories.put(type, factory);
    }

    /**
     * Resolve a dependency
     */
    @SuppressWarnings("unchecked")
    public <T> T resolve(Class<T> type) {
        // Check if we have a singleton instance
        Object instance = singletons.get(type);
        if (instance != null) {
            return (T) instance;
        }

        // Check if we have a factory
        Supplier<?> factory = factories.get(type);
        if (factory != null) {
            // PHASE 3 FIX: Create instance first, then cache it
            // This avoids ConcurrentModificationException
            T newInstance = (T) factory.get();

            // Cache the instance for future use
            singletons.put(type, newInstance);

            // Remove the factory since we don't need it anymore
            // (optional - keeps memory clean)
            factories.remove(type);

            return newInstance;
        }

        throw new IllegalStateException("No registration found for type: " + type.getName());
    }

    /**
     * Check if a type is registered
     */
    public boolean isRegistered(Class<?> type) {
        return singletons.containsKey(type) || factories.containsKey(type);
    }

    /**
     * Remove a registration
     */
    public void unregister(Class<?> type) {
        singletons.remove(type);
        factories.remove(type);
    }

    /**
     * Clear all registrations
     */
    public void clear() {
        singletons.clear();
        factories.clear();
    }

    /**
     * Get count of registered types
     */
    public int getRegistrationCount() {
        return singletons.size() + factories.size();
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\events\AbstractApplicationEvent.java
=================================================================================

package com.botmaker.events;

/**
 * Abstract base class for events that provides common functionality
 */
public abstract class AbstractApplicationEvent implements ApplicationEvent {
    private final long timestamp;
    private final String source;

    protected AbstractApplicationEvent() {
        this(null);
    }

    protected AbstractApplicationEvent(String source) {
        this.timestamp = System.currentTimeMillis();
        this.source = source != null ? source : getClass().getSimpleName();
    }

    @Override
    public long getTimestamp() {
        return timestamp;
    }

    @Override
    public String getSource() {
        return source;
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\events\ApplicationEvent.java
=================================================================================

package com.botmaker.events;

/**
 * Base interface for all application events.
 * Events represent things that have happened in the application.
 */
public interface ApplicationEvent {
    /**
     * Timestamp when the event was created
     */
    long getTimestamp();

    /**
     * Optional source identifier for debugging
     */
    default String getSource() {
        return getClass().getSimpleName();
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\events\CoreApplicationEvents.java
=================================================================================

package com.botmaker.events;

import com.botmaker.core.AbstractCodeBlock;
import com.botmaker.core.CodeBlock;
import org.eclipse.lsp4j.Diagnostic;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

public class CoreApplicationEvents {



    public static class CodeUpdatedEvent extends AbstractApplicationEvent {
        private final String newCode;
        private final String previousCode;
        public CodeUpdatedEvent(String newCode, String previousCode) {
            this.newCode = newCode;
            this.previousCode = previousCode;
        }
        public String getNewCode() { return newCode; }
        public String getPreviousCode() { return previousCode; }
    }

    public static class DiagnosticsUpdatedEvent extends AbstractApplicationEvent {
        private final List<Diagnostic> diagnostics;
        public DiagnosticsUpdatedEvent(List<Diagnostic> diagnostics) {
            this.diagnostics = diagnostics != null ? List.copyOf(diagnostics) : Collections.emptyList();
        }
        public List<Diagnostic> getDiagnostics() { return diagnostics; }
    }

    public static class UIRefreshRequestedEvent extends AbstractApplicationEvent {
        private final String code;
        public UIRefreshRequestedEvent(String code) { this.code = code; }
        public String getCode() { return code; }
    }

    public static class BlockHighlightEvent extends AbstractApplicationEvent {
        private final CodeBlock block;
        public BlockHighlightEvent(CodeBlock block) { this.block = block; }
        public CodeBlock getBlock() { return block; }
    }



    public static class UIBlocksUpdatedEvent extends AbstractApplicationEvent {
        private final AbstractCodeBlock rootBlock;

        public UIBlocksUpdatedEvent(AbstractCodeBlock rootBlock) {
            super("CodeEditorService");
            this.rootBlock = rootBlock;
        }

        public AbstractCodeBlock getRootBlock() { return rootBlock; }
    }

    public static class CompilationRequestedEvent extends AbstractApplicationEvent {}
    public static class ExecutionRequestedEvent extends AbstractApplicationEvent {}
    public static class DebugStartRequestedEvent extends AbstractApplicationEvent {}

    public static class DebugSessionStartedEvent extends AbstractApplicationEvent {}
    public static class DebugSessionResumedEvent extends AbstractApplicationEvent {}
    public static class DebugSessionFinishedEvent extends AbstractApplicationEvent {}

    public static class DebugSessionPausedEvent extends AbstractApplicationEvent {
        private final int lineNumber;
        private final CodeBlock block;
        public DebugSessionPausedEvent(int lineNumber, CodeBlock block) {
            this.lineNumber = lineNumber;
            this.block = block;
        }
        public int getLineNumber() { return lineNumber; }
        public CodeBlock getBlock() { return block; }
    }

    public static class StatusMessageEvent extends AbstractApplicationEvent {
        private final String message;
        public StatusMessageEvent(String message) { this.message = message; }
        public String getMessage() { return message; }
    }

    // Inside CoreApplicationEvents class


    public static class OutputAppendedEvent extends AbstractApplicationEvent {
        private final String text;
        public OutputAppendedEvent(String text) { this.text = text; }
        public String getText() { return text; }
    }

    public static class OutputClearedEvent extends AbstractApplicationEvent {}
    public static class OutputSetEvent extends AbstractApplicationEvent {
        private final String text;
        public OutputSetEvent(String text) { this.text = text; }
        public String getText() { return text; }
    }

    public static class UndoRequestedEvent extends AbstractApplicationEvent {
        public UndoRequestedEvent() { super("User"); }
    }

    public static class RedoRequestedEvent extends AbstractApplicationEvent {
        public RedoRequestedEvent() { super("User"); }
    }

    /**
     * Fired whenever the history stack changes (to enable/disable UI buttons)
     */
    public static class HistoryStateChangedEvent extends AbstractApplicationEvent {
        private final boolean canUndo;
        private final boolean canRedo;

        public HistoryStateChangedEvent(boolean canUndo, boolean canRedo) {
            this.canUndo = canUndo;
            this.canRedo = canRedo;
        }

        public boolean canUndo() { return canUndo; }
        public boolean canRedo() { return canRedo; }
    }


    // ADD THESE EVENT CLASSES TO CoreApplicationEvents.java:

    /**
     * Fired when a user requests to stop the currently running program
     */
    public static class StopRunRequestedEvent extends AbstractApplicationEvent {
        public StopRunRequestedEvent() {
            super("User");
        }
    }

    /**
     * Fired when a program starts executing (not debugging)
     */
    public static class ProgramStartedEvent extends AbstractApplicationEvent {
        public ProgramStartedEvent() {
            super("ExecutionService");
        }
    }

    /**
     * Fired when a program stops executing (completed or terminated)
     */
    public static class ProgramStoppedEvent extends AbstractApplicationEvent {
        public ProgramStoppedEvent() {
            super("ExecutionService");
        }
    }
    /**
     * Fired when a user wants to step over the current line
     */
    public static class DebugStepOverRequestedEvent extends AbstractApplicationEvent {
        public DebugStepOverRequestedEvent() {
            super("User");
        }
    }

    public static class DebugStopRequestedEvent extends AbstractApplicationEvent {
        public DebugStopRequestedEvent() {
            super("User");
        }
    }

    /**
     * Fired when a user wants to continue execution until the next breakpoint
     */
    public static class DebugContinueRequestedEvent extends AbstractApplicationEvent {
        public DebugContinueRequestedEvent() {
            super("User");
        }
    }

    /**
     * Fired when a user toggles a breakpoint on a block
     */
    public static class BreakpointToggledEvent extends AbstractApplicationEvent {
        private final CodeBlock block;
        private final boolean isEnabled;

        public BreakpointToggledEvent(CodeBlock block, boolean isEnabled) {
            super("User");
            this.block = block;
            this.isEnabled = isEnabled;
        }

        public CodeBlock getBlock() { return block; }
        public boolean isEnabled() { return isEnabled; }
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\events\EventBus.java
=================================================================================

package com.botmaker.events;

import javafx.application.Platform;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.function.Consumer;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * Central event bus for application-wide event communication.
 * Thread-safe and supports both synchronous and asynchronous event delivery.
 */
public class EventBus {
    private static final Logger LOGGER = Logger.getLogger(EventBus.class.getName());

    private final Map<Class<? extends ApplicationEvent>, List<EventHandler<?>>> handlers;
    // NEW: List for listeners that want to receive EVERY event (like the Event Log)
    private final List<Consumer<ApplicationEvent>> globalListeners;
    private final boolean enableLogging;

    public EventBus() {
        this(false);
    }

    public EventBus(boolean enableLogging) {
        this.handlers = new ConcurrentHashMap<>();
        this.globalListeners = new CopyOnWriteArrayList<>(); // NEW
        this.enableLogging = enableLogging;
    }

    /**
     * Subscribe to events of a specific type
     */
    public <T extends ApplicationEvent> void subscribe(Class<T> eventType, Consumer<T> handler) {
        subscribe(eventType, handler, false);
    }

    /**
     * Subscribe to events with option to run on JavaFX thread
     */
    public <T extends ApplicationEvent> void subscribe(
            Class<T> eventType,
            Consumer<T> handler,
            boolean runOnFxThread) {

        handlers.computeIfAbsent(eventType, k -> new CopyOnWriteArrayList<>())
                .add(new EventHandler<>(handler, runOnFxThread));

        if (enableLogging) {
            LOGGER.info("Subscribed to " + eventType.getSimpleName());
        }
    }

    /**
     * NEW: Subscribe to ALL events passing through the bus.
     * Useful for logging and debugging consoles.
     */
    public void subscribeAll(Consumer<ApplicationEvent> listener) {
        globalListeners.add(listener);
    }

    /**
     * Publish an event to all subscribers
     */
    public void publish(ApplicationEvent event) {
        if (event == null) {
            return;
        }

        if (enableLogging) {
            LOGGER.info("Publishing: " + event.getSource());
        }

        // 1. Notify specific handlers
        Class<? extends ApplicationEvent> eventType = event.getClass();
        List<EventHandler<?>> eventHandlers = handlers.get(eventType);

        if (eventHandlers != null && !eventHandlers.isEmpty()) {
            for (EventHandler<?> handler : eventHandlers) {
                try {
                    handler.handle(event);
                } catch (Exception e) {
                    LOGGER.log(Level.SEVERE, "Error handling event: " + eventType.getSimpleName(), e);
                }
            }
        } else if (enableLogging) {
            LOGGER.warning("No specific handlers for event: " + eventType.getSimpleName());
        }

        // 2. NEW: Notify global listeners
        for (Consumer<ApplicationEvent> globalListener : globalListeners) {
            try {
                globalListener.accept(event);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }

    /**
     * Unsubscribe a specific handler from an event type
     */
    public <T extends ApplicationEvent> void unsubscribe(Class<T> eventType, Consumer<T> handler) {
        List<EventHandler<?>> eventHandlers = handlers.get(eventType);
        if (eventHandlers != null) {
            eventHandlers.removeIf(h -> h.getHandler() == handler);
        }
    }

    /**
     * Clear all handlers for a specific event type
     */
    public void clearHandlers(Class<? extends ApplicationEvent> eventType) {
        handlers.remove(eventType);
    }

    /**
     * Clear all handlers
     */
    public void clearAllHandlers() {
        handlers.clear();
        globalListeners.clear(); // NEW
    }

    public int getHandlerCount(Class<? extends ApplicationEvent> eventType) {
        List<EventHandler<?>> eventHandlers = handlers.get(eventType);
        return eventHandlers != null ? eventHandlers.size() : 0;
    }

    private static class EventHandler<T extends ApplicationEvent> {
        private final Consumer<T> handler;
        private final boolean runOnFxThread;

        EventHandler(Consumer<T> handler, boolean runOnFxThread) {
            this.handler = handler;
            this.runOnFxThread = runOnFxThread;
        }

        @SuppressWarnings("unchecked")
        void handle(ApplicationEvent event) {
            if (runOnFxThread && !Platform.isFxApplicationThread()) {
                Platform.runLater(() -> handler.accept((T) event));
            } else {
                handler.accept((T) event);
            }
        }

        Consumer<T> getHandler() {
            return handler;
        }
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\init\AppDependencyConfigurator.java
=================================================================================

// FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\init\AppDependencyConfigurator.java
package com.botmaker.init;

import com.botmaker.config.ApplicationConfig;
import com.botmaker.di.DependencyContainer;
import com.botmaker.events.EventBus;
import com.botmaker.parser.AstRewriter;
import com.botmaker.parser.BlockFactory;
import com.botmaker.parser.NodeCreator;
import com.botmaker.runtime.CodeExecutionService;
import com.botmaker.services.*;
import com.botmaker.state.ApplicationState;
import com.botmaker.ui.BlockDragAndDropManager;
import com.botmaker.ui.UIManager;
import com.botmaker.validation.DiagnosticsManager;
import javafx.stage.Stage;

public class AppDependencyConfigurator {

    public static void configure(DependencyContainer container, ApplicationConfig config, Stage primaryStage) {
        // Core Config & State
        container.registerSingleton(ApplicationConfig.class, config);
        container.registerSingleton(ApplicationState.class, new ApplicationState());
        container.registerSingleton(EventBus.class, new EventBus(config.isEnableEventLogging()));

        // Parsing & AST
        container.registerSingleton(BlockFactory.class, new BlockFactory());
        container.registerSingleton(NodeCreator.class, new NodeCreator());
        container.registerLazySingleton(AstRewriter.class, () ->
                new AstRewriter(container.resolve(NodeCreator.class)));

        // UI Helpers & Validation
        container.registerSingleton(DiagnosticsManager.class, new DiagnosticsManager());

        // MODIFIED: Inject ApplicationState into BlockDragAndDropManager
        container.registerSingleton(BlockDragAndDropManager.class,
                new BlockDragAndDropManager(container.resolve(ApplicationState.class)));

        // Services
        registerServices(container);

        // UI Manager (Requires Stage)
        container.registerLazySingleton(UIManager.class, () -> {
            return new UIManager(
                    container.resolve(BlockDragAndDropManager.class),
                    container.resolve(EventBus.class),
                    container.resolve(CodeEditorService.class),
                    container.resolve(DiagnosticsManager.class),
                    primaryStage,
                    container.resolve(ApplicationConfig.class),
                    container.resolve(ApplicationState.class)
            );
        });
    }

    private static void registerServices(DependencyContainer container) {
        container.registerLazySingleton(LanguageServerService.class, () ->
                new LanguageServerService(
                        container.resolve(ApplicationConfig.class),
                        container.resolve(ApplicationState.class),
                        container.resolve(EventBus.class),
                        container.resolve(DiagnosticsManager.class)
                )
        );

        container.registerLazySingleton(CodeExecutionService.class, () -> {
            EventBus eventBus = container.resolve(EventBus.class);
            return new CodeExecutionService(
                    text -> eventBus.publish(new com.botmaker.events.CoreApplicationEvents.OutputAppendedEvent(text)),
                    () -> eventBus.publish(new com.botmaker.events.CoreApplicationEvents.OutputClearedEvent()),
                    text -> eventBus.publish(new com.botmaker.events.CoreApplicationEvents.OutputSetEvent(text)),
                    msg -> eventBus.publish(new com.botmaker.events.CoreApplicationEvents.StatusMessageEvent(msg)),
                    container.resolve(DiagnosticsManager.class),
                    container.resolve(ApplicationConfig.class),
                    container.resolve(ApplicationState.class)
            );
        });

        container.registerLazySingleton(CodeEditorService.class, () ->
                new CodeEditorService(
                        container.resolve(ApplicationConfig.class),
                        container.resolve(ApplicationState.class),
                        container.resolve(EventBus.class),
                        container.resolve(BlockFactory.class),
                        container.resolve(AstRewriter.class),
                        container.resolve(BlockDragAndDropManager.class),
                        container.resolve(LanguageServerService.class),
                        container.resolve(DiagnosticsManager.class)
                )
        );

        container.registerLazySingleton(ExecutionService.class, () ->
                new ExecutionService(
                        container.resolve(ApplicationConfig.class),
                        container.resolve(ApplicationState.class),
                        container.resolve(EventBus.class),
                        container.resolve(CodeExecutionService.class),
                        container.resolve(DiagnosticsManager.class)
                )
        );

        container.registerLazySingleton(DebuggingService.class, () ->
                new DebuggingService(
                        container.resolve(ApplicationState.class),
                        container.resolve(EventBus.class),
                        container.resolve(CodeExecutionService.class),
                        container.resolve(BlockFactory.class),
                        container.resolve(ApplicationConfig.class)
                )
        );
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\init\AppServiceInitializer.java
=================================================================================

package com.botmaker.init;

import com.botmaker.blocks.ClassBlock;
import com.botmaker.core.BodyBlock;
import com.botmaker.core.StatementBlock;
import com.botmaker.di.DependencyContainer;
import com.botmaker.services.*;
import com.botmaker.state.ApplicationState;
import com.botmaker.ui.AddableBlock;
import com.botmaker.ui.BlockDragAndDropManager;
import com.botmaker.ui.UIManager;
import com.botmaker.util.BlockLookupHelper;
import org.eclipse.jdt.core.dom.TypeDeclaration;

public class AppServiceInitializer {

    public static void initialize(DependencyContainer container) throws Exception {
        // 1. Initialize Language Server
        LanguageServerService lss = container.resolve(LanguageServerService.class);
        lss.initialize();

        // 2. Resolve Services needed for wiring
        CodeEditorService codeEditorService = container.resolve(CodeEditorService.class);
        ApplicationState state = container.resolve(ApplicationState.class);
        BlockDragAndDropManager dragAndDropManager = container.resolve(BlockDragAndDropManager.class);

        // 3. Wire up Drag and Drop Logic
        setupDragAndDropCallbacks(dragAndDropManager, codeEditorService, state);

        // 4. Ensure other services are instantiated
        container.resolve(ExecutionService.class);
        container.resolve(DebuggingService.class);
        container.resolve(UIManager.class);
    }

    private static void setupDragAndDropCallbacks(BlockDragAndDropManager manager,
                                                  CodeEditorService editorService,
                                                  ApplicationState state) {
        // Handle adding new blocks
// ... inside setupDragAndDropCallbacks ...
        manager.setCallback(dropInfo -> {
            // Check if dropping into a CLASS
            if (dropInfo.targetClass() != null) {
                if (dropInfo.type() == AddableBlock.METHOD_DECLARATION) {
                    editorService.getCodeEditor().addMethodToClass(
                            (TypeDeclaration) dropInfo.targetClass().getAstNode(),
                            "newMethod", "void", dropInfo.insertionIndex()
                    );
                }
                else if (dropInfo.type() == AddableBlock.DECLARE_ENUM) {
                    editorService.getCodeEditor().addEnumToClass(
                            (TypeDeclaration) dropInfo.targetClass().getAstNode(),
                            "NewEnum", dropInfo.insertionIndex()
                    );
                }
            }
            // Check if dropping into a BODY (Method)
            else if (dropInfo.targetBody() != null) {
                editorService.getCodeEditor().addStatement(
                        dropInfo.targetBody(), dropInfo.type(), dropInfo.insertionIndex()
                );
            }
        });

        // Handle moving existing blocks
        manager.setMoveCallback(moveInfo -> {
            StatementBlock blockToMove = BlockLookupHelper.findBlockById(
                    moveInfo.blockId(),
                    state.getNodeToBlockMap()
            );

            if (blockToMove != null) {
                BodyBlock sourceBody = BlockLookupHelper.findParentBody(
                        blockToMove,
                        state.getNodeToBlockMap()
                );

                if (sourceBody != null) {
                    editorService.getCodeEditor().moveStatement(
                            blockToMove,
                            sourceBody,
                            moveInfo.targetBody(),
                            moveInfo.insertionIndex()
                    );
                }
            }
        });
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\library\Main.java
=================================================================================

package com.botmaker.library;

import org.bytedeco.javacpp.Loader;
import org.bytedeco.opencv.opencv_java;


public class Main {

    static{
        Loader.load(opencv_java.class);
    }

    public static void main(String[] args) {
        try {
            //testLiveCapture();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\library\capture\CaptureTest.java
=================================================================================

package com.botmaker.library.capture;


import com.botmaker.library.opencv.*;
import com.sun.jna.platform.win32.WinDef;
import com.sun.jna.platform.win32.WinDef.HWND;
import org.opencv.core.Mat;
import org.opencv.core.Scalar;

import javax.imageio.ImageIO;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import java.util.List;
import java.util.Scanner;

import static com.botmaker.library.capture.ScreenCapture.bufferedImageToMat;
import static com.botmaker.library.capture.ScreenCapture.matToBufferedImage;


public class CaptureTest {

    public static void main(String[] args){
        try {
            testPostLeftClick();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public static void testLiveCapture() throws InterruptedException {
        User32.INSTANCE.SetProcessDPIAware();

        System.out.println("You have 5 seconds to bring the window you want to capture to the foreground...");
        Thread.sleep(5000);

        HWND selectedWindow = User32.INSTANCE.GetForegroundWindow();

        if (selectedWindow == null) {
            System.out.println("Could not get the foreground window.");
            return;
        }

        byte[] windowText = new byte[512];
        User32.INSTANCE.GetWindowTextA(selectedWindow.getPointer(), windowText, 512);
        String windowTitle = new String(windowText).trim();

        System.out.println("Capturing window: " + windowTitle);


        BufferedImage firstCapture = ScreenCapture.capture(selectedWindow);
        try {
            ImageIO.write(firstCapture, "png", new File("capture.png"));
            System.out.println("Saved the first capture to capture.png");
        } catch (IOException e) {
            e.printStackTrace();
        }

        ImageDisplay display = new ImageDisplay();
        display.showImage(firstCapture);

        while (true) {
            BufferedImage screenshot = ScreenCapture.capture(selectedWindow);
            display.showImage(screenshot);
            Thread.sleep(100); // Capture roughly 10 times per second
        }
    }

    public static void testCreateTemplateAndFind() throws IOException, InterruptedException {
        System.out.println("Press 'C' to capture the first corner of the rectangle.");
        waitForCKey();
        Point p1 = getMousePosition();
        System.out.println("First corner captured at: " + p1);

        System.out.println("Press 'C' again to capture the second corner.");
        waitForCKey();
        Point p2 = getMousePosition();
        System.out.println("Second corner captured at: " + p2);

        Rectangle rect = new Rectangle(p1);
        rect.add(p2);

        BufferedImage desktop = ScreenCapture.captureDesktop();
        if (desktop == null) {
            System.err.println("Failed to capture desktop.");
            return;
        }

        BufferedImage templateImage = desktop.getSubimage(rect.x, rect.y, rect.width, rect.height);

        Template backgroundTemplate = new Template(bufferedImageToMat(desktop), "background");
        Template template = new Template(bufferedImageToMat(templateImage), "template");

        MatchResult result = OpencvManager.findBestMatch(template, backgroundTemplate, MatType.COLOR);

        if (result != null) {
            System.out.println("Match found at: " + result.rectLocation);
            System.out.println("Confidence: " + result.getScore());

            // Draw the rectangle on the background image
            Mat drawnImage = OpencvManager.drawMatch(backgroundTemplate.mat, result, new Scalar(0, 255, 0));

            // Convert the Mat back to a BufferedImage
            BufferedImage resultImage = matToBufferedImage(drawnImage);

            // Display the result
            ImageDisplay display = new ImageDisplay();
            display.showImage(resultImage);
        } else {
            System.out.println("No match found.");
        }
    }

    private static void waitForCKey() throws InterruptedException {
        // Wait for key release first to avoid capturing a held-down key
        while ((User32.INSTANCE.GetAsyncKeyState('C') & 0x8000) != 0) {
            Thread.sleep(10);
        }
        // Now wait for a fresh key press
        while ((User32.INSTANCE.GetAsyncKeyState('C') & 0x8000) == 0) {
            Thread.sleep(10);
        }
        System.out.println("... 'C' key pressed!");
    }

    private static Point getMousePosition() {
        WinDef.POINT p = new WinDef.POINT();
        User32.INSTANCE.GetCursorPos(p);
        return new Point(p.x, p.y);
    }

    public static void testCaptureChildWindow() throws InterruptedException {
        System.out.println("You have 5 seconds to bring the window you want to capture to the foreground...");
        Thread.sleep(5000);

        HWND foregroundWindow = User32.INSTANCE.GetForegroundWindow();
        byte[] windowText = new byte[512];
        User32.INSTANCE.GetWindowTextA(foregroundWindow.getPointer(), windowText, 512);
        String windowTitle = new String(windowText).trim();

        List<WindowInfo> childWindows = WindowFinder.getChildWindows(foregroundWindow);

        System.out.println("Available windows to capture:");
        System.out.println("0: " + windowTitle + " (Parent)");
        for (int i = 0; i < childWindows.size(); i++) {
            System.out.println((i + 1) + ": " + childWindows.get(i).getTitle());
        }

        System.out.print("Enter the number of the window to capture: ");
        Scanner scanner = new Scanner(System.in);
        int choice = scanner.nextInt();

        HWND selectedWindow;
        if (choice == 0) {
            selectedWindow = foregroundWindow;
        } else if (choice > 0 && choice <= childWindows.size()) {
            selectedWindow = childWindows.get(choice - 1).getHWnd();
        } else {
            System.out.println("Invalid choice.");
            return;
        }
        BufferedImage image = ScreenCapture.capture(selectedWindow);
        try {
            ImageIO.write(image, "png", new File("capture.png"));
            System.out.println("Saved the first capture to capture.png");
        } catch (IOException e) {
            e.printStackTrace();
        }

        ImageDisplay display = new ImageDisplay();
        while (true) {
            BufferedImage screenshot = ScreenCapture.capture(selectedWindow);
            display.showImage(screenshot);
        }
    }

    public static void testPostLeftClick() throws InterruptedException {
        System.out.println("You have 5 seconds to bring the window you want to click on (using PostMessage) to the foreground...");
        Thread.sleep(5000);

        HWND selectedWindow = User32.INSTANCE.GetForegroundWindow();

        if (selectedWindow == null) {
            System.out.println("Could not get the foreground window.");
            return;
        }

        byte[] windowText = new byte[512];
        User32.INSTANCE.GetWindowTextA(selectedWindow.getPointer(), windowText, 512);
        String windowTitle = new String(windowText).trim();

        System.out.println("Move your mouse to the desired click location within the window and press 'C'.");
        waitForCKey();
        Point mousePos = getMousePosition();

        WinDef.RECT windowRect = new WinDef.RECT();
        User32.INSTANCE.GetWindowRect(selectedWindow.getPointer(), windowRect);

        int relativeX = mousePos.x - windowRect.left;
        int relativeY = mousePos.y - windowRect.top;

        System.out.println("Clicking on window (PostMessage): " + windowTitle + " at relative coordinates (" + relativeX + ", " + relativeY + ") in 3 seconds...");
        Thread.sleep(3000);
        Clicker.postLeftClick(selectedWindow, relativeX, relativeY);
        System.out.println("Clicked!");
    }

    public static void testClickOnVirtualScreen() throws InterruptedException {

        System.out.println("Place le curseur, appuie sur 'C'");
        waitForCKey();
        Point p = getMousePosition();          // GetCursorPos → virt-desktop
        Clicker.postLeftClickScreen(p.x, p.y);
        System.out.println("Click envoyé à ("+p.x+", "+p.y+")");

    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\library\capture\Clicker.java
=================================================================================

package com.botmaker.library.capture;

import com.sun.jna.platform.win32.WinDef;
import com.sun.jna.platform.win32.WinDef.HWND;
import com.sun.jna.platform.win32.WinDef.LPARAM;
import com.sun.jna.platform.win32.WinDef.POINT;
import com.sun.jna.platform.win32.WinDef.WPARAM;

public final class Clicker {

    private static LPARAM makeLParam(int x, int y) {
        return new LPARAM((y << 16) | (x & 0xFFFF));
    }



    public static void postLeftClickScreen(int xAbs, int yAbs) {

        // 1️⃣ quelle fenêtre est sous ce pixel ?
        POINT.ByValue ptScreen = new POINT.ByValue();
        ptScreen.x = xAbs;
        ptScreen.y = yAbs;

        HWND hWnd = User32.INSTANCE.WindowFromPoint(ptScreen);
        if (hWnd == null) {
            return;
        }

        POINT ptClient = new POINT();
        ptClient.x = xAbs;
        ptClient.y = yAbs;
        User32.INSTANCE.ScreenToClient(hWnd, ptClient);

        // 3️⃣ réutiliser le helper qui marche
        postLeftClick(hWnd, ptClient.x, ptClient.y);
    }


    /** Posts a left click at (x,y) given in *client* coords of hWnd. */
    public static void postLeftClick(HWND hWnd, int x, int y) {

        /* 1️⃣ client → screen */
        POINT ptScreen = new POINT();
        ptScreen.x = x;
        ptScreen.y = y;
        User32.INSTANCE.ClientToScreen(hWnd, ptScreen);

        /* 2️⃣ window really under that point (child or same) */
        HWND hTarget = User32.INSTANCE.WindowFromPoint(ptScreen);
        if (hTarget == null) {
            hTarget = hWnd;
        }

        /* 3️⃣ screen → client of that target */
        POINT ptClient = new POINT();
        ptClient.x = ptScreen.x;
        ptClient.y = ptScreen.y;
        User32.INSTANCE.ScreenToClient(hTarget, ptClient);

        /* 4️⃣ pack & shoot the messages */
        LPARAM lParam = makeLParam(ptClient.x, ptClient.y);
        WPARAM wDown  = new WPARAM(User32.MK_LBUTTON);

        User32.INSTANCE.PostMessage(hTarget, User32.WM_LBUTTONDOWN, wDown, lParam);
        User32.INSTANCE.PostMessage(hTarget, User32.WM_LBUTTONUP,   new WPARAM(0), lParam);
    }

    private Clicker() {}  // utility class
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\library\capture\GDI32.java
=================================================================================

package com.botmaker.library.capture;

import com.sun.jna.Native;
import com.sun.jna.Pointer;
import com.sun.jna.platform.win32.WinDef.HBITMAP;
import com.sun.jna.platform.win32.WinDef.HDC;
import com.sun.jna.platform.win32.WinGDI;
import com.sun.jna.platform.win32.WinNT.HANDLE;
import com.sun.jna.win32.StdCallLibrary;


public interface GDI32 extends StdCallLibrary {
    GDI32 INSTANCE = Native.load("gdi32", GDI32.class);

    boolean BitBlt(HDC hdcDest, int nXDest, int nYDest, int nWidth, int nHeight, HDC hdcSrc, int nXSrc, int nYSrc, int dwRop);
    HDC CreateCompatibleDC(HDC hdc);
    HBITMAP CreateCompatibleBitmap(HDC hdc, int nWidth, int nHeight);
    Pointer SelectObject(HDC hdc, Pointer h);
    boolean DeleteDC(HDC hdc);
    boolean DeleteObject(HBITMAP ho);
    int GetObject(HANDLE h, int c, WinGDI.BITMAP lp);
    int GetDIBits(HDC hdc, HBITMAP hbm, int uStartScan, int cScanLines, int[] lpvBits, WinGDI.BITMAPINFO lpbi, int uUsage);
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\library\capture\ImageDisplay.java
=================================================================================

package com.botmaker.library.capture;

import javax.swing.*;
import java.awt.image.BufferedImage;

public class ImageDisplay {
    private final JFrame frame;
    private final JLabel imageLabel;

    public ImageDisplay() {
        frame = new JFrame("Live Capture");
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        imageLabel = new JLabel();
        frame.getContentPane().add(imageLabel);
        frame.setResizable(false);
    }

    public void showImage(BufferedImage image) {
        if (image == null) {
            return;
        }
        imageLabel.setIcon(new ImageIcon(image));
        if (!frame.isVisible()) {
            frame.pack();
            frame.setVisible(true);
        }
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\library\capture\ScreenCapture.java
=================================================================================

package com.botmaker.library.capture;

import com.sun.jna.platform.win32.WinDef.*;
import com.sun.jna.platform.win32.WinGDI;
import org.opencv.core.CvType;
import org.opencv.core.Mat;

import java.awt.*;
import java.awt.image.BufferedImage;
import java.awt.image.DataBufferByte;
import java.awt.image.DataBufferInt;


public class ScreenCapture {


    static Mat bufferedImageToMat(BufferedImage bi) {

        BufferedImage convertedImg = new BufferedImage(bi.getWidth(), bi.getHeight(), BufferedImage.TYPE_3BYTE_BGR);

        convertedImg.getGraphics().drawImage(bi, 0, 0, null);

        Mat mat = new Mat(convertedImg.getHeight(), convertedImg.getWidth(), CvType.CV_8UC3);
        byte[] data = ((DataBufferByte) convertedImg.getRaster().getDataBuffer()).getData();
        mat.put(0, 0, data);
        return mat;
    }

    static BufferedImage matToBufferedImage(Mat mat) {
        int type = BufferedImage.TYPE_BYTE_GRAY;
        if (mat.channels() > 1) {
            type = BufferedImage.TYPE_3BYTE_BGR;
        }
        int bufferSize = mat.channels() * mat.cols() * mat.rows();
        byte[] b = new byte[bufferSize];
        mat.get(0, 0, b);
        BufferedImage image = new BufferedImage(mat.cols(), mat.rows(), type);
        final byte[] targetPixels = ((DataBufferByte) image.getRaster().getDataBuffer()).getData();
        System.arraycopy(b, 0, targetPixels, 0, b.length);
        return image;
    }

    public static BufferedImage capture(HWND hWnd) {
        // Get screen dimensions for fullscreen check
        Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
        RECT screenRect = new RECT();
        screenRect.left = 0;
        screenRect.top = 0;
        screenRect.right = (int) screenSize.getWidth();
        screenRect.bottom = (int) screenSize.getHeight();

        // Get window dimensions
        RECT windowRect = new RECT();
        User32.INSTANCE.GetWindowRect(hWnd.getPointer(), windowRect);

        BufferedImage image;

        // Check if the window is fullscreen. If so, Robot is more reliable.
        if (windowRect.toString().equals(screenRect.toString()) && User32.INSTANCE.GetForegroundWindow().equals(hWnd)) {
            image = captureWithRobot(hWnd, windowRect);
        } else {
            // For windowed mode, GDI is faster, with a fallback to Robot.
            image = captureWithGDI(hWnd);
            // Fallback for black, invalid, or frozen (stale) images.
            if (image == null || image.getWidth() == 0 || image.getHeight() == 0 || isBlack(image)) {
                image = captureWithRobot(hWnd, windowRect);
            }
        }
        return image;
    }

    private static BufferedImage captureWithGDI(HWND hWnd) {
        HDC hdcWindow = User32.INSTANCE.GetDC(hWnd);
        HDC hdcMemDC = GDI32.INSTANCE.CreateCompatibleDC(hdcWindow);

        RECT bounds = new RECT();
        User32.INSTANCE.GetClientRect(hWnd, bounds);

        int width = bounds.right - bounds.left;
        int height = bounds.bottom - bounds.top;

        if (width <= 0 || height <= 0) {
            User32.INSTANCE.ReleaseDC(hWnd, hdcWindow);
            GDI32.INSTANCE.DeleteDC(hdcMemDC);
            return null;
        }

        HBITMAP hBitmap = GDI32.INSTANCE.CreateCompatibleBitmap(hdcWindow, width, height);
        GDI32.INSTANCE.SelectObject(hdcMemDC, hBitmap.getPointer());

        User32.INSTANCE.PrintWindow(hWnd, hdcMemDC, 2); // 2 = PW_CLIENTONLY

        WinGDI.BITMAPINFO bmi = new WinGDI.BITMAPINFO();
        bmi.bmiHeader.biWidth = width;
        bmi.bmiHeader.biHeight = -height; // Top-down image
        bmi.bmiHeader.biPlanes = 1;
        bmi.bmiHeader.biBitCount = 32;
        bmi.bmiHeader.biCompression = WinGDI.BI_RGB;

        BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);
        GDI32.INSTANCE.GetDIBits(hdcWindow, hBitmap, 0, height, ((DataBufferInt) image.getRaster().getDataBuffer()).getData(), bmi, WinGDI.DIB_RGB_COLORS);

        GDI32.INSTANCE.DeleteObject(hBitmap);
        GDI32.INSTANCE.DeleteDC(hdcMemDC);
        User32.INSTANCE.ReleaseDC(hWnd, hdcWindow);

        return image;
    }

    private static BufferedImage captureWithRobot(HWND hWnd, RECT bounds) {
        int width = bounds.right - bounds.left;
        int height = bounds.bottom - bounds.top;
        if (width <= 0 || height <= 0) {
            // Before failing, try to get the bounds again, as the window might have been minimized.
            User32.INSTANCE.GetWindowRect(hWnd.getPointer(), bounds);
            width = bounds.right - bounds.left;
            height = bounds.bottom - bounds.top;
            if (width <= 0 || height <= 0) {
                return null;
            }
        }
        try {
            return new Robot().createScreenCapture(new Rectangle(bounds.left, bounds.top, width, height));
        } catch (AWTException e) {
            e.printStackTrace();
            return null;
        }
    }

    private static boolean isBlack(BufferedImage image) {
        int width = image.getWidth();
        int height = image.getHeight();
        // Check a few pixels to see if they are black. A small sample is enough.
        for (int i = 0; i < 10; i++) {
            int x = (int) (Math.random() * width);
            int y = (int) (Math.random() * height);
            if ((image.getRGB(x, y) & 0x00FFFFFF) != 0) {
                return false; // Found a non-black pixel
            }
        }
        return true;
    }

    public static BufferedImage captureDesktop() {
        try {
            return new Robot().createScreenCapture(new Rectangle(Toolkit.getDefaultToolkit().getScreenSize()));
        } catch (AWTException e) {
            e.printStackTrace();
            return null;
        }
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\library\capture\User32.java
=================================================================================

package com.botmaker.library.capture;

import com.sun.jna.Native;
import com.sun.jna.Pointer;
import com.sun.jna.win32.W32APIOptions;
import com.sun.jna.platform.win32.WinDef.*;
import com.sun.jna.win32.StdCallLibrary;

public interface User32 extends StdCallLibrary {


    User32 INSTANCE = Native.load(
            "user32",
            User32.class,
            W32APIOptions.DEFAULT_OPTIONS);
    interface WNDENUMPROC extends StdCallCallback {
        boolean callback(Pointer hWnd, Pointer arg);
    }

    boolean EnumWindows(WNDENUMPROC lpEnumFunc, Pointer arg);
    boolean EnumChildWindows(HWND parent, WNDENUMPROC lpEnumFunc, Pointer arg);

    /* ---------  text / geometry  --------- */

    int  GetWindowTextA(Pointer hWnd, byte[] lpString, int nMax);
    Pointer FindWindowA(String lpClass, String lpName);
    boolean GetWindowRect(Pointer hWnd, RECT rect);
    boolean GetClientRect(HWND hWnd, RECT rect);

    /* ---------  DC / painting  --------- */

    HDC GetDC(HWND hWnd);
    int ReleaseDC(HWND hWnd, HDC hDC);
    boolean PrintWindow(HWND hWnd, HDC hdcBlt, int flags);

    /* ---------  DPI / focus / mouse pos  --------- */

    boolean SetProcessDPIAware();
    HWND    GetForegroundWindow();
    boolean SetForegroundWindow(HWND hWnd);
    boolean GetCursorPos(POINT pt);
    short   GetAsyncKeyState(int vKey);

    /* ---------  coordinate helpers  --------- */

    boolean ClientToScreen(HWND hWnd, POINT pt);
    boolean ScreenToClient(HWND hWnd, POINT pt);

    /* ---------  hit-testing  --------- */
    HWND WindowFromPoint(POINT pt);
    HWND WindowFromPoint(POINT.ByValue pt);   // ← ByValue !
    int  CWP_ALL = 0x0000;
    HWND ChildWindowFromPointEx(HWND parent, POINT pt, int flags);

    /* ---------  messaging  --------- */

    boolean PostMessage(HWND hWnd, int msg, WPARAM wp, LPARAM lp);
    LRESULT SendMessage(HWND hWnd, int msg, WPARAM wp, LPARAM lp);

    /* ---- NEW DESKTOP / METRICS ------------------------------------------- */

    HWND GetDesktopWindow();                // top level “Progman/WorkerW” window
    int  GetSystemMetrics(int index);       // screen size, virtual-desktop origin

    int SM_XVIRTUALSCREEN = 76;   // left   of bounding rect (can be negative)
    int SM_YVIRTUALSCREEN = 77;   // top    of bounding rect
    int SM_CXVIRTUALSCREEN = 78;  // width  of bounding rect
    int SM_CYVIRTUALSCREEN = 79;  // height of bounding rect

    HWND GetAncestor(HWND hWnd, int gaFlags);     // GA_ROOT = 2, GA_ROOTOWNER = 3
    boolean ShowWindow(HWND hWnd, int nCmdShow);  // SW_RESTORE = 9
    /* ---------  mouse constants  --------- */

    int WM_LBUTTONDOWN = 0x0201;
    int WM_LBUTTONUP   = 0x0202;
    int MK_LBUTTON     = 0x0001;
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\library\capture\WindowFinder.java
=================================================================================

package com.botmaker.library.capture;

import com.sun.jna.Pointer;
import com.sun.jna.platform.win32.WinDef.HWND;

import java.util.ArrayList;
import java.util.List;

public class WindowFinder {

    public static HWND findWindow(String title) {
        return new HWND(User32.INSTANCE.FindWindowA(null, title));
    }

    public static List<WindowInfo> getChildWindows(HWND parent) {
        List<WindowInfo> windows = new ArrayList<>();
        User32.INSTANCE.EnumChildWindows(parent, (hWnd, p) -> {
            byte[] windowText = new byte[512];
            User32.INSTANCE.GetWindowTextA(hWnd, windowText, 512);
            String title = new String(windowText).trim();
            if (!title.isEmpty()) {
                windows.add(new WindowInfo(new HWND(hWnd), title));
            }
            return true;
        }, null);
        return windows;
    }

    public static List<WindowInfo> getAllWindows() {
        List<WindowInfo> windows = new ArrayList<>();
        User32.INSTANCE.EnumWindows((hWnd, p) -> {
            byte[] windowText = new byte[512];
            User32.INSTANCE.GetWindowTextA(hWnd, windowText, 512);
            String title = new String(windowText).trim();
            if (!title.isEmpty()) {
                windows.add(new WindowInfo(new HWND(hWnd), title));
            }
            return true;
        }, null);
        return windows;
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\library\capture\WindowInfo.java
=================================================================================

package com.botmaker.library.capture;

import com.sun.jna.platform.win32.WinDef.HWND;
import com.sun.jna.platform.win32.WinDef.RECT;

public class WindowInfo {

    private final HWND hWnd;
    private final String title;

    public WindowInfo(HWND hWnd, String title) {
        this.hWnd = hWnd;
        this.title = title;
    }

    public HWND getHWnd() {
        return hWnd;
    }

    public String getTitle() {
        return title;
    }

    public RECT getWindowRect() {
        RECT rect = new RECT();
        User32.INSTANCE.GetWindowRect(hWnd.getPointer(), rect);
        return rect;
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\library\emulator\AdbHelper.java
=================================================================================

package com.botmaker.library.emulator;

import com.android.ddmlib.*;

import java.io.IOException;

public class AdbHelper {

    private static AndroidDebugBridge adb;

    public static void initAdb() {
        if (adb == null) {
            AndroidDebugBridge.init(false);
            adb = AndroidDebugBridge.createBridge();
        }
    }

    public static void terminateAdb() {
        if (adb != null) {
            AndroidDebugBridge.terminate();
            adb = null;
        }
    }

    public static IDevice connect(String adbHost, int adbPort) throws Exception {
        String serial = adbHost + ":" + adbPort;

        // First, check if the device is already connected
        for (IDevice device : adb.getDevices()) {
            if (device.getSerialNumber().equals(serial)) {
                return device;
            }
        }

        // If not, try to connect to it via adb command
        System.out.println("Attempting to connect to ADB device: " + serial);
        ProcessBuilder pb = new ProcessBuilder("adb", "connect", serial);
        Process process = pb.start();
        process.waitFor(); // Wait for the adb connect command to finish

        long startTime = System.currentTimeMillis();
        long timeout = 30 * 1000; // 30 seconds timeout

        while (System.currentTimeMillis() - startTime < timeout) {
            for (IDevice device : adb.getDevices()) {
                if (device.getSerialNumber().equals(serial)) {
                    System.out.println("Successfully connected to ADB device: " + serial);
                    return device;
                }
            }
            Thread.sleep(1000); // Wait for 1 second before retrying
        }
        System.out.println("Failed to connect to ADB device: " + serial + " after timeout.");
        return null;
    }

    public static boolean isPackageInstalled(IDevice device, String packageName) throws TimeoutException, AdbCommandRejectedException, ShellCommandUnresponsiveException, IOException {
        CollectingOutputReceiver receiver = new CollectingOutputReceiver();
        device.executeShellCommand("pm list packages " + packageName, receiver);
        return receiver.getOutput().contains(packageName);
    }

    public static void launchGame(IDevice device, String packageName, String activityName) throws AdbCommandRejectedException, TimeoutException, ShellCommandUnresponsiveException, IOException {
        device.executeShellCommand("am start -n " + packageName + "/" + activityName, new CollectingOutputReceiver());
    }

    public static void waitForBootComplete(IDevice dev, long timeoutMs)
            throws TimeoutException, AdbCommandRejectedException, IOException, InterruptedException {

        long deadline = System.currentTimeMillis() + timeoutMs;


        while (dev.getState() != IDevice.DeviceState.ONLINE) {
            if (System.currentTimeMillis() > deadline) {
                throw new TimeoutException("Device never came online");
            }
            Thread.sleep(1_000);
        }


        while (true) {
            String boot = dev.getProperty("sys.boot_completed");            // shortcut wrapper
            String anim = dev.getProperty("init.svc.bootanim");             // may be null on -no-boot-anim
            if ("1".equals(boot) && (anim == null || "stopped".equals(anim))) {
                return;                                                     // fully booted
            }
            if (System.currentTimeMillis() > deadline) {
                throw new TimeoutException("Device did not finish booting");
            }
            Thread.sleep(1_000);
        }
    }


}



=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\library\emulator\BlueStacksConfig.java
=================================================================================

package com.botmaker.library.emulator;

import java.io.BufferedReader;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.HashMap;
import java.util.Map;

public class BlueStacksConfig {

    private final Map<String, String> properties = new HashMap<>();

    public BlueStacksConfig(Path filePath) throws IOException {
        try (BufferedReader reader = Files.newBufferedReader(filePath)) {
            String line;
            while ((line = reader.readLine()) != null) {
                String[] parts = line.split("=");
                if (parts.length == 2) {
                    properties.put(parts[0].trim(), parts[1].trim().replace("\"", ""));
                }
            }
        }
    }


    public String getProperty(String key) {
        return properties.get(key);
    }

    public String getAdbPort(String instanceName) {
        return getProperty("bst.instance." + instanceName + ".adb_port");
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\library\emulator\BlueStacksEmulator.java
=================================================================================

package com.botmaker.library.emulator;

import com.android.ddmlib.CollectingOutputReceiver;

import com.botmaker.library.inspector.RegistryInspector;

import java.io.IOException;
import java.nio.file.Path;
import java.nio.file.Paths;

public class BlueStacksEmulator extends Emulator {

    private static final String EMULATOR_NAME = "BlueStacks";
    private static final String BLUESTACKS_EXE = "HD-Player.exe";
    private static final String BLUESTACKS_CONF = "bluestacks.conf";

    private static final int MAX_SCREENSHOT_RETRIES = 5;
    private static final long SCREENSHOT_RETRY_DELAY_MS = 2000; // 2 seconds

    private final BlueStacksInstance instance;

    public BlueStacksEmulator(BlueStacksInstance instance) {
        super(EMULATOR_NAME, Paths.get(RegistryInspector.getBlueStacksInstallPath()));
        if (installPath == null) {
            throw new IllegalStateException("BlueStacks installation path not found.");
        }
        this.instance = instance;
    }

    @Override
    public void start() throws IOException {
        Path bluestacksExePath = installPath.resolve(BLUESTACKS_EXE);
        ProcessBuilder pb = new ProcessBuilder(bluestacksExePath.toString(), "--instance", instance.getInstanceName());
        pb.start();
    }

    @Override
    public void connect() throws Exception {
        String userDefinedDir = RegistryInspector.getBlueStacksUserDefinedDir();
        if (userDefinedDir == null) {
            throw new IllegalStateException("BlueStacks UserDefinedDir not found.");
        }
        BlueStacksConfig config = new BlueStacksConfig(Paths.get(userDefinedDir).resolve(BLUESTACKS_CONF));
        String adbPort = config.getAdbPort(instance.getInstanceName());
        if (adbPort == null) {
            throw new IllegalStateException("ADB port not found in bluestacks.conf for instance: " + instance.getInstanceName());
        }

        this.device = AdbHelper.connect("127.0.0.1", Integer.parseInt(adbPort));
        if (this.device == null) {
            throw new IllegalStateException("Failed to connect to BlueStacks ADB for instance: " + instance.getInstanceName());
        }
        AdbHelper.waitForBootComplete(this.device,120_000);
    }

    @Override
    public String getMainWindowTitle() {
        // This might need to be more dynamic, but for now, a common title
        return "BlueStacks App Player";
    }

    @Override
    public void takeScreenshot(Path outputPath) throws Exception {
        if (device == null) {
            throw new IllegalStateException("Emulator not connected.");
        }

        String devicePath = "/sdcard/screenshot.png";
        CollectingOutputReceiver receiver = new CollectingOutputReceiver();

        // Take screenshot on device
        device.executeShellCommand("screencap -p " + devicePath, receiver);

        // Pull the file from device
        device.pullFile(devicePath, outputPath.toString());

        // Delete the temporary file on device
        device.executeShellCommand("rm " + devicePath, receiver);
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\library\emulator\BlueStacksInstance.java
=================================================================================

package com.botmaker.library.emulator;

import com.fasterxml.jackson.annotation.JsonProperty;

public class BlueStacksInstance {
    @JsonProperty("ID")
    private int id;
    @JsonProperty("Name")
    private String name;
    @JsonProperty("IsFolder")
    private boolean isFolder;
    @JsonProperty("ParentFolder")
    private int parentFolder;
    @JsonProperty("IsOpen")
    private boolean isOpen;
    @JsonProperty("IsVisible")
    private boolean isVisible;
    @JsonProperty("InstanceName")
    private String instanceName;

    // Getters and Setters
    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public boolean isFolder() {
        return isFolder;
    }

    public void setFolder(boolean folder) {
        isFolder = folder;
    }

    public int getParentFolder() {
        return parentFolder;
    }

    public void setParentFolder(int parentFolder) {
        this.parentFolder = parentFolder;
    }

    public boolean isOpen() {
        return isOpen;
    }

    public void setOpen(boolean open) {
        isOpen = open;
    }

    public boolean isVisible() {
        return isVisible;
    }

    public void setVisible(boolean visible) {
        isVisible = visible;
    }

    public String getInstanceName() {
        return instanceName;
    }

    public void setInstanceName(String instanceName) {
        this.instanceName = instanceName;
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\library\emulator\BlueStacksInstanceManager.java
=================================================================================

package com.botmaker.library.emulator;



import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;

import java.io.IOException;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.List;

public class BlueStacksInstanceManager {

    public static List<BlueStacksInstance> getInstances(Path mimMetaDataPath) throws IOException {
        ObjectMapper mapper = new ObjectMapper();
        List<BlueStacksInstance> instances = new ArrayList<>();

        JsonNode rootNode = mapper.readTree(mimMetaDataPath.toFile());
        JsonNode organizationNode = rootNode.get("Organization");

        if (organizationNode != null && organizationNode.isArray()) {
            for (JsonNode node : organizationNode) {
                instances.add(mapper.treeToValue(node, BlueStacksInstance.class));
            }
        }
        return instances;
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\library\emulator\Emulator.java
=================================================================================

package com.botmaker.library.emulator;

import com.android.ddmlib.IDevice;

import java.nio.file.Path;

public abstract class Emulator {

    protected final String name;
    protected final Path installPath;
    protected IDevice device;

    public Emulator(String name, Path installPath) {
        this.name = name;
        this.installPath = installPath;
    }

    public abstract void start() throws Exception;
    public abstract void connect() throws Exception;

    public boolean isGameInstalled(String packageName) throws Exception {
        if (device == null) {
            throw new IllegalStateException("Emulator not connected.");
        }
        return AdbHelper.isPackageInstalled(device, packageName);
    }

    public void launchGame(String packageName, String gameActivity) throws Exception {
        if (device == null) {
            throw new IllegalStateException("Emulator not connected.");
        }
        AdbHelper.launchGame(device, packageName, gameActivity);
    }

    public String getName() {
        return name;
    }

    public Path getInstallPath() {
        return installPath;
    }

    public IDevice getDevice() {
        return device;
    }

    public abstract String getMainWindowTitle();
    public abstract void takeScreenshot(Path outputPath) throws Exception;
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\library\emulator\EmulatorTest.java
=================================================================================

package com.botmaker.library.emulator;



import com.botmaker.library.inspector.RegistryInspector;

import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.List;

public class EmulatorTest {

    public static void main(String[] args) {
        AdbHelper.initAdb(); // Initialize ADB once
        try {
            String bluestacksInstallPathStr = RegistryInspector.getBlueStacksInstallPath();
            if (bluestacksInstallPathStr == null) {
                System.out.println("BlueStacks not found.");
                return;
            }
            Path bluestacksInstallPath = Paths.get(bluestacksInstallPathStr);
            System.out.println("BlueStacks Install Path: " + bluestacksInstallPath);

            String bluestacksDataDirStr = RegistryInspector.getBlueStacksDataDir();
            if (bluestacksDataDirStr == null) {
                System.out.println("BlueStacks Data Directory not found.");
                return;
            }
            Path bluestacksDataDir = Paths.get(bluestacksDataDirStr);
            System.out.println("BlueStacks Data Directory: " + bluestacksDataDir);

            Path mimMetaDataPath = bluestacksDataDir.resolve("UserData").resolve("MimMetaData.json");
            if (!mimMetaDataPath.toFile().exists()) {
                System.out.println("MimMetaData.json not found at: " + mimMetaDataPath);
                return;
            }

            List<BlueStacksInstance> instances = BlueStacksInstanceManager.getInstances(mimMetaDataPath);
            if (instances.isEmpty()) {
                System.out.println("No BlueStacks instances found.");
                return;
            }

            System.out.println("Found BlueStacks Instances:");
            for (BlueStacksInstance instance : instances) {
                System.out.println("  ID: " + instance.getId() + ", Name: " + instance.getName() + ", InstanceName: " + instance.getInstanceName());

                BlueStacksEmulator emulator = new BlueStacksEmulator(instance);
                System.out.println("  Attempting to start emulator: " + emulator.getName() + " (" + emulator.getInstallPath() + ")");
                emulator.start();
                System.out.println("  Emulator started. Attempting to connect to ADB...");
                emulator.connect();

                if (emulator.getDevice() != null) {
                    System.out.println("  Connected to ADB device: " + emulator.getDevice().getSerialNumber());


                    String gamePackage = "com.supercell.clashofclans"; // Replace with your game's package name
                    if (emulator.isGameInstalled(gamePackage)) {
                        System.out.println("  Game " + gamePackage + " is installed.");
                        String gameActivity = "com.supercell.titan.GameApp"; // Replace with your game's main activity
                        emulator.launchGame(gamePackage, gameActivity);
                        System.out.println("  Game launched.");
                    } else {
                        System.out.println("  Game " + gamePackage + " is NOT installed.");
                    }

                    System.out.println("  Main Window Title: " + emulator.getMainWindowTitle());

                    // Take a screenshot
                    Path screenshotPath = Paths.get("screenshot_" + instance.getInstanceName() + ".png");
                    emulator.takeScreenshot(screenshotPath);
                    System.out.println("  Screenshot saved to: " + screenshotPath.toAbsolutePath());

                } else {
                    System.out.println("  Failed to connect to ADB for this instance.");
                }
                System.out.println("----------------------------------------");
            }



        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            AdbHelper.terminateAdb(); // Terminate ADB when done
        }
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\library\inspector\RegistryInspector.java
=================================================================================

package com.botmaker.library.inspector;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class RegistryInspector {

    public static String getLDPlayerInstallPath() {
        return getRegistryValue("HKEY_LOCAL_MACHINE\\SOFTWARE\\XuanZhi\\LDPlayer9", "InstallDir");
    }

    public static String getBlueStacksInstallPath() {
        String path = getRegistryValue("HKEY_LOCAL_MACHINE\\SOFTWARE\\BlueStacks_nxt", "InstallDir");
        if (path == null) {
            path = getRegistryValue("HKEY_LOCAL_MACHINE\\SOFTWARE\\BlueStacks_msi", "InstallDir");
        }
        return path;
    }

    public static String getBlueStacksDataDir() {
        String path = getRegistryValue("HKEY_LOCAL_MACHINE\\SOFTWARE\\BlueStacks_nxt", "DataDir");
        if (path == null) {
            path = getRegistryValue("HKEY_LOCAL_MACHINE\\SOFTWARE\\BlueStacks_msi", "DataDir");
        }
        return path;
    }

    public static String getBlueStacksUserDefinedDir() {
        String path = getRegistryValue("HKEY_LOCAL_MACHINE\\SOFTWARE\\BlueStacks_nxt", "UserDefinedDir");
        if (path == null) {
            path = getRegistryValue("HKEY_LOCAL_MACHINE\\SOFTWARE\\BlueStacks_msi", "UserDefinedDir");
        }
        return path;
    }

    private static String getRegistryValue(String key, String valueName) {
        try {
            ProcessBuilder pb = new ProcessBuilder("reg", "query", key, "/v", valueName);
            Process process = pb.start();
            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
            String line;
            while ((line = reader.readLine()) != null) {
                if (line.trim().startsWith(valueName)) {
                    String[] parts = line.trim().split("    ");
                    if (parts.length > 1) {
                        return parts[parts.length - 1];
                    }
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
        return null;
    }

    public static void main(String[] args) {
        System.out.println("Checking for LDPlayer...");
        String ldPlayerPath = getLDPlayerInstallPath();
        if (ldPlayerPath != null) {
            System.out.println("LDPlayer is installed at: " + ldPlayerPath);
        } else {
            System.out.println("LDPlayer is not installed.");
        }

        System.out.println("\nChecking for BlueStacks...");
        String blueStacksPath = getBlueStacksInstallPath();
        if (blueStacksPath != null) {
            System.out.println("BlueStacks is installed at: " + blueStacksPath);
        } else {
            System.out.println("BlueStacks is not installed.");
        }
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\library\interaction\GameInteractor.java
=================================================================================

package com.botmaker.library.interaction;


import com.botmaker.library.capture.Clicker;
import com.botmaker.library.capture.ScreenCapture;
import com.botmaker.library.capture.WindowInfo;
import com.botmaker.library.emulator.Emulator;
import com.botmaker.library.opencv.MatType;
import com.botmaker.library.opencv.MatchResult;
import com.botmaker.library.opencv.OpencvManager;
import com.botmaker.library.opencv.Template;

import java.awt.image.BufferedImage;
import java.io.File;
import java.util.logging.Logger;

public class GameInteractor{

    private static final Logger LOGGER = Logger.getLogger(GameInteractor.class.getName());

    private final GameType gameType;
    private final Emulator emulator;
    private final WindowInfo gameWindow;

    public GameInteractor(GameType gameType, Emulator emulator, WindowInfo gameWindow) {
        this.gameType = gameType;
        this.emulator = emulator;
        this.gameWindow = gameWindow;
    }

    public Template getBackground() {
        try {
            BufferedImage screenshot = null;
            if (gameType == GameType.EMULATOR && emulator != null) {
                File tempFile = File.createTempFile("screenshot", ".png");
                tempFile.deleteOnExit(); // Ensure cleanup even if the program crashes later
                emulator.takeScreenshot(tempFile.toPath());
                screenshot = javax.imageio.ImageIO.read(tempFile);
                tempFile.delete(); // Clean up the temporary file immediately
            } else if (gameType == GameType.WINDOW && gameWindow != null) {
                screenshot = ScreenCapture.capture(gameWindow.getHWnd());
            } else if (gameType == GameType.SCREEN) {
                screenshot = ScreenCapture.captureDesktop();
            }

            if (screenshot != null) {
                return new Template(OpencvManager.bufferedImageToMat(screenshot), "screenshot");
            }
            return null;
        } catch (Exception e) {
            LOGGER.severe("Failed to get background screenshot: " + e.getMessage());
            e.printStackTrace(); // Also print stack trace for easier debugging
            return null; // Return null on any exception
        }
    }


    public MatchResult findTemplateInGame(Template template, MatType matType, double confidenceThreshold) throws Exception {
        Template background = getBackground();
        if (background != null) {
            return OpencvManager.findBestMatch(template, background, matType, confidenceThreshold);
        }
        return MatchResult.noMatch();
    }


    public void click(int x, int y) throws Exception {
        LOGGER.info("Clicking at: (" + x + ", " + y + ")");
        if (gameType == GameType.EMULATOR && emulator != null) {
            if (emulator.getDevice() == null) {
                LOGGER.severe("Emulator device not connected. Cannot perform click.");
                return;
            }
            emulator.getDevice().executeShellCommand("input tap " + x + " " + y, null);
        } else if (gameType == GameType.WINDOW && gameWindow != null) {
            Clicker.postLeftClick(gameWindow.getHWnd(), x, y);
        } else if (gameType == GameType.SCREEN) {
            Clicker.postLeftClickScreen(x, y);
        } else {
            LOGGER.warning("Cannot perform click. Game type not supported or game not initialized.");
        }
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\library\interaction\GameType.java
=================================================================================

package com.botmaker.library.interaction;

public enum GameType {
    WINDOW,
    EMULATOR,
    SCREEN
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\library\opencv\MatchResult.java
=================================================================================

package com.botmaker.library.opencv;

import org.opencv.core.Rect;


public class MatchResult {
    public Rect rectLocation;
    public double score;
    public double confidenceThreshold;
    public String winningTemplateId;
    public String winningBackgroundId;
    // --- START OF MODIFICATION ---
    public final MatType matType;

    public MatchResult(Rect rect, double score, double threshold, String winningTemplateId, String winningBackgroundId, MatType matType) {
        this.rectLocation = rect;
        this.score = score;
        this.confidenceThreshold = threshold;
        this.winningTemplateId = winningTemplateId;
        this.winningBackgroundId = winningBackgroundId;
        this.matType = matType;
    }

    private MatchResult() {
        this.rectLocation = new Rect();
        this.score = 0;
        this.confidenceThreshold = 0;
        this.winningTemplateId = null;
        this.winningBackgroundId = null;
        this.matType = null;
    }

    public static MatchResult noMatch() {
        return new MatchResult();
    }

    public String getTemplateId() {
        return winningTemplateId;
    }
    public String getBackgroundId() {
        return winningBackgroundId;
    }

    public double getScore(){
        return score;
    }

    public Boolean isMatch(){
        if (winningTemplateId == null) {
            return false;
        }
        return score>=confidenceThreshold;
    }

    @Override
    public String toString() {
        if (winningTemplateId == null) {
            return "MatchResult [No Match]";
        }
        // --- START OF MODIFICATION ---
        return String.format("MatchResult [Template: %s, Background: %s, Score: %.4f, Location: %s, Threshold: %.4f, MatType: %s, IsSignificant: %b]",
                winningTemplateId != null ? winningTemplateId : "N/A",
                winningBackgroundId != null ? winningBackgroundId : "N/A",
                score,
                rectLocation != null ? rectLocation.toString() : "N/A",
                confidenceThreshold,
                matType,
                isMatch());
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\library\opencv\MatType.java
=================================================================================

package com.botmaker.library.opencv;

public enum MatType {COLOR, GRAY}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\library\opencv\OpencvManager.java
=================================================================================

package com.botmaker.library.opencv;


import org.opencv.core.*;
import org.opencv.imgproc.Imgproc;

import java.awt.image.BufferedImage;
import java.awt.image.DataBufferByte;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;

import static org.opencv.imgcodecs.Imgcodecs.imread;
import static org.opencv.imgproc.Imgproc.*;



public class OpencvManager {
    private static final double DEFAULT_CONFIDENCE_THRESHOLD = 0.8;

    public static Mat bufferedImageToMat(BufferedImage image) {

        BufferedImage convertedImg = new BufferedImage(image.getWidth(), image.getHeight(), BufferedImage.TYPE_3BYTE_BGR);

        convertedImg.getGraphics().drawImage(image, 0, 0, null);

        Mat mat = new Mat(image.getHeight(), image.getWidth(), CvType.CV_8UC3);

        byte[] pixels = ((DataBufferByte) convertedImg.getRaster().getDataBuffer()).getData();

        mat.put(0, 0, pixels);
        return mat;
    }

    public static Template loadTemplate(String path) {
        Mat mat = imread(path);
        if (mat.empty()) {
            System.err.println("Error: Could not load template from path: " + path);
            return null;
        }
        return new Template(mat, path);
    }

    public OpencvManager() {

    }

    static public Boolean isRGBA(Mat mat){
        return mat.channels() == 4;
    }

    static public Boolean isRGB(Mat mat){
        return mat.channels() == 3;
    }
    static public Boolean isGray(Mat mat){
        return mat.channels() == 1;
    }

    static void convertToBGR(Mat mat){
        if(isGray(mat)){
            cvtColor(mat, mat, COLOR_GRAY2RGB);
        }
        else if(isRGBA(mat)){
            cvtColor(mat, mat, COLOR_RGBA2RGB);
        }
    }

    static void convertToGray(Mat mat){
        if(isRGB(mat)){
            cvtColor(mat, mat, COLOR_RGB2GRAY);
        }
        else if(isRGBA(mat)){
            cvtColor(mat, mat, COLOR_RGBA2GRAY);
        }
    }
    public static Mat drawMatch(Mat image, MatchResult match, Scalar color) {
        Mat drawnImage = image.clone();
        Imgproc.rectangle(drawnImage, match.rectLocation, color, 2);
        return drawnImage;
    }
    static public MatchResult findBestMatch(Template template, Template backgroundTemplate,MatType convertType){
        return findBestMatch(template,backgroundTemplate,convertType,DEFAULT_CONFIDENCE_THRESHOLD);
    }

    static public void convertTo(Mat mat, MatType convertType){
        if(convertType == MatType.COLOR){
            convertToBGR(mat);
        }
        else if(convertType == MatType.GRAY){
            convertToGray(mat);
        }
    }

    static public void convertTo(Template template, MatType convertType){
        convertTo(template.mat,convertType);
    }



    private static Core.MinMaxLocResult performMatch(Mat templateMat, Mat backgroundMat) {
        if (backgroundMat.width() < templateMat.width() || backgroundMat.height() < templateMat.height()) {
            System.err.println("Error: Template dimensions are larger than the background image.");
            return null;
        }

        int resultCols = backgroundMat.cols() - templateMat.cols() + 1;
        int resultRows = backgroundMat.rows() - templateMat.rows() + 1;
        Mat resultMat = new Mat(resultRows, resultCols, CvType.CV_32FC1);

        Imgproc.matchTemplate(backgroundMat, templateMat, resultMat, Imgproc.TM_CCOEFF_NORMED);
        return Core.minMaxLoc(resultMat);
    }

    static public MatchResult findBestMatch(Template template, Template backgroundTemplate, MatType convertType, double confidenceThreshold){

        Template localTemplate = template.clone();
        Template localBackground = backgroundTemplate.clone();

        convertTo(localTemplate,convertType);
        convertTo(localBackground,convertType);

        if (localBackground.width() < localTemplate.width() || localBackground.height() < localTemplate.height()) {
            System.err.println("Error: Template dimensions are larger than the background image.");
            return null;
        }

        int resultCols = localBackground.cols() - localTemplate.cols() + 1;
        int resultRows = localBackground.rows() - localTemplate.rows() + 1;
        Mat resultMat = new Mat(resultRows, resultCols, CvType.CV_32FC1);

        matchTemplate(localBackground.mat,localTemplate.mat,resultMat,TM_CCOEFF_NORMED);
        Core.MinMaxLocResult mmr = Core.minMaxLoc(resultMat);
        // performMatch()
        double bestScore = mmr.maxVal;
        if (bestScore >= confidenceThreshold) {
            // If it is, create and return the MatchResult object.
            Point bestLocation = mmr.maxLoc;
            Rect rect = new Rect(bestLocation, localTemplate.size());
            // --- START OF MODIFICATION ---
            return new MatchResult(rect, bestScore, confidenceThreshold, template.id, backgroundTemplate.id, convertType);
            // --- END OF MODIFICATION ---
        }
        // --- START OF MODIFICATION ---
        return new MatchResult(null, bestScore, confidenceThreshold, template.id, backgroundTemplate.id, convertType);
        // --- END OF MODIFICATION ---
    }


    public static List<MatchResult> findMultipleMatches(Template template, Template backgroundTemplate, MatType convertType){
        return findMultipleMatches(template,backgroundTemplate,convertType,DEFAULT_CONFIDENCE_THRESHOLD, 0.5);
    }

    public static List<MatchResult> findMultipleMatches(Template template, Template backgroundTemplate, MatType convertType, double confidenceThreshold) {
        // Overload with a default overlap threshold
        return findMultipleMatches(template, backgroundTemplate, convertType, confidenceThreshold, 0.5);
    }
    public static List<MatchResult> findMultipleMatches(Template template, Template backgroundTemplate, MatType convertType, double confidenceThreshold, double overlapThreshold) {
        if (template.empty() || backgroundTemplate.empty() || backgroundTemplate.width() < template.width() || backgroundTemplate.height() < template.height()) {
            System.err.println("Error: Invalid input images for findMultipleMatches.");
            return new ArrayList<>(); // Return an empty list on error
        }

        Template localTemplate = template.clone();
        Template localBackground = backgroundTemplate.clone();

        convertTo(localTemplate,convertType);
        convertTo(localBackground,convertType);

        int resultCols = localBackground.cols() - localTemplate.cols() + 1;
        int resultRows = localBackground.rows() - localTemplate.rows() + 1;
        Mat resultMat = new Mat(resultRows, resultCols, CvType.CV_32FC1);
        Imgproc.matchTemplate(localBackground.mat, localTemplate.mat, resultMat, Imgproc.TM_CCOEFF_NORMED);

        List<MatchResult> candidates = new ArrayList<>();
        for (int y = 0; y < resultMat.rows(); y++) {
            for (int x = 0; x < resultMat.cols(); x++) {
                if (resultMat.get(y, x)[0] >= confidenceThreshold) {
                    Point matchLoc = new Point(x, y);
                    Rect rect = new Rect(matchLoc, localTemplate.size());
                    // --- START OF MODIFICATION ---
                    candidates.add(new MatchResult(rect, resultMat.get(y, x)[0], confidenceThreshold, template.id, backgroundTemplate.id, convertType));
                    // --- END OF MODIFICATION ---
                }
            }
        }

        System.out.printf("Found %d raw matches above the threshold of %.2f.%n", candidates.size(), confidenceThreshold);
        if (candidates.isEmpty()) {
            return candidates;
        }

        // Non-Maximal Suppression
        candidates.sort(Comparator.comparing(MatchResult::getScore).reversed());
        List<MatchResult> winners = new ArrayList<>();

        while(!candidates.isEmpty()) {
            MatchResult champion = candidates.getFirst();
            winners.add(champion);
            candidates.removeIf(competitor -> {
                double iou = calculateIntersectionOverUnion(champion.rectLocation, competitor.rectLocation);
                return iou > overlapThreshold;
            });
        }
        System.out.printf("Returning %d non-overlapping matches.%n", winners.size());
        return winners;
    }

    private static double calculateIntersectionOverUnion(Rect r1, Rect r2) {
        int xA = Math.max(r1.x, r2.x);
        int yA = Math.max(r1.y, r2.y);
        int xB = Math.min(r1.x + r1.width, r2.x + r2.width);
        int yB = Math.min(r1.y + r1.height, r2.y + r2.height);

        int intersectionArea = Math.max(0, xB - xA) * Math.max(0, yB - yA);

        int r1Area = r1.width * r1.height;
        int r2Area = r2.width * r2.height;

        double unionArea = (double) r1Area + r2Area - intersectionArea;

        return intersectionArea / unionArea;
    }
    public static List<MatchResult> findBestMatchPerTemplate(List<Template> allTemplates, Template backgroundTemplate, MatType convertType){
        return findBestMatchPerTemplate(allTemplates,backgroundTemplate,convertType,DEFAULT_CONFIDENCE_THRESHOLD);
    }
    public static List<MatchResult> findBestMatchPerTemplate(List<Template> allTemplates, Template backgroundTemplate, MatType convertType, double confidenceThreshold){
        return allTemplates
                .parallelStream()
                .map(template -> findBestMatch(template,backgroundTemplate,convertType,confidenceThreshold))
                .filter(Objects::nonNull)
                .collect(Collectors.toList());
    }

    public static MatchResult findOneTemplate(List<Template> allTemplates, Template backgroundTemplate,MatType convertType){
        return findOneTemplate(allTemplates,backgroundTemplate,convertType,DEFAULT_CONFIDENCE_THRESHOLD);
    }
    public static MatchResult findOneTemplate(List<Template> allTemplates, Template backgroundTemplate,MatType convertType, double confidenceThreshold){
        return allTemplates
                .parallelStream()
                .map(template -> findBestMatch(template, backgroundTemplate, convertType, confidenceThreshold))
                .filter(Objects::nonNull)
                .findAny()
                .orElse(null);
    }


    public static MatchResult findBestOneTemplate(List<Template> allTemplates, Template backgroundTemplate,MatType convertType) {
        return findBestOneTemplate(allTemplates,backgroundTemplate,convertType,DEFAULT_CONFIDENCE_THRESHOLD);
    }

    public static MatchResult findBestOneTemplate(List<Template> allTemplates, Template backgroundTemplate,MatType convertType, double confidenceThreshold){
        return findBestMatchPerTemplate(allTemplates,backgroundTemplate,convertType,confidenceThreshold)
                .stream()
                .max(Comparator.comparing(MatchResult::getScore))
                .orElse(null);
    }

    public static List<MatchResult> findAllMatches(List<Template> allTemplates, Template backgroundTemplate,MatType convertType, double confidenceThreshold){
        return allTemplates
                .parallelStream()
                .flatMap(template ->
                        Objects.requireNonNull(findMultipleMatches(template, backgroundTemplate, convertType, confidenceThreshold)).stream()
                )
                .collect(Collectors.toList());
    }

    public static List<MatchResult> findAllMatches(List<Template> allTemplates, List<Template> allBackgrounds,MatType convertType, double confidenceThreshold){
        return allBackgrounds
                .parallelStream()
                .flatMap(background -> findAllMatches(allTemplates, background, convertType, confidenceThreshold).stream())
                .collect(Collectors.toList());
    }


    public static MatchResult findBestInBackgrounds(
            Template template,
            List<Template> allBackgrounds, // Changed to List<Mat> for clarity
            MatType matType,
            double confidenceThreshold)
    {
        return allBackgrounds
                .parallelStream()
                .map(backgroundMat -> findBestMatch(template, backgroundMat, matType, confidenceThreshold))
                .filter(Objects::nonNull)
                .max(Comparator.comparing(MatchResult::getScore))
                .orElse(null);
    }


    public static List<MatchResult> findBestPerBackground(
            Template template,
            List<Template> allBackgrounds, // Changed to List<Mat>
            MatType matType,
            double confidenceThreshold)
    {
        // This implementation is already correct for its stated goal.
        return allBackgrounds
                .parallelStream()
                .map(backgroundMat -> findBestMatch(template, backgroundMat, matType, confidenceThreshold))
                .filter(Objects::nonNull)
                .collect(Collectors.toList());
    }


    //Competitive Matches

    private static boolean hasConflictWith(MatchResult wantedMatch,
                                           Template badTemplate,
                                           Template backgroundTemplate,
                                           MatType matType,
                                           double confidenceThreshold) {

        // If the wanted match wasn't even found, there can't be a conflict.
        if (wantedMatch == null || wantedMatch.rectLocation == null) {
            return false;
        }

        MatchResult badMatch = findBestMatch(badTemplate, backgroundTemplate, matType, confidenceThreshold);

        // If the bad template wasn't found or the matches don't intersect, there's no conflict.
        if (badMatch == null || badMatch.rectLocation == null || !intersects(wantedMatch.rectLocation, badMatch.rectLocation)) {
            return false;
        }

        // A conflict only exists if the bad match is found at the same location with an equal or higher score.
        if (badMatch.getScore() >= wantedMatch.getScore()) {
            System.out.printf(
                    "Conflict found: Wanted '%s' (Score: %.4f) was challenged by '%s' (Score: %.4f) at the same location.%n",
                    wantedMatch.winningTemplateId, wantedMatch.getScore(), badMatch.winningTemplateId, badMatch.getScore()
            );
            return true;
        }

        return false;
    }


    public static List<MatchResult> findCompetitiveMatches(
            List<Template> allTemplates,
            Template background,
            MatType matType,
            double confidenceThreshold)
    {
        List<MatchResult> candidates = findAllMatches(allTemplates, background, matType, confidenceThreshold);
        candidates.sort(Comparator.comparing(MatchResult::getScore).reversed());
        List<MatchResult> winners = new ArrayList<>();
        while (!candidates.isEmpty()) {
            MatchResult champion = candidates.getFirst();
            winners.add(champion);
            candidates.removeIf(competitor ->
                    intersects(champion.rectLocation, competitor.rectLocation)
            );
        }
        return winners;
    }

    public static MatchResult findWantedTemplate(
            Template wantedTemplate,
            Template backgroundTemplate,
            Template badTemplate,
            MatType matType,
            double confidenceThreshold) {
        MatchResult wantedMatch = findBestMatch(wantedTemplate, backgroundTemplate, matType, confidenceThreshold);
        if (wantedMatch == null) {
            return null;
        }
        // Step 2: Delegate the conflict check to our new helper function.
        if (hasConflictWith(wantedMatch, badTemplate, backgroundTemplate, matType, confidenceThreshold)) {
            return null; // A conflict was found, so the match is invalid.
        }

        // No conflict, the match is valid.
        return wantedMatch;
    }

    public static MatchResult findWantedTemplate(
            Template wantedTemplate,
            Template backgroundTemplate,
            List<Template> allBadTemplates,
            MatType matType,
            double confidenceThreshold)
    {
        MatchResult wantedMatch = findBestMatch(wantedTemplate, backgroundTemplate, matType, confidenceThreshold);
        if (wantedMatch == null) {
            return null;
        }

        // Step 2: Use a parallel stream to see if ANY bad template causes a conflict.
        // The lambda becomes a simple and clean call to our helper function.
        boolean hasAnyConflict = allBadTemplates
                .parallelStream()
                .anyMatch(badTemplate -> hasConflictWith(wantedMatch, badTemplate, backgroundTemplate, matType, confidenceThreshold));

        // Step 3: Return the result.
        if (hasAnyConflict) {
            return null; // At least one conflict was found, so the match is invalid.
        } else {
            return wantedMatch; // No conflicts found, the match is valid.
        }
    }

    public static List<MatchResult> findEachWantedTemplate(
            List<Template> allWantedTemplates,
            Template backgroundTemplate,
            Template badTemplate,
            MatType matType,
            double confidenceThreshold)
    {
        Template localBackground = backgroundTemplate.clone();
        Template localBadTemplate = badTemplate.clone();

        return allWantedTemplates
                .parallelStream()
                .map(wantedTemplate ->
                        findWantedTemplate(wantedTemplate.clone(), localBackground, localBadTemplate, matType, confidenceThreshold)
                )
                .filter(Objects::nonNull)
                .collect(Collectors.toList());

    }

    public static List<MatchResult> findEachWantedTemplate(
            List<Template> allWantedTemplates,
            Template backgroundTemplate,
            List<Template> allBadTemplates,
            MatType matType,
            double confidenceThreshold)
    {
        return allWantedTemplates
                .parallelStream()
                .map(wantedTemplate -> {
                    Template localWanted = wantedTemplate.clone();
                    return findWantedTemplate(localWanted, backgroundTemplate, allBadTemplates, matType, confidenceThreshold);
                })
                .filter(Objects::nonNull)
                .collect(Collectors.toList());
    }



    private static boolean intersects(Rect r1, Rect r2) {
        return r1.x < r2.x + r2.width &&
                r1.x + r1.width > r2.x &&
                r1.y < r2.y + r2.height &&
                r1.y + r1.height > r2.y;
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\library\opencv\OpencvTest.java
=================================================================================

package com.botmaker.library.opencv;


import com.botmaker.library.capture.ScreenCapture;
import org.bytedeco.javacpp.Loader;
import org.bytedeco.opencv.opencv_java;
import org.opencv.core.Mat;
import org.opencv.core.Rect;
import org.opencv.imgcodecs.Imgcodecs;

import javax.imageio.ImageIO;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Random;
import java.util.concurrent.TimeUnit;


public class OpencvTest {
    static{
        Loader.load(opencv_java.class);
    }
    private static final String BACKGROUNDS_DIR = "images/backgrounds";
    private static final String TEMPLATES_DIR = "images/templates";

    public static void main(String[] args) throws IOException, InterruptedException {
        // 1. Record screen and save backgrounds
        recordScreenAndSave(10, 2);

        // 2. Extract templates from backgrounds
        extractTemplatesFromBackgrounds(3);

        // 3. Benchmark OpenCV functions
        benchmarkOpenCVFunctions();
    }

    public static void recordScreenAndSave(int screenshotCount, int intervalSeconds) throws InterruptedException, IOException {
        File backgroundsDir = new File(BACKGROUNDS_DIR);
        if (!backgroundsDir.exists()) {
            backgroundsDir.mkdirs();
        }

        for (int i = 0; i < screenshotCount; i++) {
            BufferedImage screenshot = ScreenCapture.captureDesktop();
            if (screenshot != null) {
                File outputFile = new File(BACKGROUNDS_DIR + "/background_" + i + ".png");
                ImageIO.write(screenshot, "png", outputFile);
                System.out.println("Saved background image: " + outputFile.getAbsolutePath());
            }
            TimeUnit.SECONDS.sleep(intervalSeconds);
        }
    }

    public static void extractTemplatesFromBackgrounds(int templatesPerBackground) throws IOException {
        File templatesDir = new File(TEMPLATES_DIR);
        if (!templatesDir.exists()) {
            templatesDir.mkdirs();
        }

        File backgroundsDir = new File(BACKGROUNDS_DIR);
        File[] backgroundFiles = backgroundsDir.listFiles((dir, name) -> name.toLowerCase().endsWith(".png"));

        if (backgroundFiles == null) {
            System.out.println("No background images found in " + BACKGROUNDS_DIR);
            return;
        }

        Random random = new Random();
        int templateCount = 0;
        for (File backgroundFile : backgroundFiles) {
            BufferedImage backgroundImage = ImageIO.read(backgroundFile);
            for (int i = 0; i < templatesPerBackground; i++) {
                // Random size between 5% and 20% of the background dimensions
                double scale = 0.05 + (0.15 * random.nextDouble());
                int templateWidth = (int) (backgroundImage.getWidth() * scale);
                int templateHeight = (int) (backgroundImage.getHeight() * scale);

                int x = random.nextInt(backgroundImage.getWidth() - templateWidth);
                int y = random.nextInt(backgroundImage.getHeight() - templateHeight);
                BufferedImage templateImage = backgroundImage.getSubimage(x, y, templateWidth, templateHeight);

                File outputFile = new File(TEMPLATES_DIR + "/template_" + templateCount++ + ".png");
                ImageIO.write(templateImage, "png", outputFile);
                System.out.println("Saved template image: " + outputFile.getAbsolutePath());
            }
        }
    }

    public static void benchmarkOpenCVFunctions() {
        File backgroundsDir = new File(BACKGROUNDS_DIR);
        File[] backgroundFiles = backgroundsDir.listFiles((dir, name) -> name.toLowerCase().endsWith(".png"));
        File templatesDir = new File(TEMPLATES_DIR);
        File[] templateFiles = templatesDir.listFiles((dir, name) -> name.toLowerCase().endsWith(".png"));

        if (backgroundFiles == null || templateFiles == null) {
            System.out.println("No background or template images found.");
            return;
        }

        List<Template> backgroundTemplates = new ArrayList<>();
        for (File file : backgroundFiles) {
            backgroundTemplates.add(new Template(file.getAbsolutePath()));
        }

        List<Template> templates = new ArrayList<>();
        for (File file : templateFiles) {
            templates.add(new Template(file.getAbsolutePath()));
        }

        System.out.println("--- Benchmarking Results ---");

        // --- Benchmarking findBestMatch ---
        long totalTimeBestMatch = 0;
        int bestMatchCount = 0;
        for (Template background : backgroundTemplates) {
            for (Template template : templates) {
                long startTime = System.nanoTime();
                MatchResult result = OpencvManager.findBestMatch(template, background, MatType.COLOR);
                long endTime = System.nanoTime();
                totalTimeBestMatch += (endTime - startTime);
                bestMatchCount++;
                if (result != null) {
                    System.out.printf("findBestMatch: Found %s in %s with score %.4f%n",
                            new File(template.id).getName(), new File(background.id).getName(), result.getScore());
                }
            }
        }
        System.out.println("findBestMatch average time: " + (totalTimeBestMatch / bestMatchCount) / 1_000_000.0 + " ms");


        long totalTimeMultipleMatches = 0;
        int multipleMatchesCount = 0;
        for (Template background : backgroundTemplates) {
            for (Template template : templates) {
                long startTime = System.nanoTime();
                List<MatchResult> results = OpencvManager.findMultipleMatches(template, background, MatType.COLOR);
                long endTime = System.nanoTime();
                totalTimeMultipleMatches += (endTime - startTime);
                multipleMatchesCount++;
                if (results != null && !results.isEmpty()) {
                    for (MatchResult result : results) {
                        System.out.printf("findMultipleMatches: Found %s in %s with score %.4f%n",
                                new File(template.id).getName(), new File(background.id).getName(), result.getScore());
                    }
                }
            }
        }
        System.out.println("findMultipleMatches average time: " + (totalTimeMultipleMatches / multipleMatchesCount) / 1_000_000.0 + " ms");

         long totalTimeBestMatchPerTemplate = 0;
        int bestMatchPerTemplateCount = 0;
        for (Template background : backgroundTemplates) {
            long startTime = System.nanoTime();
            List<MatchResult> results = OpencvManager.findBestMatchPerTemplate(templates, background, MatType.COLOR);
            long endTime = System.nanoTime();
            totalTimeBestMatchPerTemplate += (endTime - startTime);
            bestMatchPerTemplateCount++;
            if (results != null && !results.isEmpty()) {
                for (MatchResult result : results) {
                    System.out.printf("findBestMatchPerTemplate: Found match in %s with score %.4f%n",
                            new File(background.id).getName(), result.getScore());
                }
            }
        }
        System.out.println("findBestMatchPerTemplate average time: " + (totalTimeBestMatchPerTemplate / bestMatchPerTemplateCount) / 1_000_000.0 + " ms");
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\library\opencv\Template.java
=================================================================================

package com.botmaker.library.opencv;


import org.opencv.core.Mat;
import org.opencv.core.Size;
import org.opencv.imgcodecs.Imgcodecs;

public class Template {
    public final Mat mat;
    public final String id;

    public Template(Mat mat, String id) {
        this.mat = mat;
        this.id = id;
    }

    public Template(String filePath) {
        this(Imgcodecs.imread(filePath), filePath);
    }

    public int rows(){
        return mat.rows();
    }
    public int cols(){
        return mat.cols();
    }
    public int channels(){
        return mat.channels();
    }
    public int type(){
        return mat.type();
    }

    public int width(){
        return mat.width();
    }
    public int height(){
        return mat.height();
    }

    public Size size(){
        return mat.size();
    }
    public boolean empty(){
        return mat.empty();
    }
    public Template clone(){
        return new Template(mat.clone(),id);
    }

    @Override
    public String toString() {
        return "Template[id='" + id + "', width=" + width() + ", height=" + height() + "]";
    }

}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\lsp\CompletionContext.java
=================================================================================

package com.botmaker.lsp;

import com.botmaker.parser.CodeEditor;
import com.botmaker.state.ApplicationState; // Import State
import com.botmaker.ui.BlockDragAndDropManager;
import org.eclipse.lsp4j.services.LanguageServer;

public record CompletionContext(
        CodeEditor codeEditor,
        LanguageServer server,
        String docUri,
        String sourceCode,
        long docVersion,
        BlockDragAndDropManager dragAndDropManager,
        ApplicationState applicationState // Added field
) {
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\lsp\JdtLanguageServerLauncher.java
=================================================================================

package com.botmaker.lsp;

import com.botmaker.config.Constants;
import org.eclipse.lsp4j.jsonrpc.Launcher;
import org.eclipse.lsp4j.launch.LSPLauncher;
import org.eclipse.lsp4j.services.LanguageClient;
import org.eclipse.lsp4j.services.LanguageServer;
import org.eclipse.lsp4j.*;

import java.io.*;
import java.nio.file.*;
import java.util.*;
import java.util.concurrent.CompletableFuture;
import java.util.function.Consumer;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.stream.Stream;

public class JdtLanguageServerLauncher {

    private final Process process;
    private final LanguageServer server;

    public JdtLanguageServerLauncher(
            Path jdtlsPath,
            Path projectPath,
            Path workspaceData,
            Consumer<PublishDiagnosticsParams> diagnosticsConsumer) throws Exception {

        System.out.println("Initializing JDT LS...");

        // Suppress LSP4J internal logging
        Logger.getLogger("org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint").setLevel(Level.SEVERE);
        Logger.getLogger("org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer").setLevel(Level.SEVERE);

        // Locate launcher jar
        Path launcherJar = Files.list(jdtlsPath.resolve("plugins"))
                .filter(p -> p.getFileName().toString().startsWith("org.eclipse.equinox.launcher_"))
                .findFirst()
                .orElseThrow(() -> new RuntimeException("Launcher JAR not found at: " + jdtlsPath.resolve("plugins")));

        String javaExecutable = Paths.get(System.getProperty("java.home"), "bin", "java").toString();
        if (System.getProperty("os.name").toLowerCase().contains("win")) {
            if (!javaExecutable.endsWith(".exe")) javaExecutable += ".exe";
        }

        Path projectDir = projectPath.toAbsolutePath().normalize();
        Files.createDirectories(workspaceData);

        String osName = System.getProperty("os.name").toLowerCase();
        String configDirName;
        if (osName.contains("win")) {
            configDirName = "config_win";
        } else if (osName.contains("mac")) {
            configDirName = "config_mac";
        } else {
            configDirName = "config_linux";
        }

        Path configPath = jdtlsPath.resolve(configDirName);

        List<String> command = new ArrayList<>(Arrays.asList(
                javaExecutable,
                Constants.JVM_ENTITY_SIZE_LIMIT,
                Constants.JVM_TOTAL_ENTITY_SIZE_LIMIT,
                "--add-modules=ALL-SYSTEM",
                "--add-opens", "java.base/java.util=ALL-UNNAMED",
                "--add-opens", "java.base/java.lang=ALL-UNNAMED",
                "--add-opens", "java.base/sun.nio.fs=ALL-UNNAMED",
                "-Declipse.application=org.eclipse.jdt.ls.core.id1",
                "-Dosgi.bundles.defaultStartLevel=4",
                "-Declipse.product=org.eclipse.jdt.ls.core.product",
                Constants.LSP_DETECT_VM_DISABLED,
                Constants.LSP_FILE_ENCODING,
                Constants.LSP_LOG_DISABLE,
                Constants.JVM_MAX_HEAP,
                Constants.LSP_DEPENDENCY_COLLECTOR,
                "--enable-native-access=javafx.graphics"
        ));

        if (Constants.LSP_LOG_PROTOCOL) {
            command.add("-Dlog.protocol=true");
            command.add("-Dlog.level=" + Constants.LSP_LOG_LEVEL);
        }

        command.addAll(Arrays.asList(
                "-jar", launcherJar.toString(),
                "-configuration", configPath.toString(),
                "-data", workspaceData.toAbsolutePath().normalize().toString()
        ));

        ProcessBuilder pb = new ProcessBuilder(command);
        pb.redirectErrorStream(false); // Keep stderr separate
        process = pb.start();

        // Consume stderr
        new Thread(() -> {
            try (BufferedReader br = new BufferedReader(new InputStreamReader(process.getErrorStream()))) {
                String line;
                while ((line = br.readLine()) != null) {
                    // Uncomment to debug JDT internal errors
                    // System.out.println("[JDT LS STDERR] " + line);
                }
            } catch (IOException ignored) {}
        }, "JDT-LS-Stderr-Gobbler").start();

        Launcher<LanguageServer> launcher = LSPLauncher.createClientLauncher(
                new SimpleLanguageClient(diagnosticsConsumer),
                process.getInputStream(),
                process.getOutputStream()
        );

        launcher.startListening();
        server = launcher.getRemoteProxy();

        InitializeParams init = new InitializeParams();
        init.setProcessId((int) ProcessHandle.current().pid());

        ClientCapabilities capabilities = new ClientCapabilities();
        WorkspaceClientCapabilities workspaceCaps = new WorkspaceClientCapabilities();
        workspaceCaps.setDidChangeConfiguration(new DidChangeConfigurationCapabilities(true));
        workspaceCaps.setWorkspaceFolders(true);
        capabilities.setWorkspace(workspaceCaps);

        TextDocumentClientCapabilities textDocCaps = new TextDocumentClientCapabilities();
        capabilities.setTextDocument(textDocCaps);
        init.setCapabilities(capabilities);

        WorkspaceFolder folder = new WorkspaceFolder(projectDir.toUri().toString());
        init.setWorkspaceFolders(List.of(folder));
        init.setRootUri(folder.getUri());

        try {
            // --- FIX: INCREASED TIMEOUT TO 60 SECONDS ---
            server.initialize(init).get(60, java.util.concurrent.TimeUnit.SECONDS);
            server.initialized(new InitializedParams());
            System.out.println("JDT LS Initialized successfully.");
        } catch (Exception e) {
            e.printStackTrace();
            System.err.println("JDT LS failed to initialize within timeout.");
        }
    }

    public LanguageServer getServer() { return server; }

    public void stop() {
        if (server != null) {
            try { server.shutdown().get(); } catch (Exception ignored) {}
            server.exit();
        }
        if (process != null) process.destroy();
    }

    public static void cleanupWorkspace(Path workspaceData) {
        if (!Files.exists(workspaceData)) return;
        try (Stream<Path> walk = Files.walk(workspaceData)) {
            walk.sorted(Comparator.reverseOrder())
                    .map(Path::toFile)
                    .forEach(File::delete);
        } catch (IOException e) {}
    }

    static class SimpleLanguageClient implements LanguageClient {
        private final Consumer<PublishDiagnosticsParams> diagnosticsConsumer;
        public SimpleLanguageClient(Consumer<PublishDiagnosticsParams> diagnosticsConsumer) { this.diagnosticsConsumer = diagnosticsConsumer; }
        @Override public void telemetryEvent(Object o) { }
        @Override public void publishDiagnostics(PublishDiagnosticsParams diagnostics) { if (diagnosticsConsumer != null) diagnosticsConsumer.accept(diagnostics); }
        @Override public void showMessage(MessageParams messageParams) { System.out.println("[LSP] " + messageParams.getMessage()); }
        @Override public CompletableFuture<MessageActionItem> showMessageRequest(ShowMessageRequestParams showMessageRequestParams) { return CompletableFuture.completedFuture(null); }
        @Override public void logMessage(MessageParams messageParams) { System.out.println("[LSP Log] " + messageParams.getMessage()); }
        @Override public CompletableFuture<Void> registerCapability(RegistrationParams params) { return CompletableFuture.completedFuture(null); }
        @Override public CompletableFuture<Void> unregisterCapability(UnregistrationParams params) { return CompletableFuture.completedFuture(null); }
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\parser\AstRewriter.java
=================================================================================

package com.botmaker.parser;

import com.botmaker.core.BodyBlock;
import com.botmaker.core.StatementBlock;
import com.botmaker.parser.handlers.*;
import com.botmaker.parser.helpers.AstRewriteHelper;
import com.botmaker.parser.helpers.TypeConversionHelper;
import com.botmaker.ui.AddableBlock;
import com.botmaker.ui.AddableExpression;
import org.eclipse.jdt.core.dom.*;
import org.eclipse.jdt.core.dom.rewrite.*;
import org.eclipse.jface.text.Document;
import org.eclipse.jface.text.IDocument;

import java.util.ArrayList;
import java.util.List;

/**
 * Coordinates AST rewriting operations by delegating to specialized handlers.
 * Reduced from 580 lines to ~200 lines by extracting handlers.
 */
public class AstRewriter {

    private final NodeCreator nodeCreator;
    private final TypeReplacementHandler typeHandler;
    private final OperatorReplacementHandler operatorHandler;
    private final ListManipulationHandler listHandler;
    private final MethodManipulationHandler methodHandler;
    private final EnumManipulationHandler enumHandler;

    public AstRewriter(NodeCreator nodeCreator) {
        this.nodeCreator = nodeCreator;
        this.typeHandler = new TypeReplacementHandler(nodeCreator);
        this.operatorHandler = new OperatorReplacementHandler();
        this.listHandler = new ListManipulationHandler(nodeCreator);
        this.methodHandler = new MethodManipulationHandler(nodeCreator);
        this.enumHandler = new EnumManipulationHandler();
    }

    // ========================================================================
    // STATEMENT MANIPULATION
    // ========================================================================

    public String moveStatement(CompilationUnit cu, String originalCode, StatementBlock blockToMove,
                                BodyBlock sourceBody, BodyBlock targetBody, int targetIndex) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);
        Statement statement = (Statement) blockToMove.getAstNode();

        ListRewrite sourceListRewrite = getListRewriteForBody(rewriter, sourceBody);
        ListRewrite targetListRewrite = getListRewriteForBody(rewriter, targetBody);

        Statement copiedStatement = (Statement) ASTNode.copySubtree(ast, statement);
        sourceListRewrite.remove(statement, null);
        insertIntoList(targetListRewrite, targetBody, copiedStatement, targetIndex);

        return AstRewriteHelper.applyRewrite(rewriter, originalCode);
    }

    public String addStatement(CompilationUnit cu, String originalCode, BodyBlock targetBody,
                               AddableBlock type, int index) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);

        Statement newStatement;
        if (type == AddableBlock.COMMENT) {
            newStatement = (Statement) rewriter.createStringPlaceholder("// Comment", ASTNode.EMPTY_STATEMENT);
        } else {
            newStatement = nodeCreator.createDefaultStatement(ast, type, cu, rewriter);
        }

        if (newStatement == null) return originalCode;

        ListRewrite listRewrite = getListRewriteForBody(rewriter, targetBody);
        insertIntoList(listRewrite, targetBody, newStatement, index);

        return AstRewriteHelper.applyRewrite(rewriter, originalCode);
    }

    public String deleteNode(CompilationUnit cu, String originalCode, ASTNode toDelete) {
        ASTRewrite rewriter = ASTRewrite.create(cu.getAST());
        rewriter.remove(toDelete, null);
        return AstRewriteHelper.applyRewrite(rewriter, originalCode);
    }

    /**
     * Smart deletion for statements. Handles special cases like unwrapping 'else if' chains.
     */
    public String deleteStatement(CompilationUnit cu, String originalCode, Statement statement) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);

        // Check if we are deleting an 'else if' block (IfStatement nested in an else property)
        if (statement instanceof IfStatement) {
            IfStatement ifStmt = (IfStatement) statement;
            if (ifStmt.getParent() instanceof IfStatement) {
                IfStatement parent = (IfStatement) ifStmt.getParent();

                // Confirm it is the 'else' child
                if (parent.getElseStatement() == ifStmt) {

                    Statement childElse = ifStmt.getElseStatement();

                    // If the node being deleted has its own else/else-if, pull it up
                    if (childElse != null) {
                        ASTNode moveTarget = rewriter.createMoveTarget(childElse);
                        rewriter.replace(ifStmt, moveTarget, null);
                        return AstRewriteHelper.applyRewrite(rewriter, originalCode);
                    }
                }
            }
        }

        // Default behavior: just remove the node
        rewriter.remove(statement, null);
        return AstRewriteHelper.applyRewrite(rewriter, originalCode);
    }

    // ========================================================================
    // EXPRESSION MANIPULATION
    // ========================================================================

    public String replaceExpression(CompilationUnit cu, String originalCode, Expression toReplace,
                                    AddableExpression type) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);

        String contextType = TypeConversionHelper.inferContextType(toReplace);
        Expression newExpression = nodeCreator.createDefaultExpression(ast, type, cu, rewriter, contextType);

        if (newExpression == null) return originalCode;

        rewriter.replace(toReplace, newExpression, null);
        return AstRewriteHelper.applyRewrite(rewriter, originalCode);
    }

    public String replaceLiteral(CompilationUnit cu, String originalCode, Expression toReplace,
                                 String newLiteralValue) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);

        Expression newExpression;
        if (toReplace instanceof StringLiteral) {
            StringLiteral newString = ast.newStringLiteral();
            newString.setLiteralValue(newLiteralValue);
            newExpression = newString;
        } else if (toReplace instanceof NumberLiteral) {
            newExpression = ast.newNumberLiteral(newLiteralValue);
        } else if (toReplace instanceof BooleanLiteral) {
            newExpression = ast.newBooleanLiteral(Boolean.parseBoolean(newLiteralValue));
        } else {
            return originalCode;
        }

        rewriter.replace(toReplace, newExpression, null);
        return AstRewriteHelper.applyRewrite(rewriter, originalCode);
    }

    public String replaceSimpleName(CompilationUnit cu, String originalCode, SimpleName toReplace,
                                    String newName) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);
        rewriter.replace(toReplace, ast.newSimpleName(newName), null);
        return AstRewriteHelper.applyRewrite(rewriter, originalCode);
    }

    // ========================================================================
    // TYPE OPERATIONS - Delegated to TypeReplacementHandler
    // ========================================================================

    public String replaceVariableType(CompilationUnit cu, String originalCode,
                                      VariableDeclarationStatement varDecl, String newTypeName) {
        return typeHandler.replaceVariableType(cu, originalCode, varDecl, newTypeName);
    }

    public String replaceFieldType(CompilationUnit cu, String originalCode,
                                   FieldDeclaration fieldDecl, String newTypeName) {
        return typeHandler.replaceFieldType(cu, originalCode, fieldDecl, newTypeName);
    }

    // ========================================================================
    // OPERATOR OPERATIONS - Delegated to OperatorReplacementHandler
    // ========================================================================

    public String replaceInfixOperator(CompilationUnit cu, String originalCode,
                                       InfixExpression infix, InfixExpression.Operator newOp) {
        return operatorHandler.replaceInfixOperator(cu, originalCode, infix, newOp);
    }

    public String replaceAssignmentOperator(CompilationUnit cu, String originalCode,
                                            Assignment assignment, Assignment.Operator newOp) {
        return operatorHandler.replaceAssignmentOperator(cu, originalCode, assignment, newOp);
    }

    public String replacePrefixOperator(CompilationUnit cu, String originalCode,
                                        PrefixExpression prefix, PrefixExpression.Operator newOp) {
        return operatorHandler.replacePrefixOperator(cu, originalCode, prefix, newOp);
    }

    public String replacePostfixOperator(CompilationUnit cu, String originalCode,
                                         PostfixExpression postfix, PostfixExpression.Operator newOp) {
        return operatorHandler.replacePostfixOperator(cu, originalCode, postfix, newOp);
    }

    // ========================================================================
    // LIST OPERATIONS - Delegated to ListManipulationHandler
    // ========================================================================

    public String addElementToList(CompilationUnit cu, String originalCode, ASTNode listNode,
                                   AddableExpression type, int insertIndex) {
        return listHandler.addElementToList(cu, originalCode, listNode, type, insertIndex);
    }

    public String deleteElementFromList(CompilationUnit cu, String originalCode,
                                        ASTNode listNode, int elementIndex) {
        return listHandler.deleteElementFromList(cu, originalCode, listNode, elementIndex);
    }

    // ========================================================================
    // METHOD OPERATIONS - Delegated to MethodManipulationHandler
    // ========================================================================

    public String addMethodToClass(CompilationUnit cu, String originalCode, TypeDeclaration typeDecl,
                                   String methodName, String returnType, int index) {
        return methodHandler.addMethodToClass(cu, originalCode, typeDecl, methodName, returnType, index);
    }

    public String deleteMethodFromClass(CompilationUnit cu, String originalCode,
                                        MethodDeclaration method) {
        return methodHandler.deleteMethodFromClass(cu, originalCode, method);
    }

    public String updateMethodInvocation(CompilationUnit cu, String originalCode, MethodInvocation mi,
                                         String newScope, String newMethodName, List<String> newParamTypes) {
        return methodHandler.updateMethodInvocation(cu, originalCode, mi, newScope, newMethodName, newParamTypes);
    }

    public String addArgumentToMethodInvocation(CompilationUnit cu, String originalCode,
                                                MethodInvocation mi, AddableExpression type) {
        return methodHandler.addArgumentToMethodInvocation(cu, originalCode, mi, type);
    }

    public String addArgumentToMethodInvocation(CompilationUnit cu, String originalCode,
                                                MethodInvocation mi, Expression newArgument) {
        return methodHandler.addArgumentToMethodInvocation(cu, originalCode, mi, newArgument);
    }

    public String renameMethodParameter(CompilationUnit cu, String originalCode,
                                        MethodDeclaration method, int index, String newName) {
        return methodHandler.renameMethodParameter(cu, originalCode, method, index, newName);
    }

    public String setMethodReturnType(CompilationUnit cu, String originalCode,
                                      MethodDeclaration method, String newTypeName) {
        return methodHandler.setMethodReturnType(cu, originalCode, method, newTypeName);
    }

    public String addParameterToMethod(CompilationUnit cu, String originalCode,
                                       MethodDeclaration method, String typeName, String paramName) {
        return methodHandler.addParameterToMethod(cu, originalCode, method, typeName, paramName);
    }

    public String deleteParameterFromMethod(CompilationUnit cu, String originalCode,
                                            MethodDeclaration method, int index) {
        return methodHandler.deleteParameterFromMethod(cu, originalCode, method, index);
    }

    public String setReturnExpression(CompilationUnit cu, String originalCode,
                                      ReturnStatement returnStmt, AddableExpression type) {
        return methodHandler.setReturnExpression(cu, originalCode, returnStmt, type);
    }

    // ========================================================================
    // ENUM OPERATIONS - Delegated to EnumManipulationHandler
    // ========================================================================

    public String addEnumToClass(CompilationUnit cu, String originalCode, TypeDeclaration typeDecl,
                                 String enumName, int index) {
        return enumHandler.addEnumToClass(cu, originalCode, typeDecl, enumName, index);
    }

    public String deleteEnumFromClass(CompilationUnit cu, String originalCode,
                                      EnumDeclaration enumDecl) {
        return enumHandler.deleteEnumFromClass(cu, originalCode, enumDecl);
    }

    public String renameEnum(CompilationUnit cu, String originalCode, EnumDeclaration enumNode,
                             String newName) {
        return enumHandler.renameEnum(cu, originalCode, enumNode, newName);
    }

    public String addEnumConstant(CompilationUnit cu, String originalCode, EnumDeclaration enumNode,
                                  String constantName) {
        return enumHandler.addEnumConstant(cu, originalCode, enumNode, constantName);
    }

    public String deleteEnumConstant(CompilationUnit cu, String originalCode,
                                     EnumDeclaration enumNode, int index) {
        return enumHandler.deleteEnumConstant(cu, originalCode, enumNode, index);
    }

    public String renameEnumConstant(CompilationUnit cu, String originalCode, EnumDeclaration enumNode,
                                     int index, String newName) {
        return enumHandler.renameEnumConstant(cu, originalCode, enumNode, index, newName);
    }

    // ========================================================================
    // VARIABLE/FIELD INITIALIZERS
    // ========================================================================

    public String setVariableInitializer(CompilationUnit cu, String originalCode,
                                         VariableDeclarationStatement varDecl, AddableExpression type) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);

        VariableDeclarationFragment fragment = (VariableDeclarationFragment) varDecl.fragments().get(0);

        String typeName = varDecl.getType().toString();
        String contextType = TypeConversionHelper.unwrapArrayListType(typeName);

        Expression newExpr = nodeCreator.createDefaultExpression(ast, type, cu, rewriter, contextType);
        if (newExpr == null) return originalCode;

        if (fragment.getInitializer() == null) {
            rewriter.set(fragment, VariableDeclarationFragment.INITIALIZER_PROPERTY, newExpr, null);
        } else {
            rewriter.replace(fragment.getInitializer(), newExpr, null);
        }

        return AstRewriteHelper.applyRewrite(rewriter, originalCode);
    }

    public String setFieldInitializer(CompilationUnit cu, String originalCode,
                                      FieldDeclaration fieldDecl, AddableExpression type) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);

        VariableDeclarationFragment fragment = (VariableDeclarationFragment) fieldDecl.fragments().get(0);

        String typeName = fieldDecl.getType().toString();
        String contextType = TypeConversionHelper.unwrapArrayListType(typeName);

        Expression newExpr = nodeCreator.createDefaultExpression(ast, type, cu, rewriter, contextType);
        if (newExpr == null) return originalCode;

        if (fragment.getInitializer() == null) {
            rewriter.set(fragment, VariableDeclarationFragment.INITIALIZER_PROPERTY, newExpr, null);
        } else {
            rewriter.replace(fragment.getInitializer(), newExpr, null);
        }

        return AstRewriteHelper.applyRewrite(rewriter, originalCode);
    }

    // ========================================================================
    // IF/ELSE OPERATIONS
    // ========================================================================

    public String convertElseToElseIf(CompilationUnit cu, String originalCode, IfStatement ifStatement) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);

        Statement elseStatement = ifStatement.getElseStatement();
        if (elseStatement != null && elseStatement.getNodeType() == ASTNode.BLOCK) {
            IfStatement newElseIf = ast.newIfStatement();
            newElseIf.setExpression(ast.newBooleanLiteral(true));
            newElseIf.setThenStatement((Block) ASTNode.copySubtree(ast, elseStatement));
            rewriter.replace(elseStatement, newElseIf, null);
        }

        return AstRewriteHelper.applyRewrite(rewriter, originalCode);
    }

    public String addElseToIfStatement(CompilationUnit cu, String originalCode, IfStatement ifStatement) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);

        if (ifStatement.getElseStatement() == null) {
            rewriter.set(ifStatement, IfStatement.ELSE_STATEMENT_PROPERTY, ast.newBlock(), null);
        }

        return AstRewriteHelper.applyRewrite(rewriter, originalCode);
    }

    public String deleteElseFromIfStatement(CompilationUnit cu, String originalCode,
                                            IfStatement ifStatement) {
        ASTRewrite rewriter = ASTRewrite.create(cu.getAST());

        if (ifStatement.getElseStatement() != null) {
            rewriter.remove(ifStatement.getElseStatement(), null);
        }

        return AstRewriteHelper.applyRewrite(rewriter, originalCode);
    }

    // ========================================================================
    // SWITCH OPERATIONS
    // ========================================================================

    public String addCaseToSwitch(CompilationUnit cu, String originalCode, SwitchStatement switchStmt) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);
        ListRewrite listRewrite = rewriter.getListRewrite(switchStmt, SwitchStatement.STATEMENTS_PROPERTY);

        SwitchCase newCase = ast.newSwitchCase();
        int count = 0;
        for (Object o : switchStmt.statements()) {
            if (o instanceof SwitchCase) count++;
        }

        try {
            newCase.expressions().add(ast.newNumberLiteral(String.valueOf(count)));
        } catch (Exception ignored) {}

        listRewrite.insertLast(newCase, null);
        listRewrite.insertLast(ast.newBreakStatement(), null);

        return AstRewriteHelper.applyRewrite(rewriter, originalCode);
    }

    public String moveSwitchCase(CompilationUnit cu, String originalCode, SwitchCase caseNode,
                                 boolean moveUp) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);
        SwitchStatement parent = (SwitchStatement) caseNode.getParent();
        List<Statement> statements = parent.statements();

        // Group statements into chunks by case
        List<List<Statement>> chunks = new ArrayList<>();
        List<Statement> currentChunk = null;

        for (Statement stmt : statements) {
            if (stmt instanceof SwitchCase) {
                if (currentChunk != null) chunks.add(currentChunk);
                currentChunk = new ArrayList<>();
            }
            if (currentChunk != null) currentChunk.add(stmt);
        }
        if (currentChunk != null) chunks.add(currentChunk);

        // Find target chunk
        int targetIndex = -1;
        for (int i = 0; i < chunks.size(); i++) {
            if (!chunks.get(i).isEmpty() && chunks.get(i).get(0) == caseNode) {
                targetIndex = i;
                break;
            }
        }

        if (targetIndex == -1) return originalCode;

        int neighborIndex = moveUp ? targetIndex - 1 : targetIndex + 1;
        if (neighborIndex < 0 || neighborIndex >= chunks.size()) return originalCode;

        List<Statement> targetChunk = chunks.get(targetIndex);
        List<Statement> neighborChunk = chunks.get(neighborIndex);

        ListRewrite listRewrite = rewriter.getListRewrite(parent, SwitchStatement.STATEMENTS_PROPERTY);

        if (moveUp) {
            ASTNode insertPoint = neighborChunk.get(0);
            for (Statement stmt : targetChunk) {
                ASTNode moveTarget = rewriter.createMoveTarget(stmt);
                listRewrite.insertBefore(moveTarget, insertPoint, null);
            }
        } else {
            ASTNode insertPoint = targetChunk.get(0);
            for (Statement stmt : neighborChunk) {
                ASTNode moveTarget = rewriter.createMoveTarget(stmt);
                listRewrite.insertBefore(moveTarget, insertPoint, null);
            }
        }

        return AstRewriteHelper.applyRewrite(rewriter, originalCode);
    }

    // ========================================================================
    // COMMENT OPERATIONS
    // ========================================================================

    public String updateComment(String originalCode, Comment commentNode, String newText) {
        try {
            IDocument document = new Document(originalCode);
            String replacement = newText.contains("\n") ? "/* " + newText + " */" : "// " + newText;
            document.replace(commentNode.getStartPosition(), commentNode.getLength(), replacement);
            return document.get();
        } catch (Exception e) {
            return originalCode;
        }
    }

    public String deleteComment(String originalCode, Comment commentNode) {
        try {
            IDocument document = new Document(originalCode);
            document.replace(commentNode.getStartPosition(), commentNode.getLength(), "");
            return document.get();
        } catch (Exception e) {
            return originalCode;
        }
    }

    // ========================================================================
    // PRIVATE HELPER METHODS
    // ========================================================================

    private ListRewrite getListRewriteForBody(ASTRewrite rewriter, BodyBlock body) {
        ASTNode node = body.getAstNode();
        if (node instanceof Block) {
            return rewriter.getListRewrite(node, Block.STATEMENTS_PROPERTY);
        } else if (node instanceof SwitchCase) {
            return rewriter.getListRewrite(node.getParent(), SwitchStatement.STATEMENTS_PROPERTY);
        }
        throw new IllegalArgumentException("Unsupported body node type: " + node.getClass());
    }

    private void insertIntoList(ListRewrite listRewrite, BodyBlock body, Statement newStatement,
                                int relativeIndex) {
        ASTNode node = body.getAstNode();
        if (node instanceof Block) {
            listRewrite.insertAt(newStatement, relativeIndex, null);
        } else if (node instanceof SwitchCase) {
            SwitchCase caseNode = (SwitchCase) node;
            SwitchStatement parent = (SwitchStatement) caseNode.getParent();
            List<?> allStatements = parent.statements();
            int caseIndex = allStatements.indexOf(caseNode);
            int absoluteIndex = caseIndex + 1 + relativeIndex;
            listRewrite.insertAt(newStatement, absoluteIndex, null);
        }
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\parser\BlockFactory.java
=================================================================================

package com.botmaker.parser;

import com.botmaker.blocks.*;
import com.botmaker.core.*;
import com.botmaker.ui.BlockDragAndDropManager;
import com.botmaker.parser.BlockIdPrefix;
import org.eclipse.jdt.core.JavaCore;
import org.eclipse.jdt.core.dom.*;

import java.util.*;

public class BlockFactory {

    private CompilationUnit ast;
    private String currentSourceCode;
    private List<Comment> allComments;
    private boolean markNewIdentifiersAsUnedited = false;
    private BlockParser blockParser;


    public AbstractCodeBlock convert(String javaCode, Map<ASTNode, CodeBlock> nodeToBlockMap, BlockDragAndDropManager manager) {
        this.currentSourceCode = javaCode;
        // Initialize parser used for method bodies
        this.blockParser = new BlockParser(this, manager, markNewIdentifiersAsUnedited);

        try {
            // 1. Setup AST Parser
            ASTParser parser = ASTParser.newParser(AST.JLS17);
            parser.setSource(javaCode.toCharArray());
            parser.setKind(ASTParser.K_COMPILATION_UNIT);
            parser.setResolveBindings(true);
            parser.setUnitName("Unit.java");
            parser.setEnvironment(null, null, null, true);

            Map<String, String> options = JavaCore.getOptions();
            options.put(JavaCore.COMPILER_COMPLIANCE, JavaCore.latestSupportedJavaVersion()); // or VERSION_11, VERSION_1_8, etc.
            options.put(JavaCore.COMPILER_CODEGEN_TARGET_PLATFORM, JavaCore.latestSupportedJavaVersion());
            options.put(JavaCore.COMPILER_SOURCE, JavaCore.latestSupportedJavaVersion());
            parser.setCompilerOptions(options);

            this.ast = (CompilationUnit) parser.createAST(null);

            // 2. Extract Comments
            this.allComments = new ArrayList<>();
            for (Object obj : ast.getCommentList()) {
                if (obj instanceof Comment && !(obj instanceof Javadoc)) allComments.add((Comment) obj);
            }

            if (ast.types().isEmpty()) return null;

            // Get the root declaration (can be TypeDeclaration OR EnumDeclaration)
            AbstractTypeDeclaration rootNode = (AbstractTypeDeclaration) ast.types().get(0);

            // --- CASE A: Standard Class File ---
            if (rootNode instanceof TypeDeclaration) {
                TypeDeclaration typeDecl = (TypeDeclaration) rootNode;

                ClassBlock classBlock = new ClassBlock(
                        BlockIdPrefix.generate(BlockIdPrefix.CLASS, typeDecl),
                        typeDecl,
                        manager
                );
                nodeToBlockMap.put(typeDecl, classBlock);

                // Iterate over ALL body declarations (Methods AND Inner Enums)
                for (Object obj : typeDecl.bodyDeclarations()) {

                    // 1. Handle Methods
                    if (obj instanceof MethodDeclaration) {
                        MethodDeclaration method = (MethodDeclaration) obj;
                        MethodDeclarationBlock methodBlock;

                        if (isMainMethod(method)) {
                            methodBlock = new MainBlock(
                                    BlockIdPrefix.generate(BlockIdPrefix.METHOD, method),
                                    method,
                                    manager
                            );
                        } else {
                            methodBlock = new MethodDeclarationBlock(
                                    BlockIdPrefix.generate(BlockIdPrefix.METHOD, method),
                                    method,
                                    manager
                            );
                        }

                        nodeToBlockMap.put(method, methodBlock);

                        // Recursively parse the method body using BlockParser
                        if (method.getBody() != null) {
                            methodBlock.setBody(parseBodyBlock(method.getBody(), nodeToBlockMap, manager));
                        }

                        classBlock.addBodyDeclaration(methodBlock);
                    }

                    // 2. Handle Inner Enums (e.g. inside a class)
                    else if (obj instanceof EnumDeclaration) {
                        EnumDeclaration enumDecl = (EnumDeclaration) obj;

                        // FIX: Use the constructor that takes EnumDeclaration directly (not TypeDeclarationStatement)
                        DeclareEnumBlock enumBlock = new DeclareEnumBlock(
                                BlockIdPrefix.generate(BlockIdPrefix.ENUM, enumDecl),
                                enumDecl  // ← This is the correct constructor for class-level enums
                        );

                        nodeToBlockMap.put(enumDecl, enumBlock);
                        classBlock.addBodyDeclaration(enumBlock);
                    }
                    // 3. Handle Field Declarations
                    else if (obj instanceof FieldDeclaration) {
                        FieldDeclaration field = (FieldDeclaration) obj;
                        DeclareClassVariableBlock fieldBlock = new DeclareClassVariableBlock(
                                BlockIdPrefix.generate(BlockIdPrefix.FIELD_ACCESS, field),
                                field
                        );
                        nodeToBlockMap.put(field, fieldBlock);

                        // Parse initializer if present
                        VariableDeclarationFragment fragment = (VariableDeclarationFragment) field.fragments().get(0);
                        if (fragment.getInitializer() != null) {
                            parseExpression(fragment.getInitializer(), nodeToBlockMap).ifPresent(fieldBlock::setInitializer);
                        }

                        classBlock.addBodyDeclaration(fieldBlock);
                    }
                }

                return classBlock;
            }

            // --- CASE B: Standalone Enum File ---
            else if (rootNode instanceof EnumDeclaration) {
                EnumDeclaration enumDecl = (EnumDeclaration) rootNode;

                // Create the EnumBlock as the root element
                DeclareEnumBlock rootEnumBlock = new DeclareEnumBlock(
                        BlockIdPrefix.generate(BlockIdPrefix.ENUM, enumDecl),
                        enumDecl
                );
                nodeToBlockMap.put(enumDecl, rootEnumBlock);

                return rootEnumBlock;
            }

            return null;

        } catch (Exception e) {
            System.err.println("Critical error in BlockFactory.convert: " + e.getMessage());
            e.printStackTrace();
            return null;
        } finally {
            setMarkNewIdentifiersAsUnedited(false);
        }
    }

    private boolean isMainMethod(MethodDeclaration method) {
        if (!"main".equals(method.getName().getIdentifier())) return false;
        if (!Modifier.isStatic(method.getModifiers())) return false;
        if (!Modifier.isPublic(method.getModifiers())) return false;
        if (method.parameters().size() != 1) return false;
        return true;
    }

    private MethodDeclaration findMainMethod(TypeDeclaration type) {
        for (MethodDeclaration method : type.getMethods()) {
            if ("main".equals(method.getName().getIdentifier()) &&
                    Modifier.isStatic(method.getModifiers()) &&
                    method.parameters().size() == 1) { // Simplified check
                return method;
            }
        }
        return null;
    }

    public void setMarkNewIdentifiersAsUnedited(boolean mark) { this.markNewIdentifiersAsUnedited = mark; }
    public BodyBlock parseBodyBlock(Block astBlock, Map<ASTNode, CodeBlock> nodeToBlockMap, BlockDragAndDropManager manager) {
        BodyBlock bodyBlock = new BodyBlock(BlockIdPrefix.generate(BlockIdPrefix.BODY, astBlock), astBlock, manager);
        nodeToBlockMap.put(astBlock, bodyBlock);

        List<CodeBlock> allChildren = new ArrayList<>();
        for (Object statementObj : astBlock.statements()) {
            blockParser.parseStatement((Statement) statementObj, nodeToBlockMap).ifPresent(allChildren::add);
        }
        // [Comment handling logic...]
        int blockStart = astBlock.getStartPosition() + 1;
        int blockEnd = astBlock.getStartPosition() + astBlock.getLength() - 1;

        for (Comment comment : allComments) {
            int cPos = comment.getStartPosition();
            if (cPos > blockStart && cPos < blockEnd) {
                boolean isInsideChild = false;
                for (Object stmtObj : astBlock.statements()) {
                    Statement s = (Statement) stmtObj;
                    if (cPos >= s.getStartPosition() && cPos <= s.getStartPosition() + s.getLength()) {
                        isInsideChild = true;
                        break;
                    }
                }
                if (!isInsideChild) {
                    allChildren.add(parseCommentBlock(comment, nodeToBlockMap));
                }
            }
        }

        allChildren.sort(Comparator.comparingInt(b -> b.getAstNode().getStartPosition()));
        for (CodeBlock cb : allChildren) {
            if (cb instanceof StatementBlock) bodyBlock.addStatement((StatementBlock) cb);
        }
        return bodyBlock;
    }


    public Optional<StatementBlock> parseStatement(Statement stmt, Map<ASTNode, CodeBlock> map, BlockDragAndDropManager manager) {
        return blockParser.parseStatement(stmt, map);
    }

    public Optional<ExpressionBlock> parseExpression(Expression expr, Map<ASTNode, CodeBlock> map) {
        // --- NEW: Handle ArrayCreation (new int[] {...}) ---
        if (expr instanceof ArrayCreation) {
            ArrayCreation ac = (ArrayCreation) expr;
            if (ac.getInitializer() != null) {
                // Recursively parse the inner ArrayInitializer
                Optional<ExpressionBlock> innerBlock = parseExpression(ac.getInitializer(), map);

                // IMPORTANT: Map the ArrayCreation node to the same block as the initializer.
                // This ensures that when a VariableDeclarationFragment asks for the block corresponding
                // to its initializer (which is the ArrayCreation node), it gets the correct ListBlock.
                if (innerBlock.isPresent()) {
                    map.put(expr, innerBlock.get());
                }
                return innerBlock;
            }
        }

        return blockParser.parseExpression(expr, map);
    }

    private CommentBlock parseCommentBlock(Comment astNode, Map<ASTNode, CodeBlock> nodeToBlockMap) {
        String text = "Comment";
        if (currentSourceCode != null) {
            try {
                String raw = currentSourceCode.substring(astNode.getStartPosition(), astNode.getStartPosition() + astNode.getLength());
                text = astNode.isLineComment() ? raw.substring(2).trim() : raw.substring(2, raw.length() - 2).trim();
            } catch (Exception ignored) {}
        }
        CommentBlock commentBlock = new CommentBlock(BlockIdPrefix.generate(BlockIdPrefix.COMMENT, astNode), astNode, text);
        nodeToBlockMap.put(astNode, commentBlock);
        return commentBlock;
    }

    public boolean isPrintStatement(Expression expression) {
        if (!(expression instanceof MethodInvocation)) return false;
        MethodInvocation method = (MethodInvocation) expression;
        if (!method.getName().getIdentifier().equals("println")) return false;
        return method.getExpression() != null && "System.out".equals(method.getExpression().toString());
    }

    public boolean isReadInputStatement(VariableDeclarationStatement varDecl) {
        if (varDecl.fragments().isEmpty()) return false;
        VariableDeclarationFragment fragment = (VariableDeclarationFragment) varDecl.fragments().get(0);
        if (!(fragment.getInitializer() instanceof MethodInvocation)) return false;
        MethodInvocation mi = (MethodInvocation) fragment.getInitializer();
        return mi.getExpression() instanceof SimpleName &&
                ((SimpleName) mi.getExpression()).getIdentifier().equals("scanner");
    }

    public CompilationUnit getCompilationUnit() { return ast; }

    // Helper used by BlockParser
    public boolean isListStructure(Expression expr) {
        if (expr instanceof ArrayInitializer) return true;
        if (expr instanceof ArrayCreation) return true; // Added
        if (expr instanceof ClassInstanceCreation) {
            ClassInstanceCreation cic = (ClassInstanceCreation) expr;
            String typeName = cic.getType().toString();
            return (typeName.startsWith("ArrayList") || typeName.startsWith("java.util.ArrayList")) && !cic.arguments().isEmpty();
        }
        if (expr instanceof MethodInvocation) {
            MethodInvocation mi = (MethodInvocation) expr;
            String scope = mi.getExpression() != null ? mi.getExpression().toString() : "";
            return (scope.equals("Arrays") && mi.getName().getIdentifier().equals("asList")) ||
                    (scope.equals("List") && mi.getName().getIdentifier().equals("of"));
        }
        return false;
    }

    @SuppressWarnings("unchecked")
    public List<Expression> getListItems(Expression expr) {
        if (expr instanceof ArrayInitializer) return ((ArrayInitializer) expr).expressions();
        if (expr instanceof ArrayCreation) { // Added
            ArrayCreation ac = (ArrayCreation) expr;
            return ac.getInitializer() != null ? ac.getInitializer().expressions() : Collections.emptyList();
        }
        if (expr instanceof ClassInstanceCreation) {
            ClassInstanceCreation cic = (ClassInstanceCreation) expr;
            if (!cic.arguments().isEmpty()) {
                Expression arg = (Expression) cic.arguments().get(0);
                return getListItems(arg);
            }
        }
        if (expr instanceof MethodInvocation) return ((MethodInvocation) expr).arguments();
        return List.of();
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\parser\BlockIdPrefix.java
=================================================================================

package com.botmaker.parser;

/**
 * Constants for block ID prefixes
 */
public class BlockIdPrefix {
    public static final String MAIN = "main_";
    public static final String BODY = "body_";
    public static final String VARIABLE = "var_";
    public static final String IF = "if_";
    public static final String WHILE = "while_";
    public static final String FOR = "for_";
    public static final String BREAK = "break_";
    public static final String CONTINUE = "continue_";
    public static final String ASSIGNMENT = "assign_";
    public static final String INCREMENT = "inc_";
    public static final String DECREMENT = "dec_";
    public static final String READ_INPUT = "read_";
    public static final String PRINT = "print_";
    public static final String BINARY = "binary_";
    public static final String STRING = "string_";
    public static final String NUMBER_FLOAT = "float_";
    public static final String NUMBER_DOUBLE = "double_";
    public static final String NUMBER_INT = "int_";
    public static final String BOOLEAN = "boolean_";
    public static final String IDENTIFIER = "id_";
    public static final String SYNTHETIC_STRING = "synthetic_string_";
    public static final String DO_WHILE = "do_while_";
    public static final String SWITCH = "switch_";
    public static final String RETURN = "return_";
    public static final String COMMENT = "comment_";
    public static final String WAIT = "wait_";
    public static final String LIST = "list_";
    // In BlockIdPrefix.java
    public static final String CLASS = "class_";
    public static final String METHOD = "method_";
    public static final String ENUM = "enum_";
    public static final String ENUM_CONSTANT = "enum_const_";
    public static final String FIELD_ACCESS = "field_access_";


    private BlockIdPrefix() {} // Prevent instantiation

    /**
     * Generate ID with prefix and hash
     */
    public static String generate(String prefix, Object node) {
        return prefix + node.hashCode();
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\parser\BlockParser.java
=================================================================================

// FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\parser\BlockParser.java
package com.botmaker.parser;

import com.botmaker.blocks.*;
import com.botmaker.core.BodyBlock;
import com.botmaker.core.CodeBlock;
import com.botmaker.core.ExpressionBlock;
import com.botmaker.core.StatementBlock;
import com.botmaker.ui.BlockDragAndDropManager;
import org.eclipse.jdt.core.dom.*;

import java.util.List;
import java.util.Map;
import java.util.Optional;

public class BlockParser {

    private final BlockFactory factory;
    private final BlockDragAndDropManager manager;
    private final boolean markNewIdentifiersAsUnedited;

    public BlockParser(BlockFactory factory, BlockDragAndDropManager manager, boolean markNewIdentifiersAsUnedited) {
        this.factory = factory;
        this.manager = manager;
        this.markNewIdentifiersAsUnedited = markNewIdentifiersAsUnedited;
    }

    // ... (Existing parseStatement and other methods remain unchanged) ...
    public Optional<StatementBlock> parseStatement(Statement stmt, Map<ASTNode, CodeBlock> map) {
        try {
            if (stmt instanceof Block) return Optional.of(factory.parseBodyBlock((Block) stmt, map, manager));
            if (stmt instanceof TypeDeclarationStatement) return parseTypeDeclaration((TypeDeclarationStatement) stmt, map);
            if (stmt instanceof VariableDeclarationStatement) return parseVariableDecl((VariableDeclarationStatement) stmt, map);
            if (stmt instanceof IfStatement) return parseIf((IfStatement) stmt, map);
            if (stmt instanceof WhileStatement) return parseWhile((WhileStatement) stmt, map);
            if (stmt instanceof EnhancedForStatement) return parseFor((EnhancedForStatement) stmt, map);
            if (stmt instanceof DoStatement) return parseDoWhile((DoStatement) stmt, map);
            if (stmt instanceof SwitchStatement) return parseSwitch((SwitchStatement) stmt, map);
            if (stmt instanceof BreakStatement) return Optional.of(new BreakBlock(BlockIdPrefix.generate(BlockIdPrefix.BREAK, stmt), (BreakStatement) stmt));
            if (stmt instanceof ContinueStatement) return Optional.of(new ContinueBlock(BlockIdPrefix.generate(BlockIdPrefix.CONTINUE, stmt), (ContinueStatement) stmt));
            if (stmt instanceof ReturnStatement) return parseReturn((ReturnStatement) stmt, map);
            if (stmt instanceof TryStatement) return parseTry((TryStatement) stmt, map);
            if (stmt instanceof ExpressionStatement) return parseExprStmt((ExpressionStatement) stmt, map);
        } catch (Exception e) {
            System.err.println("Error parsing statement: " + stmt);
            e.printStackTrace();
        }
        return Optional.empty();
    }

    // ... (Keep existing private helper methods: parseReturn, parseTypeDeclaration, etc.) ...

    // Copy all the private parse* methods from the original file here to ensure they aren't lost.
    // For brevity in this response, I assume they exist.
    // ...
    private Optional<StatementBlock> parseReturn(ReturnStatement stmt, Map<ASTNode, CodeBlock> map) {
        ReturnBlock block = new ReturnBlock(BlockIdPrefix.generate(BlockIdPrefix.RETURN, stmt), stmt);
        map.put(stmt, block);
        if (stmt.getExpression() != null) {
            factory.parseExpression(stmt.getExpression(), map).ifPresent(block::setExpression);
        }
        return Optional.of(block);
    }

    private Optional<StatementBlock> parseTypeDeclaration(TypeDeclarationStatement stmt, Map<ASTNode, CodeBlock> map) {
        if (stmt.getDeclaration() instanceof EnumDeclaration) {
            EnumDeclaration enumDecl = (EnumDeclaration) stmt.getDeclaration();
            DeclareEnumBlock block = new DeclareEnumBlock(BlockIdPrefix.generate(BlockIdPrefix.ENUM, stmt), stmt);
            map.put(stmt, block);
            map.put(enumDecl, block);
            return Optional.of(block);
        }
        return Optional.empty();
    }

    private Optional<StatementBlock> parseExprStmt(ExpressionStatement stmt, Map<ASTNode, CodeBlock> map) {
        Expression expr = stmt.getExpression();
        if (factory.isPrintStatement(expr)) return parsePrint(stmt, map);
        if (expr instanceof Assignment) return parseAssignment(stmt, map);
        if (expr instanceof PostfixExpression || expr instanceof PrefixExpression) {
            AssignmentBlock block = new AssignmentBlock(BlockIdPrefix.generate(BlockIdPrefix.ASSIGNMENT, stmt), stmt);
            map.put(stmt, block);
            if (expr instanceof PostfixExpression) factory.parseExpression(((PostfixExpression) expr).getOperand(), map).ifPresent(block::setLeftHandSide);
            if (expr instanceof PrefixExpression) factory.parseExpression(((PrefixExpression) expr).getOperand(), map).ifPresent(block::setLeftHandSide);
            return Optional.of(block);
        }
        if (expr instanceof MethodInvocation) {
            MethodInvocationBlock block = new MethodInvocationBlock(BlockIdPrefix.generate("call_", stmt), stmt);
            map.put(stmt, block);
            MethodInvocation mi = (MethodInvocation) expr;
            for (Object arg : mi.arguments()) {
                factory.parseExpression((Expression) arg, map).ifPresent(block::addArgument);
            }
            return Optional.of(block);
        }
        return Optional.empty();
    }

    private Optional<StatementBlock> parseVariableDecl(VariableDeclarationStatement stmt, Map<ASTNode, CodeBlock> map) {
        if (factory.isReadInputStatement(stmt)) {
            VariableDeclarationFragment frag = (VariableDeclarationFragment) stmt.fragments().get(0);
            MethodInvocation mi = (MethodInvocation) frag.getInitializer();
            ReadInputBlock block = new ReadInputBlock(BlockIdPrefix.generate(BlockIdPrefix.READ_INPUT, stmt), stmt, mi.getName().getIdentifier());
            map.put(stmt, block);
            factory.parseExpression(frag.getName(), map).ifPresent(block::setVariableName);
            return Optional.of(block);
        } else {
            VariableDeclarationBlock block = new VariableDeclarationBlock(BlockIdPrefix.generate(BlockIdPrefix.VARIABLE, stmt), stmt);
            map.put(stmt, block);
            VariableDeclarationFragment frag = (VariableDeclarationFragment) stmt.fragments().get(0);
            if (frag.getInitializer() != null) {
                factory.parseExpression(frag.getInitializer(), map).ifPresent(block::setInitializer);
            }
            return Optional.of(block);
        }
    }

    private Optional<StatementBlock> parseIf(IfStatement stmt, Map<ASTNode, CodeBlock> map) {
        IfBlock block = new IfBlock(BlockIdPrefix.generate(BlockIdPrefix.IF, stmt), stmt);
        map.put(stmt, block);
        factory.parseExpression(stmt.getExpression(), map).ifPresent(block::setCondition);
        if (stmt.getThenStatement() instanceof Block) {
            block.setThenBody(factory.parseBodyBlock((Block) stmt.getThenStatement(), map, manager));
        }
        if (stmt.getElseStatement() != null) {
            factory.parseStatement(stmt.getElseStatement(), map, manager).ifPresent(block::setElseStatement);
        }
        return Optional.of(block);
    }

    private Optional<StatementBlock> parseWhile(WhileStatement stmt, Map<ASTNode, CodeBlock> map) {
        WhileBlock block = new WhileBlock(BlockIdPrefix.generate(BlockIdPrefix.WHILE, stmt), stmt, manager);
        map.put(stmt, block);
        factory.parseExpression(stmt.getExpression(), map).ifPresent(block::setCondition);
        if (stmt.getBody() instanceof Block) block.setBody(factory.parseBodyBlock((Block) stmt.getBody(), map, manager));
        return Optional.of(block);
    }

    private Optional<StatementBlock> parseFor(EnhancedForStatement stmt, Map<ASTNode, CodeBlock> map) {
        ForBlock block = new ForBlock(BlockIdPrefix.generate(BlockIdPrefix.FOR, stmt), stmt, manager);
        map.put(stmt, block);
        if (stmt.getParameter() != null) factory.parseExpression(stmt.getParameter().getName(), map).ifPresent(block::setVariable);
        if (stmt.getExpression() != null) factory.parseExpression(stmt.getExpression(), map).ifPresent(block::setCollection);
        if (stmt.getBody() instanceof Block) block.setBody(factory.parseBodyBlock((Block) stmt.getBody(), map, manager));
        return Optional.of(block);
    }

    private Optional<StatementBlock> parseDoWhile(DoStatement stmt, Map<ASTNode, CodeBlock> map) {
        DoWhileBlock block = new DoWhileBlock(BlockIdPrefix.generate(BlockIdPrefix.DO_WHILE, stmt), stmt, manager);
        map.put(stmt, block);
        factory.parseExpression(stmt.getExpression(), map).ifPresent(block::setCondition);
        if (stmt.getBody() instanceof Block) block.setBody(factory.parseBodyBlock((Block) stmt.getBody(), map, manager));
        return Optional.of(block);
    }

    private Optional<StatementBlock> parseSwitch(SwitchStatement stmt, Map<ASTNode, CodeBlock> map) {
        SwitchBlock block = new SwitchBlock(BlockIdPrefix.generate(BlockIdPrefix.SWITCH, stmt), stmt, manager);
        map.put(stmt, block);
        if (stmt.getExpression() != null) factory.parseExpression(stmt.getExpression(), map).ifPresent(block::setExpression);

        BodyBlock currentBody = null;
        SwitchBlock.SwitchCaseBlock currentCase = null;

        for (Object obj : stmt.statements()) {
            Statement s = (Statement) obj;
            if (s instanceof SwitchCase) {
                SwitchCase sc = (SwitchCase) s;
                currentCase = new SwitchBlock.SwitchCaseBlock(BlockIdPrefix.generate(BlockIdPrefix.SWITCH + "_case_", sc), sc);
                map.put(sc, currentCase);
                if (!sc.isDefault() && !sc.expressions().isEmpty()) {
                    factory.parseExpression((Expression) sc.expressions().getFirst(), map).ifPresent(currentCase::setCaseExpression);
                }
                currentBody = new BodyBlock(BlockIdPrefix.generate(BlockIdPrefix.BODY, sc), sc, manager);
                currentCase.setBody(currentBody);
                block.addCase(currentCase);
            } else if (currentBody != null) {
                factory.parseStatement(s, map, manager).ifPresent(currentBody::addStatement);
            }
        }
        return Optional.of(block);
    }

    private Optional<StatementBlock> parsePrint(ExpressionStatement stmt, Map<ASTNode, CodeBlock> map) {
        PrintBlock block = new PrintBlock(BlockIdPrefix.generate(BlockIdPrefix.PRINT, stmt), stmt);
        map.put(stmt, block);
        MethodInvocation mi = (MethodInvocation) stmt.getExpression();
        if (mi.arguments().isEmpty()) {
            block.addArgument(new LiteralBlock<>(BlockIdPrefix.generate(BlockIdPrefix.SYNTHETIC_STRING, stmt), mi, ""));
        } else {
            for (Object arg : mi.arguments()) factory.parseExpression((Expression) arg, map).ifPresent(block::addArgument);
        }
        return Optional.of(block);
    }

    private Optional<StatementBlock> parseAssignment(ExpressionStatement stmt, Map<ASTNode, CodeBlock> map) {
        AssignmentBlock block = new AssignmentBlock(BlockIdPrefix.generate(BlockIdPrefix.ASSIGNMENT, stmt), stmt);
        map.put(stmt, block);
        Assignment a = (Assignment) stmt.getExpression();
        factory.parseExpression(a.getLeftHandSide(), map).ifPresent(block::setLeftHandSide);
        factory.parseExpression(a.getRightHandSide(), map).ifPresent(block::setRightHandSide);
        return Optional.of(block);
    }

    private Optional<StatementBlock> parseTry(TryStatement stmt, Map<ASTNode, CodeBlock> map) {
        if (isWait(stmt)) {
            WaitBlock block = new WaitBlock(BlockIdPrefix.generate(BlockIdPrefix.WAIT, stmt), stmt);
            map.put(stmt, block);
            Statement inner = (Statement) stmt.getBody().statements().getFirst();
            MethodInvocation mi = (MethodInvocation) ((ExpressionStatement) inner).getExpression();
            if (!mi.arguments().isEmpty()) factory.parseExpression((Expression) mi.arguments().getFirst(), map).ifPresent(block::setDuration);
            return Optional.of(block);
        }
        return Optional.empty();
    }

    private boolean isWait(TryStatement stmt) {
        if (stmt.getBody().statements().size() != 1) return false;
        Statement first = (Statement) stmt.getBody().statements().get(0);
        if (!(first instanceof ExpressionStatement)) return false;
        Expression e = ((ExpressionStatement) first).getExpression();
        return e instanceof MethodInvocation && "sleep".equals(((MethodInvocation) e).getName().getIdentifier()) && "Thread".equals(((MethodInvocation) e).getExpression().toString());
    }

    public Optional<ExpressionBlock> parseExpression(Expression expr, Map<ASTNode, CodeBlock> map) {
        if (expr instanceof StringLiteral) {
            LiteralBlock<String> b = new LiteralBlock<>(BlockIdPrefix.generate(BlockIdPrefix.STRING, expr), expr, ((StringLiteral) expr).getLiteralValue());
            map.put(expr, b);
            return Optional.of(b);
        }

        if (expr instanceof ArrayInitializer) {
            ArrayInitializer arrayInit = (ArrayInitializer) expr;
            ListBlock block = new ListBlock(BlockIdPrefix.generate(BlockIdPrefix.LIST, expr), arrayInit);
            map.put(expr, block);
            for (Object item : arrayInit.expressions()) {
                parseExpression((Expression) item, map).ifPresent(block::addElement);
            }
            return Optional.of(block);
        }
        if (expr instanceof PrefixExpression) {
            PrefixExpression prefix = (PrefixExpression) expr;
            if (prefix.getOperator() == PrefixExpression.Operator.NOT) {
                NotOperatorBlock b = new NotOperatorBlock(BlockIdPrefix.generate("not_", expr), prefix);
                map.put(expr, b);
                factory.parseExpression(prefix.getOperand(), map).ifPresent(b::setOperand);
                return Optional.of(b);
            }
        }
        if (factory.isListStructure(expr)) {
            ListBlock b = new ListBlock(BlockIdPrefix.generate(BlockIdPrefix.LIST, expr), expr);
            map.put(expr, b);
            List<Expression> items = factory.getListItems(expr);
            for (Expression item : items) factory.parseExpression(item, map).ifPresent(b::addElement);
            return Optional.of(b);
        }
        if (expr instanceof FieldAccess) {
            FieldAccess fa = (FieldAccess) expr;
            FieldAccessBlock b = new FieldAccessBlock(BlockIdPrefix.generate(BlockIdPrefix.FIELD_ACCESS, expr), fa, markNewIdentifiersAsUnedited);
            map.put(expr, b);
            return Optional.of(b);
        }
        if (expr instanceof QualifiedName) {
            QualifiedName qn = (QualifiedName) expr;
            if (isEnumConstantReference(qn)) {
                EnumConstantBlock b = new EnumConstantBlock(BlockIdPrefix.generate(BlockIdPrefix.ENUM_CONSTANT, expr), qn);
                map.put(expr, b);
                return Optional.of(b);
            } else if (isFieldAccessReference(qn)) {
                FieldAccessBlock b = new FieldAccessBlock(BlockIdPrefix.generate(BlockIdPrefix.FIELD_ACCESS, expr), qn, markNewIdentifiersAsUnedited);
                map.put(expr, b);
                return Optional.of(b);
            }
        }
        if (expr instanceof MethodInvocation) {
            MethodInvocation mi = (MethodInvocation) expr;
            MethodInvocationBlock block = new MethodInvocationBlock(BlockIdPrefix.generate("call_expr_", expr), expr);
            map.put(expr, block);
            for (Object arg : mi.arguments()) {
                factory.parseExpression((Expression) arg, map).ifPresent(block::addArgument);
            }
            return Optional.of(block);
        }
        if (expr instanceof NumberLiteral) {
            String t = ((NumberLiteral) expr).getToken();
            ExpressionBlock b;
            if (t.toLowerCase().endsWith("f")) b = new LiteralBlock<>(BlockIdPrefix.generate(BlockIdPrefix.NUMBER_FLOAT, expr), expr, Float.parseFloat(t));
            else if (t.contains(".") || t.toLowerCase().endsWith("d")) b = new LiteralBlock<>(BlockIdPrefix.generate(BlockIdPrefix.NUMBER_DOUBLE, expr), expr, Double.parseDouble(t));
            else b = new LiteralBlock<>(BlockIdPrefix.generate(BlockIdPrefix.NUMBER_INT, expr), expr, Integer.parseInt(t));
            map.put(expr, b);
            return Optional.of(b);
        }
        if (expr instanceof BooleanLiteral) {
            BooleanLiteralBlock b = new BooleanLiteralBlock(BlockIdPrefix.generate(BlockIdPrefix.BOOLEAN, expr), (BooleanLiteral) expr);
            map.put(expr, b);
            return Optional.of(b);
        }
        if (expr instanceof SimpleName) {
            if (expr.getParent() instanceof Type) return Optional.empty();
            IdentifierBlock b = new IdentifierBlock(BlockIdPrefix.generate(BlockIdPrefix.IDENTIFIER, expr), (SimpleName) expr, markNewIdentifiersAsUnedited);
            map.put(expr, b);
            return Optional.of(b);
        }

        // --- MODIFIED SECTION: Handling Comparison/Logic Operators ---
        if (expr instanceof InfixExpression) {
            InfixExpression infix = (InfixExpression) expr;
            InfixExpression.Operator op = infix.getOperator();

            // Check if it is a comparison or logic operator
            if (isComparisonOperator(op)) {
                ComparisonExpressionBlock b = new ComparisonExpressionBlock(
                        BlockIdPrefix.generate(BlockIdPrefix.BINARY, expr),
                        infix
                );
                map.put(expr, b);
                factory.parseExpression(infix.getLeftOperand(), map).ifPresent(b::setLeftOperand);
                factory.parseExpression(infix.getRightOperand(), map).ifPresent(b::setRightOperand);
                return Optional.of(b);
            }
            // Default to Math (BinaryExpressionBlock)
            else {
                BinaryExpressionBlock b = new BinaryExpressionBlock(
                        BlockIdPrefix.generate(BlockIdPrefix.BINARY, expr),
                        infix
                );
                map.put(expr, b);
                factory.parseExpression(infix.getLeftOperand(), map).ifPresent(b::setLeftOperand);
                factory.parseExpression(infix.getRightOperand(), map).ifPresent(b::setRightOperand);
                return Optional.of(b);
            }
        }
        return Optional.empty();
    }

    private boolean isComparisonOperator(InfixExpression.Operator op) {
        return op == InfixExpression.Operator.EQUALS ||
                op == InfixExpression.Operator.NOT_EQUALS ||
                op == InfixExpression.Operator.LESS ||
                op == InfixExpression.Operator.GREATER ||
                op == InfixExpression.Operator.LESS_EQUALS ||
                op == InfixExpression.Operator.GREATER_EQUALS ||
                op == InfixExpression.Operator.CONDITIONAL_AND ||
                op == InfixExpression.Operator.CONDITIONAL_OR;
    }

    // Helper methods for validation
    private boolean isEnumConstantReference(QualifiedName qn) {
        Name qualifier = qn.getQualifier();
        if (qualifier instanceof SimpleName) {
            String constantName = qn.getName().getIdentifier();
            return constantName.equals(constantName.toUpperCase());
        }
        return false;
    }

    private boolean isFieldAccessReference(QualifiedName qn) {
        Name qualifier = qn.getQualifier();
        if (qualifier instanceof SimpleName) {
            String qualifierName = ((SimpleName) qualifier).getIdentifier();
            if (qualifierName.equals("this") || qualifierName.equals("super")) {
                return true;
            }
            if (Character.isLowerCase(qualifierName.charAt(0))) {
                return true;
            }
        }
        return false;
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\parser\CodeEditor.java
=================================================================================

package com.botmaker.parser;

import com.botmaker.state.*;
import com.botmaker.core.BodyBlock;
import com.botmaker.core.StatementBlock;
import com.botmaker.events.CoreApplicationEvents;
import com.botmaker.events.EventBus;
import com.botmaker.ui.AddableBlock;
import com.botmaker.ui.AddableExpression;
import com.botmaker.util.TypeInfo;
import org.eclipse.jdt.core.dom.*;
import org.eclipse.jdt.core.dom.rewrite.ASTRewrite;

import java.util.List;

public class CodeEditor {

    private final ApplicationState state;
    private final EventBus eventBus;
    private final AstRewriter astRewriter;
    private final BlockFactory blockFactory;

    public CodeEditor(ApplicationState state, EventBus eventBus,
                      AstRewriter astRewriter, BlockFactory blockFactory) {
        this.state = state;
        this.eventBus = eventBus;
        this.astRewriter = astRewriter;
        this.blockFactory = blockFactory;
    }

    private String getCurrentCode() { return state.getCurrentCode(); }
    private CompilationUnit getCompilationUnit() { return state.getCompilationUnit().orElse(null); }

    private void triggerUpdate(String newCode) {
        String previousCode = getCurrentCode();
        eventBus.publish(new CoreApplicationEvents.CodeUpdatedEvent(newCode, previousCode));
    }

    public void updateMethodInvocation(MethodInvocation mi, String newScope, String newMethodName, List<String> newParamTypes) {
        blockFactory.setMarkNewIdentifiersAsUnedited(true);
        String newCode = astRewriter.updateMethodInvocation(getCompilationUnit(), getCurrentCode(), mi, newScope, newMethodName, newParamTypes);
        triggerUpdate(newCode);
    }

    public void addArgumentToMethodInvocation(MethodInvocation mi, AddableExpression type) {
        blockFactory.setMarkNewIdentifiersAsUnedited(true);
        String newCode = astRewriter.addArgumentToMethodInvocation(getCompilationUnit(), getCurrentCode(), mi, type);
        triggerUpdate(newCode);
    }

    /**
     * Wraps a bare ArrayInitializer in ArrayCreation when needed.
     *
     * @param initializer The expression to potentially wrap
     * @param varType The type of the variable being initialized
     * @param ast The AST for creating nodes
     * @return Wrapped expression if needed, or original expression
     */
    private Expression wrapArrayInitializerIfNeeded(Expression initializer, Type varType, AST ast) {
        if (initializer instanceof ArrayInitializer && varType.isArrayType()) {
            ArrayType arrayType = (ArrayType) varType;

            // Create the ArrayCreation wrapper: new T[] { ... }
            ArrayCreation arrayCreation = ast.newArrayCreation();

            // Copy the array type
            arrayCreation.setType((ArrayType) ASTNode.copySubtree(ast, arrayType));

            // Set the initializer
            arrayCreation.setInitializer((ArrayInitializer) ASTNode.copySubtree(ast, initializer));

            return arrayCreation;
        }

        // Not an array initializer or not an array type - return as-is
        return initializer;
    }

    public void addArgumentToMethodInvocation(MethodInvocation mi, Expression expr) {
        String newCode = astRewriter.addArgumentToMethodInvocation(getCompilationUnit(), getCurrentCode(), mi, expr);
        triggerUpdate(newCode);
    }

    public void moveStatement(StatementBlock blockToMove, BodyBlock sourceBody, BodyBlock targetBody, int targetIndex) {
        String newCode = astRewriter.moveStatement(getCompilationUnit(), getCurrentCode(), blockToMove, sourceBody, targetBody, targetIndex);
        triggerUpdate(newCode);
    }

    public void replaceLiteralValue(Expression toReplace, String newLiteralValue) {
        String newCode = astRewriter.replaceLiteral(getCompilationUnit(), getCurrentCode(), toReplace, newLiteralValue);
        triggerUpdate(newCode);
    }

    public void renameEnum(EnumDeclaration enumNode, String newName) {
        String newCode = astRewriter.renameEnum(getCompilationUnit(), getCurrentCode(), enumNode, newName);
        triggerUpdate(newCode);
    }

    public void addEnumConstant(EnumDeclaration enumNode, String constantName) {
        String newCode = astRewriter.addEnumConstant(getCompilationUnit(), getCurrentCode(), enumNode, constantName);
        triggerUpdate(newCode);
    }

    public void deleteEnumConstant(EnumDeclaration enumNode, int index) {
        String newCode = astRewriter.deleteEnumConstant(getCompilationUnit(), getCurrentCode(), enumNode, index);
        triggerUpdate(newCode);
    }

    public void renameEnumConstant(EnumDeclaration enumNode, int index, String newName) {
        String newCode = astRewriter.renameEnumConstant(getCompilationUnit(), getCurrentCode(), enumNode, index, newName);
        triggerUpdate(newCode);
    }



    public void addMethodToClass(TypeDeclaration typeDecl, String methodName, String returnType, int index) {
        blockFactory.setMarkNewIdentifiersAsUnedited(true);
        String newCode = astRewriter.addMethodToClass(
                getCompilationUnit(),
                getCurrentCode(),
                typeDecl,
                methodName,
                returnType,
                index
        );
        triggerUpdate(newCode);
    }

    public void deleteMethod(MethodDeclaration method) {
        String newCode = astRewriter.deleteMethodFromClass(
                getCompilationUnit(),
                getCurrentCode(),
                method
        );
        triggerUpdate(newCode);
    }

    public void addStringArgumentToMethodInvocation(MethodInvocation mi, String text) {
        CompilationUnit cu = getCompilationUnit();
        if (cu == null) return;
        AST ast = cu.getAST();
        StringLiteral newArg = ast.newStringLiteral();
        newArg.setLiteralValue(text);
        String newCode = astRewriter.addArgumentToMethodInvocation(cu, getCurrentCode(), mi, newArg);
        triggerUpdate(newCode);
    }

    public void renameMethodParameter(MethodDeclaration method, int index, String newName) {
        String newCode = astRewriter.renameMethodParameter(getCompilationUnit(), getCurrentCode(), method, index, newName);
        triggerUpdate(newCode);
    }

    public void setMethodReturnType(MethodDeclaration method, String newTypeName) {
        String newCode = astRewriter.setMethodReturnType(getCompilationUnit(), getCurrentCode(), method, newTypeName);
        triggerUpdate(newCode);
    }

    public void addParameterToMethod(MethodDeclaration method, String typeName, String paramName) {
        String newCode = astRewriter.addParameterToMethod(getCompilationUnit(), getCurrentCode(), method, typeName, paramName);
        triggerUpdate(newCode);
    }

    public void deleteParameterFromMethod(MethodDeclaration method, int index) {
        String newCode = astRewriter.deleteParameterFromMethod(getCompilationUnit(), getCurrentCode(), method, index);
        triggerUpdate(newCode);
    }

    public void setReturnExpression(ReturnStatement returnStmt, AddableExpression type) {
        blockFactory.setMarkNewIdentifiersAsUnedited(true);
        String newCode = astRewriter.setReturnExpression(getCompilationUnit(), getCurrentCode(), returnStmt, type);
        triggerUpdate(newCode);
    }

    public void addElementToList(ASTNode listNode, AddableExpression type, int insertIndex) {
        blockFactory.setMarkNewIdentifiersAsUnedited(true);
        String newCode = astRewriter.addElementToList(getCompilationUnit(), getCurrentCode(), listNode, type, insertIndex);
        triggerUpdate(newCode);
    }

    public void addEnumToClass(TypeDeclaration typeDecl, String enumName, int index) {
        blockFactory.setMarkNewIdentifiersAsUnedited(true);
        String newCode = astRewriter.addEnumToClass(getCompilationUnit(), getCurrentCode(), typeDecl, enumName, index);
        triggerUpdate(newCode);
    }

    public void deleteEnumFromClass(EnumDeclaration enumDecl) {
        String newCode = astRewriter.deleteEnumFromClass(getCompilationUnit(), getCurrentCode(), enumDecl);
        triggerUpdate(newCode);
    }

    public void deleteElementFromList(ASTNode listNode, int elementIndex) {
        String newCode = astRewriter.deleteElementFromList(getCompilationUnit(), getCurrentCode(), listNode, elementIndex);
        triggerUpdate(newCode);
    }

    public void updateComment(Comment commentNode, String newText) {
        String newCode = astRewriter.updateComment(getCurrentCode(), commentNode, newText);
        triggerUpdate(newCode);
    }

    public void deleteComment(Comment commentNode) {
        String newCode = astRewriter.deleteComment(getCurrentCode(), commentNode);
        triggerUpdate(newCode);
    }

    public void setVariableInitializer(VariableDeclarationStatement varDecl, AddableExpression type) {
        blockFactory.setMarkNewIdentifiersAsUnedited(true);
        String newCode = astRewriter.setVariableInitializer(getCompilationUnit(), getCurrentCode(), varDecl, type);
        triggerUpdate(newCode);
    }

    public void setFieldInitializer(FieldDeclaration fieldDecl, AddableExpression type) {
        blockFactory.setMarkNewIdentifiersAsUnedited(true);
        String newCode = astRewriter.setFieldInitializer(getCompilationUnit(), getCurrentCode(), fieldDecl, type);
        triggerUpdate(newCode);
    }

    public void setFieldInitializerToDefault(FieldDeclaration fieldDecl, String uiTargetType) {
        blockFactory.setMarkNewIdentifiersAsUnedited(true);

        // Determine which AddableExpression to create based on type
        AddableExpression defaultType;

        switch (uiTargetType) {
            case "number":
                defaultType = AddableExpression.NUMBER;
                break;
            case "boolean":
                defaultType = AddableExpression.FALSE;
                break;
            case "String":
                defaultType = AddableExpression.TEXT;
                break;
            case "list":
                defaultType = AddableExpression.LIST;
                break;
            case "enum":
                defaultType = AddableExpression.ENUM_CONSTANT;
                break;
            default:
                // For unknown types, use a variable reference
                defaultType = AddableExpression.VARIABLE;
                break;
        }

        String newCode = astRewriter.setFieldInitializer(
                getCompilationUnit(),
                getCurrentCode(),
                fieldDecl,
                defaultType
        );
        triggerUpdate(newCode);
    }

    /**
     * TypeInfo overload for setFieldInitializerToDefault
     */
    public void setFieldInitializerToDefault(FieldDeclaration fieldDecl,
                                             TypeInfo fieldType) {
        // Convert TypeInfo to string and call existing method
        setFieldInitializerToDefault(fieldDecl, fieldType.getTypeName());
    }

    public void replaceExpression(Expression toReplace, AddableExpression type) {
        blockFactory.setMarkNewIdentifiersAsUnedited(true);
        String newCode = astRewriter.replaceExpression(getCompilationUnit(), getCurrentCode(), toReplace, type);
        triggerUpdate(newCode);
    }


    public void addStatement(BodyBlock targetBody, AddableBlock type, int index) {
        blockFactory.setMarkNewIdentifiersAsUnedited(true);
        String newCode = astRewriter.addStatement(getCompilationUnit(), getCurrentCode(), targetBody, type, index);
        triggerUpdate(newCode);
    }

    public void deleteElseFromIfStatement(IfStatement ifStmt) {
        String newCode = astRewriter.deleteElseFromIfStatement(getCompilationUnit(), getCurrentCode(), ifStmt);
        triggerUpdate(newCode);
    }

    public void convertElseToElseIf(IfStatement ifStmt) {
        String newCode = astRewriter.convertElseToElseIf(getCompilationUnit(), getCurrentCode(), ifStmt);
        triggerUpdate(newCode);
    }

    public void addElseToIfStatement(IfStatement ifStmt) {
        String newCode = astRewriter.addElseToIfStatement(getCompilationUnit(), getCurrentCode(), ifStmt);
        triggerUpdate(newCode);
    }

    public void replaceSimpleName(SimpleName toReplace, String newName) {
        String newCode = astRewriter.replaceSimpleName(getCompilationUnit(), getCurrentCode(), toReplace, newName);
        triggerUpdate(newCode);
    }

    public void deleteStatement(Statement toDelete) {
        // Use the smart delete logic in AstRewriter
        String newCode = astRewriter.deleteStatement(getCompilationUnit(), getCurrentCode(), toDelete);
        triggerUpdate(newCode);
    }

    public void replaceVariableType(VariableDeclarationStatement toReplace, String newTypeName) {
        String newCode = astRewriter.replaceVariableType(getCompilationUnit(), getCurrentCode(), toReplace, newTypeName);
        triggerUpdate(newCode);
    }
    public void replaceFieldType(FieldDeclaration fieldDecl, String newTypeName) {
        String newCode = astRewriter.replaceFieldType(getCompilationUnit(), getCurrentCode(), fieldDecl, newTypeName);
        triggerUpdate(newCode);
    }

    public void updateAssignmentOperator(ASTNode node, String newOperatorSymbol) {
        String newCode = null;
        if (node instanceof Assignment) {
            Assignment.Operator op = getAssignmentOperator(newOperatorSymbol);
            if (op != null) {
                newCode = astRewriter.replaceAssignmentOperator(getCompilationUnit(), getCurrentCode(), (Assignment) node, op);
            }
        } else if (node instanceof PrefixExpression) {
            PrefixExpression.Operator op = getPrefixOperator(newOperatorSymbol);
            if (op != null) {
                newCode = astRewriter.replacePrefixOperator(getCompilationUnit(), getCurrentCode(), (org.eclipse.jdt.core.dom.PrefixExpression) node, op);
            }
        } else if (node instanceof org.eclipse.jdt.core.dom.PostfixExpression) {
            org.eclipse.jdt.core.dom.PostfixExpression.Operator op = getPostfixOperator(newOperatorSymbol);
            if (op != null) {
                newCode = astRewriter.replacePostfixOperator(getCompilationUnit(), getCurrentCode(), (org.eclipse.jdt.core.dom.PostfixExpression) node, op);
            }
        }
        if (newCode != null) {
            triggerUpdate(newCode);
        }
    }

    // --- NEW: Binary Operator Updates ---
    public void updateBinaryOperator(ASTNode node, String newOperatorSymbol) {
        if (node instanceof InfixExpression) {
            InfixExpression.Operator op = getInfixOperator(newOperatorSymbol);
            if (op != null) {
                String newCode = astRewriter.replaceInfixOperator(getCompilationUnit(), getCurrentCode(), (InfixExpression) node, op);
                triggerUpdate(newCode);
            }
        }
    }

    // --- Switch Case Methods ---
    public void addCaseToSwitch(SwitchStatement switchStmt) {
        blockFactory.setMarkNewIdentifiersAsUnedited(true);
        String newCode = astRewriter.addCaseToSwitch(getCompilationUnit(), getCurrentCode(), switchStmt);
        triggerUpdate(newCode);
    }

    public void moveSwitchCase(SwitchCase caseNode, boolean moveUp) {
        String newCode = astRewriter.moveSwitchCase(getCompilationUnit(), getCurrentCode(), caseNode, moveUp);
        triggerUpdate(newCode);
    }

    // --- Helpers ---
    private InfixExpression.Operator getInfixOperator(String symbol) {
        if ("+".equals(symbol)) return InfixExpression.Operator.PLUS;
        if ("-".equals(symbol)) return InfixExpression.Operator.MINUS;
        if ("*".equals(symbol)) return InfixExpression.Operator.TIMES;
        if ("/".equals(symbol)) return InfixExpression.Operator.DIVIDE;
        if ("%".equals(symbol)) return InfixExpression.Operator.REMAINDER;
        if ("==".equals(symbol)) return InfixExpression.Operator.EQUALS;
        if ("!=".equals(symbol)) return InfixExpression.Operator.NOT_EQUALS;
        if (">".equals(symbol)) return InfixExpression.Operator.GREATER;
        if (">=".equals(symbol)) return InfixExpression.Operator.GREATER_EQUALS;
        if ("<".equals(symbol)) return InfixExpression.Operator.LESS;
        if ("<=".equals(symbol)) return InfixExpression.Operator.LESS_EQUALS;
        if ("&&".equals(symbol)) return InfixExpression.Operator.CONDITIONAL_AND;
        if ("||".equals(symbol)) return InfixExpression.Operator.CONDITIONAL_OR;
        return null;
    }

    private Assignment.Operator getAssignmentOperator(String symbol) {
        if ("=".equals(symbol)) return Assignment.Operator.ASSIGN;
        if ("+=".equals(symbol)) return Assignment.Operator.PLUS_ASSIGN;
        if ("-=".equals(symbol)) return Assignment.Operator.MINUS_ASSIGN;
        if ("*=".equals(symbol)) return Assignment.Operator.TIMES_ASSIGN;
        if ("/=".equals(symbol)) return Assignment.Operator.DIVIDE_ASSIGN;
        if ("%=".equals(symbol)) return Assignment.Operator.REMAINDER_ASSIGN;
        return null;
    }

    private org.eclipse.jdt.core.dom.PrefixExpression.Operator getPrefixOperator(String symbol) {
        if ("++".equals(symbol)) return org.eclipse.jdt.core.dom.PrefixExpression.Operator.INCREMENT;
        if ("--".equals(symbol)) return org.eclipse.jdt.core.dom.PrefixExpression.Operator.DECREMENT;
        return null;
    }

    private org.eclipse.jdt.core.dom.PostfixExpression.Operator getPostfixOperator(String symbol) {
        if ("++".equals(symbol)) return org.eclipse.jdt.core.dom.PostfixExpression.Operator.INCREMENT;
        if ("--".equals(symbol)) return org.eclipse.jdt.core.dom.PostfixExpression.Operator.DECREMENT;
        return null;
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\parser\ImportManager.java
=================================================================================

package com.botmaker.parser;

import org.eclipse.jdt.core.dom.*;
import org.eclipse.jdt.core.dom.rewrite.ASTRewrite;
import org.eclipse.jdt.core.dom.rewrite.ListRewrite;

import java.util.HashSet;
import java.util.List;
import java.util.Set;

public class ImportManager {

    /**
     * Ensures that the specific class is imported in the CompilationUnit.
     * @param cu The compilation unit.
     * @param rewriter The ASTRewrite instance.
     * @param qualifiedClassName The full class name (e.g., "java.util.ArrayList").
     */
    public static void addImport(CompilationUnit cu, ASTRewrite rewriter, String qualifiedClassName) {
        if (cu == null || qualifiedClassName == null) return;

        // Check existing imports
        List<ImportDeclaration> imports = cu.imports();
        Set<String> existingImports = new HashSet<>();

        for (ImportDeclaration imp : imports) {
            if (imp.isOnDemand()) {
                // e.g., java.util.*
                String packageName = imp.getName().getFullyQualifiedName();
                String targetPackage = qualifiedClassName.substring(0, qualifiedClassName.lastIndexOf('.'));
                if (packageName.equals(targetPackage)) {
                    return; // Covered by wildcard
                }
            } else {
                existingImports.add(imp.getName().getFullyQualifiedName());
            }
        }

        if (existingImports.contains(qualifiedClassName)) {
            return; // Already imported
        }

        // Create new import
        AST ast = cu.getAST();
        ImportDeclaration newImport = ast.newImportDeclaration();
        newImport.setName(ast.newName(qualifiedClassName));

        // Insert into AST
        ListRewrite listRewrite = rewriter.getListRewrite(cu, CompilationUnit.IMPORTS_PROPERTY);
        listRewrite.insertLast(newImport, null);
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\parser\NodeCreator.java
=================================================================================

// FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\parser\NodeCreator.java
package com.botmaker.parser;

import com.botmaker.parser.factories.ExpressionFactory;
import com.botmaker.parser.factories.InitializerFactory;
import com.botmaker.parser.factories.StatementFactory;
import com.botmaker.ui.AddableBlock;
import com.botmaker.ui.AddableExpression;
import com.botmaker.util.TypeInfo;
import org.eclipse.jdt.core.dom.*;
import org.eclipse.jdt.core.dom.rewrite.ASTRewrite;

import java.util.List;

public class NodeCreator {

    private final InitializerFactory initializerFactory;
    private final ExpressionFactory expressionFactory;
    private final StatementFactory statementFactory;

    public NodeCreator() {
        this.initializerFactory = new InitializerFactory();
        this.expressionFactory = new ExpressionFactory(initializerFactory);
        this.statementFactory = new StatementFactory(initializerFactory);
    }

    public Expression createDefaultExpression(AST ast, AddableExpression type, CompilationUnit cu,
                                              ASTRewrite rewriter, String contextTypeName) {
        return expressionFactory.createDefaultExpression(ast, type, cu, rewriter, contextTypeName);
    }

    public Expression createDefaultExpression(AST ast, AddableExpression type, CompilationUnit cu,
                                              ASTRewrite rewriter) {
        return expressionFactory.createDefaultExpression(ast, type, cu, rewriter, null);
    }

    public Statement createDefaultStatement(AST ast, AddableBlock type, CompilationUnit cu,
                                            ASTRewrite rewriter) {
        return statementFactory.createDefaultStatement(ast, type, cu, rewriter);
    }

    public Expression createDefaultInitializer(AST ast, String typeName) {
        // Fix: Convert String to TypeInfo for safety, though overload exists
        return initializerFactory.createDefaultInitializer(ast, TypeInfo.from(typeName));
    }

    public Expression createRecursiveListInitializer(AST ast, String typeName, CompilationUnit cu,
                                                     ASTRewrite rewriter, List<Expression> leavesToPreserve) {
        // Fixed: Call delegated correctly to InitializerFactory
        return initializerFactory.createRecursiveListInitializer(ast, typeName, cu, rewriter, leavesToPreserve);
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\parser\factories\ExpressionFactory.java
=================================================================================

// FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\parser\factories\ExpressionFactory.java
package com.botmaker.parser.factories;

import com.botmaker.parser.helpers.EnumNodeHelper;
import com.botmaker.ui.AddableExpression;
import com.botmaker.util.DefaultNames;
import org.eclipse.jdt.core.dom.*;
import org.eclipse.jdt.core.dom.rewrite.ASTRewrite;

public class ExpressionFactory {
    private final InitializerFactory initializerFactory;

    public ExpressionFactory(InitializerFactory initializerFactory) {
        this.initializerFactory = initializerFactory;
    }

    public Expression createDefaultExpression(AST ast, AddableExpression type, CompilationUnit cu,
                                              ASTRewrite rewriter, String contextTypeName) {
        switch (type) {
            case TEXT: return createStringLiteral(ast, "text");
            case FUNCTION_CALL: return createMethodInvocation(ast, "selectMethod");
            case NUMBER: return ast.newNumberLiteral("0");
            case TRUE: return ast.newBooleanLiteral(true);
            case FALSE: return ast.newBooleanLiteral(false);
            case VARIABLE: return ast.newSimpleName(DefaultNames.DEFAULT_VARIABLE);
            case LIST: return createArrayInitializerExpression(ast);
            case ENUM_CONSTANT: return createEnumConstantExpression(ast, cu, contextTypeName);

            // Math & Comparison & Logic (Binary)
            case ADD:
            case SUBTRACT:
            case MULTIPLY:
            case DIVIDE:
            case MODULO:
            case EQUALS:
            case NOT_EQUALS:
            case GREATER:
            case LESS:
            case GREATER_EQUALS:
            case LESS_EQUALS:
            case AND:
            case OR:
                return createInfixExpression(ast, type);

            case NOT:
                return createPrefixExpression(ast, PrefixExpression.Operator.NOT);

            default: return null;
        }
    }
    // ... (Keep existing overload and helpers) ...
    public Expression createDefaultExpression(AST ast, AddableExpression type, CompilationUnit cu, ASTRewrite rewriter) {
        return createDefaultExpression(ast, type, cu, rewriter, null);
    }

    private StringLiteral createStringLiteral(AST ast, String value) {
        StringLiteral literal = ast.newStringLiteral();
        literal.setLiteralValue(value);
        return literal;
    }

    private MethodInvocation createMethodInvocation(AST ast, String methodName) {
        MethodInvocation call = ast.newMethodInvocation();
        call.setName(ast.newSimpleName(methodName));
        return call;
    }

    private Expression createArrayInitializerExpression(AST ast) {
        ArrayInitializer arrayInit = ast.newArrayInitializer();
        SimpleName placeholder = ast.newSimpleName(DefaultNames.DEFAULT_VARIABLE);
        arrayInit.expressions().add(placeholder);
        return arrayInit;
    }

    private Expression createEnumConstantExpression(AST ast, CompilationUnit cu, String contextTypeName) {
        String enumTypeName = contextTypeName != null ? contextTypeName : "MyEnum";
        String firstConstant = EnumNodeHelper.findFirstEnumConstant(cu, enumTypeName);
        if (firstConstant == null) firstConstant = "VALUE";
        return ast.newQualifiedName(ast.newSimpleName(enumTypeName), ast.newSimpleName(firstConstant));
    }

    private Expression createInfixExpression(AST ast, AddableExpression type) {
        InfixExpression infixExpr = ast.newInfixExpression();
        infixExpr.setLeftOperand(ast.newSimpleName(DefaultNames.DEFAULT_VARIABLE));

        if (type == AddableExpression.AND || type == AddableExpression.OR) {
            infixExpr.setRightOperand(ast.newBooleanLiteral(true));
        } else {
            infixExpr.setRightOperand(ast.newNumberLiteral("0"));
        }

        switch (type) {
            case ADD: infixExpr.setOperator(InfixExpression.Operator.PLUS); break;
            case SUBTRACT: infixExpr.setOperator(InfixExpression.Operator.MINUS); break;
            case MULTIPLY: infixExpr.setOperator(InfixExpression.Operator.TIMES); break;
            case DIVIDE: infixExpr.setOperator(InfixExpression.Operator.DIVIDE); break;
            case MODULO: infixExpr.setOperator(InfixExpression.Operator.REMAINDER); break;
            case EQUALS: infixExpr.setOperator(InfixExpression.Operator.EQUALS); break;
            case NOT_EQUALS: infixExpr.setOperator(InfixExpression.Operator.NOT_EQUALS); break;
            case GREATER: infixExpr.setOperator(InfixExpression.Operator.GREATER); break;
            case LESS: infixExpr.setOperator(InfixExpression.Operator.LESS); break;
            case GREATER_EQUALS: infixExpr.setOperator(InfixExpression.Operator.GREATER_EQUALS); break;
            case LESS_EQUALS: infixExpr.setOperator(InfixExpression.Operator.LESS_EQUALS); break;
            case AND: infixExpr.setOperator(InfixExpression.Operator.CONDITIONAL_AND); break;
            case OR: infixExpr.setOperator(InfixExpression.Operator.CONDITIONAL_OR); break;
        }
        return infixExpr;
    }

    // NEW Helper
    private Expression createPrefixExpression(AST ast, PrefixExpression.Operator op) {
        PrefixExpression prefix = ast.newPrefixExpression();
        prefix.setOperator(op);
        // Default operand is boolean true
        prefix.setOperand(ast.newBooleanLiteral(true));
        return prefix;
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\parser\factories\InitializerFactory.java
=================================================================================

// FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\parser\factories\InitializerFactory.java
package com.botmaker.parser.factories;

import com.botmaker.parser.helpers.EnumNodeHelper;
import com.botmaker.util.TypeInfo;
import com.botmaker.util.TypeManager;
import org.eclipse.jdt.core.dom.*;
import java.util.List;

public class InitializerFactory {

    // Overload for backward compatibility and NodeCreator call
    public Expression createDefaultInitializer(AST ast, String typeName) {
        return createDefaultInitializer(ast, TypeInfo.from(typeName), null);
    }

    public Expression createDefaultInitializer(AST ast, TypeInfo type) {
        return createDefaultInitializer(ast, type, null);
    }

    /**
     * Creates a default initializer for a given type.
     * Uses CompilationUnit to find default Enum constants if available.
     */
    public Expression createDefaultInitializer(AST ast, TypeInfo type, CompilationUnit cu) {
        // Handle arrays
        if (type.isArray()) {
            return createArrayInitializer(ast, type, java.util.Collections.emptyList(), cu);
        }

        // Handle Enums (Fix for Issue 4: Auto-pick first constant)
        if (type.isEnum() && cu != null) {
            String enumName = type.getLeafType().getTypeName();
            String firstConstant = EnumNodeHelper.findFirstEnumConstant(cu, enumName);
            if (firstConstant != null) {
                return ast.newQualifiedName(
                        ast.newSimpleName(enumName),
                        ast.newSimpleName(firstConstant)
                );
            }
        }

        // Handle Primitives and common types
        if (type.isNumeric()) {
            String leaf = type.getLeafType().getTypeName();
            if (leaf.equalsIgnoreCase("double") || leaf.equalsIgnoreCase("float")) {
                return ast.newNumberLiteral("0.0");
            }
            return ast.newNumberLiteral("0");
        }

        if (type.isBoolean()) {
            return ast.newBooleanLiteral(false);
        }

        if (type.isString()) {
            if (type.getTypeName().equals("char") || type.getTypeName().equals("Character")) {
                CharacterLiteral literal = ast.newCharacterLiteral();
                literal.setCharValue('a');
                return literal;
            }
            StringLiteral str = ast.newStringLiteral();
            str.setLiteralValue("");
            return str;
        }

        return ast.newNullLiteral();
    }

    // Overload to fix StatementFactory error (3 args)
    public Expression createArrayInitializer(AST ast, TypeInfo type, List<Expression> valuesToPreserve) {
        return createArrayInitializer(ast, type, valuesToPreserve, null);
    }

    public Expression createArrayInitializer(AST ast, String typeName, List<Expression> valuesToPreserve) {
        return createArrayInitializer(ast, TypeInfo.from(typeName), valuesToPreserve, null);
    }

    public Expression createArrayInitializer(AST ast, TypeInfo type, List<Expression> valuesToPreserve, CompilationUnit cu) {
        int dimensions = type.getArrayDimensions();
        TypeInfo leafType = type.getLeafType();

        if (dimensions == 0) {
            return createDefaultInitializer(ast, leafType, cu);
        }

        ArrayCreation arrayCreation = ast.newArrayCreation();
        Type elementType = TypeManager.createTypeNode(ast, type.getTypeName());
        arrayCreation.setType((ArrayType) elementType);

        ArrayInitializer initializer = createNestedArrayInitializer(ast, leafType, dimensions, valuesToPreserve, cu);
        arrayCreation.setInitializer(initializer);

        return arrayCreation;
    }

    private ArrayInitializer createNestedArrayInitializer(AST ast, TypeInfo leafType, int dimensions, List<Expression> valuesToPreserve, CompilationUnit cu) {
        ArrayInitializer initializer = ast.newArrayInitializer();

        if (valuesToPreserve != null && !valuesToPreserve.isEmpty()) {
            for (Expression value : valuesToPreserve) {
                initializer.expressions().add((Expression) ASTNode.copySubtree(ast, value));
            }
        } else if (dimensions == 1) {
            // Create ONE default element
            initializer.expressions().add(createDefaultInitializer(ast, leafType, cu));
        } else {
            // Recursively create sub-array
            ArrayInitializer subArray = createNestedArrayInitializer(ast, leafType, dimensions - 1, null, cu);
            initializer.expressions().add(subArray);
        }

        return initializer;
    }

    /**
     * Restore for NodeCreator compatibility, redirecting to new logic.
     */
    public Expression createRecursiveListInitializer(AST ast, String typeName, CompilationUnit cu,
                                                     org.eclipse.jdt.core.dom.rewrite.ASTRewrite rewriter, List<Expression> leavesToPreserve) {
        return createArrayInitializer(ast, TypeInfo.from(typeName), leavesToPreserve, cu);
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\parser\factories\StatementFactory.java
=================================================================================

// FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\parser\factories\StatementFactory.java
package com.botmaker.parser.factories;

import com.botmaker.ui.AddableBlock;
import com.botmaker.util.DefaultNames;
import com.botmaker.util.TypeInfo;
import com.botmaker.util.TypeManager;
import org.eclipse.jdt.core.dom.*;
import org.eclipse.jdt.core.dom.rewrite.ASTRewrite;

import java.util.Collections;

public class StatementFactory {

    private final InitializerFactory initializerFactory;

    public StatementFactory(InitializerFactory initializerFactory) {
        this.initializerFactory = initializerFactory;
    }

    public Statement createDefaultStatement(AST ast, AddableBlock type, CompilationUnit cu,
                                            ASTRewrite rewriter) {
        switch (type) {
            case PRINT: return createPrintStatement(ast);
            case DECLARE_INT: return createVariableDeclaration(ast, DefaultNames.DEFAULT_INT, "0", PrimitiveType.INT);
            case DECLARE_DOUBLE: return createVariableDeclaration(ast, DefaultNames.DEFAULT_DOUBLE, "0.0", PrimitiveType.DOUBLE);
            case DECLARE_BOOLEAN: return createVariableDeclaration(ast, DefaultNames.DEFAULT_BOOLEAN, false, PrimitiveType.BOOLEAN);
            case DECLARE_STRING: return createStringDeclaration(ast);
            case DECLARE_ARRAY: return createArrayDeclaration(ast, cu, rewriter);
            case IF: return createIfStatement(ast);
            case WHILE: return createWhileStatement(ast);
            case FOR: return createForStatement(ast);
            case DO_WHILE: return createDoWhileStatement(ast);
            case FUNCTION_CALL: return createFunctionCallStatement(ast);
            case BREAK: return ast.newBreakStatement();
            case CONTINUE: return ast.newContinueStatement();
            case RETURN: return ast.newReturnStatement();
            case COMMENT: return ast.newEmptyStatement();
            case DECLARE_ENUM: return createEnumDeclaration(ast);
            case ASSIGNMENT: return createAssignmentStatement(ast);
            case READ_LINE: return createScannerCall(ast, "input", "nextLine", "String");
            case READ_INT: return createScannerCall(ast, "num", "nextInt", PrimitiveType.INT);
            case READ_DOUBLE: return createScannerCall(ast, "num", "nextDouble", PrimitiveType.DOUBLE);
            case SWITCH: return createSwitchStatement(ast);
            case WAIT: return createWaitStatement(ast);
            default: return null;
        }
    }

    private Statement createPrintStatement(AST ast) {
        MethodInvocation println = ast.newMethodInvocation();
        println.setExpression(ast.newQualifiedName(ast.newSimpleName("System"), ast.newSimpleName("out")));
        println.setName(ast.newSimpleName("println"));
        StringLiteral emptyString = ast.newStringLiteral();
        emptyString.setLiteralValue("");
        println.arguments().add(emptyString);
        return ast.newExpressionStatement(println);
    }

    private Statement createVariableDeclaration(AST ast, String name, String val, PrimitiveType.Code type) {
        VariableDeclarationFragment fragment = ast.newVariableDeclarationFragment();
        fragment.setName(ast.newSimpleName(name));
        fragment.setInitializer(ast.newNumberLiteral(val));
        VariableDeclarationStatement varDecl = ast.newVariableDeclarationStatement(fragment);
        varDecl.setType(ast.newPrimitiveType(type));
        return varDecl;
    }

    private Statement createVariableDeclaration(AST ast, String name, boolean val, PrimitiveType.Code type) {
        VariableDeclarationFragment fragment = ast.newVariableDeclarationFragment();
        fragment.setName(ast.newSimpleName(name));
        fragment.setInitializer(ast.newBooleanLiteral(val));
        VariableDeclarationStatement varDecl = ast.newVariableDeclarationStatement(fragment);
        varDecl.setType(ast.newPrimitiveType(type));
        return varDecl;
    }

    private Statement createStringDeclaration(AST ast) {
        VariableDeclarationFragment fragment = ast.newVariableDeclarationFragment();
        fragment.setName(ast.newSimpleName(DefaultNames.DEFAULT_STRING));
        fragment.setInitializer(ast.newStringLiteral());
        VariableDeclarationStatement varDecl = ast.newVariableDeclarationStatement(fragment);
        varDecl.setType(TypeManager.createTypeNode(ast, "String"));
        return varDecl;
    }

    private Statement createArrayDeclaration(AST ast, CompilationUnit cu, ASTRewrite rewriter) {
        VariableDeclarationFragment frag = ast.newVariableDeclarationFragment();
        frag.setName(ast.newSimpleName("myList"));

        // Fixed: Use 4-arg overload passing 'cu' to support correct default values
        frag.setInitializer(
                initializerFactory.createArrayInitializer(
                        ast,
                        TypeInfo.from("int[]"),
                        Collections.emptyList(),
                        cu // Pass CU
                )
        );

        VariableDeclarationStatement listDecl = ast.newVariableDeclarationStatement(frag);
        listDecl.setType(TypeManager.createTypeNode(ast, "int[]"));
        return listDecl;
    }

    // ... (Remainder of methods unchanged)
    private Statement createIfStatement(AST ast) {
        IfStatement ifStatement = ast.newIfStatement();
        ifStatement.setExpression(ast.newBooleanLiteral(true));
        ifStatement.setThenStatement(ast.newBlock());
        return ifStatement;
    }

    private Statement createWhileStatement(AST ast) {
        WhileStatement whileStatement = ast.newWhileStatement();
        whileStatement.setExpression(ast.newBooleanLiteral(true));
        whileStatement.setBody(ast.newBlock());
        return whileStatement;
    }

    private Statement createForStatement(AST ast) {
        EnhancedForStatement enhancedFor = ast.newEnhancedForStatement();
        SingleVariableDeclaration parameter = ast.newSingleVariableDeclaration();
        parameter.setType(TypeManager.createTypeNode(ast, "String"));
        parameter.setName(ast.newSimpleName("item"));
        enhancedFor.setParameter(parameter);
        enhancedFor.setExpression(ast.newSimpleName("array"));
        enhancedFor.setBody(ast.newBlock());
        return enhancedFor;
    }

    private Statement createDoWhileStatement(AST ast) {
        DoStatement doStatement = ast.newDoStatement();
        doStatement.setExpression(ast.newBooleanLiteral(true));
        doStatement.setBody(ast.newBlock());
        return doStatement;
    }

    private Statement createFunctionCallStatement(AST ast) {
        MethodInvocation methodCall = ast.newMethodInvocation();
        methodCall.setName(ast.newSimpleName("selectMethod"));
        return ast.newExpressionStatement(methodCall);
    }

    private Statement createEnumDeclaration(AST ast) {
        TypeDeclarationStatement typeDeclStmt = ast.newTypeDeclarationStatement(ast.newEnumDeclaration());
        EnumDeclaration enumDecl = (EnumDeclaration) typeDeclStmt.getDeclaration();
        enumDecl.setName(ast.newSimpleName("MyEnum"));
        EnumConstantDeclaration const1 = ast.newEnumConstantDeclaration();
        const1.setName(ast.newSimpleName("OPTION_A"));
        enumDecl.enumConstants().add(const1);
        EnumConstantDeclaration const2 = ast.newEnumConstantDeclaration();
        const2.setName(ast.newSimpleName("OPTION_B"));
        enumDecl.enumConstants().add(const2);
        return typeDeclStmt;
    }

    private Statement createAssignmentStatement(AST ast) {
        Assignment assignment = ast.newAssignment();
        assignment.setLeftHandSide(ast.newSimpleName(DefaultNames.DEFAULT_VARIABLE));
        assignment.setOperator(Assignment.Operator.ASSIGN);
        assignment.setRightHandSide(ast.newNumberLiteral("0"));
        return ast.newExpressionStatement(assignment);
    }

    private Statement createScannerCall(AST ast, String varName, String methodName, Object typeObj) {
        VariableDeclarationFragment fragment = ast.newVariableDeclarationFragment();
        fragment.setName(ast.newSimpleName(varName));
        MethodInvocation scannerCall = ast.newMethodInvocation();
        scannerCall.setExpression(ast.newSimpleName("scanner"));
        scannerCall.setName(ast.newSimpleName(methodName));
        fragment.setInitializer(scannerCall);
        VariableDeclarationStatement varDecl = ast.newVariableDeclarationStatement(fragment);
        if (typeObj instanceof String) varDecl.setType(TypeManager.createTypeNode(ast, (String) typeObj));
        else varDecl.setType(ast.newPrimitiveType((PrimitiveType.Code) typeObj));
        return varDecl;
    }

    private Statement createSwitchStatement(AST ast) {
        SwitchStatement switchStmt = ast.newSwitchStatement();
        switchStmt.setExpression(ast.newSimpleName(DefaultNames.DEFAULT_VARIABLE));
        SwitchCase defaultCase = ast.newSwitchCase();
        switchStmt.statements().add(defaultCase);
        switchStmt.statements().add(ast.newBreakStatement());
        return switchStmt;
    }

    private Statement createWaitStatement(AST ast) {
        TryStatement tryStmt = ast.newTryStatement();
        Block tryBody = ast.newBlock();
        MethodInvocation sleepCall = ast.newMethodInvocation();
        sleepCall.setExpression(ast.newSimpleName("Thread"));
        sleepCall.setName(ast.newSimpleName("sleep"));
        sleepCall.arguments().add(ast.newNumberLiteral("1000"));
        tryBody.statements().add(ast.newExpressionStatement(sleepCall));
        tryStmt.setBody(tryBody);
        CatchClause catchClause = ast.newCatchClause();
        SingleVariableDeclaration exceptionDecl = ast.newSingleVariableDeclaration();
        exceptionDecl.setType(ast.newSimpleType(ast.newSimpleName("InterruptedException")));
        exceptionDecl.setName(ast.newSimpleName("e"));
        catchClause.setException(exceptionDecl);
        Block catchBody = ast.newBlock();
        MethodInvocation printStackTrace = ast.newMethodInvocation();
        printStackTrace.setExpression(ast.newSimpleName("e"));
        printStackTrace.setName(ast.newSimpleName("printStackTrace"));
        catchBody.statements().add(ast.newExpressionStatement(printStackTrace));
        catchClause.setBody(catchBody);
        tryStmt.catchClauses().add(catchClause);
        return tryStmt;
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\parser\handlers\EnumManipulationHandler.java
=================================================================================

package com.botmaker.parser.handlers;

import com.botmaker.parser.helpers.AstRewriteHelper;
import org.eclipse.jdt.core.dom.*;
import org.eclipse.jdt.core.dom.rewrite.ASTRewrite;
import org.eclipse.jdt.core.dom.rewrite.ListRewrite;

import java.util.List;

/**
 * Handles enum declaration and constant operations.
 */
public class EnumManipulationHandler {

    /**
     * Adds a new enum to a class.
     */
    public String addEnumToClass(CompilationUnit cu, String originalCode,
                                 TypeDeclaration typeDecl, String enumName, int index) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);

        EnumDeclaration newEnum = ast.newEnumDeclaration();
        newEnum.setName(ast.newSimpleName(enumName));
        newEnum.modifiers().add(ast.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD));

        // Add default values
        EnumConstantDeclaration const1 = ast.newEnumConstantDeclaration();
        const1.setName(ast.newSimpleName("OPTION_A"));
        newEnum.enumConstants().add(const1);

        ListRewrite listRewrite = rewriter.getListRewrite(typeDecl, TypeDeclaration.BODY_DECLARATIONS_PROPERTY);
        listRewrite.insertAt(newEnum, index, null);

        return AstRewriteHelper.applyRewrite(rewriter, originalCode);
    }

    /**
     * Deletes an enum from a class.
     */
    public String deleteEnumFromClass(CompilationUnit cu, String originalCode,
                                      EnumDeclaration enumDecl) {
        ASTRewrite rewriter = ASTRewrite.create(cu.getAST());
        rewriter.remove(enumDecl, null);
        return AstRewriteHelper.applyRewrite(rewriter, originalCode);
    }

    /**
     * Renames an enum.
     */
    public String renameEnum(CompilationUnit cu, String originalCode,
                             EnumDeclaration enumNode, String newName) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);
        rewriter.replace(enumNode.getName(), ast.newSimpleName(newName), null);
        return AstRewriteHelper.applyRewrite(rewriter, originalCode);
    }

    /**
     * Adds a constant to an enum.
     */
    public String addEnumConstant(CompilationUnit cu, String originalCode,
                                  EnumDeclaration enumNode, String constantName) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);

        ListRewrite listRewrite = rewriter.getListRewrite(enumNode, EnumDeclaration.ENUM_CONSTANTS_PROPERTY);

        EnumConstantDeclaration newConst = ast.newEnumConstantDeclaration();
        newConst.setName(ast.newSimpleName(constantName));

        listRewrite.insertLast(newConst, null);
        return AstRewriteHelper.applyRewrite(rewriter, originalCode);
    }

    /**
     * Deletes a constant from an enum.
     */
    public String deleteEnumConstant(CompilationUnit cu, String originalCode,
                                     EnumDeclaration enumNode, int index) {
        ASTRewrite rewriter = ASTRewrite.create(cu.getAST());
        ListRewrite listRewrite = rewriter.getListRewrite(enumNode, EnumDeclaration.ENUM_CONSTANTS_PROPERTY);

        List<?> constants = enumNode.enumConstants();
        if (index >= 0 && index < constants.size()) {
            listRewrite.remove((ASTNode) constants.get(index), null);
        }

        return AstRewriteHelper.applyRewrite(rewriter, originalCode);
    }

    /**
     * Renames a constant in an enum.
     */
    public String renameEnumConstant(CompilationUnit cu, String originalCode,
                                     EnumDeclaration enumNode, int index, String newName) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);

        List<?> constants = enumNode.enumConstants();
        if (index >= 0 && index < constants.size()) {
            EnumConstantDeclaration constDecl = (EnumConstantDeclaration) constants.get(index);
            rewriter.replace(constDecl.getName(), ast.newSimpleName(newName), null);
        }

        return AstRewriteHelper.applyRewrite(rewriter, originalCode);
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\parser\handlers\ListManipulationHandler.java
=================================================================================

package com.botmaker.parser.handlers;

import com.botmaker.parser.NodeCreator;
import com.botmaker.parser.helpers.AstRewriteHelper;
import com.botmaker.ui.AddableExpression;
import org.eclipse.jdt.core.dom.*;
import org.eclipse.jdt.core.dom.rewrite.ASTRewrite;
import org.eclipse.jdt.core.dom.rewrite.ListRewrite;

import java.util.List;

/**
 * Handles operations on lists and arrays.
 */
public class ListManipulationHandler {

    private final NodeCreator nodeCreator;

    public ListManipulationHandler(NodeCreator nodeCreator) {
        this.nodeCreator = nodeCreator;
    }

    /**
     * Adds an element to a list structure at the specified index.
     */
    public String addElementToList(CompilationUnit cu, String originalCode,
                                   ASTNode listNode, AddableExpression type, int insertIndex) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);

        Expression newElement = nodeCreator.createDefaultExpression(ast, type, cu, rewriter);
        if (newElement == null) return originalCode;

        if (listNode instanceof ArrayInitializer) {
            rewriter.getListRewrite(listNode, ArrayInitializer.EXPRESSIONS_PROPERTY)
                    .insertAt(newElement, insertIndex, null);
        } else if (listNode instanceof MethodInvocation) {
            rewriter.getListRewrite(listNode, MethodInvocation.ARGUMENTS_PROPERTY)
                    .insertAt(newElement, insertIndex, null);
        } else if (listNode instanceof ClassInstanceCreation) {
            ClassInstanceCreation cic = (ClassInstanceCreation) listNode;
            if (!cic.arguments().isEmpty() && cic.arguments().get(0) instanceof MethodInvocation) {
                MethodInvocation mi = (MethodInvocation) cic.arguments().get(0);
                rewriter.getListRewrite(mi, MethodInvocation.ARGUMENTS_PROPERTY)
                        .insertAt(newElement, insertIndex, null);
            }
        }

        return AstRewriteHelper.applyRewrite(rewriter, originalCode);
    }

    /**
     * Deletes an element from a list structure at the specified index.
     */
    public String deleteElementFromList(CompilationUnit cu, String originalCode,
                                        ASTNode listNode, int elementIndex) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);

        List<?> expressions;
        ChildListPropertyDescriptor property;
        ASTNode targetNode = listNode;

        if (listNode instanceof ClassInstanceCreation) {
            ClassInstanceCreation cic = (ClassInstanceCreation) listNode;
            if (!cic.arguments().isEmpty() && cic.arguments().get(0) instanceof MethodInvocation) {
                MethodInvocation mi = (MethodInvocation) cic.arguments().get(0);
                targetNode = mi;
                expressions = mi.arguments();
                property = MethodInvocation.ARGUMENTS_PROPERTY;
            } else {
                return originalCode;
            }
        } else if (listNode instanceof ArrayInitializer) {
            expressions = ((ArrayInitializer) listNode).expressions();
            property = ArrayInitializer.EXPRESSIONS_PROPERTY;
        } else if (listNode instanceof MethodInvocation) {
            expressions = ((MethodInvocation) listNode).arguments();
            property = MethodInvocation.ARGUMENTS_PROPERTY;
        } else {
            return originalCode;
        }

        if (elementIndex >= 0 && elementIndex < expressions.size()) {
            rewriter.getListRewrite(targetNode, property)
                    .remove((ASTNode) expressions.get(elementIndex), null);
        }

        return AstRewriteHelper.applyRewrite(rewriter, originalCode);
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\parser\handlers\MethodManipulationHandler.java
=================================================================================

package com.botmaker.parser.handlers;

import com.botmaker.parser.NodeCreator;
import com.botmaker.parser.helpers.AstRewriteHelper;
import com.botmaker.ui.AddableExpression;
import com.botmaker.util.TypeInfo;
import com.botmaker.util.TypeManager;
import org.eclipse.jdt.core.dom.*;
import org.eclipse.jdt.core.dom.rewrite.ASTRewrite;
import org.eclipse.jdt.core.dom.rewrite.ListRewrite;

import java.util.List;

public class MethodManipulationHandler {

    private final NodeCreator nodeCreator;

    public MethodManipulationHandler(NodeCreator nodeCreator) {
        this.nodeCreator = nodeCreator;
    }

    // ... (Keep existing addMethodToClass, deleteMethodFromClass) ...
    public String addMethodToClass(CompilationUnit cu, String originalCode, TypeDeclaration typeDecl, String methodName, String returnType, int index) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);
        MethodDeclaration newMethod = ast.newMethodDeclaration();
        newMethod.setName(ast.newSimpleName(methodName));
        newMethod.modifiers().add(ast.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD));
        newMethod.modifiers().add(ast.newModifier(Modifier.ModifierKeyword.STATIC_KEYWORD));
        if ("void".equals(returnType)) newMethod.setReturnType2(ast.newPrimitiveType(PrimitiveType.VOID));
        else newMethod.setReturnType2(TypeManager.createTypeNode(ast, returnType));
        Block body = ast.newBlock();
        newMethod.setBody(body);
        ListRewrite listRewrite = rewriter.getListRewrite(typeDecl, TypeDeclaration.BODY_DECLARATIONS_PROPERTY);
        listRewrite.insertAt(newMethod, index, null);
        return AstRewriteHelper.applyRewrite(rewriter, originalCode);
    }

    public String deleteMethodFromClass(CompilationUnit cu, String originalCode, MethodDeclaration method) {
        ASTRewrite rewriter = ASTRewrite.create(cu.getAST());
        rewriter.remove(method, null);
        return AstRewriteHelper.applyRewrite(rewriter, originalCode);
    }

    /**
     * Updates a method invocation. Now uses TypeInfo to generate default arguments.
     */
    public String updateMethodInvocation(CompilationUnit cu, String originalCode,
                                         MethodInvocation mi, String newScope,
                                         String newMethodName, List<String> newParamTypes) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);

        // Update scope
        if (newScope == null || newScope.isEmpty() || newScope.equals("Local")) {
            if (mi.getExpression() != null) rewriter.remove(mi.getExpression(), null);
        } else {
            SimpleName newScopeNode = ast.newSimpleName(newScope);
            if (mi.getExpression() == null) rewriter.set(mi, MethodInvocation.EXPRESSION_PROPERTY, newScopeNode, null);
            else rewriter.replace(mi.getExpression(), newScopeNode, null);
        }

        // Update method name
        if (!mi.getName().getIdentifier().equals(newMethodName)) {
            rewriter.replace(mi.getName(), ast.newSimpleName(newMethodName), null);
        }

        // Update arguments
        ListRewrite argsRewrite = rewriter.getListRewrite(mi, MethodInvocation.ARGUMENTS_PROPERTY);
        List<?> currentArgs = mi.arguments();
        int targetCount = newParamTypes.size();
        int currentCount = currentArgs.size();

        if (currentCount > targetCount) {
            for (int i = currentCount - 1; i >= targetCount; i--) {
                argsRewrite.remove((ASTNode) currentArgs.get(i), null);
            }
        } else if (currentCount < targetCount) {
            for (int i = currentCount; i < targetCount; i++) {
                // Use TypeInfo.from() to handle array creation elegantly via InitializerFactory
                String typeName = newParamTypes.get(i);
                TypeInfo typeInfo = TypeInfo.from(typeName);
                Expression defaultExpr = nodeCreator.createDefaultInitializer(ast, typeName); // Note: InitializerFactory now handles TypeInfo logic internally
                argsRewrite.insertLast(defaultExpr, null);
            }
        }

        return AstRewriteHelper.applyRewrite(rewriter, originalCode);
    }

    // ... (Keep remainder of file: addArgumentToMethodInvocation, renameMethodParameter, etc.) ...
    public String addArgumentToMethodInvocation(CompilationUnit cu, String originalCode, MethodInvocation mi, AddableExpression type) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);
        Expression newArg = nodeCreator.createDefaultExpression(ast, type, cu, rewriter);
        if (newArg != null) rewriter.getListRewrite(mi, MethodInvocation.ARGUMENTS_PROPERTY).insertLast(newArg, null);
        return AstRewriteHelper.applyRewrite(rewriter, originalCode);
    }

    public String addArgumentToMethodInvocation(CompilationUnit cu, String originalCode, MethodInvocation mi, Expression newArgument) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);
        rewriter.getListRewrite(mi, MethodInvocation.ARGUMENTS_PROPERTY).insertLast(newArgument, null);
        return AstRewriteHelper.applyRewrite(rewriter, originalCode);
    }

    public String renameMethodParameter(CompilationUnit cu, String originalCode, MethodDeclaration method, int index, String newName) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);
        List<?> params = method.parameters();
        if (index >= 0 && index < params.size()) {
            SingleVariableDeclaration param = (SingleVariableDeclaration) params.get(index);
            SimpleName newNameNode = ast.newSimpleName(newName);
            rewriter.replace(param.getName(), newNameNode, null);
        }
        return AstRewriteHelper.applyRewrite(rewriter, originalCode);
    }

    public String setMethodReturnType(CompilationUnit cu, String originalCode, MethodDeclaration method, String newTypeName) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);
        Type newType;
        if ("void".equals(newTypeName)) newType = ast.newPrimitiveType(PrimitiveType.VOID);
        else newType = TypeManager.createTypeNode(ast, newTypeName);
        rewriter.replace(method.getReturnType2(), newType, null);
        return AstRewriteHelper.applyRewrite(rewriter, originalCode);
    }

    public String addParameterToMethod(CompilationUnit cu, String originalCode, MethodDeclaration method, String typeName, String paramName) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);
        ListRewrite listRewrite = rewriter.getListRewrite(method, MethodDeclaration.PARAMETERS_PROPERTY);
        SingleVariableDeclaration newParam = ast.newSingleVariableDeclaration();
        newParam.setType(TypeManager.createTypeNode(ast, typeName));
        newParam.setName(ast.newSimpleName(paramName));
        listRewrite.insertLast(newParam, null);
        return AstRewriteHelper.applyRewrite(rewriter, originalCode);
    }

    public String deleteParameterFromMethod(CompilationUnit cu, String originalCode, MethodDeclaration method, int index) {
        ASTRewrite rewriter = ASTRewrite.create(cu.getAST());
        ListRewrite listRewrite = rewriter.getListRewrite(method, MethodDeclaration.PARAMETERS_PROPERTY);
        List<?> params = method.parameters();
        if (index >= 0 && index < params.size()) listRewrite.remove((ASTNode) params.get(index), null);
        return AstRewriteHelper.applyRewrite(rewriter, originalCode);
    }

    public String setReturnExpression(CompilationUnit cu, String originalCode, ReturnStatement returnStmt, AddableExpression type) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);
        Expression newExpr = nodeCreator.createDefaultExpression(ast, type, cu, rewriter);
        if (newExpr == null) return originalCode;
        if (returnStmt.getExpression() == null) rewriter.set(returnStmt, ReturnStatement.EXPRESSION_PROPERTY, newExpr, null);
        else rewriter.replace(returnStmt.getExpression(), newExpr, null);
        return AstRewriteHelper.applyRewrite(rewriter, originalCode);
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\parser\handlers\OperatorReplacementHandler.java
=================================================================================

package com.botmaker.parser.handlers;

import com.botmaker.parser.helpers.AstRewriteHelper;
import org.eclipse.jdt.core.dom.*;
import org.eclipse.jdt.core.dom.rewrite.ASTRewrite;

/**
 * Handles replacement of operators in expressions.
 */
public class OperatorReplacementHandler {

    /**
     * Replaces an infix operator (e.g., +, -, *, /)
     */
    public String replaceInfixOperator(CompilationUnit cu, String originalCode,
                                       InfixExpression infix, InfixExpression.Operator newOp) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);
        rewriter.set(infix, InfixExpression.OPERATOR_PROPERTY, newOp, null);
        return AstRewriteHelper.applyRewrite(rewriter, originalCode);
    }

    /**
     * Replaces an assignment operator (e.g., =, +=, -=)
     */
    public String replaceAssignmentOperator(CompilationUnit cu, String originalCode,
                                            Assignment assignment, Assignment.Operator newOp) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);

        Assignment newAssignment = ast.newAssignment();
        newAssignment.setLeftHandSide((Expression) ASTNode.copySubtree(ast, assignment.getLeftHandSide()));
        newAssignment.setRightHandSide((Expression) ASTNode.copySubtree(ast, assignment.getRightHandSide()));
        newAssignment.setOperator(newOp);

        rewriter.replace(assignment, newAssignment, null);
        return AstRewriteHelper.applyRewrite(rewriter, originalCode);
    }

    /**
     * Replaces a prefix operator (e.g., ++, --)
     */
    public String replacePrefixOperator(CompilationUnit cu, String originalCode,
                                        PrefixExpression prefix, PrefixExpression.Operator newOp) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);

        PrefixExpression newPrefix = ast.newPrefixExpression();
        newPrefix.setOperand((Expression) ASTNode.copySubtree(ast, prefix.getOperand()));
        newPrefix.setOperator(newOp);

        rewriter.replace(prefix, newPrefix, null);
        return AstRewriteHelper.applyRewrite(rewriter, originalCode);
    }

    /**
     * Replaces a postfix operator (e.g., ++, --)
     */
    public String replacePostfixOperator(CompilationUnit cu, String originalCode,
                                         PostfixExpression postfix, PostfixExpression.Operator newOp) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);

        PostfixExpression newPostfix = ast.newPostfixExpression();
        newPostfix.setOperand((Expression) ASTNode.copySubtree(ast, postfix.getOperand()));
        newPostfix.setOperator(newOp);

        rewriter.replace(postfix, newPostfix, null);
        return AstRewriteHelper.applyRewrite(rewriter, originalCode);
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\parser\handlers\TypeReplacementHandler.java
=================================================================================

package com.botmaker.parser.handlers;

import com.botmaker.parser.ImportManager;
import com.botmaker.parser.NodeCreator;
import com.botmaker.parser.helpers.AstRewriteHelper;
import com.botmaker.parser.helpers.EnumNodeHelper;
import com.botmaker.parser.helpers.TypeConversionHelper;
import com.botmaker.util.TypeInfo;
import com.botmaker.util.TypeManager;
import org.eclipse.jdt.core.dom.*;
import org.eclipse.jdt.core.dom.rewrite.ASTRewrite;

import java.util.ArrayList;
import java.util.List;

public class TypeReplacementHandler {

    private final NodeCreator nodeCreator;

    public TypeReplacementHandler(NodeCreator nodeCreator) {
        this.nodeCreator = nodeCreator;
    }

    // ... (Keep existing replaceVariableType, replaceFieldType) ...
    public String replaceVariableType(CompilationUnit cu, String originalCode, VariableDeclarationStatement varDecl, String newTypeName) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);
        addRequiredImports(cu, rewriter, newTypeName);
        Type newType = TypeManager.createTypeNode(ast, newTypeName);
        rewriter.replace(varDecl.getType(), newType, null);
        if (!varDecl.fragments().isEmpty()) {
            VariableDeclarationFragment fragment = (VariableDeclarationFragment) varDecl.fragments().get(0);
            Expression currentInitializer = fragment.getInitializer();
            Expression newInitializer = createInitializerForNewType(ast, cu, rewriter, varDecl.getType().toString(), newTypeName, currentInitializer);
            if (newInitializer != null && currentInitializer != null) rewriter.replace(currentInitializer, newInitializer, null);
        }
        return AstRewriteHelper.applyRewrite(rewriter, originalCode);
    }

    public String replaceFieldType(CompilationUnit cu, String originalCode, FieldDeclaration fieldDecl, String newTypeName) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);
        addRequiredImports(cu, rewriter, newTypeName);
        Type newType = TypeManager.createTypeNode(ast, newTypeName);
        rewriter.replace(fieldDecl.getType(), newType, null);
        if (!fieldDecl.fragments().isEmpty()) {
            VariableDeclarationFragment fragment = (VariableDeclarationFragment) fieldDecl.fragments().get(0);
            Expression currentInitializer = fragment.getInitializer();
            Expression newInitializer = createInitializerForNewType(ast, cu, rewriter, fieldDecl.getType().toString(), newTypeName, currentInitializer);
            if (newInitializer != null && currentInitializer != null) rewriter.replace(currentInitializer, newInitializer, null);
        }
        return AstRewriteHelper.applyRewrite(rewriter, originalCode);
    }

    /**
     * Creates an appropriate initializer for a new type, preserving values where possible.
     * UPDATED: Uses TypeInfo extensively.
     */
    private Expression createInitializerForNewType(AST ast, CompilationUnit cu, ASTRewrite rewriter,
                                                   String oldTypeName, String newTypeName,
                                                   Expression currentInitializer) {
        List<Expression> valuesToPreserve = new ArrayList<>();

        TypeInfo oldType = TypeInfo.from(oldTypeName);
        TypeInfo newType = TypeInfo.from(newTypeName);

        String oldLeaf = oldType.getLeafType().getTypeName();
        String newLeaf = newType.getLeafType().getTypeName();

        // Preserve values if leaf types match (e.g. converting int to int[])
        if (oldLeaf.equals(newLeaf) && currentInitializer != null) {
            TypeConversionHelper.collectLeafValues(currentInitializer, valuesToPreserve);
        }

        boolean isNewTypeEnum = newType.getLeafType().isEnum() || TypeManager.isEnumType(newType.getLeafType(), cu);

        if (isNewTypeEnum) {
            return createEnumInitializer(ast, cu, rewriter, newTypeName, newLeaf);
        } else if (newType.isArray()) {
            // Using the overloaded createDefaultInitializer that accepts TypeInfo inside NodeCreator would be ideal,
            // but for now we call the specific array logic via the factory logic we know exists.
            // Note: nodeCreator delegates to InitializerFactory.
            // Here we construct it manually since we have valuesToPreserve.
            return createArrayInitializer(ast, newType, valuesToPreserve);
        } else {
            // Primitive or Object
            return !valuesToPreserve.isEmpty() ?
                    (Expression) ASTNode.copySubtree(ast, valuesToPreserve.get(0)) :
                    nodeCreator.createDefaultInitializer(ast, newTypeName);
        }
    }

    private Expression createEnumInitializer(AST ast, CompilationUnit cu, ASTRewrite rewriter,
                                             String newTypeName, String enumTypeName) {
        String firstConstant = EnumNodeHelper.findFirstEnumConstant(cu, enumTypeName);
        if (firstConstant != null) {
            if (newTypeName.endsWith("[]")) {
                // Array of Enums - create empty array or array with one default
                return createArrayInitializer(ast, TypeInfo.from(newTypeName), null);
            } else {
                // Single enum value
                return ast.newQualifiedName(ast.newSimpleName(enumTypeName), ast.newSimpleName(firstConstant));
            }
        } else {
            return ast.newNullLiteral();
        }
    }

    /**
     * Creates an array initializer with preserved values.
     * UPDATED: Uses TypeInfo parameter.
     */
    private Expression createArrayInitializer(AST ast, TypeInfo typeInfo, List<Expression> valuesToPreserve) {
        ArrayCreation creation = ast.newArrayCreation();
        creation.setType((ArrayType) TypeManager.createTypeNode(ast, typeInfo));
        ArrayInitializer ai = ast.newArrayInitializer();

        // If we have preserved values, add them
        if (valuesToPreserve != null && !valuesToPreserve.isEmpty()) {
            for (Expression val : valuesToPreserve) {
                ai.expressions().add(ASTNode.copySubtree(ast, val));
            }
        }
        // If specific dimensions and no values, ensure nested structure is created (e.g. new int[2][])
        else {
            // If we rely on the InitializerFactory logic for nested arrays:
            // We can just return the creation with empty initializer, or one default element.
            // For now, empty is safer for refactoring.
        }

        creation.setInitializer(ai);
        return creation;
    }

    private void addRequiredImports(CompilationUnit cu, ASTRewrite rewriter, String typeName) {
        if (typeName.contains("ArrayList")) {
            ImportManager.addImport(cu, rewriter, "java.util.ArrayList");
            ImportManager.addImport(cu, rewriter, "java.util.List");
        }
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\parser\helpers\AstRewriteHelper.java
=================================================================================

package com.botmaker.parser.helpers;

import org.eclipse.jdt.core.dom.ASTNode;
import org.eclipse.jdt.core.dom.rewrite.ASTRewrite;
import org.eclipse.jdt.core.dom.rewrite.ListRewrite;
import org.eclipse.jface.text.Document;
import org.eclipse.jface.text.IDocument;
import org.eclipse.text.edits.TextEdit;

/**
 * Common utilities for AST rewriting operations.
 */
public class AstRewriteHelper {

    /**
     * Applies an ASTRewrite to source code and returns the modified code.
     * @param rewriter The ASTRewrite to apply
     * @param originalCode The original source code
     * @return The modified code, or original code if rewrite fails
     */
    public static String applyRewrite(ASTRewrite rewriter, String originalCode) {
        IDocument document = new Document(originalCode);
        try {
            TextEdit edits = rewriter.rewriteAST(document, null);
            edits.apply(document);
            return document.get();
        } catch (Exception e) {
            e.printStackTrace();
            return originalCode;
        }
    }

    /**
     * Replaces one AST node with another.
     * @param rewriter The ASTRewrite instance
     * @param oldNode The node to replace
     * @param newNode The replacement node
     */
    public static void replaceNode(ASTRewrite rewriter, ASTNode oldNode, ASTNode newNode) {
        rewriter.replace(oldNode, newNode, null);
    }

    /**
     * Removes an AST node.
     * @param rewriter The ASTRewrite instance
     * @param node The node to remove
     */
    public static void removeNode(ASTRewrite rewriter, ASTNode node) {
        rewriter.remove(node, null);
    }

    /**
     * Sets a property on an AST node.
     * @param rewriter The ASTRewrite instance
     * @param node The node to modify
     * @param property The property to set
     * @param value The new value
     */
    public static void setProperty(ASTRewrite rewriter, ASTNode node,
                                   org.eclipse.jdt.core.dom.ChildPropertyDescriptor property,
                                   Object value) {
        rewriter.set(node, property, value, null);
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\parser\helpers\CommentParser.java
=================================================================================

package com.botmaker.parser.helpers;

import com.botmaker.blocks.CommentBlock;
import com.botmaker.core.CodeBlock;
import com.botmaker.parser.BlockIdPrefix;
import org.eclipse.jdt.core.dom.*;

import java.util.ArrayList;
import java.util.List;

/**
 * Handles parsing and extraction of comments from the AST.
 */
public class CommentParser {

    /**
     * Parses a comment AST node into a CommentBlock.
     */
    public static CommentBlock parseCommentBlock(Comment astNode, java.util.Map<ASTNode, CodeBlock> nodeToBlockMap,
                                                 String sourceCode) {
        String text = extractCommentText(astNode, sourceCode);
        CommentBlock commentBlock = new CommentBlock(
                BlockIdPrefix.generate(BlockIdPrefix.COMMENT, astNode),
                astNode,
                text
        );
        nodeToBlockMap.put(astNode, commentBlock);
        return commentBlock;
    }

    /**
     * Extracts the text content from a comment node.
     */
    public static String extractCommentText(Comment astNode, String sourceCode) {
        String text = "Comment";
        if (sourceCode != null) {
            try {
                String raw = sourceCode.substring(
                        astNode.getStartPosition(),
                        astNode.getStartPosition() + astNode.getLength()
                );

                if (astNode.isLineComment()) {
                    text = raw.substring(2).trim();
                } else {
                    text = raw.substring(2, raw.length() - 2).trim();
                }
            } catch (Exception ignored) {
                // Keep default "Comment" text
            }
        }
        return text;
    }

    /**
     * Finds comments that are orphaned (not inside any specific statement).
     * These are comments that belong to the body but aren't nested inside statements.
     */
    public static List<Comment> findOrphanedComments(Block block, List<Comment> allComments) {
        List<Comment> orphaned = new ArrayList<>();

        int blockStart = block.getStartPosition() + 1;
        int blockEnd = block.getStartPosition() + block.getLength() - 1;

        for (Comment comment : allComments) {
            int cPos = comment.getStartPosition();

            // Check if comment is within block bounds
            if (cPos > blockStart && cPos < blockEnd) {
                boolean isInsideChild = false;

                // Check if it's inside a statement
                for (Object stmtObj : block.statements()) {
                    Statement s = (Statement) stmtObj;
                    if (cPos >= s.getStartPosition() &&
                            cPos <= s.getStartPosition() + s.getLength()) {
                        isInsideChild = true;
                        break;
                    }
                }

                if (!isInsideChild) {
                    orphaned.add(comment);
                }
            }
        }

        return orphaned;
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\parser\helpers\EnumNodeHelper.java
=================================================================================

package com.botmaker.parser.helpers;

import org.eclipse.jdt.core.dom.*;

import java.util.ArrayList;
import java.util.List;

/**
 * Shared utility for working with enum declarations in the AST.
 * Used by both AstRewriter and NodeCreator to avoid duplication.
 */
public class EnumNodeHelper {

    /**
     * Finds the first constant name in an enum declaration.
     * @param cu The compilation unit to search
     * @param enumName The name of the enum to find
     * @return The name of the first constant, or null if not found
     */
    public static String findFirstEnumConstant(CompilationUnit cu, String enumName) {
        if (cu == null || enumName == null) return null;

        EnumDeclaration enumDecl = findEnumDeclaration(cu, enumName);
        if (enumDecl != null && !enumDecl.enumConstants().isEmpty()) {
            EnumConstantDeclaration first = (EnumConstantDeclaration) enumDecl.enumConstants().get(0);
            return first.getName().getIdentifier();
        }
        return null;
    }

    /**
     * Finds an enum declaration by name.
     * Searches both top-level types and class body declarations.
     * @param cu The compilation unit to search
     * @param enumName The name of the enum
     * @return The EnumDeclaration if found, null otherwise
     */
    public static EnumDeclaration findEnumDeclaration(CompilationUnit cu, String enumName) {
        if (cu == null || enumName == null) return null;

        // Search top-level types
        for (Object obj : cu.types()) {
            if (obj instanceof EnumDeclaration) {
                EnumDeclaration enumDecl = (EnumDeclaration) obj;
                if (enumDecl.getName().getIdentifier().equals(enumName)) {
                    return enumDecl;
                }
            }
            // Check class body declarations
            else if (obj instanceof TypeDeclaration) {
                TypeDeclaration typeDecl = (TypeDeclaration) obj;
                EnumDeclaration found = findEnumInTypeDeclaration(typeDecl, enumName);
                if (found != null) return found;

                // NEW: Also search inside methods for local enums
                for (MethodDeclaration method : typeDecl.getMethods()) {
                    EnumDeclaration methodEnum = findEnumInMethod(method, enumName);
                    if (methodEnum != null) return methodEnum;
                }
            }
        }
        return null;
    }

    // NEW: Search for enums declared inside method bodies
    private static EnumDeclaration findEnumInMethod(MethodDeclaration method, String enumName) {
        if (method.getBody() == null) return null;

        for (Object stmt : method.getBody().statements()) {
            if (stmt instanceof TypeDeclarationStatement) {
                TypeDeclarationStatement tds = (TypeDeclarationStatement) stmt;
                if (tds.getDeclaration() instanceof EnumDeclaration) {
                    EnumDeclaration enumDecl = (EnumDeclaration) tds.getDeclaration();
                    if (enumDecl.getName().getIdentifier().equals(enumName)) {
                        return enumDecl;
                    }
                }
            }
        }
        return null;
    }

    /**
     * Searches for an enum within a TypeDeclaration's body.
     */
    private static EnumDeclaration findEnumInTypeDeclaration(TypeDeclaration typeDecl, String enumName) {
        for (Object bodyObj : typeDecl.bodyDeclarations()) {
            if (bodyObj instanceof EnumDeclaration) {
                EnumDeclaration enumDecl = (EnumDeclaration) bodyObj;
                if (enumDecl.getName().getIdentifier().equals(enumName)) {
                    return enumDecl;
                }
            }
        }
        return null;
    }

    /**
     * Gets all constant names from an enum declaration.
     * @param enumDecl The enum declaration
     * @return List of constant names
     */
    public static List<String> getAllEnumConstantNames(EnumDeclaration enumDecl) {
        List<String> names = new ArrayList<>();
        if (enumDecl != null) {
            for (Object obj : enumDecl.enumConstants()) {
                EnumConstantDeclaration constant = (EnumConstantDeclaration) obj;
                names.add(constant.getName().getIdentifier());
            }
        }
        return names;
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\parser\helpers\FileTypeDetector.java
=================================================================================

package com.botmaker.parser.helpers;

import org.eclipse.jdt.core.dom.*;

/**
 * Detects file and method types in the AST.
 */
public class FileTypeDetector {

    /**
     * Checks if a type declaration is a standalone enum file.
     */
    public static boolean isStandaloneEnumFile(AbstractTypeDeclaration typeDecl) {
        return typeDecl instanceof EnumDeclaration;
    }

    /**
     * Checks if a type declaration is a class file.
     */
    public static boolean isClassFile(AbstractTypeDeclaration typeDecl) {
        return typeDecl instanceof TypeDeclaration;
    }

    /**
     * Checks if a method is a main method.
     */
    public static boolean isMainMethod(MethodDeclaration method) {
        if (!"main".equals(method.getName().getIdentifier())) {
            return false;
        }
        if (!Modifier.isStatic(method.getModifiers())) {
            return false;
        }
        if (!Modifier.isPublic(method.getModifiers())) {
            return false;
        }
        if (method.parameters().size() != 1) {
            return false;
        }
        return true;
    }

    /**
     * Finds the main method in a type declaration.
     */
    public static MethodDeclaration findMainMethod(TypeDeclaration type) {
        for (MethodDeclaration method : type.getMethods()) {
            if (isMainMethod(method)) {
                return method;
            }
        }
        return null;
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\parser\helpers\TypeConversionHelper.java
=================================================================================

package com.botmaker.parser.helpers;

import org.eclipse.jdt.core.dom.*;

import java.util.ArrayList;
import java.util.List;

/**
 * Helper for type conversions and value preservation across type changes.
 */
public class TypeConversionHelper {

    /**
     * Infers the expected type from the parent context of an expression.
     * Used when replacing expressions to provide type context.
     */
    public static String inferContextType(Expression expr) {
        ASTNode parent = expr.getParent();

        // Variable declaration
        if (parent instanceof VariableDeclarationFragment) {
            VariableDeclarationFragment frag = (VariableDeclarationFragment) parent;
            if (frag.getParent() instanceof VariableDeclarationStatement) {
                VariableDeclarationStatement varDecl = (VariableDeclarationStatement) frag.getParent();
                String typeName = varDecl.getType().toString();
                return unwrapArrayListType(typeName);
            }
        }

        // Assignment
        if (parent instanceof Assignment) {
            Assignment assign = (Assignment) parent;
            Expression lhs = assign.getLeftHandSide();
            if (lhs instanceof SimpleName) {
                ITypeBinding binding = lhs.resolveTypeBinding();
                if (binding != null) {
                    return binding.getName();
                }
            }
        }

        // --- NEW: Switch Case (Fix for Enum identification) ---
        if (parent instanceof SwitchCase) {
            ASTNode grandParent = parent.getParent();
            if (grandParent instanceof SwitchStatement) {
                SwitchStatement switchStmt = (SwitchStatement) grandParent;
                Expression switchExpr = switchStmt.getExpression();
                if (switchExpr != null) {
                    ITypeBinding binding = switchExpr.resolveTypeBinding();
                    if (binding != null) {
                        return binding.getName();
                    }
                }
            }
        }

        return null;
    }

    /**
     * Unwraps ArrayList<T> to get T.
     */
    public static String unwrapArrayListType(String typeName) {
        if (typeName.startsWith("ArrayList<") && typeName.endsWith(">")) {
            return typeName.substring(10, typeName.length() - 1);
        }
        return typeName;
    }

    /**
     * Extracts the leaf type from a potentially nested type.
     * E.g., "ArrayList<ArrayList<Integer>>" -> "Integer"
     */
    public static String getLeafType(String typeName) {
        if (typeName == null) return "Object";
        String temp = typeName;
        while (temp.startsWith("ArrayList<") || temp.startsWith("List<")) {
            int start = temp.indexOf("<") + 1;
            int end = temp.lastIndexOf(">");
            if (start < end) {
                temp = temp.substring(start, end);
            } else {
                break;
            }
        }
        return temp;
    }

    /**
     * Collects all leaf values from a potentially nested list structure.
     * This preserves user data when converting between list types.
     */
    public static void collectLeafValues(Expression expr, List<Expression> accumulator) {
        if (expr == null) return;

        boolean isContainer = false;

        if (expr instanceof ClassInstanceCreation) {
            ClassInstanceCreation cic = (ClassInstanceCreation) expr;
            if (cic.getType().toString().startsWith("ArrayList") && !cic.arguments().isEmpty()) {
                isContainer = true;
                collectLeafValues((Expression) cic.arguments().get(0), accumulator);
            }
        } else if (expr instanceof MethodInvocation) {
            MethodInvocation mi = (MethodInvocation) expr;
            String name = mi.getName().getIdentifier();
            if (name.equals("asList") || name.equals("of")) {
                isContainer = true;
                for (Object arg : mi.arguments()) {
                    collectLeafValues((Expression) arg, accumulator);
                }
            }
        } else if (expr instanceof ArrayInitializer) {
            isContainer = true;
            for (Object e : ((ArrayInitializer) expr).expressions()) {
                collectLeafValues((Expression) e, accumulator);
            }
        } else if (expr instanceof ArrayCreation) {
            isContainer = true;
            if (((ArrayCreation) expr).getInitializer() != null) {
                collectLeafValues(((ArrayCreation) expr).getInitializer(), accumulator);
            }
        }

        if (!isContainer) {
            accumulator.add(expr);
        }
    }

    /**
     * Checks if two types have the same leaf type (ignoring list wrappers).
     */
    public static boolean haveSameLeafType(String type1, String type2) {
        String leaf1 = getLeafType(type1);
        String leaf2 = getLeafType(type2);
        return leaf1.equals(leaf2);
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\project\LibraryManager.java
=================================================================================

package com.botmaker.project;

import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.HashMap;
import java.util.Map;

public class LibraryManager {

    // Map of Relative Path -> Source Code Content
    private static final Map<String, String> LIBRARY_FILES = new HashMap<>();

    // Load the library definition
    static {
        // 1. CAPTURE
        loadSource("capture/Clicker.java");
        loadSource("capture/GDI32.java");
        loadSource("capture/ImageDisplay.java");
        loadSource("capture/ScreenCapture.java");
        loadSource("capture/User32.java");
        loadSource("capture/WindowFinder.java");
        loadSource("capture/WindowInfo.java");

        // 2. EMULATOR
        loadSource("emulator/AdbHelper.java");
        loadSource("emulator/BlueStacksConfig.java");
        loadSource("emulator/BlueStacksEmulator.java");
        loadSource("emulator/BlueStacksInstance.java");
        loadSource("emulator/BlueStacksInstanceManager.java");
        loadSource("emulator/Emulator.java");

        // 3. INSPECTOR
        loadSource("inspector/RegistryInspector.java");

        // 4. INTERACTION
        loadSource("interaction/GameInteractor.java");
        loadSource("interaction/GameType.java");

        // 5. OPENCV
        loadSource("opencv/MatchResult.java");
        loadSource("opencv/MatType.java");
        loadSource("opencv/OpencvManager.java");
        loadSource("opencv/Template.java");

        // 6. LIBRARY ROOT
        loadSource("Main.java"); // The library Main class if needed
    }

    /**
     * Loads source code into memory.
     * Priority 1: Read from current IntelliJ Project (Dev Mode)
     * Priority 2: Read from JAR Resources (Production Mode)
     */
    private static void loadSource(String relativePath) {
        String content = null;
        try {
            // DEV MODE: Try reading directly from your source folder
            // This assumes BotMaker is running from within the project root
            Path devPath = Paths.get("src/main/java/com/botmaker/library", relativePath);
            if (Files.exists(devPath)) {
                content = Files.readString(devPath);
            } else {
                // PROD MODE: Read from classpath resources
                // You must ensure your build process copies these java files to src/main/resources/library_src/
                String resourcePath = "/library_src/" + relativePath;
                InputStream stream = LibraryManager.class.getResourceAsStream(resourcePath);
                if (stream != null) {
                    content = new String(stream.readAllBytes(), StandardCharsets.UTF_8);
                }
            }

            if (content != null) {
                // Correct the package declaration if necessary, though usually it stays com.botmaker.library...
                LIBRARY_FILES.put(relativePath, content);
            } else {
                System.err.println("LibraryManager: Could not find source for " + relativePath);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * Installs the library source code into the user's project.
     */
    public void installLibrary(Path projectPath) {
        try {
            Path libRoot = projectPath.resolve("src/main/java/com/botmaker/library");

            for (Map.Entry<String, String> entry : LIBRARY_FILES.entrySet()) {
                Path targetFile = libRoot.resolve(entry.getKey());
                Files.createDirectories(targetFile.getParent());

                // Only write if different to preserve file modification times if possible
                if (!Files.exists(targetFile) || !Files.readString(targetFile).equals(entry.getValue())) {
                    Files.writeString(targetFile, entry.getValue());
                }
            }
        } catch (IOException e) {
            System.err.println("Failed to install library: " + e.getMessage());
        }
    }

    /**
     * Checks if user modified library files and repairs them.
     * Returns true if repairs were made.
     */
    public boolean verifyAndRepair(Path projectPath) {
        Path libRoot = projectPath.resolve("src/main/java/com/botmaker/library");
        boolean repaired = false;

        try {
            for (Map.Entry<String, String> entry : LIBRARY_FILES.entrySet()) {
                Path targetFile = libRoot.resolve(entry.getKey());
                String expected = entry.getValue();

                if (!Files.exists(targetFile)) {
                    System.out.println("Restoring missing library file: " + entry.getKey());
                    Files.createDirectories(targetFile.getParent());
                    Files.writeString(targetFile, expected);
                    repaired = true;
                } else {
                    // Simple string comparison.
                    // In production, you might ignore whitespace or use a hash.
                    String current = Files.readString(targetFile);
                    // Normalize line endings
                    if (!current.replace("\r\n", "\n").trim().equals(expected.replace("\r\n", "\n").trim())) {
                        System.out.println("Repairing modified library file: " + entry.getKey());
                        Files.writeString(targetFile, expected);
                        repaired = true;
                    }
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
        return repaired;
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\project\ProjectConfig.java
=================================================================================

package com.botmaker.project;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.List;

/**
 * Configuration for BotMaker projects, stored in projects/.botmaker-config.json
 */
public class ProjectConfig {

    private static final Path CONFIG_FILE = Paths.get("projects/.botmaker-config.json");
    private static final Gson GSON = new GsonBuilder()
            .setPrettyPrinting()
            .create();

    private String lastOpenedProject;
    private List<ProjectEntry> recentProjects;

    public ProjectConfig() {
        this.recentProjects = new ArrayList<>();
    }

    public String getLastOpenedProject() {
        return lastOpenedProject;
    }

    public void setLastOpenedProject(String projectName) {
        this.lastOpenedProject = projectName;
    }

    public List<ProjectEntry> getRecentProjects() {
        return recentProjects;
    }

    public void addRecentProject(String projectName) {
        // Remove if already exists
        recentProjects.removeIf(p -> p.getName().equals(projectName));

        // Add at the beginning
        ProjectEntry entry = new ProjectEntry(projectName);
        recentProjects.add(0, entry);

        // Keep only last 10 projects
        if (recentProjects.size() > 10) {
            recentProjects = recentProjects.subList(0, 10);
        }
    }

    /**
     * Loads the configuration from disk
     */
    public static ProjectConfig load() {
        try {
            if (Files.exists(CONFIG_FILE)) {
                String json = Files.readString(CONFIG_FILE);
                return GSON.fromJson(json, ProjectConfig.class);
            }
        } catch (Exception e) {
            System.err.println("Failed to load project config: " + e.getMessage());
        }

        // Return default config if file doesn't exist or can't be read
        return new ProjectConfig();
    }

    /**
     * Saves the configuration to disk
     */
    public void save() {
        try {
            // Ensure projects directory exists
            Files.createDirectories(CONFIG_FILE.getParent());

            // Write JSON
            String json = GSON.toJson(this);
            Files.writeString(CONFIG_FILE, json);
        } catch (IOException e) {
            System.err.println("Failed to save project config: " + e.getMessage());
        }
    }

    /**
     * Updates the last opened project and saves
     */
    public static void updateLastOpened(String projectName) {
        ProjectConfig config = load();
        config.setLastOpenedProject(projectName);
        config.addRecentProject(projectName);
        config.save();
    }

    /**
     * Gets the last opened project name, or null if none
     */
    public static String getLastOpened() {
        ProjectConfig config = load();
        return config.getLastOpenedProject();
    }

    /**
     * Represents a recent project entry
     */
    public static class ProjectEntry {
        private String name;
        private String lastOpened; // ISO-8601 timestamp string

        public ProjectEntry() {
            // For Gson
        }

        public ProjectEntry(String name) {
            this.name = name;
            this.lastOpened = LocalDateTime.now().format(DateTimeFormatter.ISO_LOCAL_DATE_TIME);
        }

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }

        public String getLastOpened() {
            return lastOpened;
        }

        public void setLastOpened(String lastOpened) {
            this.lastOpened = lastOpened;
        }

        /**
         * Gets the last opened time as LocalDateTime
         */
        public LocalDateTime getLastOpenedDateTime() {
            try {
                return LocalDateTime.parse(lastOpened, DateTimeFormatter.ISO_LOCAL_DATE_TIME);
            } catch (Exception e) {
                return LocalDateTime.now();
            }
        }
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\project\ProjectCreator.java
=================================================================================

package com.botmaker.project;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

/**
 * Handles creation of new Gradle projects with proper structure
 */
public class ProjectCreator {

    private static final Path PROJECTS_ROOT = Paths.get("projects");

    private final LibraryManager libraryManager = new LibraryManager();
    /**
     * Creates a new Gradle project with standard structure
     *
     * @param projectName The name of the project to create
     * @throws IOException if project creation fails
     * @throws IllegalArgumentException if project name is invalid or already exists
     */
    public void createProject(String projectName) throws IOException {
        // Validate project name
        validateProjectName(projectName);

        // Check if project already exists
        if (projectExists(projectName)) {
            throw new IllegalArgumentException("Project '" + projectName + "' already exists");
        }

        // Create project structure
        Path projectPath = PROJECTS_ROOT.resolve(projectName);
        createProjectStructure(projectPath, projectName);

        System.out.println("Successfully created project: " + projectName);
    }

    /**
     * Validates the project name
     */
    private void validateProjectName(String projectName) {
        if (projectName == null || projectName.trim().isEmpty()) {
            throw new IllegalArgumentException("Project name cannot be empty");
        }

        // Check for valid Java class name (starts with letter, contains only letters/digits)
        if (!projectName.matches("^[A-Z][a-zA-Z0-9]*$")) {
            throw new IllegalArgumentException(
                    "Project name must start with an uppercase letter and contain only letters and numbers"
            );
        }

        // Check length
        if (projectName.length() < 2 || projectName.length() > 50) {
            throw new IllegalArgumentException("Project name must be between 2 and 50 characters");
        }
    }

    /**
     * Checks if a project already exists
     */
    public boolean projectExists(String projectName) {
        Path projectPath = PROJECTS_ROOT.resolve(projectName);
        return Files.exists(projectPath);
    }

    /**
     * Creates the complete project structure
     */
    private void createProjectStructure(Path projectPath, String projectName) throws IOException {
        // Create directories
        Files.createDirectories(projectPath);

        String packageName = projectName.toLowerCase();
        Path srcPath = projectPath.resolve("src/main/java/com/" + packageName);
        Files.createDirectories(srcPath);

        Path gradlePath = projectPath.resolve("gradle/wrapper");
        Files.createDirectories(gradlePath);

        // Create build.gradle
        createBuildGradle(projectPath, projectName);

        // Create settings.gradle
        createSettingsGradle(projectPath, projectName);

        // Create gradle-wrapper.properties
        createGradleWrapperProperties(gradlePath);

        // Create gradlew scripts
        createGradlewScripts(projectPath);

        // Create main Java file
        createMainJavaFile(srcPath, projectName, packageName);

        // 2. Install Native Library
        libraryManager.installLibrary(projectPath);

        // 3. Create main Java file
        createMainJavaFile(srcPath, projectName, packageName);
    }

    /**
     * Creates build.gradle file
     */
    private void createBuildGradle(Path projectPath, String projectName) throws IOException {
        String packageName = projectName.toLowerCase();
                String content = String.format("""
            plugins {
                id 'java'
                id 'application'
            }
            
            group = 'com.%s'
            version = '0.0.1-SNAPSHOT'
            
            repositories {
                mavenCentral()
                google() // For Android ddmlib
            }
            
            dependencies {
                // JNA for Windows Interaction
                implementation 'net.java.dev.jna:jna:5.13.0'
                implementation 'net.java.dev.jna:jna-platform:5.13.0'
            
                // OpenCV
                implementation 'org.bytedeco:opencv-platform:4.7.0-1.5.9'
            
                // JSON processing
                implementation 'com.fasterxml.jackson.core:jackson-databind:2.15.2'
            
                // ADB Connection (ddmlib)
                // Note: You may need to adjust version based on availability
                implementation 'com.android.tools.ddms:ddmlib:30.0.0'
            }
            
            application {
                mainClass = 'com.%s.%s'
            }
            
            java {
                sourceCompatibility = JavaVersion.VERSION_17
                targetCompatibility = JavaVersion.VERSION_17
            }
            """, packageName, packageName, projectName);

        Files.writeString(projectPath.resolve("build.gradle"), content);
    }

    /**
     * Creates settings.gradle file
     */
    private void createSettingsGradle(Path projectPath, String projectName) throws IOException {
        String content = String.format("""
            
            pluginManagement {
                repositories {
                    gradlePluginPortal()
                    mavenCentral()
                }
            }
            
            
            
            rootProject.name = '%s'
            
            """, projectName);

        Files.writeString(projectPath.resolve("settings.gradle"), content);
    }

    /**
     * Creates gradle-wrapper.properties file
     */
    private void createGradleWrapperProperties(Path gradlePath) throws IOException {
        String content = """
            distributionBase=GRADLE_USER_HOME
            distributionPath=wrapper/dists
            distributionUrl=https\\://services.gradle.org/distributions/gradle-9.1.0-bin.zip
            networkTimeout=10000
            validateDistributionUrl=true
            zipStoreBase=GRADLE_USER_HOME
            zipStorePath=wrapper/dists
            """;

        Files.writeString(gradlePath.resolve("gradle-wrapper.properties"), content);
    }

    /**
     * Creates gradlew scripts (Unix and Windows)
     */
    private void createGradlewScripts(Path projectPath) throws IOException {
        // Create Unix gradlew script
        String gradlewUnix = """
            #!/bin/sh
            
            #
            # Copyright © 2015 the original authors.
            #
            # Licensed under the Apache License, Version 2.0 (the "License");
            # you may not use this file except in compliance with the License.
            # You may obtain a copy of the License at
            #
            #      https://www.apache.org/licenses/LICENSE-2.0
            #
            # Unless required by applicable law or agreed to in writing, software
            # distributed under the License is distributed on an "AS IS" BASIS,
            # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
            # See the License for the specific language governing permissions and
            # limitations under the License.
            #
            
            ##############################################################################
            #
            #   Gradle start up script for POSIX generated by Gradle.
            #
            ##############################################################################
            
            # Attempt to set APP_HOME
            app_path=$0
            
            APP_HOME=${app_path%"${app_path##*/}"}
            APP_BASE_NAME=${0##*/}
            APP_HOME=$( cd -P "${APP_HOME:-./}" > /dev/null && printf '%s\\n' "$PWD" ) || exit
            
            DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'
            
            JAVACMD=java
            if [ -n "$JAVA_HOME" ] ; then
                if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
                    JAVACMD=$JAVA_HOME/jre/sh/java
                else
                    JAVACMD=$JAVA_HOME/bin/java
                fi
            fi
            
            exec "$JAVACMD" "$@"
            """;

        Path gradlewPath = projectPath.resolve("gradlew");
        Files.writeString(gradlewPath, gradlewUnix);

        // Make it executable on Unix systems
        try {
            gradlewPath.toFile().setExecutable(true);
        } catch (Exception e) {
            System.err.println("Warning: Could not set gradlew as executable: " + e.getMessage());
        }

        // Create Windows gradlew.bat script
        String gradlewBat = """
            @rem
            @rem Copyright 2015 the original author or authors.
            @rem
            @rem Licensed under the Apache License, Version 2.0 (the "License");
            @rem you may not use this file except in compliance with the License.
            @rem You may obtain a copy of the License at
            @rem
            @rem      https://www.apache.org/licenses/LICENSE-2.0
            @rem
            @rem Unless required by applicable law or agreed to in writing, software
            @rem distributed under the License is distributed on an "AS IS" BASIS,
            @rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
            @rem See the License for the specific language governing permissions and
            @rem limitations under the License.
            @rem
            
            @if "%DEBUG%"=="" @echo off
            
            set DIRNAME=%~dp0
            if "%DIRNAME%"=="" set DIRNAME=.
            set APP_BASE_NAME=%~n0
            
            set DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"
            
            set JAVA_EXE=java.exe
            if defined JAVA_HOME goto findJavaFromJavaHome
            
            %JAVA_EXE% -version >NUL 2>&1
            if %ERRORLEVEL% equ 0 goto execute
            
            :findJavaFromJavaHome
            set JAVA_HOME=%JAVA_HOME:"=%
            set JAVA_EXE=%JAVA_HOME%/bin/java.exe
            
            :execute
            "%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -jar "%DIRNAME%\\gradle\\wrapper\\gradle-wrapper.jar" %*
            
            :end
            if %ERRORLEVEL% equ 0 goto mainEnd
            
            :fail
            exit /b %ERRORLEVEL%
            
            :mainEnd
            """;

        Files.writeString(projectPath.resolve("gradlew.bat"), gradlewBat);
    }

    /**
     * Creates the main Java source file
     */
    private void createMainJavaFile(Path srcPath, String projectName, String packageName) throws IOException {
        String content = String.format("""
            package com.%s;
            
            public class %s {
                public static void main(String[] args) {
                    System.out.println("Hello from %s!");
                }
            }
            """, packageName, projectName, projectName);

        Files.writeString(srcPath.resolve(projectName + ".java"), content);
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\project\ProjectFile.java
=================================================================================

package com.botmaker.project;

import org.eclipse.jdt.core.dom.CompilationUnit;
import java.nio.file.Path;

public class ProjectFile {
    private final Path path;
    private String content;
    private CompilationUnit ast;
    private final String className; // e.g., "Movement"

    public ProjectFile(Path path, String content) {
        this.path = path;
        this.content = content;
        String filename = path.getFileName().toString();
        this.className = filename.substring(0, filename.lastIndexOf('.'));
    }

    public Path getPath() { return path; }

    public String getContent() { return content; }
    public void setContent(String content) { this.content = content; }

    public CompilationUnit getAst() { return ast; }
    public void setAst(CompilationUnit ast) { this.ast = ast; }

    public String getClassName() { return className; }

    public String getUri() {
        return path.toUri().toString();
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\project\ProjectInfo.java
=================================================================================

package com.botmaker.project;

import java.nio.file.Path;
import java.time.LocalDateTime;

/**
 * Information about a project
 */
public class ProjectInfo {
    private final String name;
    private final Path projectPath;
    private final LocalDateTime lastModified;

    public ProjectInfo(String name, Path projectPath, LocalDateTime lastModified) {
        this.name = name;
        this.projectPath = projectPath;
        this.lastModified = lastModified;
    }

    public String getName() {
        return name;
    }

    public Path getProjectPath() {
        return projectPath;
    }

    public LocalDateTime getLastModified() {
        return lastModified;
    }

    @Override
    public String toString() {
        return name;
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\project\ProjectManager.java
=================================================================================

package com.botmaker.project;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.attribute.FileTime;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Stream;

/**
 * Manages project discovery and listing
 */
public class ProjectManager {

    private static final Path PROJECTS_ROOT = Paths.get("projects");

    /**
     * Lists all available projects
     */
    public List<ProjectInfo> listProjects() {
        List<ProjectInfo> projects = new ArrayList<>();

        if (!Files.exists(PROJECTS_ROOT)) {
            return projects;
        }

        try (Stream<Path> paths = Files.list(PROJECTS_ROOT)) {
            paths.filter(Files::isDirectory)
                    .filter(this::isValidProject)
                    .forEach(projectPath -> {
                        try {
                            String projectName = projectPath.getFileName().toString();
                            FileTime lastModified = Files.getLastModifiedTime(projectPath);
                            LocalDateTime modifiedDate = LocalDateTime.ofInstant(
                                    lastModified.toInstant(),
                                    ZoneId.systemDefault()
                            );
                            projects.add(new ProjectInfo(projectName, projectPath, modifiedDate));
                        } catch (IOException e) {
                            System.err.println("Error reading project: " + projectPath);
                        }
                    });
        } catch (IOException e) {
            System.err.println("Error listing projects: " + e.getMessage());
        }

        return projects;
    }

    /**
     * Checks if a directory is a valid project
     * (has src/main/java structure and build.gradle)
     */
    private boolean isValidProject(Path projectPath) {
        Path srcPath = projectPath.resolve("src/main/java");
        Path buildGradle = projectPath.resolve("build.gradle");
        boolean isValid = Files.exists(srcPath) && Files.exists(buildGradle);

        // Debug output
        System.out.println("Checking project: " + projectPath);
        System.out.println("  src/main/java exists: " + Files.exists(srcPath));
        System.out.println("  build.gradle exists: " + Files.exists(buildGradle));
        System.out.println("  Valid: " + isValid);

        return isValid;
    }

    /**
     * Gets the source file path for a project
     */
    public Path getSourceFilePath(String projectName) {
        String packageName = projectName.toLowerCase();
        return PROJECTS_ROOT
                .resolve(projectName)
                .resolve("src/main/java/com")
                .resolve(packageName)
                .resolve(projectName + ".java");
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\runtime\CodeExecutionService.java
=================================================================================

package com.botmaker.runtime;

import com.botmaker.config.ApplicationConfig;
import com.botmaker.project.ProjectFile;
import com.botmaker.state.ApplicationState;
import com.botmaker.validation.DiagnosticsManager;
import javafx.application.Platform;

import java.io.IOException;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.function.Consumer;

public class CodeExecutionService {

    private final Consumer<String> appendOutputConsumer;
    private final Runnable clearOutputConsumer;
    private final Consumer<String> setOutputConsumer;
    private final Consumer<String> statusConsumer;
    private final DiagnosticsManager diagnosticsManager;
    private final ApplicationConfig config;
    private final ApplicationState state;

    private volatile Process currentRunningProcess;
    private final AtomicBoolean isRunning = new AtomicBoolean(false);

    private static final int MAX_UI_BUFFER_SIZE = 4096;
    private static final int UI_UPDATE_RATE_MS = 100;

    public CodeExecutionService(
            Consumer<String> appendOutputConsumer,
            Runnable clearOutputConsumer,
            Consumer<String> setOutputConsumer,
            Consumer<String> statusConsumer,
            DiagnosticsManager diagnosticsManager,
            ApplicationConfig config,
            ApplicationState state) {
        this.appendOutputConsumer = appendOutputConsumer;
        this.clearOutputConsumer = clearOutputConsumer;
        this.setOutputConsumer = setOutputConsumer;
        this.statusConsumer = statusConsumer;
        this.diagnosticsManager = diagnosticsManager;
        this.config = config;
        this.state = state;
    }

    public void runCode(String currentEditorCode) {
        if (diagnosticsManager.hasErrors()) {
            Platform.runLater(() -> statusConsumer.accept("Run aborted due to errors."));
            return;
        }

        if (isRunning.get()) {
            Platform.runLater(() -> statusConsumer.accept("Program is already running. Stop it first."));
            return;
        }

        try {
            Path compiledOutputPath = config.getCompiledOutputPath();

            // 1. Compile (Blocking)
            if (!compileAndWait(currentEditorCode, compiledOutputPath)) {
                Platform.runLater(() -> statusConsumer.accept("Run aborted due to compilation failure."));
                return;
            }

            // 2. Setup Execution
            Platform.runLater(() -> {
                statusConsumer.accept("Running... (Press Stop to terminate)");
                clearOutputConsumer.run();
            });

            isRunning.set(true);

            String classPath = compiledOutputPath.toString();
            String className = config.getMainClassName();
            String javaExecutable = config.getJavaExecutable();

            ProcessBuilder pb = new ProcessBuilder(javaExecutable, "-cp", classPath, className);
            currentRunningProcess = pb.start();

            // 3. Start IO Readers and keep references to them
            Thread outReader = startLeakyBucketReader(currentRunningProcess.getInputStream());
            Thread errReader = startLeakyBucketReader(currentRunningProcess.getErrorStream());

            // 4. Wait for process to exit
            int exitCode = currentRunningProcess.waitFor();

            // 5. CRITICAL FIX: Wait for readers to drain the stream before stopping UI updates
            try {
                outReader.join(1000); // Wait up to 1s for streams to flush
                errReader.join(1000);
            } catch (InterruptedException ignored) {}

            Platform.runLater(() -> {
                if (exitCode == 0) statusConsumer.accept("Program completed successfully.");
                else if (exitCode == 143 || exitCode == 130 || exitCode == 1 || exitCode == -1) statusConsumer.accept("Program stopped.");
                else statusConsumer.accept("Program exited with code: " + exitCode);
            });

        } catch (InterruptedException e) {
            Platform.runLater(() -> statusConsumer.accept("Program stopped by user."));
        } catch (Exception e) {
            e.printStackTrace();
            Platform.runLater(() -> statusConsumer.accept("Error: " + e.getMessage()));
        } finally {
            isRunning.set(false); // NOW safe to stop UI updates
            currentRunningProcess = null;
        }
    }

    public void compileCode(String code) {
        new Thread(() -> {
            try {
                Platform.runLater(() -> setOutputConsumer.accept("Saving and compiling..."));
                Path compiledOutputPath = config.getCompiledOutputPath();
                if (compileAndWait(code, compiledOutputPath)) {
                    Platform.runLater(() -> setOutputConsumer.accept("Compilation successful."));
                }
            } catch (IOException | InterruptedException e) {
                Platform.runLater(() -> setOutputConsumer.accept("Compilation Error: " + e.getMessage()));
            }
        }).start();
    }

    public boolean compileAndWait(String currentActiveCode, Path compiledOutputPath) throws IOException, InterruptedException {
        // Sync memory
        state.setCurrentCode(currentActiveCode);

        // Save ALL files to disk
        for (ProjectFile file : state.getAllFiles()) {
            Path path = file.getPath();
            if (path != null) {
                Files.createDirectories(path.getParent());
                Files.writeString(path, file.getContent());
            }
        }

        Files.createDirectories(compiledOutputPath);

        String javacExecutable = Paths.get(System.getProperty("java.home"), "bin", "javac").toString();

        // Calculate source root (3 levels up from Main file: com/pkg/Main.java -> src/main/java)
        Path sourcePathRoot = config.getSourceFilePath().getParent().getParent().getParent();

        ProcessBuilder pb = new ProcessBuilder(
                javacExecutable,
                "-g",
                "-d", compiledOutputPath.toString(),
                "-sourcepath", sourcePathRoot.toString(),
                config.getSourceFilePath().toString()
        );

        Process process = pb.start();

        String errors = new String(process.getErrorStream().readAllBytes());
        int exitCode = process.waitFor();

        if (exitCode != 0) {
            Platform.runLater(() -> setOutputConsumer.accept("Compilation Failed:\n" + errors));
            return false;
        }
        return true;
    }

    public void stopRunningProgram() {
        if (currentRunningProcess != null && currentRunningProcess.isAlive()) {
            currentRunningProcess.destroyForcibly();
        }
    }

    public boolean isRunning() { return isRunning.get(); }

    // CHANGED: Returns the Thread so we can join() it
    private Thread startLeakyBucketReader(InputStream inputStream) {
        final StringBuilder buffer = new StringBuilder();
        final ScheduledExecutorService uiUpdater = Executors.newSingleThreadScheduledExecutor();

        // UI Pusher Loop
        uiUpdater.scheduleAtFixedRate(() -> {
            // Only stop if process is dead AND buffer is empty
            if (!isRunning.get() && buffer.length() == 0) {
                uiUpdater.shutdown();
                return;
            }

            String textToSend = "";
            synchronized (buffer) {
                if (buffer.length() > 0) {
                    textToSend = buffer.toString();
                    buffer.setLength(0);
                }
            }

            if (!textToSend.isEmpty()) {
                String finalTx = textToSend;
                Platform.runLater(() -> appendOutputConsumer.accept(finalTx));
            }
        }, UI_UPDATE_RATE_MS, UI_UPDATE_RATE_MS, TimeUnit.MILLISECONDS);

        // Stream Reader Thread
        Thread readerThread = new Thread(() -> {
            byte[] readBuf = new byte[1024];
            int len;
            try {
                while ((len = inputStream.read(readBuf)) != -1) {
                    synchronized (buffer) {
                        if (buffer.length() < MAX_UI_BUFFER_SIZE) {
                            buffer.append(new String(readBuf, 0, len, StandardCharsets.UTF_8));
                        }
                    }
                }
            } catch (IOException ignored) {
            } finally {
                // Do not shut down UI updater here; let the scheduler decide based on buffer/isRunning state
            }
        }, "Leaky-Reader");

        readerThread.start();
        return readerThread;
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\services\CodeEditorService.java
=================================================================================

package com.botmaker.services;

import com.botmaker.blocks.MainBlock;
import com.botmaker.config.ApplicationConfig;
import com.botmaker.core.AbstractCodeBlock;
import com.botmaker.core.CodeBlock;
import com.botmaker.events.CoreApplicationEvents;
import com.botmaker.events.EventBus;
import com.botmaker.lsp.CompletionContext;
import com.botmaker.parser.AstRewriter;
import com.botmaker.parser.BlockFactory;
import com.botmaker.parser.CodeEditor;
import com.botmaker.project.ProjectFile;
import com.botmaker.state.ApplicationState;
import com.botmaker.state.HistoryManager;
import com.botmaker.ui.BlockDragAndDropManager;
import com.botmaker.validation.DiagnosticsManager;
import javafx.application.Platform;

import java.nio.file.Files;
import java.nio.file.Path;
import java.util.stream.Stream;

public class CodeEditorService {

    private final ApplicationConfig config;
    private final ApplicationState state;
    private final EventBus eventBus;
    private final BlockFactory blockFactory;
    private final AstRewriter astRewriter;
    private final CodeEditor codeEditor;
    private final BlockDragAndDropManager dragAndDropManager;
    private final LanguageServerService languageServerService;
    private final DiagnosticsManager diagnosticsManager;
    private final HistoryManager historyManager;
    private boolean isRestoringHistory = false;

    public CodeEditorService(
            ApplicationConfig config,
            ApplicationState state,
            EventBus eventBus,
            BlockFactory blockFactory,
            AstRewriter astRewriter,
            BlockDragAndDropManager dragAndDropManager,
            LanguageServerService languageServerService,
            DiagnosticsManager diagnosticsManager) {
        this.config = config;
        this.state = state;
        this.eventBus = eventBus;
        this.blockFactory = blockFactory;
        this.astRewriter = astRewriter;
        this.dragAndDropManager = dragAndDropManager;
        this.languageServerService = languageServerService;
        this.diagnosticsManager = diagnosticsManager;
        this.historyManager = new HistoryManager();
        this.codeEditor = new CodeEditor(state, eventBus, astRewriter, blockFactory);
        setupEventHandlers();
    }

    private void setupEventHandlers() {
        eventBus.subscribe(CoreApplicationEvents.UIRefreshRequestedEvent.class, event ->
                Platform.runLater(() -> refreshUI(event.getCode())), false);

        eventBus.subscribe(CoreApplicationEvents.BreakpointToggledEvent.class,
                this::handleBreakpointToggle, false);

        eventBus.subscribe(CoreApplicationEvents.CodeUpdatedEvent.class, event -> {
            handleCodeUpdateForHistory(event);
            if (!isRestoringHistory) {
                Platform.runLater(() -> refreshUI(event.getNewCode()));
            }
        }, false);

        eventBus.subscribe(CoreApplicationEvents.UndoRequestedEvent.class,
                e -> undo(), false);

        eventBus.subscribe(CoreApplicationEvents.RedoRequestedEvent.class,
                e -> redo(), false);
    }

    private void handleCodeUpdateForHistory(CoreApplicationEvents.CodeUpdatedEvent event) {
        if (isRestoringHistory) return;
        String previousCode = event.getPreviousCode();
        if (previousCode != null && !previousCode.isEmpty()) {
            historyManager.pushState(previousCode);
            broadcastHistoryState();
        }
    }

    private void undo() {
        if (!historyManager.canUndo()) return;
        applyHistoryState(historyManager.undo(state.getCurrentCode()));
    }

    private void redo() {
        if (!historyManager.canRedo()) return;
        applyHistoryState(historyManager.redo(state.getCurrentCode()));
    }

    private void applyHistoryState(String code) {
        isRestoringHistory = true;
        try {
            eventBus.publish(new CoreApplicationEvents.CodeUpdatedEvent(code, state.getCurrentCode()));
            broadcastHistoryState();
        } finally {
            isRestoringHistory = false;
        }
    }

    private void broadcastHistoryState() {
        eventBus.publish(new CoreApplicationEvents.HistoryStateChangedEvent(historyManager.canUndo(), historyManager.canRedo()));
    }

    private void handleBreakpointToggle(CoreApplicationEvents.BreakpointToggledEvent event) {
        if (event.isEnabled()) {
            state.addBreakpoint(event.getBlock().getId());
        } else {
            state.removeBreakpoint(event.getBlock().getId());
        }
    }

    // --- FIX: LOAD ALL FILES INCLUDING LIBRARY FILES ---
    public void loadInitialCode() {
        try {
            Path mainFile = config.getSourceFilePath();

            // Get the source root (src/main/java)
            Path sourceRoot = mainFile.getParent();
            while (sourceRoot != null && !sourceRoot.getFileName().toString().equals("java")) {
                sourceRoot = sourceRoot.getParent();
            }

            if (sourceRoot == null) {
                sourceRoot = mainFile.getParent();
            }

            // Load ALL java files recursively, including library files
            loadFilesRecursively(sourceRoot);

            // Set Active File to Main and refresh UI
            switchToFile(mainFile);

        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * Recursively loads all .java files in the directory tree
     */
    private void loadFilesRecursively(Path directory) {
        if (!Files.exists(directory) || !Files.isDirectory(directory)) {
            return;
        }

        try (Stream<Path> paths = Files.walk(directory)) {
            paths.filter(p -> p.toString().endsWith(".java"))
                    .forEach(path -> {
                        try {
                            // Check if already loaded
                            boolean alreadyLoaded = state.getAllFiles().stream()
                                    .anyMatch(f -> f.getPath().equals(path));

                            if (!alreadyLoaded) {
                                String content = Files.readString(path);
                                ProjectFile pf = new ProjectFile(path, content);
                                state.addFile(pf);

                                // Open file in Language Server
                                languageServerService.openFile(path, content);
                            }
                        } catch (Exception e) {
                            System.err.println("Error loading file: " + path);
                            e.printStackTrace();
                        }
                    });
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public void switchToFile(Path path) {
        ProjectFile file = state.getAllFiles().stream()
                .filter(f -> f.getPath().equals(path))
                .findFirst().orElse(null);

        if (file == null) {
            System.err.println("File not found in state: " + path);
            return;
        }

        state.setActiveFile(path);
        state.setDocUri(file.getUri());

        refreshUI(file.getContent());
    }

    public void createFile(String className) {
        try {
            String packageName = config.getMainClassName().substring(0, config.getMainClassName().lastIndexOf('.'));
            Path dir = config.getSourceFilePath().getParent();
            Path newPath = dir.resolve(className + ".java");

            String template = "package " + packageName + ";\n\n" +
                    "public class " + className + " {\n" +
                    "    // Add functions here\n" +
                    "    public static void action() {\n" +
                    "        System.out.println(\"Action from " + className + "\");\n" +
                    "    }\n" +
                    "}";

            Files.writeString(newPath, template);
            ProjectFile pf = new ProjectFile(newPath, template);
            state.addFile(pf);

            languageServerService.openFile(newPath, template);
            switchToFile(newPath);

        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private void refreshUI(String javaCode) {
        state.setCurrentCode(javaCode);
        state.clearNodeToBlockMap();

        if (diagnosticsManager != null) {
            diagnosticsManager.updateSource(state.getMutableNodeToBlockMap(), javaCode);
        }

        AbstractCodeBlock rootBlock = blockFactory.convert(
                javaCode,
                state.getMutableNodeToBlockMap(),
                dragAndDropManager
        );

        for (CodeBlock block : state.getNodeToBlockMap().values()) {
            if (state.hasBreakpoint(block.getId())) {
                block.setBreakpoint(true);
            }
        }

        state.setCompilationUnit(blockFactory.getCompilationUnit());
        eventBus.publish(new CoreApplicationEvents.UIBlocksUpdatedEvent(rootBlock));

        if (state.getActiveFile() != null) {
            String fileName = state.getActiveFile().getPath().getFileName().toString();
            // Add [Lib] indicator for library files
            if (state.getActiveFile().getPath().toString().contains("com/botmaker/library") ||
                    state.getActiveFile().getPath().toString().contains("com\\botmaker\\library")) {
                fileName += " [Library - Read Only]";
            }
            eventBus.publish(new CoreApplicationEvents.StatusMessageEvent("Loaded: " + fileName));
        }
    }

    public CompletionContext createCompletionContext() {
        return new CompletionContext(
                codeEditor,
                languageServerService.getServer(),
                state.getDocUri(),
                state.getCurrentCode(),
                state.getDocVersion(),
                dragAndDropManager,
                state
        );
    }

    public CodeEditor getCodeEditor() { return codeEditor; }
    public BlockFactory getBlockFactory() { return blockFactory; }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\services\DebuggingService.java
=================================================================================

package com.botmaker.services;

import com.botmaker.config.ApplicationConfig;
import com.botmaker.config.Constants;
import com.botmaker.core.CodeBlock;
import com.botmaker.core.StatementBlock;
import com.botmaker.events.CoreApplicationEvents;
import com.botmaker.events.EventBus;
import com.botmaker.parser.BlockFactory;
import com.botmaker.runtime.CodeExecutionService;
import com.botmaker.state.ApplicationState;
import com.sun.jdi.*;
import com.sun.jdi.connect.AttachingConnector;
import com.sun.jdi.connect.Connector;
import com.sun.jdi.event.*;
import com.sun.jdi.request.BreakpointRequest;
import com.sun.jdi.request.ClassPrepareRequest;
import com.sun.jdi.request.EventRequestManager;
import com.sun.jdi.request.StepRequest;
import javafx.application.Platform;
import org.eclipse.jdt.core.dom.CompilationUnit;

import java.io.IOException;
import java.io.InputStream;
import java.net.ServerSocket;
import java.util.*;
import java.util.concurrent.CountDownLatch;

/**
 * Handles the entire debugging lifecycle:
 * 1. Mapping AST nodes to line numbers.
 * 2. Launching the JVM in debug mode.
 * 3. Attaching via JDI (Java Debug Interface).
 * 4. Managing Breakpoints, Stepping, and Resuming.
 */
public class DebuggingService {

    // Console Coloring for internal logs
    private static final String ANSI_RESET = "\u001B[0m";
    private static final String ANSI_BLUE = "\u001B[34m";
    private static final String ANSI_GREEN = "\u001B[32m";
    private static final String ANSI_RED = "\u001B[31m";

    private final ApplicationState state;
    private final EventBus eventBus;
    private final CodeExecutionService codeExecutionService;
    private final BlockFactory factory;
    private final ApplicationConfig config;

    // Debug Session State
    private volatile Process currentProcess;
    private VirtualMachine vm;
    private ThreadReference currentDebugThread;
    private Map<Integer, CodeBlock> lineToBlockMap;

    public DebuggingService(
            ApplicationState state,
            EventBus eventBus,
            CodeExecutionService codeExecutionService,
            BlockFactory factory,
            ApplicationConfig config) {
        this.state = state;
        this.eventBus = eventBus;
        this.codeExecutionService = codeExecutionService;
        this.factory = factory;
        this.config = config;

        setupEventHandlers();
    }

    private void setupEventHandlers() {
        eventBus.subscribe(CoreApplicationEvents.DebugStartRequestedEvent.class, e -> startDebugging(), false);
        eventBus.subscribe(CoreApplicationEvents.DebugStepOverRequestedEvent.class, e -> stepOver(), false);
        eventBus.subscribe(CoreApplicationEvents.DebugContinueRequestedEvent.class, e -> continueExecution(), false);
        eventBus.subscribe(CoreApplicationEvents.DebugStopRequestedEvent.class, e -> stopDebugging(), false);
    }

    /**
     * Kicks off the debugging session on a separate thread.
     */
    public void startDebugging() {
        new Thread(() -> {
            try {
                String code = state.getCurrentCode();

                // 1. Compile
                // FIXED: Removed config.getSourceFilePath() argument to match new signature
                if (!codeExecutionService.compileAndWait(code, config.getCompiledOutputPath())) {
                    eventBus.publish(new CoreApplicationEvents.StatusMessageEvent("Debug aborted due to compilation failure."));
                    return;
                }

                // 2. Map Breakpoints (AST -> Line Numbers)
                CompilationUnit cu = factory.getCompilationUnit();
                // Note: getNodeToBlockMap only refers to the ACTIVE file.
                // Multi-file debugging requires mapping logic expansion, but this works for the active file.
                if (cu == null || state.getNodeToBlockMap().isEmpty()) {
                    eventBus.publish(new CoreApplicationEvents.StatusMessageEvent("Error: Could not parse code to get breakpoints."));
                    return;
                }

                this.lineToBlockMap = new HashMap<>();
                List<Integer> activeBreakpointLines = new ArrayList<>();

                for (CodeBlock block : state.getNodeToBlockMap().values()) {
                    int line = block.getBreakpointLine(cu);
                    if (line > 0) {
                        // Only map StatementBlocks (executable lines)
                        if (!lineToBlockMap.containsKey(line) || block instanceof StatementBlock) {
                            lineToBlockMap.put(line, block);
                        }
                        if (block.isBreakpoint()) {
                            activeBreakpointLines.add(line);
                        }
                    }
                }

                // If no breakpoints, add one at start so it doesn't just run to finish immediately
                if (activeBreakpointLines.isEmpty() && !lineToBlockMap.isEmpty()) {
                    lineToBlockMap.keySet().stream().min(Integer::compareTo).ifPresent(firstLine -> {
                        activeBreakpointLines.add(firstLine);
                        eventBus.publish(new CoreApplicationEvents.StatusMessageEvent("No breakpoints set. Pausing at start (Line " + firstLine + ")."));
                    });
                }

                // 3. Find Free Port
                int freePort;
                try (ServerSocket socket = new ServerSocket(0)) {
                    freePort = socket.getLocalPort();
                }

                // 4. Launch Target Process
                eventBus.publish(new CoreApplicationEvents.StatusMessageEvent("Starting debugger on port " + freePort + "..."));
                eventBus.publish(new CoreApplicationEvents.DebugSessionStartedEvent());
                Platform.runLater(() -> eventBus.publish(new CoreApplicationEvents.OutputClearedEvent()));

                String classPath = config.getCompiledOutputPath().toString();
                // We debug the Main class defined in config
                String className = config.getMainClassName();
                String javaExecutable = config.getJavaExecutable();

                // Suspend=y waits for us to attach before running main()
                String debugAgent = String.format("-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=%d", freePort);

                ProcessBuilder pb = new ProcessBuilder(javaExecutable, debugAgent, "-cp", classPath, className);
                this.currentProcess = pb.start();

                // Redirect output to UI
                redirectStream(currentProcess.getInputStream());
                redirectStream(currentProcess.getErrorStream());

                // 5. Attach JDI
                attachJdi(className, freePort, activeBreakpointLines);

            } catch (Exception e) {
                eventBus.publish(new CoreApplicationEvents.StatusMessageEvent("Debugger Error: " + e.getMessage()));
                e.printStackTrace();
                stopDebugging(); // Cleanup if fail
            }
        }).start();
    }

    /**
     * Connects the JDI VirtualMachine to the running process.
     */
    private void attachJdi(String mainClassName, int port, List<Integer> breakpointLines) throws Exception {
        VirtualMachineManager vmMgr = Bootstrap.virtualMachineManager();
        AttachingConnector connector = vmMgr.attachingConnectors().stream()
                .filter(c -> c.transport().name().equals("dt_socket"))
                .findFirst()
                .orElseThrow(() -> new RuntimeException("Socket attaching connector not found"));

        Map<String, Connector.Argument> arguments = connector.defaultArguments();
        arguments.get("port").setValue(String.valueOf(port));
        arguments.get("hostname").setValue("localhost");

        // Retry logic for connection
        int maxRetries = Constants.DEBUGGER_MAX_CONNECT_RETRIES;
        for (int i = 0; i < maxRetries; i++) {
            try {
                vm = connector.attach(arguments);
                System.out.println(ANSI_BLUE + "Attached to VM: " + vm.name() + ANSI_RESET);
                break;
            } catch (IOException e) {
                if (i == maxRetries - 1) throw e;
                Thread.sleep(Constants.DEBUGGER_RETRY_DELAY_MS);
            }
        }

        EventRequestManager erm = vm.eventRequestManager();

        // Handle Breakpoints
        List<ReferenceType> classes = vm.classesByName(mainClassName);
        if (!classes.isEmpty()) {
            applyBreakpointsToClass(classes.get(0), breakpointLines);
        } else {
            ClassPrepareRequest classPrepareRequest = erm.createClassPrepareRequest();
            classPrepareRequest.addClassFilter(mainClassName);
            classPrepareRequest.enable();
        }

        // Start Event Loop
        CountDownLatch listenerReadyLatch = new CountDownLatch(1);
        new Thread(() -> jdiEventLoop(listenerReadyLatch, mainClassName, breakpointLines)).start();

        listenerReadyLatch.await();
        vm.resume();
    }

    private void jdiEventLoop(CountDownLatch listenerReadyLatch, String mainClassName, List<Integer> breakpointLines) {
        EventQueue eventQueue = vm.eventQueue();
        listenerReadyLatch.countDown();

        while (true) {
            try {
                EventSet eventSet = eventQueue.remove();
                boolean shouldResume = true;

                for (Event event : eventSet) {
                    if (event instanceof VMDisconnectEvent) {
                        handleDisconnect();
                        return;
                    }

                    if (event instanceof ClassPrepareEvent) {
                        ClassPrepareEvent cpe = (ClassPrepareEvent) event;
                        if (cpe.referenceType().name().equals(mainClassName)) {
                            applyBreakpointsToClass(cpe.referenceType(), breakpointLines);
                        }
                    }
                    else if (event instanceof LocatableEvent) {
                        handleLocatableEvent((LocatableEvent) event);
                        shouldResume = false;
                    }
                }

                if (shouldResume) {
                    eventSet.resume();
                }
            } catch (InterruptedException | VMDisconnectedException e) {
                handleDisconnect();
                return;
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }

    private void applyBreakpointsToClass(ReferenceType refType, List<Integer> lines) {
        if (lines == null || lines.isEmpty()) return;
        try {
            EventRequestManager erm = vm.eventRequestManager();
            for (int lineNumber : lines) {
                List<Location> locations = refType.locationsOfLine(lineNumber);
                if (!locations.isEmpty()) {
                    BreakpointRequest bpReq = erm.createBreakpointRequest(locations.get(0));
                    bpReq.enable();
                }
            }
        } catch (AbsentInformationException e) {
            System.err.println("No debug info available (compiled without -g?).");
        }
    }

    private void handleLocatableEvent(LocatableEvent event) {
        this.currentDebugThread = event.thread();

        if (event instanceof StepEvent) {
            vm.eventRequestManager().deleteEventRequest(event.request());
        }

        int lineNumber = event.location().lineNumber();
        CodeBlock block = lineToBlockMap.get(lineNumber);
        CodeBlock target = (block != null) ? block.getHighlightTarget() : null;

        eventBus.publish(new CoreApplicationEvents.DebugSessionPausedEvent(lineNumber, target));
        eventBus.publish(new CoreApplicationEvents.BlockHighlightEvent(target));
        eventBus.publish(new CoreApplicationEvents.StatusMessageEvent("Paused at line: " + lineNumber));
    }

    private void handleDisconnect() {
        this.currentDebugThread = null;
        this.vm = null;
        this.currentProcess = null;

        eventBus.publish(new CoreApplicationEvents.DebugSessionFinishedEvent());
        eventBus.publish(new CoreApplicationEvents.StatusMessageEvent("Debug session finished."));
        eventBus.publish(new CoreApplicationEvents.BlockHighlightEvent(null));
    }

    public void stepOver() {
        if (vm == null || currentDebugThread == null) return;
        try {
            eventBus.publish(new CoreApplicationEvents.DebugSessionResumedEvent());
            EventRequestManager erm = vm.eventRequestManager();

            erm.stepRequests().stream()
                    .filter(r -> r.thread().equals(currentDebugThread))
                    .forEach(erm::deleteEventRequest);

            StepRequest request = erm.createStepRequest(currentDebugThread, StepRequest.STEP_LINE, StepRequest.STEP_OVER);
            request.addCountFilter(1);
            request.enable();

            vm.resume();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public void continueExecution() {
        if (vm != null) {
            eventBus.publish(new CoreApplicationEvents.DebugSessionResumedEvent());
            vm.resume();
        }
    }

    public void stopDebugging() {
        if (vm != null) {
            try {
                vm.dispose();
            } catch (VMDisconnectedException ignored) {
            } catch (Exception e) { e.printStackTrace(); }
        }

        if (currentProcess != null && currentProcess.isAlive()) {
            try {
                currentProcess.destroyForcibly();
                eventBus.publish(new CoreApplicationEvents.StatusMessageEvent("Debug process terminated."));
            } catch (Exception e) { e.printStackTrace(); }
        }

        handleDisconnect();
    }

    private void redirectStream(InputStream stream) {
        new Thread(() -> {
            try (Scanner s = new Scanner(stream)) {
                while (s.hasNextLine()) {
                    String line = s.nextLine();
                    Platform.runLater(() -> eventBus.publish(new CoreApplicationEvents.OutputAppendedEvent(line + "\n")));
                }
            }
        }).start();
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\services\ExecutionService.java
=================================================================================

package com.botmaker.services;

import com.botmaker.config.ApplicationConfig;
import com.botmaker.events.CoreApplicationEvents;
import com.botmaker.events.EventBus;
import com.botmaker.runtime.CodeExecutionService;
import com.botmaker.state.ApplicationState;

/**
 * Service wrapper for code execution (compilation and running).
 * Bridges between the event system and the existing CodeExecutionService.
 */
public class ExecutionService {

    private final ApplicationConfig config;
    private final ApplicationState state;
    private final EventBus eventBus;
    private final CodeExecutionService codeExecutionService;
    private final com.botmaker.validation.DiagnosticsManager diagnosticsManager;

    public ExecutionService(
            ApplicationConfig config,
            ApplicationState state,
            EventBus eventBus,
            CodeExecutionService codeExecutionService,
            com.botmaker.validation.DiagnosticsManager diagnosticsManager) {

        this.config = config;
        this.state = state;
        this.eventBus = eventBus;
        this.codeExecutionService = codeExecutionService;
        this.diagnosticsManager = diagnosticsManager;

        setupEventHandlers();
    }

    private void setupEventHandlers() {
        // Subscribe to compilation requests
        eventBus.subscribe(
                CoreApplicationEvents.CompilationRequestedEvent.class,
                event -> compile(),
                false
        );

        // Subscribe to execution requests
        eventBus.subscribe(
                CoreApplicationEvents.ExecutionRequestedEvent.class,
                event -> run(),
                false
        );

        // NEW: Subscribe to stop run requests
        eventBus.subscribe(
                CoreApplicationEvents.StopRunRequestedEvent.class,
                event -> stopRun(),
                false
        );
    }

    /**
     * Compiles the current code
     */
    public void compile() {
        codeExecutionService.compileCode(state.getCurrentCode());
    }

    /**
     * Runs the current code
     */
    public void run() {
        // 1. UI Updates to RUNNING state
        eventBus.publish(new CoreApplicationEvents.ProgramStartedEvent());

        // 2. Thread Starts
        new Thread(() -> {
            // 3. Blocks here while program runs
            codeExecutionService.runCode(state.getCurrentCode());

            // 4. Program finishes/dies, then UI Updates to IDLE state
            eventBus.publish(new CoreApplicationEvents.ProgramStoppedEvent());
        }).start();
    }

    /**
     * NEW: Stops the currently running program
     */
    public void stopRun() {
        codeExecutionService.stopRunningProgram();
        eventBus.publish(new CoreApplicationEvents.ProgramStoppedEvent());
    }

    /**
     * Get the underlying code execution service
     */
    public CodeExecutionService getCodeExecutionService() {
        return codeExecutionService;
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\services\LanguageServerService.java
=================================================================================

package com.botmaker.services;

import com.botmaker.config.ApplicationConfig;
import com.botmaker.config.Constants;
import com.botmaker.events.CoreApplicationEvents;
import com.botmaker.events.EventBus;
import com.botmaker.lsp.JdtLanguageServerLauncher;
import com.botmaker.state.ApplicationState;
import javafx.application.Platform;
import org.eclipse.lsp4j.*;
import org.eclipse.lsp4j.services.LanguageServer;

import java.nio.file.Files;
import java.nio.file.Path;
import java.util.List;

public class LanguageServerService {

    private final ApplicationConfig config;
    private final ApplicationState state;
    private final EventBus eventBus;
    private final com.botmaker.validation.DiagnosticsManager diagnosticsManager;

    private LanguageServer server;
    private JdtLanguageServerLauncher launcher;
    private boolean shouldClearCache = false;

    public LanguageServerService(
            ApplicationConfig config,
            ApplicationState state,
            EventBus eventBus,
            com.botmaker.validation.DiagnosticsManager diagnosticsManager) {
        this.config = config;
        this.state = state;
        this.eventBus = eventBus;
        this.diagnosticsManager = diagnosticsManager;
        setupEventHandlers();
    }

    public void setShouldClearCache(boolean shouldClear) { this.shouldClearCache = shouldClear; }

    private void setupEventHandlers() {
        eventBus.subscribe(CoreApplicationEvents.CodeUpdatedEvent.class, this::handleCodeUpdate, false);
    }

    public void initialize() throws Exception {
        if (shouldClearCache) {
            JdtLanguageServerLauncher.cleanupWorkspace(config.getWorkspaceDataPath());
        }

        launcher = new JdtLanguageServerLauncher(
                config.getJdtServerPath(),
                config.getProjectPath(),
                config.getWorkspaceDataPath(),
                (PublishDiagnosticsParams params) -> {
                    Platform.runLater(() -> {
                        List<Diagnostic> diagnostics = params.getDiagnostics();
                        eventBus.publish(new CoreApplicationEvents.DiagnosticsUpdatedEvent(diagnostics));
                    });
                }
        );

        server = launcher.getServer();

        // Ensure the Main file exists on disk, but do NOT open it here.
        // CodeEditorService.loadInitialCode() will open it shortly after.
        Path docPath = config.getSourceFilePath().toAbsolutePath().normalize();

        if (!Files.exists(docPath)) {
            Files.createDirectories(docPath.getParent());
            String mainClassName = config.getMainClassName();
            String[] parts = mainClassName.split("\\.");
            String packageName = parts.length > 1 ? String.join(".", java.util.Arrays.copyOf(parts, parts.length - 1)) : "com.demo";
            String className = parts[parts.length - 1];

            String defaultCode = String.format("""
            package %s;
            public class %s {
                public static void main(String[] args) {
                    System.out.println("Hello from %s!");
                }
            }
            """, packageName, className, className);
            Files.writeString(docPath, defaultCode);
        }

        // Setup initial state URIs
        String docUri = docPath.toUri().toString();
        state.setDocUri(docUri);
        state.setDocVersion(1);
    }

    private void handleCodeUpdate(CoreApplicationEvents.CodeUpdatedEvent event) {
        try {
            // Write to file
            Path docPath = Path.of(new java.net.URI(state.getDocUri()));
            Files.writeString(docPath, event.getNewCode());

            // Update state
            state.incrementDocVersion();
            state.setCurrentCode(event.getNewCode());

            // Notify LSP server
            if (server != null) {
                server.getTextDocumentService().didChange(new DidChangeTextDocumentParams(
                        new VersionedTextDocumentIdentifier(state.getDocUri(), (int) state.getDocVersion()),
                        List.of(new TextDocumentContentChangeEvent(event.getNewCode()))
                ));
            }

            eventBus.publish(new CoreApplicationEvents.UIRefreshRequestedEvent(event.getNewCode()));

        } catch (Exception e) {
            e.printStackTrace();
            eventBus.publish(new CoreApplicationEvents.StatusMessageEvent("Error saving file: " + e.getMessage()));
        }
    }

    public void openFile(Path path, String content) {
        if (server == null) return;
        String uri = path.toUri().toString();
        // Use version 1 for newly opened files
        server.getTextDocumentService().didOpen(new DidOpenTextDocumentParams(
                new TextDocumentItem(uri, "java", 1, content)
        ));
    }

    public void shutdown() {
        if (launcher != null) {
            try {
                System.out.println("Requesting server shutdown...");
                if (server != null) {
                    server.shutdown().get(Constants.DEBUGGER_SHUTDOWN_TIMEOUT_SECONDS, java.util.concurrent.TimeUnit.SECONDS);
                    server.exit();
                }
                Thread.sleep(Constants.SHORT_SLEEP_MS);
            } catch (Exception e) {
                System.err.println("Error during server shutdown: " + e.getMessage());
            } finally {
                launcher.stop();
            }
        }
    }

    public LanguageServer getServer() { return server; }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\state\ApplicationState.java
=================================================================================

package com.botmaker.state;

import com.botmaker.core.CodeBlock;
import com.botmaker.project.ProjectFile;
import org.eclipse.jdt.core.dom.ASTNode;
import org.eclipse.jdt.core.dom.CompilationUnit;

import java.nio.file.Path;
import java.util.*;

public class ApplicationState {

    // Multi-file state
    private final Map<Path, ProjectFile> openFiles = new HashMap<>();
    private ProjectFile activeFile;

    // AST and block mappings (For the ACTIVE file)
    private Map<ASTNode, CodeBlock> nodeToBlockMap = new HashMap<>();

    // UI state
    private CodeBlock highlightedBlock;
    private boolean isDebugging;
    private final Set<String> breakpointIds = new HashSet<>();
    private long docVersion = 1;

    // --- File Management ---

    public void addFile(ProjectFile file) {
        openFiles.put(file.getPath(), file);
    }

    public void setActiveFile(Path path) {
        this.activeFile = openFiles.get(path);
        // Reset or sync doc version when switching if necessary,
        // though usually we track version per file.
        // For now, we keep a global version counter for LSP sync simplicity.
    }

    public ProjectFile getActiveFile() {
        return activeFile;
    }

    public Collection<ProjectFile> getAllFiles() {
        return Collections.unmodifiableCollection(openFiles.values());
    }

    // --- Helpers (Delegate to Active File) ---

    public String getCurrentCode() {
        return activeFile != null ? activeFile.getContent() : "";
    }

    public void setCurrentCode(String code) {
        if (activeFile != null) activeFile.setContent(code);
    }

    public String getDocUri() {
        return activeFile != null ? activeFile.getUri() : "";
    }

    /**
     * Set Doc URI.
     * Note: In multi-file mode, the URI is derived from the ProjectFile path.
     * This method exists for backward compatibility with LanguageServerService.
     */
    public void setDocUri(String docUri) {
        // No-op: The URI is determined by the active file's path.
        // We accept the call to satisfy the compiler, but rely on setActiveFile() being called previously.
    }

    public Optional<CompilationUnit> getCompilationUnit() {
        return activeFile != null ? Optional.ofNullable(activeFile.getAst()) : Optional.empty();
    }

    public void setCompilationUnit(CompilationUnit cu) {
        if (activeFile != null) activeFile.setAst(cu);
    }

    // --- Versioning ---

    public long getDocVersion() {
        return docVersion;
    }

    public void setDocVersion(long version) {
        this.docVersion = version;
    }

    public void incrementDocVersion() {
        this.docVersion++;
    }

    // --- Mappings & UI State ---

    public Map<ASTNode, CodeBlock> getNodeToBlockMap() {
        return Collections.unmodifiableMap(nodeToBlockMap);
    }

    public Map<ASTNode, CodeBlock> getMutableNodeToBlockMap() {
        return nodeToBlockMap;
    }

    public void setNodeToBlockMap(Map<ASTNode, CodeBlock> nodeToBlockMap) {
        this.nodeToBlockMap = nodeToBlockMap != null ?
                new HashMap<>(nodeToBlockMap) : new HashMap<>();
    }

    public void clearNodeToBlockMap() {
        this.nodeToBlockMap.clear();
    }

    public Optional<CodeBlock> getBlockForNode(ASTNode node) {
        return Optional.ofNullable(nodeToBlockMap.get(node));
    }

    public Optional<CodeBlock> getHighlightedBlock() {
        return Optional.ofNullable(highlightedBlock);
    }

    public void setHighlightedBlock(CodeBlock block) {
        if (this.highlightedBlock != null) {
            this.highlightedBlock.unhighlight();
        }
        this.highlightedBlock = block;
        if (this.highlightedBlock != null) {
            this.highlightedBlock.highlight();
        }
    }

    public void clearHighlight() {
        setHighlightedBlock(null);
    }

    // --- Debugging ---

    public boolean isDebugging() {
        return isDebugging;
    }

    public void setDebugging(boolean debugging) {
        this.isDebugging = debugging;
    }

    public Set<String> getBreakpointIds() {
        return Collections.unmodifiableSet(breakpointIds);
    }

    public void addBreakpoint(String blockId) {
        breakpointIds.add(blockId);
    }

    public void removeBreakpoint(String blockId) {
        breakpointIds.remove(blockId);
    }

    public boolean hasBreakpoint(String blockId) {
        return breakpointIds.contains(blockId);
    }

    /**
     * Snapshot for debugging/logging
     */
    public StateSnapshot createSnapshot() {
        return new StateSnapshot(
                getCurrentCode(),
                getDocUri(),
                docVersion,
                nodeToBlockMap.size(),
                highlightedBlock != null,
                isDebugging
        );
    }

    public static class StateSnapshot {
        public final String currentCode;
        public final String docUri;
        public final long docVersion;
        public final int blockCount;
        public final boolean hasHighlight;
        public final boolean isDebugging;

        private StateSnapshot(String currentCode, String docUri, long docVersion,
                              int blockCount, boolean hasHighlight, boolean isDebugging) {
            this.currentCode = currentCode;
            this.docUri = docUri;
            this.docVersion = docVersion;
            this.blockCount = blockCount;
            this.hasHighlight = hasHighlight;
            this.isDebugging = isDebugging;
        }

        @Override
        public String toString() {
            return String.format(
                    "StateSnapshot{docVersion=%d, codeLength=%d, blockCount=%d, hasHighlight=%s, isDebugging=%s}",
                    docVersion, currentCode != null ? currentCode.length() : 0, blockCount, hasHighlight, isDebugging
            );
        }
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\state\HistoryManager.java
=================================================================================

package com.botmaker.state;

import java.util.Stack;

public class HistoryManager {

    private final Stack<String> undoStack = new Stack<>();
    private final Stack<String> redoStack = new Stack<>();
    private static final int MAX_HISTORY_SIZE = 50; // Limit memory usage

    /**
     * Saves a snapshot of the code.
     * Call this BEFORE applying a new change.
     */
    public void pushState(String code) {
        // Avoid saving duplicates (e.g. if multiple events fire for same code)
        if (!undoStack.isEmpty() && undoStack.peek().equals(code)) {
            return;
        }

        undoStack.push(code);

        // Enforce size limit
        if (undoStack.size() > MAX_HISTORY_SIZE) {
            undoStack.remove(0);
        }

        // New change clears the redo future
        redoStack.clear();
    }

    public boolean canUndo() { return !undoStack.isEmpty(); }
    public boolean canRedo() { return !redoStack.isEmpty(); }

    public String undo(String currentCode) {
        if (!canUndo()) return currentCode;

        // Save current state to Redo stack
        redoStack.push(currentCode);

        // Return previous state
        return undoStack.pop();
    }

    public String redo(String currentCode) {
        if (!canRedo()) return currentCode;

        // Save current state to Undo stack
        undoStack.push(currentCode);

        // Return future state
        return redoStack.pop();
    }

    public void clear() {
        undoStack.clear();
        redoStack.clear();
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\ui\AddableBlock.java
=================================================================================

package com.botmaker.ui;

import com.botmaker.blocks.*;
import com.botmaker.core.StatementBlock;

public enum AddableBlock {
    PRINT("Print", PrintBlock.class, BlockCategory.OUTPUT),

    // --- FLOW CONTROL ---
    IF("If Statement", IfBlock.class, BlockCategory.FLOW),
    SWITCH("Switch", SwitchBlock.class, BlockCategory.FLOW),

    // --- LOOPS ---
    WHILE("While Loop", WhileBlock.class, BlockCategory.LOOPS),
    FOR("For Each Loop", ForBlock.class, BlockCategory.LOOPS),
    DO_WHILE("Do While", DoWhileBlock.class, BlockCategory.LOOPS),

    // --- CONTROL COMMANDS ---
    BREAK("Break", BreakBlock.class, BlockCategory.CONTROL),
    CONTINUE("Continue", ContinueBlock.class, BlockCategory.CONTROL),
    RETURN("Return", ReturnBlock.class, BlockCategory.CONTROL),
    WAIT("Wait (ms)", WaitBlock.class, BlockCategory.CONTROL),

    // --- VARIABLES ---
    DECLARE_INT("Int Variable", VariableDeclarationBlock.class, BlockCategory.VARIABLES),
    DECLARE_DOUBLE("Double Variable", VariableDeclarationBlock.class, BlockCategory.VARIABLES),
    DECLARE_BOOLEAN("Bool Variable", VariableDeclarationBlock.class, BlockCategory.VARIABLES),
    DECLARE_STRING("String Variable", VariableDeclarationBlock.class, BlockCategory.VARIABLES),
    DECLARE_ARRAY("Create List", VariableDeclarationBlock.class, BlockCategory.VARIABLES),
    ASSIGNMENT("Set Variable", AssignmentBlock.class, BlockCategory.VARIABLES),

    // --- INPUT ---
    READ_LINE("Read Text", ReadInputBlock.class, BlockCategory.INPUT),
    READ_INT("Read Int", ReadInputBlock.class, BlockCategory.INPUT),
    READ_DOUBLE("Read Double", ReadInputBlock.class, BlockCategory.INPUT),

    // --- FUNCTIONS ---
    FUNCTION_CALL("Call Function", MethodInvocationBlock.class, BlockCategory.FUNCTIONS), // MOVED HERE
    METHOD_DECLARATION("Declare Function", MethodDeclarationBlock.class, BlockCategory.FUNCTIONS),
    DECLARE_ENUM("Define Enum", DeclareEnumBlock.class, BlockCategory.VARIABLES),
    // --- UTILITY ---
    COMMENT("Comment", CommentBlock.class, BlockCategory.UTILITY);


    private final String displayName;
    private final Class<? extends StatementBlock> blockClass;
    private final BlockCategory category;

    AddableBlock(String displayName, Class<? extends StatementBlock> blockClass, BlockCategory category) {
        this.displayName = displayName;
        this.blockClass = blockClass;
        this.category = category;
    }

    public String getDisplayName() { return displayName; }
    public Class<? extends StatementBlock> getBlockClass() { return blockClass; }
    public BlockCategory getCategory() { return category; }

    public enum BlockCategory {
        OUTPUT("Output"),
        INPUT("Input"),
        VARIABLES("Variables"),
        FLOW("Logic"),
        LOOPS("Loops"),
        CONTROL("Control"),
        FUNCTIONS("Functions"),
        UTILITY("Utility");

        private final String label;
        BlockCategory(String label) { this.label = label; }
        public String getLabel() { return label; }
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\ui\AddableExpression.java
=================================================================================

package com.botmaker.ui;

import com.botmaker.util.TypeInfo;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

public enum AddableExpression {
    // Literals
    TEXT("Text", "text", TypeInfo.STRING, Category.LITERAL, true),
    NUMBER("Number", "0", TypeInfo.INT, Category.LITERAL, true),
    TRUE("True", "true", TypeInfo.BOOLEAN, Category.LITERAL, true),
    FALSE("False", "false", TypeInfo.BOOLEAN, Category.LITERAL, true),

    // References
    VARIABLE("Variable", null, TypeInfo.UNKNOWN, Category.REFERENCE, false),
    FUNCTION_CALL("Function Call", null, TypeInfo.UNKNOWN, Category.REFERENCE, false),
    ENUM_CONSTANT("Enum Value", null, null, Category.LITERAL, true), // Special: compatibility checked dynamically
    LIST("Sub-List", null, null, Category.STRUCTURE, false),

    // Math
    ADD("Addition (+)", "+", TypeInfo.INT, Category.MATH, false),
    SUBTRACT("Subtraction (-)", "-", TypeInfo.INT, Category.MATH, false),
    MULTIPLY("Multiplication (*)", "*", TypeInfo.INT, Category.MATH, false),
    DIVIDE("Division (/)", "/", TypeInfo.INT, Category.MATH, false),
    MODULO("Modulo (%)", "%", TypeInfo.INT, Category.MATH, false),

    // Comparison
    EQUALS("Equals (==)", "==", TypeInfo.BOOLEAN, Category.COMPARISON, false),
    NOT_EQUALS("Not Equals (!=)", "!=", TypeInfo.BOOLEAN, Category.COMPARISON, false),
    GREATER("Greater (>)", ">", TypeInfo.BOOLEAN, Category.COMPARISON, false),
    LESS("Less (<)", "<", TypeInfo.BOOLEAN, Category.COMPARISON, false),
    GREATER_EQUALS("Greater Or Equal (>=)", ">=", TypeInfo.BOOLEAN, Category.COMPARISON, false),
    LESS_EQUALS("Less Or Equal (<=)", "<=", TypeInfo.BOOLEAN, Category.COMPARISON, false),

    // Logic
    AND("And (&&)", "&&", TypeInfo.BOOLEAN, Category.LOGIC, false),
    OR("Or (||)", "||", TypeInfo.BOOLEAN, Category.LOGIC, false),
    NOT("Not (!)", "!", TypeInfo.BOOLEAN, Category.LOGIC, false);

    private final String displayName;
    private final String operator;
    private final TypeInfo returnType;
    private final Category category;
    private final boolean isConstant;

    AddableExpression(String displayName, String operator, TypeInfo returnType, Category category, boolean isConstant) {
        this.displayName = displayName;
        this.operator = operator;
        this.returnType = returnType;
        this.category = category;
        this.isConstant = isConstant;
    }

    public String getDisplayName() { return displayName; }
    public Category getCategory() { return category; }
    public boolean isConstant() { return isConstant; }

    public enum Category {
        LITERAL("Values"),
        REFERENCE("References"),
        MATH("Math"),
        COMPARISON("Comparison"),
        LOGIC("Logic"),
        STRUCTURE("Structure");

        private final String label;
        Category(String label) { this.label = label; }
        public String getLabel() { return label; }
    }

    public static List<AddableExpression> getForType(TypeInfo targetType) {
        return getForType(targetType, false);
    }

    public static List<AddableExpression> getForType(TypeInfo targetType, boolean constantOnly) {
        if (targetType == null || targetType.isUnknown()) {
            // If unknown target, allow everything (unless constant filtering is on)
            return Arrays.stream(values())
                    .filter(e -> !constantOnly || e.isConstant)
                    .collect(Collectors.toList());
        }

        return Arrays.stream(values())
                .filter(expr -> !constantOnly || expr.isConstant)
                .filter(expr -> expr.isCompatibleWith(targetType))
                .collect(Collectors.toList());
    }

    public boolean isCompatibleWith(TypeInfo targetType) {
        if (targetType == null || targetType.isUnknown()) return true;

        // Special case: Enum Constant only matches Enums
        if (this == ENUM_CONSTANT) return targetType.isEnum();

        // Special case: List only matches Arrays
        if (this == LIST) return targetType.isArray();

        // Variables and Functions can be anything
        if (this == VARIABLE || this == FUNCTION_CALL) return true;

        if (returnType == null) return true;

        return returnType.isCompatibleWith(targetType);
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\ui\BlockDragAndDropManager.java
=================================================================================

package com.botmaker.ui;

import com.botmaker.blocks.ClassBlock;
import com.botmaker.core.BodyBlock;
import com.botmaker.core.StatementBlock;
import com.botmaker.state.ApplicationState;
import javafx.scene.Node;
import javafx.scene.input.ClipboardContent;
import javafx.scene.input.DataFormat;
import javafx.scene.input.Dragboard;
import javafx.scene.input.TransferMode;
import javafx.scene.layout.Region;

import java.util.function.Consumer;

public class BlockDragAndDropManager {

    public static final DataFormat ADDABLE_BLOCK_FORMAT = new DataFormat("application/x-java-addable-block");
    public static final DataFormat EXISTING_BLOCK_FORMAT = new DataFormat("application/x-java-existing-block");

    // Callbacks
    private Consumer<DropInfo> onDrop;
    private Consumer<MoveBlockInfo> onBlockMove;

    private final ApplicationState state;

    public BlockDragAndDropManager(ApplicationState state) {
        this.state = state;
    }

    public void setCallback(Consumer<DropInfo> onDrop) {
        this.onDrop = onDrop;
    }

    public void setMoveCallback(Consumer<MoveBlockInfo> onBlockMove) {
        this.onBlockMove = onBlockMove;
    }

    /**
     * Makes a UI node draggable (Palette Items).
     */
    public void makeDraggable(Node node, AddableBlock blockType) {
        node.setOnDragDetected(event -> {
            Dragboard db = node.startDragAndDrop(TransferMode.COPY);
            ClipboardContent content = new ClipboardContent();
            content.put(ADDABLE_BLOCK_FORMAT, blockType.name());
            db.setContent(content);

            // Visual feedback
            node.setOpacity(0.5);

            System.out.println("Drag detected for: " + blockType.name());
            event.consume();
        });

        node.setOnDragDone(event -> {
            node.setOpacity(1.0);
            event.consume();
        });
    }

    /**
     * Makes an existing block's UI node draggable for repositioning.
     */
    public void makeBlockMovable(Node node, StatementBlock block, BodyBlock sourceBody) {
        node.setOnDragDetected(event -> {
            if (event.getTarget() instanceof javafx.scene.control.Control) {
                return;
            }

            Dragboard db = node.startDragAndDrop(TransferMode.MOVE);
            ClipboardContent content = new ClipboardContent();
            content.put(EXISTING_BLOCK_FORMAT, block.getId());
            db.setContent(content);

            node.setOpacity(0.5);

            System.out.println("Dragging existing block: " + block.getDetails());
            event.consume();
        });

        node.setOnDragDone(event -> {
            node.setOpacity(1.0);
            javafx.application.Platform.runLater(() -> {
                javafx.scene.Node current = node;
                javafx.scene.control.ScrollPane scrollPane = null;
                while (current != null) {
                    if (current instanceof javafx.scene.control.ScrollPane) {
                        scrollPane = (javafx.scene.control.ScrollPane) current;
                        break;
                    }
                    current = current.getParent();
                }

                if (scrollPane != null) {
                    scrollPane.setFocusTraversable(true);
                    scrollPane.requestFocus();
                }
            });
        });
    }

    public Region createSeparator() {
        Region separator = new Region();
        separator.setMinHeight(8);
        separator.setStyle("-fx-background-color: transparent;");
        return separator;
    }

    public void addSeparatorDragHandlers(Region separator, BodyBlock targetBody, int insertionIndex, StatementBlock adjacentBlock) {
        String defaultColor = "transparent";
        String hoverColor = "#007bff";
        String moveHoverColor = "#28a745";

        separator.setOnDragEntered(event -> {
            Dragboard db = event.getDragboard();
            if (db.hasContent(ADDABLE_BLOCK_FORMAT)) {
                separator.setStyle("-fx-background-color: " + hoverColor + ";");
            } else if (db.hasContent(EXISTING_BLOCK_FORMAT)) {
                String draggedId = (String) db.getContent(EXISTING_BLOCK_FORMAT);
                if (!isRecursiveDrag(draggedId, targetBody)) {
                    separator.setStyle("-fx-background-color: " + moveHoverColor + ";");
                }
            }
            event.consume();
        });

        separator.setOnDragExited(event -> {
            separator.setStyle("-fx-background-color: " + defaultColor);
            event.consume();
        });

        separator.setOnDragOver(event -> {
            Dragboard db = event.getDragboard();
            if (db.hasContent(ADDABLE_BLOCK_FORMAT)) {
                event.acceptTransferModes(TransferMode.COPY);
            } else if (db.hasContent(EXISTING_BLOCK_FORMAT)) {
                String draggedId = (String) db.getContent(EXISTING_BLOCK_FORMAT);
                if (!isRecursiveDrag(draggedId, targetBody)) {
                    event.acceptTransferModes(TransferMode.MOVE);
                }
            }
            event.consume();
        });

        separator.setOnDragDropped(event -> {
            Dragboard db = event.getDragboard();
            boolean success = false;

            if (db.hasContent(ADDABLE_BLOCK_FORMAT)) {
                String blockTypeName = (String) db.getContent(ADDABLE_BLOCK_FORMAT);
                AddableBlock type = AddableBlock.valueOf(blockTypeName);
                if (onDrop != null) {
                    onDrop.accept(new DropInfo(type, targetBody, insertionIndex));
                    success = true;
                }
            } else if (db.hasContent(EXISTING_BLOCK_FORMAT)) {
                String blockId = (String) db.getContent(EXISTING_BLOCK_FORMAT);
                if (!isRecursiveDrag(blockId, targetBody)) {
                    if (onBlockMove != null) {
                        onBlockMove.accept(new MoveBlockInfo(blockId, targetBody, insertionIndex));
                        success = true;
                    }
                }
            }

            event.setDropCompleted(success);
            event.consume();
        });
    }

    public void addClassMemberDropHandlers(Region separator, ClassBlock targetClass, int insertionIndex) {
        separator.setOnDragOver(event -> {
            Dragboard db = event.getDragboard();
            if (db.hasContent(ADDABLE_BLOCK_FORMAT)) {
                String blockTypeName = (String) db.getContent(ADDABLE_BLOCK_FORMAT);
                AddableBlock type = AddableBlock.valueOf(blockTypeName);

                if (type == AddableBlock.METHOD_DECLARATION || type == AddableBlock.DECLARE_ENUM) {
                    event.acceptTransferModes(TransferMode.COPY);
                }
            }
            event.consume();
        });

        separator.setOnDragDropped(event -> {
            Dragboard db = event.getDragboard();
            boolean success = false;
            if (db.hasContent(ADDABLE_BLOCK_FORMAT)) {
                String blockTypeName = (String) db.getContent(ADDABLE_BLOCK_FORMAT);
                AddableBlock type = AddableBlock.valueOf(blockTypeName);

                if ((type == AddableBlock.METHOD_DECLARATION || type == AddableBlock.DECLARE_ENUM) && onDrop != null) {
                    onDrop.accept(new DropInfo(type, null, insertionIndex, targetClass));
                    success = true;
                }
            }
            event.setDropCompleted(success);
            event.consume();
        });
    }

    public void addEmptyBodyDropHandlers(Region target, BodyBlock targetBody) {
        target.setOnDragEntered(event -> {
            Dragboard db = event.getDragboard();
            if (db.hasContent(ADDABLE_BLOCK_FORMAT)) {
                target.getStyleClass().add("empty-body-drop-hover");
            } else if (db.hasContent(EXISTING_BLOCK_FORMAT)) {
                String draggedId = (String) db.getContent(EXISTING_BLOCK_FORMAT);
                if (!isRecursiveDrag(draggedId, targetBody)) {
                    target.getStyleClass().add("empty-body-drop-hover");
                }
            }
            event.consume();
        });

        target.setOnDragExited(event -> {
            target.getStyleClass().remove("empty-body-drop-hover");
            event.consume();
        });

        target.setOnDragOver(event -> {
            Dragboard db = event.getDragboard();
            if (db.hasContent(ADDABLE_BLOCK_FORMAT)) {
                event.acceptTransferModes(TransferMode.COPY);
            } else if (db.hasContent(EXISTING_BLOCK_FORMAT)) {
                String draggedId = (String) db.getContent(EXISTING_BLOCK_FORMAT);
                if (!isRecursiveDrag(draggedId, targetBody)) {
                    event.acceptTransferModes(TransferMode.MOVE);
                }
            }
            event.consume();
        });

        target.setOnDragDropped(event -> {
            Dragboard db = event.getDragboard();
            boolean success = false;
            if (db.hasContent(ADDABLE_BLOCK_FORMAT)) {
                String blockTypeName = (String) db.getContent(ADDABLE_BLOCK_FORMAT);
                AddableBlock type = AddableBlock.valueOf(blockTypeName);
                if (onDrop != null) {
                    onDrop.accept(new DropInfo(type, targetBody, 0));
                    success = true;
                }
            } else if (db.hasContent(EXISTING_BLOCK_FORMAT)) {
                String blockId = (String) db.getContent(EXISTING_BLOCK_FORMAT);
                if (!isRecursiveDrag(blockId, targetBody)) {
                    if (onBlockMove != null) {
                        onBlockMove.accept(new MoveBlockInfo(blockId, targetBody, 0));
                        success = true;
                    }
                }
            }
            event.setDropCompleted(success);
            event.consume();
        });
    }

    public void addExpressionDropHandlers(Region target) {
        String defaultStyle = "-fx-background-color: #f0f0f0; -fx-border-color: #c0c0c0; -fx-border-style: dashed; -fx-min-width: 50; -fx-min-height: 25;";
        String hoverStyle = defaultStyle + "-fx-border-color: #007bff;";

        target.setStyle(defaultStyle);

        target.setOnDragEntered(event -> {
            if (event.getDragboard().hasContent(ADDABLE_BLOCK_FORMAT)) {
                target.setStyle(hoverStyle);
            }
            event.consume();
        });

        target.setOnDragExited(event -> {
            target.setStyle(defaultStyle);
            event.consume();
        });

        target.setOnDragOver(event -> {
            if (event.getDragboard().hasContent(ADDABLE_BLOCK_FORMAT)) {
                event.acceptTransferModes(TransferMode.COPY);
            }
            event.consume();
        });

        target.setOnDragDropped(event -> {
            Dragboard db = event.getDragboard();
            boolean success = false;
            if (db.hasContent(ADDABLE_BLOCK_FORMAT)) {
                success = true;
            }
            event.setDropCompleted(success);
            event.consume();
        });
    }

    /**
     * Checks if the dragged block is an ancestor of the target body.
     */
    private boolean isRecursiveDrag(String draggedBlockId, BodyBlock targetBody) {
        if (state == null || draggedBlockId == null || targetBody == null) return false;

        // Traverse up the AST from the target drop location
        org.eclipse.jdt.core.dom.ASTNode currentNode = targetBody.getAstNode();

        while (currentNode != null) {
            com.botmaker.core.CodeBlock block = state.getBlockForNode(currentNode).orElse(null);
            // If we find that one of the parents is the block we are dragging, it's recursive
            if (block != null && draggedBlockId.equals(block.getId())) {
                return true;
            }
            currentNode = currentNode.getParent();
        }
        return false;
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\ui\BlockEvent.java
=================================================================================

package com.botmaker.ui;

import com.botmaker.core.CodeBlock;
import javafx.event.Event;
import javafx.event.EventType;

public class BlockEvent extends Event {
    public static final EventType<BlockEvent> ANY = new EventType<>(Event.ANY, "BLOCK_EVENT");

    public BlockEvent(EventType<? extends Event> eventType) {
        super(eventType);
    }

    public static class BreakpointToggleEvent extends BlockEvent {
        public static final EventType<BreakpointToggleEvent> TOGGLE_BREAKPOINT = new EventType<>(ANY, "TOGGLE_BREAKPOINT");

        private final CodeBlock block;
        private final boolean isEnabled;

        public BreakpointToggleEvent(CodeBlock block, boolean isEnabled) {
            super(TOGGLE_BREAKPOINT);
            this.block = block;
            this.isEnabled = isEnabled;
        }

        public CodeBlock getBlock() { return block; }
        public boolean isEnabled() { return isEnabled; }
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\ui\DropInfo.java
=================================================================================

// In DropInfo.java - update the record
package com.botmaker.ui;

import com.botmaker.blocks.ClassBlock;
import com.botmaker.core.BodyBlock;

public record DropInfo(
        AddableBlock type,
        BodyBlock targetBody,
        int insertionIndex,
        ClassBlock targetClass // NEW: for method declarations
) {
    // Convenience constructor for statement drops (existing behavior)
    public DropInfo(AddableBlock type, BodyBlock targetBody, int insertionIndex) {
        this(type, targetBody, insertionIndex, null);
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\ui\EventLogManager.java
=================================================================================

package com.botmaker.ui;

import com.botmaker.events.ApplicationEvent;
import com.botmaker.events.CoreApplicationEvents;
import com.botmaker.events.EventBus;
import javafx.application.Platform;
import javafx.scene.control.ListView;
import javafx.scene.control.SelectionMode;

import java.time.Instant;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

/**
 * Manages the Event Log pane.
 * Buffers events to prevent UI flooding and filters out high-frequency noise.
 */
public class EventLogManager {

    private final ListView<String> eventListView;
    private final ConcurrentLinkedQueue<String> pendingLogs = new ConcurrentLinkedQueue<>();
    private final ScheduledExecutorService uiUpdater;
    private final DateTimeFormatter timeFormatter = DateTimeFormatter.ofPattern("HH:mm:ss.SSS")
            .withZone(ZoneId.systemDefault());

    private static final int MAX_LOG_ENTRIES = 1000;
    private static final int UPDATE_INTERVAL_MS = 250; // Update UI max 4 times per second

    public EventLogManager(EventBus eventBus) {
        this.eventListView = new ListView<>();
        this.eventListView.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE);
        this.eventListView.getStyleClass().add("event-log-list");

        // Use a monospaced font style via CSS or inline for now
        this.eventListView.setStyle("-fx-font-family: 'Consolas', 'Monospaced'; -fx-font-size: 11px;");

        // Subscribe to everything
        eventBus.subscribeAll(this::handleEvent);

        // Start the UI update thread
        this.uiUpdater = Executors.newSingleThreadScheduledExecutor(r -> {
            Thread t = new Thread(r, "EventLog-Updater");
            t.setDaemon(true);
            return t;
        });

        startUiLoop();
    }

    public ListView<String> getView() {
        return eventListView;
    }

    private void handleEvent(ApplicationEvent event) {
        // 1. FILTERING: Ignore extremely frequent events that have their own displays
        if (event instanceof CoreApplicationEvents.OutputAppendedEvent) return;

        // Optional: Filter CodeUpdatedEvent if it's too noisy (happens on every keypress)
        // if (event instanceof CoreApplicationEvents.CodeUpdatedEvent) return;

        // 2. FORMATTING
        String timestamp = timeFormatter.format(Instant.ofEpochMilli(event.getTimestamp()));
        String eventName = event.getClass().getSimpleName();
        String source = event.getSource();

        String details = "";

        // Extract interesting details for specific events
        if (event instanceof CoreApplicationEvents.StatusMessageEvent) {
            details = ": " + ((CoreApplicationEvents.StatusMessageEvent) event).getMessage();
        } else if (event instanceof CoreApplicationEvents.DebugSessionPausedEvent) {
            details = " @ Line " + ((CoreApplicationEvents.DebugSessionPausedEvent) event).getLineNumber();
        } else if (event instanceof CoreApplicationEvents.BreakpointToggledEvent) {
            var bp = (CoreApplicationEvents.BreakpointToggledEvent) event;
            details = " (" + (bp.isEnabled() ? "ON" : "OFF") + ") ID: " + bp.getBlock().getId();
        }

        String logEntry = String.format("[%s] %-25s | %s%s", timestamp, eventName, source, details);

        // 3. QUEUING
        pendingLogs.offer(logEntry);
    }

    private void startUiLoop() {
        uiUpdater.scheduleAtFixedRate(() -> {
            if (pendingLogs.isEmpty()) return;

            // Drain the queue into a temporary list
            List<String> batch = new ArrayList<>();
            String log;
            while ((log = pendingLogs.poll()) != null) {
                batch.add(log);
            }

            if (!batch.isEmpty()) {
                Platform.runLater(() -> {
                    eventListView.getItems().addAll(batch);

                    // Prune old entries
                    if (eventListView.getItems().size() > MAX_LOG_ENTRIES) {
                        eventListView.getItems().remove(0, eventListView.getItems().size() - MAX_LOG_ENTRIES);
                    }

                    // Auto-scroll to bottom
                    eventListView.scrollTo(eventListView.getItems().size() - 1);
                });
            }
        }, UPDATE_INTERVAL_MS, UPDATE_INTERVAL_MS, TimeUnit.MILLISECONDS);
    }

    public void shutdown() {
        uiUpdater.shutdownNow();
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\ui\FileExplorerManager.java
=================================================================================

package com.botmaker.ui;

import com.botmaker.config.ApplicationConfig;
import com.botmaker.services.CodeEditorService;
import com.botmaker.state.ApplicationState;
import javafx.scene.control.*;
import javafx.scene.layout.VBox;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Optional;
import java.util.stream.Stream;

public class FileExplorerManager {

    private final ApplicationConfig config;
    private final CodeEditorService codeEditorService;
    private final ApplicationState state;
    private final TreeView<Path> fileTree;

    public FileExplorerManager(ApplicationConfig config, CodeEditorService codeEditorService, ApplicationState state) {
        this.config = config;
        this.codeEditorService = codeEditorService;
        this.state = state;
        this.fileTree = new TreeView<>();
    }

    public VBox createView() {
        VBox container = new VBox();
        container.getStyleClass().add("file-explorer");

        Label header = new Label("Project Files");
        header.getStyleClass().add("sidebar-header");

        Button newFileBtn = new Button("New Function Library");
        newFileBtn.setMaxWidth(Double.MAX_VALUE);
        newFileBtn.setOnAction(e -> showCreateFileDialog());

        configureTree();
        refreshTree();

        container.getChildren().addAll(header, newFileBtn, fileTree);
        return container;
    }

    private void configureTree() {
        // We hide the root "java" folder to make it look cleaner
        fileTree.setShowRoot(false);

        fileTree.setCellFactory(tv -> new TreeCell<>() {
            @Override
            protected void updateItem(Path item, boolean empty) {
                super.updateItem(item, empty);
                if (empty || item == null) {
                    setText(null);
                    setGraphic(null);
                    setStyle("");
                } else {
                    String fileName = item.getFileName().toString();

                    // Visual Logic
                    boolean isDirectory = Files.isDirectory(item);
                    String pathStr = item.toString().replace("\\", "/");
                    boolean isLibrary = pathStr.contains("com/botmaker/library");

                    if (isDirectory) {
                        setText(fileName);
                        setStyle("-fx-font-weight: bold; -fx-text-fill: #333;");
                    }
                    else if (isLibrary) {
                        setText(fileName + " [Lib]");
                        // Locked/Library style
                        setStyle("-fx-text-fill: #888; -fx-font-style: italic;");
                    }
                    else {
                        setText(fileName);
                        // Highlight active file
                        if (state.getActiveFile() != null && item.equals(state.getActiveFile().getPath())) {
                            setStyle("-fx-font-weight: bold; -fx-text-fill: #007bff;");
                        } else {
                            setStyle("-fx-text-fill: black;");
                        }
                    }
                }
            }
        });

        fileTree.getSelectionModel().selectedItemProperty().addListener((obs, oldVal, newVal) -> {
            if (newVal != null && newVal.getValue() != null) {
                Path selectedPath = newVal.getValue();

                // Only open if it's a file, not a directory
                if (Files.isRegularFile(selectedPath)) {
                    // Allow opening all files, including library files (for visualization)
                    if (state.getActiveFile() == null || !state.getActiveFile().getPath().equals(selectedPath)) {
                        codeEditorService.switchToFile(selectedPath);
                        fileTree.refresh();
                    }
                }
            }
        });
    }

    public void refreshTree() {
        // 1. Find the root 'src/main/java' directory
        // Start from Main file: .../src/main/java/com/myproject/Main.java
        Path current = config.getSourceFilePath().getParent();

        // Traverse up until we hit "java" (or run out of parents)
        while (current != null && !current.getFileName().toString().equals("java")) {
            current = current.getParent();
        }

        // Fallback if structure is weird
        if (current == null) {
            current = config.getSourceFilePath().getParent();
        }

        TreeItem<Path> root = new TreeItem<>(current);
        root.setExpanded(true);

        // 2. Recursively build the tree
        buildFileTree(root, current);

        fileTree.setRoot(root);
    }

    private void buildFileTree(TreeItem<Path> parentItem, Path parentPath) {
        try (Stream<Path> files = Files.list(parentPath)) {
            files.sorted((p1, p2) -> {
                // Sort directories first, then files
                boolean d1 = Files.isDirectory(p1);
                boolean d2 = Files.isDirectory(p2);
                if (d1 && !d2) return -1;
                if (!d1 && d2) return 1;
                return p1.getFileName().toString().compareTo(p2.getFileName().toString());
            }).forEach(path -> {
                TreeItem<Path> item = new TreeItem<>(path);
                parentItem.getChildren().add(item);

                if (Files.isDirectory(path)) {
                    // Auto-expand 'com' and 'botmaker' folders for convenience
                    String name = path.getFileName().toString();
                    if (name.equals("com") || name.equals("botmaker") || name.equals("library")) {
                        item.setExpanded(true);
                    }
                    buildFileTree(item, path);
                }
            });
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private void showCreateFileDialog() {
        TextInputDialog dialog = new TextInputDialog();
        dialog.setTitle("New Function Library");
        dialog.setHeaderText("Create a new library of functions");
        dialog.setContentText("Name (e.g. Movement):");

        Optional<String> result = dialog.showAndWait();
        result.ifPresent(name -> {
            String className = name.trim().replaceAll("[^a-zA-Z0-9]", "");
            if (!className.isEmpty()) {
                codeEditorService.createFile(className);
                refreshTree();
            }
        });
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\ui\MenuBarManager.java
=================================================================================

package com.botmaker.ui;

import com.botmaker.events.CoreApplicationEvents;
import com.botmaker.events.EventBus;
import javafx.scene.control.Menu;
import javafx.scene.control.MenuBar;
import javafx.scene.control.MenuItem;
import javafx.scene.control.SeparatorMenuItem;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyCodeCombination;
import javafx.scene.input.KeyCombination;
import javafx.stage.Stage;

import java.util.function.Consumer;

/**
 * Manages the application menu bar
 */
public class MenuBarManager {

    private final MenuBar menuBar;
    private final Stage primaryStage;
    private Consumer<Void> onSelectProject;
    private EventBus eventBus;
    private MenuItem undoItem;
    private MenuItem redoItem;
    public MenuBarManager(Stage primaryStage) {
        this.primaryStage = primaryStage;
        this.menuBar = new MenuBar();
        createMenus();
    }

    /**
     * Creates all menus
     */
    private void createMenus() {
        // File menu
        Menu fileMenu = createFileMenu();

        // Edit menu (placeholder for future)
        Menu editMenu = createEditMenu();

        // View menu (placeholder for future)
        Menu viewMenu = createViewMenu();

        // Help menu
        Menu helpMenu = createHelpMenu();

        menuBar.getMenus().addAll(fileMenu, editMenu, viewMenu, helpMenu);
    }

    /**
     * Creates the File menu
     */
    private Menu createFileMenu() {
        Menu fileMenu = new Menu("File");

        // Select Project
        MenuItem selectProjectItem = new MenuItem("Select Project...");
        selectProjectItem.setAccelerator(new KeyCodeCombination(
                KeyCode.O,
                KeyCombination.CONTROL_DOWN,
                KeyCombination.SHIFT_DOWN
        ));
        selectProjectItem.setOnAction(e -> {
            if (onSelectProject != null) {
                onSelectProject.accept(null);
            }
        });

        // Separator
        SeparatorMenuItem separator1 = new SeparatorMenuItem();

        // Exit
        MenuItem exitItem = new MenuItem("Exit");
        exitItem.setAccelerator(new KeyCodeCombination(
                KeyCode.Q,
                KeyCombination.CONTROL_DOWN
        ));

        // UPDATED: Force system exit
        exitItem.setOnAction(e -> {
            javafx.application.Platform.exit(); // Close JavaFX
            System.exit(0); // Kill JVM (stops LSP, Debugger, etc.)
        });

        fileMenu.getItems().addAll(
                selectProjectItem,
                separator1,
                exitItem
        );

        return fileMenu;
    }

    /**
     * Creates the Edit menu
     */
    private Menu createEditMenu() {
        Menu editMenu = new Menu("Edit");

        undoItem = new MenuItem("Undo");
        undoItem.setAccelerator(new KeyCodeCombination(KeyCode.Z, KeyCombination.CONTROL_DOWN));
        undoItem.setDisable(true);
        undoItem.setOnAction(e -> {
            if (eventBus != null) eventBus.publish(new CoreApplicationEvents.UndoRequestedEvent());
        });

        redoItem = new MenuItem("Redo");
        redoItem.setAccelerator(new KeyCodeCombination(KeyCode.Y, KeyCombination.CONTROL_DOWN));
        redoItem.setDisable(true);
        redoItem.setOnAction(e -> {
            if (eventBus != null) eventBus.publish(new CoreApplicationEvents.RedoRequestedEvent());
        });

        SeparatorMenuItem separator = new SeparatorMenuItem();

        MenuItem cutItem = new MenuItem("Cut");
        cutItem.setAccelerator(new KeyCodeCombination(KeyCode.X, KeyCombination.CONTROL_DOWN));
        cutItem.setDisable(true); // Not implemented yet

        MenuItem copyItem = new MenuItem("Copy");
        copyItem.setAccelerator(new KeyCodeCombination(KeyCode.C, KeyCombination.CONTROL_DOWN));
        copyItem.setDisable(true); // Not implemented yet

        MenuItem pasteItem = new MenuItem("Paste");
        pasteItem.setAccelerator(new KeyCodeCombination(KeyCode.V, KeyCombination.CONTROL_DOWN));
        pasteItem.setDisable(true); // Not implemented yet

        editMenu.getItems().addAll(
                undoItem,
                redoItem,
                separator,
                cutItem,
                copyItem,
                pasteItem
        );

        return editMenu;
    }

    /**
     * Creates the View menu
     */
    private Menu createViewMenu() {
        Menu viewMenu = new Menu("View");

        // Placeholder items for future implementation
        MenuItem zoomInItem = new MenuItem("Zoom In");
        zoomInItem.setAccelerator(new KeyCodeCombination(
                KeyCode.PLUS,
                KeyCombination.CONTROL_DOWN
        ));
        zoomInItem.setDisable(true); // Not implemented yet

        MenuItem zoomOutItem = new MenuItem("Zoom Out");
        zoomOutItem.setAccelerator(new KeyCodeCombination(
                KeyCode.MINUS,
                KeyCombination.CONTROL_DOWN
        ));
        zoomOutItem.setDisable(true); // Not implemented yet

        MenuItem resetZoomItem = new MenuItem("Reset Zoom");
        resetZoomItem.setAccelerator(new KeyCodeCombination(
                KeyCode.DIGIT0,
                KeyCombination.CONTROL_DOWN
        ));
        resetZoomItem.setDisable(true); // Not implemented yet

        viewMenu.getItems().addAll(
                zoomInItem,
                zoomOutItem,
                resetZoomItem
        );

        return viewMenu;
    }


    public void setEventBus(EventBus eventBus) {
        this.eventBus = eventBus;
        eventBus.subscribe(CoreApplicationEvents.HistoryStateChangedEvent.class, this::updateMenuState, true);
    }

    private void updateMenuState(CoreApplicationEvents.HistoryStateChangedEvent event) {
        if (undoItem != null) undoItem.setDisable(!event.canUndo());
        if (redoItem != null) redoItem.setDisable(!event.canRedo());
    }

    /**
     * Creates the Help menu
     */
    private Menu createHelpMenu() {
        Menu helpMenu = new Menu("Help");

        MenuItem aboutItem = new MenuItem("About BotMaker");
        aboutItem.setOnAction(e -> showAboutDialog());

        helpMenu.getItems().add(aboutItem);

        return helpMenu;
    }

    /**
     * Shows the about dialog
     */
    private void showAboutDialog() {
        javafx.scene.control.Alert alert = new javafx.scene.control.Alert(
                javafx.scene.control.Alert.AlertType.INFORMATION
        );
        alert.initOwner(primaryStage);
        alert.setTitle("About BotMaker");
        alert.setHeaderText("BotMaker Blocks");
        alert.setContentText(
                "Version: 1.0.0\n\n" +
                        "A visual block-based programming environment for Java.\n\n" +
                        "Build Java applications using drag-and-drop blocks!"
        );
        alert.showAndWait();
    }

    /**
     * Gets the menu bar
     */
    public MenuBar getMenuBar() {
        return menuBar;
    }

    /**
     * Sets the callback for when "Select Project" is clicked
     */
    public void setOnSelectProject(Consumer<Void> callback) {
        this.onSelectProject = callback;
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\ui\MoveBlockInfo.java
=================================================================================

package com.botmaker.ui;

import com.botmaker.core.BodyBlock;

/**
 * Information about moving an existing block to a new position.
 * @param blockId The ID of the block being moved
 * @param targetBody The BodyBlock where the block should be moved to
 * @param insertionIndex The index where the block should be inserted
 */
public record MoveBlockInfo(String blockId, BodyBlock targetBody, int insertionIndex) {
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\ui\PaletteManager.java
=================================================================================

package com.botmaker.ui;

import com.botmaker.ui.AddableBlock.BlockCategory;
import javafx.geometry.Pos;
import javafx.scene.control.CustomMenuItem;
import javafx.scene.control.Label;
import javafx.scene.control.MenuButton;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Priority;
import javafx.scene.layout.Region;

import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

public class PaletteManager {

    private final BlockDragAndDropManager dragAndDropManager;

    public PaletteManager(BlockDragAndDropManager dragAndDropManager) {
        this.dragAndDropManager = dragAndDropManager;
    }

    public HBox createHorizontalPalette() {
        HBox container = new HBox(8);
        container.setAlignment(Pos.CENTER);
        // Remove padding here so buttons can touch edges if needed
        container.setStyle("-fx-padding: 0;");
        container.getStyleClass().add("palette-bar");

        Map<BlockCategory, List<AddableBlock>> grouped = Arrays.stream(AddableBlock.values())
                .collect(Collectors.groupingBy(AddableBlock::getCategory));

        BlockCategory[] order = {
                BlockCategory.OUTPUT,
                BlockCategory.INPUT,
                BlockCategory.VARIABLES,
                BlockCategory.FLOW,
                BlockCategory.LOOPS,
                BlockCategory.CONTROL,
                BlockCategory.FUNCTIONS,
                BlockCategory.UTILITY
        };

        for (BlockCategory category : order) {
            List<AddableBlock> blocks = grouped.get(category);
            if (blocks == null) continue;

            String categoryColor = getCategoryColor(category);

            MenuButton categoryMenu = new MenuButton();
            categoryMenu.getStyleClass().addAll("palette-category-btn", "palette-" + category.name().toLowerCase());

            // Make button stretch to fill toolbar height
            categoryMenu.setMaxHeight(Double.MAX_VALUE);
            // Allow button to shrink horizontally if needed
            categoryMenu.setMinWidth(Region.USE_PREF_SIZE);

            // Allow HBox to distribute extra space or shrink components
            HBox.setHgrow(categoryMenu, Priority.SOMETIMES);

            Label btnLabel = new Label(category.getLabel());
            btnLabel.setStyle(
                    "-fx-text-fill: white; " +
                            "-fx-font-family: 'Segoe UI', sans-serif; " +
                            "-fx-font-weight: bold; " +
                            "-fx-font-size: 13px;"
            );
            categoryMenu.setGraphic(btnLabel);

            categoryMenu.setStyle(
                    "-fx-background-color: " + categoryColor + "; " +
                            "-fx-background-radius: 4; " + // Slightly smaller radius for "bar" look
                            "-fx-border-color: rgba(0,0,0,0.1); " +
                            "-fx-border-radius: 4; " +
                            "-fx-cursor: hand;"
                    // Removed fixed padding here to allow layout to control height
            );

            for (AddableBlock blockType : blocks) {
                Label blockLabel = new Label(blockType.getDisplayName());
                blockLabel.setPrefWidth(180);
                blockLabel.setMaxWidth(Double.MAX_VALUE);

                blockLabel.setStyle(
                        "-fx-background-color: " + categoryColor + "; " +
                                "-fx-text-fill: white; " +
                                "-fx-font-weight: bold; " +
                                "-fx-font-size: 12px; " +
                                "-fx-padding: 8 12 8 12; " +
                                "-fx-background-radius: 2;"
                );

                dragAndDropManager.makeDraggable(blockLabel, blockType);

                CustomMenuItem item = new CustomMenuItem(blockLabel);
                item.setHideOnClick(false);
                categoryMenu.getItems().add(item);
            }

            container.getChildren().add(categoryMenu);
        }

        return container;
    }

    private String getCategoryColor(BlockCategory category) {
        return switch (category) {
            case OUTPUT -> "#3498DB";
            case INPUT -> "#9B59B6";
            case VARIABLES -> "#F39C12";
            case FLOW -> "#E67E22";
            case LOOPS -> "#2ECC71";
            case CONTROL -> "#E74C3C";
            case FUNCTIONS -> "#8E44AD";
            case UTILITY -> "#7F8C8D";
            default -> "#34495E";
        };
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\ui\ProjectSelectionScreen.java
=================================================================================

package com.botmaker.ui;

import com.botmaker.project.ProjectCreator;
import com.botmaker.project.ProjectInfo;
import com.botmaker.project.ProjectManager;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.Scene;
import javafx.scene.control.*;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.HBox;
import javafx.scene.layout.VBox;
import javafx.stage.Stage;

import java.time.format.DateTimeFormatter;
import java.util.List;
import java.util.Optional;
import java.util.function.BiConsumer;
import java.util.function.Consumer;

/**
 * Project selection screen shown on startup with project creation capability
 */
public class ProjectSelectionScreen {

    private final ProjectManager projectManager;
    private final ProjectCreator projectCreator;

    // Changed to BiConsumer to pass (ProjectName, ShouldClearCache)
    private final BiConsumer<String, Boolean> onProjectSelected;

    private final Stage stage;
    private ListView<ProjectInfo> projectListView;

    // New Checkbox
    private CheckBox clearCacheCheckbox;

    public ProjectSelectionScreen(Stage stage, BiConsumer<String, Boolean> onProjectSelected) {
        this.stage = stage;
        this.projectManager = new ProjectManager();
        this.projectCreator = new ProjectCreator();
        this.onProjectSelected = onProjectSelected;
    }

    public Scene createScene() {
        BorderPane root = new BorderPane();
        root.setPadding(new Insets(20));

        // Header
        Label titleLabel = new Label("Select a Project");
        titleLabel.setStyle("-fx-font-size: 24px; -fx-font-weight: bold;");
        VBox header = new VBox(10, titleLabel);
        header.setAlignment(Pos.CENTER);
        header.setPadding(new Insets(0, 0, 20, 0));

        // Project list
        projectListView = new ListView<>();
        projectListView.setPrefHeight(400);

        projectListView.setCellFactory(lv -> new ListCell<>() {
            @Override
            protected void updateItem(ProjectInfo project, boolean empty) {
                super.updateItem(project, empty);
                if (empty || project == null) {
                    setText(null);
                    setGraphic(null);
                } else {
                    VBox box = new VBox(5);
                    Label nameLabel = new Label(project.getName());
                    nameLabel.setStyle("-fx-font-size: 16px; -fx-font-weight: bold;");

                    Label pathLabel = new Label(project.getProjectPath().toString());
                    pathLabel.setStyle("-fx-font-size: 11px; -fx-text-fill: gray;");

                    Label dateLabel = new Label("Last modified: " +
                            project.getLastModified().format(DateTimeFormatter.ofPattern("MMM dd, yyyy HH:mm")));
                    dateLabel.setStyle("-fx-font-size: 11px; -fx-text-fill: gray;");

                    box.getChildren().addAll(nameLabel, pathLabel, dateLabel);
                    setGraphic(box);
                }
            }
        });

        refreshProjectList();

        if (!projectListView.getItems().isEmpty()) {
            projectListView.getSelectionModel().select(0);
        }

        // Controls Area
        Button openButton = new Button("Open Project");
        openButton.setPrefWidth(150);
        openButton.setDefaultButton(true);
        openButton.setOnAction(e -> openSelectedProject());

        Button createButton = new Button("Create New Project");
        createButton.setPrefWidth(150);
        createButton.setOnAction(e -> showCreateProjectDialog());

        // CLEAR CACHE CHECKBOX
        clearCacheCheckbox = new CheckBox("Clear Language Server Cache (Fix startup freeze)");
        clearCacheCheckbox.setStyle("-fx-text-fill: #666; -fx-font-size: 11px;");
        clearCacheCheckbox.setTooltip(new Tooltip("Check this if the application hangs on loading."));

        projectListView.setOnMouseClicked(e -> {
            if (e.getClickCount() == 2) {
                openSelectedProject();
            }
        });

        HBox buttonBox = new HBox(10, openButton, createButton);
        buttonBox.setAlignment(Pos.CENTER);

        VBox footer = new VBox(15, clearCacheCheckbox, buttonBox);
        footer.setAlignment(Pos.CENTER);
        footer.setPadding(new Insets(20, 0, 0, 0));

        VBox center = new VBox(10, projectListView, footer);
        root.setTop(header);
        root.setCenter(center);

        Scene scene = new Scene(root, 600, 550); // Increased height slightly


        return scene;
    }

    private void openSelectedProject() {
        ProjectInfo selected = projectListView.getSelectionModel().getSelectedItem();
        if (selected != null) {
            onProjectSelected.accept(selected.getName(), clearCacheCheckbox.isSelected());
        }
    }

    // ... rest of file (refreshProjectList, showCreateProjectDialog, etc) remains the same ...

    private void refreshProjectList() {
        List<ProjectInfo> projects = projectManager.listProjects();
        projectListView.getItems().clear();
        projectListView.getItems().addAll(projects);
    }

    private void showCreateProjectDialog() {
        Dialog<String> dialog = new Dialog<>();
        dialog.setTitle("Create New Project");
        dialog.setHeaderText("Enter project name");

        ButtonType createButtonType = new ButtonType("Create", ButtonBar.ButtonData.OK_DONE);
        dialog.getDialogPane().getButtonTypes().addAll(createButtonType, ButtonType.CANCEL);

        VBox content = new VBox(10);
        content.setPadding(new Insets(20));

        TextField projectNameField = new TextField();
        projectNameField.setPromptText("ProjectName");

        Label instructionLabel = new Label("Project name must:");
        instructionLabel.setStyle("-fx-font-size: 11px; -fx-text-fill: gray;");

        Label rule1 = new Label("• Start with an uppercase letter");
        rule1.setStyle("-fx-font-size: 10px; -fx-text-fill: gray;");

        Label rule2 = new Label("• Contain only letters and numbers");
        rule2.setStyle("-fx-font-size: 10px; -fx-text-fill: gray;");

        Label rule3 = new Label("• Be between 2-50 characters");
        rule3.setStyle("-fx-font-size: 10px; -fx-text-fill: gray;");

        Label exampleLabel = new Label("Example: MyFirstProject");
        exampleLabel.setStyle("-fx-font-size: 10px; -fx-font-style: italic; -fx-text-fill: gray;");

        content.getChildren().addAll(
                new Label("Project Name:"),
                projectNameField,
                instructionLabel,
                rule1,
                rule2,
                rule3,
                exampleLabel
        );

        dialog.getDialogPane().setContent(content);

        Button createButton = (Button) dialog.getDialogPane().lookupButton(createButtonType);
        createButton.setDisable(true);

        projectNameField.textProperty().addListener((observable, oldValue, newValue) -> {
            boolean isValid = isValidProjectName(newValue);
            createButton.setDisable(!isValid);
            if (newValue.isEmpty()) projectNameField.setStyle("");
            else if (isValid) projectNameField.setStyle("-fx-border-color: green; -fx-border-width: 2px;");
            else projectNameField.setStyle("-fx-border-color: red; -fx-border-width: 2px;");
        });

        javafx.application.Platform.runLater(projectNameField::requestFocus);

        dialog.setResultConverter(dialogButton -> {
            if (dialogButton == createButtonType) return projectNameField.getText();
            return null;
        });

        Optional<String> result = dialog.showAndWait();
        result.ifPresent(this::createProject);
    }

    private boolean isValidProjectName(String name) {
        if (name == null || name.trim().isEmpty()) return false;
        if (!name.matches("^[A-Z][a-zA-Z0-9]*$")) return false;
        if (name.length() < 2 || name.length() > 50) return false;
        if (projectCreator.projectExists(name)) return false;
        return true;
    }

    private void createProject(String projectName) {
        try {
            projectCreator.createProject(projectName);
            refreshProjectList();
            for (ProjectInfo project : projectListView.getItems()) {
                if (project.getName().equals(projectName)) {
                    projectListView.getSelectionModel().select(project);
                    break;
                }
            }
        } catch (Exception e) {
            Alert errorAlert = new Alert(Alert.AlertType.ERROR);
            errorAlert.setTitle("Error");
            errorAlert.setHeaderText("Failed to create project");
            errorAlert.setContentText(e.getMessage());
            errorAlert.showAndWait();
        }
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\ui\ToolbarManager.java
=================================================================================

package com.botmaker.ui;

import com.botmaker.events.CoreApplicationEvents;
import com.botmaker.events.EventBus;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.control.Button;
import javafx.scene.control.Tooltip;
import javafx.scene.layout.HBox;

public class ToolbarManager {

    private final EventBus eventBus;

    // Controls
    private Button undoButton, redoButton;
    private Button runButton, debugButton, unifiedStopButton;
    private Button stepOverButton, continueButton;

    private enum AppState { IDLE, RUNNING, DEBUGGING }
    private AppState currentAppState = AppState.IDLE;

    public ToolbarManager(EventBus eventBus) {
        this.eventBus = eventBus;
        setupEventHandlers();
    }

    private void setupEventHandlers() {
        eventBus.subscribe(CoreApplicationEvents.ProgramStartedEvent.class, e -> setAppState(AppState.RUNNING), true);
        eventBus.subscribe(CoreApplicationEvents.ProgramStoppedEvent.class, e -> setAppState(AppState.IDLE), true);
        eventBus.subscribe(CoreApplicationEvents.DebugSessionStartedEvent.class, e -> setAppState(AppState.DEBUGGING), true);
        eventBus.subscribe(CoreApplicationEvents.DebugSessionFinishedEvent.class, e -> setAppState(AppState.IDLE), true);
        eventBus.subscribe(CoreApplicationEvents.DebugSessionPausedEvent.class, e -> updateDebugControls(true), true);
        eventBus.subscribe(CoreApplicationEvents.DebugSessionResumedEvent.class, e -> updateDebugControls(false), true);
        eventBus.subscribe(CoreApplicationEvents.HistoryStateChangedEvent.class, event -> {
            if (undoButton != null) undoButton.setDisable(!event.canUndo());
            if (redoButton != null) redoButton.setDisable(!event.canRedo());
        }, true);
    }

    /**
     * Creates the Left-side group: Undo, Redo, Compile
     */
    public HBox createEditGroup() {
        undoButton = new Button("↶");
        undoButton.setTooltip(new Tooltip("Undo (Ctrl+Z)"));
        undoButton.setDisable(true);
        undoButton.setOnAction(e -> eventBus.publish(new CoreApplicationEvents.UndoRequestedEvent()));

        redoButton = new Button("↷");
        redoButton.setTooltip(new Tooltip("Redo (Ctrl+Y)"));
        redoButton.setDisable(true);
        redoButton.setOnAction(e -> eventBus.publish(new CoreApplicationEvents.RedoRequestedEvent()));

        Button compileButton = new Button("⚙ Compile");
        compileButton.getStyleClass().add("toolbar-btn");
        compileButton.setOnAction(e -> eventBus.publish(new CoreApplicationEvents.CompilationRequestedEvent()));

        HBox group = new HBox(5, undoButton, redoButton, compileButton);
        group.setAlignment(Pos.CENTER_LEFT);
        group.setPadding(new Insets(0, 10, 0, 0));
        return group;
    }

    /**
     * Creates the Right-side group: Run, Debug, Stop, Step, Continue
     */
    public HBox createExecutionGroup() {
        runButton = new Button("▶ Run");
        runButton.getStyleClass().addAll("toolbar-btn", "btn-run");
        runButton.setOnAction(e -> eventBus.publish(new CoreApplicationEvents.ExecutionRequestedEvent()));

        debugButton = new Button("🐞 Debug");
        debugButton.getStyleClass().addAll("toolbar-btn", "btn-debug");
        debugButton.setOnAction(e -> eventBus.publish(new CoreApplicationEvents.DebugStartRequestedEvent()));

        unifiedStopButton = new Button("⏹ Stop");
        unifiedStopButton.getStyleClass().addAll("toolbar-btn", "btn-stop");
        unifiedStopButton.setDisable(true);
        unifiedStopButton.setOnAction(e -> {
            if (currentAppState == AppState.RUNNING) eventBus.publish(new CoreApplicationEvents.StopRunRequestedEvent());
            else if (currentAppState == AppState.DEBUGGING) eventBus.publish(new CoreApplicationEvents.DebugStopRequestedEvent());
        });

        stepOverButton = new Button("⤵ Step");
        stepOverButton.setDisable(true);
        stepOverButton.setOnAction(e -> eventBus.publish(new CoreApplicationEvents.DebugStepOverRequestedEvent()));

        continueButton = new Button("⏩ Cont");
        continueButton.setDisable(true);
        continueButton.setOnAction(e -> eventBus.publish(new CoreApplicationEvents.DebugContinueRequestedEvent()));

        HBox group = new HBox(5, runButton, debugButton, unifiedStopButton, stepOverButton, continueButton);
        group.setAlignment(Pos.CENTER_RIGHT);
        return group;
    }

    private void setAppState(AppState state) {
        this.currentAppState = state;
        updateToolbarState();
    }

    private void updateToolbarState() {
        boolean isBusy = (currentAppState != AppState.IDLE);
        runButton.setDisable(isBusy);
        debugButton.setDisable(isBusy);
        unifiedStopButton.setDisable(!isBusy);

        if (currentAppState == AppState.DEBUGGING) {
            unifiedStopButton.setStyle("-fx-background-color: #E74C3C; -fx-text-fill: white;");
        } else if (currentAppState == AppState.RUNNING) {
            unifiedStopButton.setStyle("-fx-background-color: #E74C3C; -fx-text-fill: white;");
            stepOverButton.setDisable(true);
            continueButton.setDisable(true);
        } else {
            unifiedStopButton.setStyle("");
            stepOverButton.setDisable(true);
            continueButton.setDisable(true);
        }
    }

    private void updateDebugControls(boolean isPaused) {
        if (currentAppState == AppState.DEBUGGING) {
            stepOverButton.setDisable(!isPaused);
            continueButton.setDisable(!isPaused);
        }
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\ui\UIManager.java
=================================================================================

package com.botmaker.ui;

import com.botmaker.config.ApplicationConfig;
import com.botmaker.events.CoreApplicationEvents;
import com.botmaker.events.EventBus;
import com.botmaker.lsp.CompletionContext;
import com.botmaker.services.CodeEditorService;
import com.botmaker.state.ApplicationState;
import com.botmaker.validation.DiagnosticsManager;
import com.botmaker.validation.ErrorTranslator;
import javafx.geometry.Insets;
import javafx.geometry.Orientation;
import javafx.geometry.Pos;
import javafx.scene.Node;
import javafx.scene.Scene;
import javafx.scene.control.*;
import javafx.scene.layout.*;
import javafx.stage.Stage;
import org.eclipse.lsp4j.Diagnostic;
import org.eclipse.lsp4j.DiagnosticSeverity;

import java.util.List;
import java.util.function.Consumer;

public class UIManager {

    private final EventBus eventBus;
    private final CodeEditorService codeEditorService;
    private final DiagnosticsManager diagnosticsManager;
    private final Stage primaryStage;

    private final PaletteManager paletteManager;
    private final ToolbarManager toolbarManager;
    private final EventLogManager eventLogManager;
    private final MenuBarManager menuBarManager;
    private final FileExplorerManager fileExplorerManager;

    private VBox blocksContainer;
    private Label statusLabel;
    private TextArea outputArea;
    private ListView<Diagnostic> errorListView;
    private TabPane bottomTabPane;
    private Consumer<Void> onSelectProject;

    public UIManager(BlockDragAndDropManager dragAndDropManager,
                     EventBus eventBus,
                     CodeEditorService codeEditorService,
                     DiagnosticsManager diagnosticsManager,
                     Stage primaryStage,
                     ApplicationConfig config,
                     ApplicationState state) {
        this.eventBus = eventBus;
        this.codeEditorService = codeEditorService;
        this.diagnosticsManager = diagnosticsManager;
        this.primaryStage = primaryStage;

        this.paletteManager = new PaletteManager(dragAndDropManager);
        this.toolbarManager = new ToolbarManager(eventBus);
        this.eventLogManager = new EventLogManager(eventBus);
        this.menuBarManager = new MenuBarManager(primaryStage);
        this.menuBarManager.setEventBus(eventBus);
        this.fileExplorerManager = new FileExplorerManager(config, codeEditorService, state);

        setupEventHandlers();
    }

    private void setupEventHandlers() {
        eventBus.subscribe(CoreApplicationEvents.UIBlocksUpdatedEvent.class, this::handleBlocksUpdate, true);
        eventBus.subscribe(CoreApplicationEvents.OutputAppendedEvent.class, event -> {
            if (outputArea.getText().length() > 10_000) {
                String current = outputArea.getText();
                outputArea.setText("[...Trimmed...]\n" + current.substring(current.length() - 5000) + event.getText());
                outputArea.positionCaret(outputArea.getLength());
            } else {
                outputArea.appendText(event.getText());
            }
        }, true);
        eventBus.subscribe(CoreApplicationEvents.OutputClearedEvent.class, event -> outputArea.clear(), true);
        eventBus.subscribe(CoreApplicationEvents.OutputSetEvent.class, event -> outputArea.setText(event.getText()), true);
        eventBus.subscribe(CoreApplicationEvents.StatusMessageEvent.class, event -> statusLabel.setText(event.getMessage()), true);
        eventBus.subscribe(CoreApplicationEvents.DiagnosticsUpdatedEvent.class, event -> {
            diagnosticsManager.processDiagnostics(event.getDiagnostics());
            updateErrors(diagnosticsManager.getDiagnostics());
            statusLabel.setText(diagnosticsManager.getErrorSummary());
        }, true);
        eventBus.subscribe(CoreApplicationEvents.ProgramStartedEvent.class, e -> selectBottomTab(0), true);
        eventBus.subscribe(CoreApplicationEvents.DebugSessionStartedEvent.class, e -> selectBottomTab(0), true);
    }

    private void handleBlocksUpdate(CoreApplicationEvents.UIBlocksUpdatedEvent event) {
        blocksContainer.getChildren().clear();
        if (event.getRootBlock() != null) {
            CompletionContext context = codeEditorService.createCompletionContext();
            Node rootNode = event.getRootBlock().getUINode(context);
            rootNode.addEventHandler(BlockEvent.BreakpointToggleEvent.TOGGLE_BREAKPOINT, e ->
                    eventBus.publish(new CoreApplicationEvents.BreakpointToggledEvent(e.getBlock(), e.isEnabled())));
            blocksContainer.getChildren().add(rootNode);
        }
    }

    public Scene createScene() {
        menuBarManager.setOnSelectProject(v -> { if (onSelectProject != null) onSelectProject.accept(null); });

        // --- 1. Top Bar Construction ---

        // Left
        HBox editControls = toolbarManager.createEditGroup();
        Separator leftSep = new Separator(Orientation.VERTICAL);
        leftSep.setPadding(new Insets(0, 5, 0, 5));
        HBox leftContainer = new HBox(editControls, leftSep);
        leftContainer.setAlignment(Pos.CENTER_LEFT);

        // Center: Palette
        HBox paletteControls = paletteManager.createHorizontalPalette();

        ScrollPane paletteScroll = new ScrollPane(paletteControls);
        paletteScroll.setVbarPolicy(ScrollPane.ScrollBarPolicy.NEVER);
        paletteScroll.setHbarPolicy(ScrollPane.ScrollBarPolicy.NEVER); // Hide Horizontal Bar too, let it shrink

        // Ensure content fills the scroll pane area
        paletteScroll.setFitToWidth(true);
        paletteScroll.setFitToHeight(true);

        paletteScroll.setStyle("-fx-background-color: transparent; -fx-padding: 0;");
        paletteScroll.getStyleClass().add("edge-to-edge");

        // Right
        HBox executionControls = toolbarManager.createExecutionGroup();
        Separator rightSep = new Separator(Orientation.VERTICAL);
        rightSep.setPadding(new Insets(0, 5, 0, 5));
        HBox rightContainer = new HBox(rightSep, executionControls);
        rightContainer.setAlignment(Pos.CENTER_RIGHT);

        BorderPane topBar = new BorderPane();
        topBar.setPadding(new Insets(6)); // Comfortable padding around the whole bar
        topBar.setLeft(leftContainer);
        topBar.setCenter(paletteScroll);
        topBar.setRight(rightContainer);
        topBar.getStyleClass().add("main-toolbar");

        // FIXED HEIGHT CONSTRAINTS
        // This stops the "Expand as much as I want" issue.
        // 45px content + 12px padding = ~57px total height
        topBar.setMinHeight(50);
        topBar.setPrefHeight(50);
        topBar.setMaxHeight(50);

        topBar.setStyle("-fx-border-color: #dcdcdc; -fx-border-width: 0 0 1 0; -fx-background-color: #f4f4f4;");

        // --- 2. Left Panel: File Explorer ---
        VBox fileExplorer = fileExplorerManager.createView();
        fileExplorer.setMinWidth(150);
        fileExplorer.setMaxWidth(400);

        // --- 3. Center: Code Canvas ---
        blocksContainer = new VBox(10);
        blocksContainer.getStyleClass().add("blocks-canvas");
        blocksContainer.setPadding(new Insets(20));

        ScrollPane canvasScroll = new ScrollPane(blocksContainer);
        canvasScroll.setFitToWidth(true);
        canvasScroll.setFitToHeight(true);
        canvasScroll.getStyleClass().add("code-scroll-pane");

        // --- 4. Bottom Panel: Terminal/Errors ---
        outputArea = new TextArea();
        outputArea.setEditable(false);
        outputArea.getStyleClass().add("console-area");
        addContextMenu(outputArea);

        errorListView = new ListView<>();
        configureErrorList(errorListView);
        addContextMenu(errorListView);

        bottomTabPane = new TabPane();
        Tab terminalTab = new Tab("Terminal", outputArea); terminalTab.setClosable(false);
        Tab errorsTab = new Tab("Errors", errorListView); errorsTab.setClosable(false);
        Tab eventsTab = new Tab("Event Log", eventLogManager.getView()); eventsTab.setClosable(false);
        bottomTabPane.getTabs().addAll(terminalTab, errorsTab, eventsTab);

        // --- 5. Layout Assembly ---

        SplitPane verticalSplit = new SplitPane();
        verticalSplit.setOrientation(Orientation.VERTICAL);
        verticalSplit.getItems().addAll(canvasScroll, bottomTabPane);
        verticalSplit.setDividerPositions(0.82);

        SplitPane mainSplit = new SplitPane();
        mainSplit.setOrientation(Orientation.HORIZONTAL);
        mainSplit.getItems().addAll(fileExplorer, verticalSplit);
        mainSplit.setDividerPositions(0.25);

        statusLabel = new Label("Ready");
        statusLabel.setId("status-label");
        statusLabel.setPadding(new Insets(2, 5, 2, 5));

        VBox root = new VBox(menuBarManager.getMenuBar(), topBar, mainSplit, statusLabel);
        VBox.setVgrow(mainSplit, Priority.ALWAYS);
        root.getStyleClass().add("light-theme");

        primaryStage.setOnHidden(e -> eventLogManager.shutdown());

        Scene scene = new Scene(root, 1000, 700);
        return scene;
    }

    private void configureErrorList(ListView<Diagnostic> lv) {
        lv.setPlaceholder(new Label("No errors."));
        lv.setCellFactory(list -> new ListCell<>() {
            @Override
            protected void updateItem(Diagnostic diagnostic, boolean empty) {
                super.updateItem(diagnostic, empty);
                getStyleClass().removeAll("error-cell", "warning-cell");
                if (empty || diagnostic == null) {
                    setText(null);
                    setOnMouseClicked(null);
                } else {
                    String message = ErrorTranslator.getShortSummary(diagnostic);
                    int line = diagnostic.getRange().getStart().getLine() + 1;
                    setText(String.format("Line %d: %s", line, message));
                    if (diagnostic.getSeverity() == DiagnosticSeverity.Error) getStyleClass().add("error-cell");
                    else if (diagnostic.getSeverity() == DiagnosticSeverity.Warning) getStyleClass().add("warning-cell");
                    setOnMouseClicked(event -> {
                        if (event.getClickCount() >= 1) {
                            diagnosticsManager.findBlockForDiagnostic(diagnostic).ifPresent(block -> {
                                Node uiNode = block.getUINode();
                                if (uiNode != null) uiNode.requestFocus();
                            });
                        }
                    });
                }
            }
        });
    }

    private void addContextMenu(Control control) {
        ContextMenu cm = new ContextMenu();
        if (control instanceof TextArea) {
            TextArea ta = (TextArea) control;
            MenuItem copy = new MenuItem("Copy");
            copy.setOnAction(e -> ta.copy());
            MenuItem clear = new MenuItem("Clear");
            clear.setOnAction(e -> ta.clear());
            cm.getItems().addAll(copy, new SeparatorMenuItem(), clear);
            ta.setContextMenu(cm);
        } else if (control instanceof ListView) {
            ListView<?> lv = (ListView<?>) control;
            MenuItem copy = new MenuItem("Copy Selection");
            copy.setOnAction(e -> {
                Object selected = lv.getSelectionModel().getSelectedItem();
                if (selected != null) {
                    javafx.scene.input.ClipboardContent content = new javafx.scene.input.ClipboardContent();
                    content.putString(selected.toString());
                    javafx.scene.input.Clipboard.getSystemClipboard().setContent(content);
                }
            });
            cm.getItems().add(copy);
            lv.setContextMenu(cm);
        }
    }

    private void updateErrors(List<Diagnostic> diagnostics) {
        if (diagnostics == null) errorListView.getItems().clear();
        else errorListView.getItems().setAll(diagnostics);
        if (diagnostics != null && !diagnostics.isEmpty()) selectBottomTab(1);
    }

    private void selectBottomTab(int index) {
        if (bottomTabPane != null && index < bottomTabPane.getTabs().size()) {
            bottomTabPane.getSelectionModel().select(index);
        }
    }

    public void setOnSelectProject(Consumer<Void> callback) { this.onSelectProject = callback; }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\ui\builders\BlockLayout.java
=================================================================================

package com.botmaker.ui.builders;

/**
 * Main entry point for building block UIs.
 * Provides fluent API for common block layouts.
 */
public class BlockLayout {

    // Factory methods for different layout types
    public static HeaderLayoutBuilder header() {
        return new HeaderLayoutBuilder();
    }

    public static BodyLayoutBuilder body() {
        return new BodyLayoutBuilder();
    }

    public static SentenceLayoutBuilder sentence() {
        return new SentenceLayoutBuilder();
    }

    public static LoopLayoutBuilder loop() {
        return new LoopLayoutBuilder();
    }

    public static ConditionalLayoutBuilder conditional() {
        return new ConditionalLayoutBuilder();
    }

    public static ExpressionLayoutBuilder expression() {
        return new ExpressionLayoutBuilder();
    }

    public static DeclarationLayoutBuilder declaration() {
        return new DeclarationLayoutBuilder();
    }

    public static OperatorLayoutBuilder operator() {
        return new OperatorLayoutBuilder();
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\ui\builders\BodyLayoutBuilder.java
=================================================================================

package com.botmaker.ui.builders;

import com.botmaker.core.BodyBlock;
import com.botmaker.lsp.CompletionContext;
import javafx.geometry.Insets;
import javafx.scene.Node;
import javafx.scene.layout.VBox;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class BodyLayoutBuilder {
    private final Node headerNode; // Optional header
    private BodyBlock bodyBlock;
    private CompletionContext context;
    private boolean indented = true;
    private Insets indentation = new Insets(5, 0, 0, 20);
    private final List<String> styleClasses = new ArrayList<>();

    public BodyLayoutBuilder() {
        this.headerNode = null;
    }

    public BodyLayoutBuilder(Node headerNode) {
        this.headerNode = headerNode;
    }

    public BodyLayoutBuilder withContent(BodyBlock body, CompletionContext context) {
        this.bodyBlock = body;
        this.context = context;
        return this;
    }

    public BodyLayoutBuilder withIndentation(Insets insets) {
        this.indentation = insets;
        this.indented = true;
        return this;
    }

    public BodyLayoutBuilder noIndentation() {
        this.indented = false;
        return this;
    }

    public BodyLayoutBuilder withStyleClass(String... classes) {
        styleClasses.addAll(Arrays.asList(classes));
        return this;
    }

    public VBox build() {
        VBox container = new VBox(5);
        styleClasses.forEach(c -> container.getStyleClass().add(c));

        if (headerNode != null) {
            container.getChildren().add(headerNode);
        }

        if (bodyBlock != null) {
            VBox bodyContainer = new VBox();
            if (indented) {
                bodyContainer.setPadding(indentation);
            }
            bodyContainer.getChildren().add(bodyBlock.getUINode(context));
            container.getChildren().add(bodyContainer);
        }

        return container;
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\ui\builders\ConditionalLayoutBuilder.java
=================================================================================

package com.botmaker.ui.builders;

import com.botmaker.core.BodyBlock;
import com.botmaker.core.ExpressionBlock;
import com.botmaker.lsp.CompletionContext;
import javafx.geometry.Insets;
import javafx.scene.Node;
import javafx.scene.control.Button;
import javafx.scene.layout.VBox;

public class ConditionalLayoutBuilder {
    private ExpressionBlock condition;
    private BodyBlock thenBody;
    private Node elseNode; // Could be another IfBlock or BodyBlock
    private CompletionContext context;
    private Runnable onDelete;
    private Runnable onAddElse;
    private Runnable onConditionChange;

    public ConditionalLayoutBuilder withCondition(
            ExpressionBlock condition,
            CompletionContext context) {
        this.condition = condition;
        this.context = context;
        return this;
    }

    public ConditionalLayoutBuilder withThenBody(BodyBlock body) {
        this.thenBody = body;
        return this;
    }

    public ConditionalLayoutBuilder withElse(Node elseNode) {
        this.elseNode = elseNode;
        return this;
    }

    public ConditionalLayoutBuilder withAddElseButton(Runnable onAddElse) {
        this.onAddElse = onAddElse;
        return this;
    }

    public ConditionalLayoutBuilder withDeleteButton(Runnable onDelete) {
        this.onDelete = onDelete;
        return this;
    }

    public ConditionalLayoutBuilder withConditionChangeHandler(Runnable onChange) {
        this.onConditionChange = onChange;
        return this;
    }

    public VBox build() {
        VBox container = new VBox(5);
        container.getStyleClass().add("if-block");

        // Header
        HeaderLayoutBuilder headerBuilder = BlockLayout.header()
                .withKeyword("If")
                .withExpressionSlot(condition, context, "boolean");

        if (onConditionChange != null) {
            headerBuilder.withAddButton(onConditionChange);
        }

        if (onDelete != null) {
            headerBuilder.withDeleteButton(onDelete);
        }

        container.getChildren().add(headerBuilder.build());

        // Then body
        if (thenBody != null) {
            VBox bodyContainer = new VBox();
            bodyContainer.setPadding(new Insets(5, 0, 0, 20));
            bodyContainer.getChildren().add(thenBody.getUINode(context));
            container.getChildren().add(bodyContainer);
        }

        // Else
        if (elseNode != null) {
            container.getChildren().add(elseNode);
        } else if (onAddElse != null) {
            Button addElseBtn = new Button("+");
            addElseBtn.getStyleClass().add("expression-add-button");
            addElseBtn.setOnAction(e -> onAddElse.run());
            container.getChildren().add(addElseBtn);
        }

        return container;
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\ui\builders\DeclarationLayoutBuilder.java
=================================================================================

package com.botmaker.ui.builders;

import com.botmaker.core.ExpressionBlock;
import com.botmaker.lsp.CompletionContext;
import com.botmaker.ui.components.TextFieldComponents;
import com.botmaker.util.TypeInfo;
import javafx.scene.Cursor;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.control.TextField;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Pane;
import javafx.scene.layout.Priority;

import java.util.function.Consumer;

public class DeclarationLayoutBuilder {
    private String type;
    private String variableName;
    private ExpressionBlock initializer;
    private CompletionContext context;
    private Runnable onDelete;
    private Runnable onTypeChange;
    private Runnable onInitializerChange;
    private Consumer<String> onNameChange;

    public DeclarationLayoutBuilder withType(String type) {
        this.type = type;
        return this;
    }

    public DeclarationLayoutBuilder withVariableName(
            String name,
            Consumer<String> onNameChange) {
        this.variableName = name;
        this.onNameChange = onNameChange;
        return this;
    }

    public DeclarationLayoutBuilder withInitializer(
            ExpressionBlock initializer,
            CompletionContext context) {
        this.initializer = initializer;
        this.context = context;
        return this;
    }

    public DeclarationLayoutBuilder withTypeChangeHandler(Runnable onChange) {
        this.onTypeChange = onChange;
        return this;
    }

    public DeclarationLayoutBuilder withInitializerChangeHandler(Runnable onChange) {
        this.onInitializerChange = onChange;
        return this;
    }

    public DeclarationLayoutBuilder withDeleteButton(Runnable onDelete) {
        this.onDelete = onDelete;
        return this;
    }

    public HBox build() {
        SentenceLayoutBuilder sentence = BlockLayout.sentence();

        // Type label (clickable if change handler provided)
        Label typeLabel = new Label(type);
        typeLabel.getStyleClass().add("type-label");
        if (onTypeChange != null) {
            typeLabel.setCursor(Cursor.HAND);
            typeLabel.setOnMouseClicked(e -> onTypeChange.run());
        }
        sentence.addNode(typeLabel);

        // Variable name field
        TextField nameField = TextFieldComponents.createVariableNameField(
                variableName,
                onNameChange != null ? onNameChange : (s) -> {}
        );
        sentence.addNode(nameField);

        // Assignment operator
        sentence.addKeyword("=");

        // Initializer
        sentence.addExpressionSlot(initializer, context, TypeInfo.UNKNOWN);

        // Change button
        if (onInitializerChange != null) {
            sentence.addNode(createAddButton(onInitializerChange));
        }

        HBox result = sentence.build();

        // Add delete button to the end
        if (onDelete != null) {
            Pane spacer = new Pane();
            HBox.setHgrow(spacer, Priority.ALWAYS);
            result.getChildren().addAll(spacer, createDeleteButton(onDelete));
        }

        return result;
    }

    private Button createAddButton(Runnable onClick) {
        Button btn = new Button("+");
        btn.getStyleClass().add("expression-add-button");
        btn.setOnAction(e -> onClick.run());
        return btn;
    }

    private Button createDeleteButton(Runnable onDelete) {
        Button btn = new Button("X");
        btn.setOnAction(e -> onDelete.run());
        return btn;
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\ui\builders\DropZoneFactory.java
=================================================================================

package com.botmaker.ui.builders;

import com.botmaker.lsp.CompletionContext;
import javafx.scene.Node;
import javafx.scene.layout.Region;

/**
 * Factory for creating drop zones used across different builders
 */
public class DropZoneFactory {

    /**
     * Creates a standard expression drop zone with drag-and-drop handlers
     */
    public static Node createExpressionDropZone(CompletionContext context) {
        Region dropZone = new Region();
        dropZone.setMinHeight(25);
        dropZone.setMinWidth(50);
        dropZone.setStyle(
                "-fx-background-color: #f0f0f0; " +
                        "-fx-border-color: #c0c0c0; " +
                        "-fx-border-style: dashed;"
        );

        if (context != null && context.dragAndDropManager() != null) {
            context.dragAndDropManager().addExpressionDropHandlers(dropZone);
        }

        return dropZone;
    }

    /**
     * Creates a statement drop zone with different styling
     */
    public static Node createStatementDropZone(CompletionContext context) {
        Region dropZone = new Region();
        dropZone.setMinHeight(30);
        dropZone.setStyle(
                "-fx-background-color: rgba(52, 73, 94, 0.15);" +
                        "-fx-border-color: rgba(52, 73, 94, 0.4);" +
                        "-fx-border-width: 2px 0 2px 0;" +
                        "-fx-border-style: dashed;"
        );

        // Statement drop zones handled differently
        // (usually managed by BodyBlock)

        return dropZone;
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\ui\builders\ExpressionLayoutBuilder.java
=================================================================================

package com.botmaker.ui.builders;

import com.botmaker.core.ExpressionBlock;
import com.botmaker.lsp.CompletionContext;
import com.botmaker.ui.theme.BlockTheme;
import com.botmaker.ui.theme.StyleBuilder;
import javafx.geometry.Pos;
import javafx.scene.Node;
import javafx.scene.control.Label;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Region;

import java.util.ArrayList;
import java.util.List;

/**
 * Builder for creating expression block UIs.
 * Handles literals, identifiers, operators, method calls, and complex expressions.
 */
public class ExpressionLayoutBuilder {

    // Common properties
    private final List<Node> components = new ArrayList<>();
    private double spacing = 5.0;
    private Pos alignment = Pos.CENTER_LEFT;
    private CompletionContext context;
    private final List<String> styleClasses = new ArrayList<>();

    // Expression-specific properties
    private ExpressionType type;

    public enum ExpressionType {
        LITERAL,
        IDENTIFIER,
        OPERATOR,
        METHOD_CALL,
        FIELD_ACCESS,
        ARRAY_ACCESS,
        LIST,
        ENUM_CONSTANT,
        PARENTHESIZED
    }

    public ExpressionLayoutBuilder() {
        styleClasses.add("expression-block");
    }

    // ===== TYPE-SPECIFIC FACTORY METHODS =====

    public static ExpressionLayoutBuilder literal() {
        ExpressionLayoutBuilder builder = new ExpressionLayoutBuilder();
        builder.type = ExpressionType.LITERAL;
        builder.styleClasses.add("literal-block");
        return builder;
    }

    public static ExpressionLayoutBuilder identifier() {
        ExpressionLayoutBuilder builder = new ExpressionLayoutBuilder();
        builder.type = ExpressionType.IDENTIFIER;
        builder.styleClasses.add("identifier-block");
        return builder;
    }

    public static ExpressionLayoutBuilder operator() {
        ExpressionLayoutBuilder builder = new ExpressionLayoutBuilder();
        builder.type = ExpressionType.OPERATOR;
        builder.styleClasses.add("operator-block");
        return builder;
    }

    public static ExpressionLayoutBuilder methodCall() {
        ExpressionLayoutBuilder builder = new ExpressionLayoutBuilder();
        builder.type = ExpressionType.METHOD_CALL;
        builder.styleClasses.add("method-call-block");
        return builder;
    }

    public static ExpressionLayoutBuilder fieldAccess() {
        ExpressionLayoutBuilder builder = new ExpressionLayoutBuilder();
        builder.type = ExpressionType.FIELD_ACCESS;
        builder.styleClasses.add("field-access-block");
        return builder;
    }

    public static ExpressionLayoutBuilder list() {
        ExpressionLayoutBuilder builder = new ExpressionLayoutBuilder();
        builder.type = ExpressionType.LIST;
        builder.styleClasses.add("list-block");
        return builder;
    }

    public static ExpressionLayoutBuilder enumConstant() {
        ExpressionLayoutBuilder builder = new ExpressionLayoutBuilder();
        builder.type = ExpressionType.ENUM_CONSTANT;
        builder.styleClasses.add("enum-constant-block");
        return builder;
    }

    // ===== COMPONENT ADDITION METHODS =====

    public ExpressionLayoutBuilder withContext(CompletionContext context) {
        this.context = context;
        return this;
    }

    public ExpressionLayoutBuilder addLabel(String text) {
        components.add(new Label(text));
        return this;
    }

    public ExpressionLayoutBuilder addStyledLabel(String text, String style) {
        Label label = new Label(text);
        label.setStyle(style);
        components.add(label);
        return this;
    }

    public ExpressionLayoutBuilder addKeyword(String text) {
        Label label = new Label(text);
        StyleBuilder.create().asKeyword().applyTo(label);
        components.add(label);
        return this;
    }

    public ExpressionLayoutBuilder addNode(Node node) {
        components.add(node);
        return this;
    }

    public ExpressionLayoutBuilder addExpression(ExpressionBlock expr) {
        if (expr != null && context != null) {
            components.add(expr.getUINode(context));
        } else if (context != null) {
            components.add(createDropZone(context));
        }
        return this;
    }

    public ExpressionLayoutBuilder addSeparator(String text) {
        Label separator = new Label(text);
        StyleBuilder.create()
                .textColor(BlockTheme.current().colors().operator())
                .fontWeight(BlockTheme.current().typography().boldWeight())
                .applyTo(separator);
        components.add(separator);
        return this;
    }

    // ===== LITERAL-SPECIFIC METHODS =====

    public ExpressionLayoutBuilder withTextField(javafx.scene.control.TextField field) {
        components.add(field);
        return this;
    }

    public ExpressionLayoutBuilder withBooleanToggle(javafx.scene.control.ComboBox<String> toggle) {
        components.add(toggle);
        return this;
    }

    // ===== IDENTIFIER-SPECIFIC METHODS =====

    public ExpressionLayoutBuilder withIdentifierText(String identifier, boolean isUnedited) {
        javafx.scene.text.Text text = new javafx.scene.text.Text(identifier);
        HBox container = new HBox(text);
        container.setAlignment(Pos.CENTER_LEFT);

        if (isUnedited) {
            container.getStyleClass().add("unedited-identifier");
        }

        components.add(container);
        return this;
    }

    public ExpressionLayoutBuilder withClickHandler(Runnable onClick) {
        // Will be applied to the final container
        return this;
    }

    // ===== FIELD ACCESS-SPECIFIC METHODS =====

    public ExpressionLayoutBuilder withQualifier(String qualifier) {
        javafx.scene.text.Text qualifierText = new javafx.scene.text.Text(qualifier + ".");
        StyleBuilder.create()
                .textColor("#8E44AD")
                .fontWeight(BlockTheme.current().typography().boldWeight())
                .applyTo(qualifierText);
        components.add(qualifierText);
        return this;
    }

    public ExpressionLayoutBuilder withFieldName(String fieldName) {
        javafx.scene.text.Text fieldText = new javafx.scene.text.Text(fieldName);
        StyleBuilder.create()
                .textColor("#2C3E50")
                .applyTo(fieldText);
        components.add(fieldText);
        return this;
    }

    // ===== METHOD CALL-SPECIFIC METHODS =====

    public ExpressionLayoutBuilder withMethodName(String methodName) {
        Label nameLabel = new Label(methodName);
        StyleBuilder.create()
                .fontWeight(BlockTheme.current().typography().boldWeight())
                .fontSize(BlockTheme.current().typography().normal())
                .applyTo(nameLabel);
        components.add(nameLabel);
        return this;
    }

    public ExpressionLayoutBuilder withArgumentList(List<Node> arguments) {
        components.add(new Label("("));

        for (int i = 0; i < arguments.size(); i++) {
            if (i > 0) {
                components.add(new Label(", "));
            }
            components.add(arguments.get(i));
        }

        components.add(new Label(")"));
        return this;
    }

    public ExpressionLayoutBuilder withArguments(ArgumentsBuilder argsBuilder) {
        components.add(argsBuilder.build());
        return this;
    }

    // ===== OPERATOR-SPECIFIC METHODS =====

    public ExpressionLayoutBuilder withLeftOperand(ExpressionBlock operand) {
        if (operand != null && context != null) {
            components.add(operand.getUINode(context));
        }
        return this;
    }

    public ExpressionLayoutBuilder withOperatorSelector(
            javafx.scene.control.ComboBox<String> selector) {
        components.add(selector);
        return this;
    }

    public ExpressionLayoutBuilder withOperatorLabel(String operator) {
        Label opLabel = new Label(operator);
        StyleBuilder.create().asOperator().applyTo(opLabel);
        components.add(opLabel);
        return this;
    }

    public ExpressionLayoutBuilder withRightOperand(ExpressionBlock operand) {
        if (operand != null && context != null) {
            components.add(operand.getUINode(context));
        }
        return this;
    }

    public ExpressionLayoutBuilder withTypeIndicator(String typeName) {
        Label typeLabel = new Label("→ " + typeName);
        StyleBuilder.create()
                .textColor("#999")
                .fontSize(BlockTheme.current().typography().small())
                .build();
        components.add(typeLabel);
        return this;
    }

    // ===== LIST-SPECIFIC METHODS =====

    public ExpressionLayoutBuilder withListHeader(String listType, int elementCount) {
        Label header = new Label(listType + " (" + elementCount + ")");
        header.getStyleClass().add("list-label");
        components.add(header);
        return this;
    }

    public ExpressionLayoutBuilder withListElements(javafx.scene.layout.VBox elementsContainer) {
        components.add(elementsContainer);
        return this;
    }

    // ===== ENUM CONSTANT-SPECIFIC METHODS =====

    public ExpressionLayoutBuilder withEnumType(String enumTypeName) {
        Label typeLabel = new Label(enumTypeName);
        StyleBuilder.create()
                .textColor("white")
                .fontWeight(BlockTheme.current().typography().boldWeight())
                .fontSize(BlockTheme.current().typography().normal())
                .applyTo(typeLabel);
        components.add(typeLabel);
        return this;
    }

    public ExpressionLayoutBuilder withEnumDot() {
        Label dot = new Label(".");
        StyleBuilder.create()
                .textColor("rgba(255,255,255,0.7)")
                .fontWeight(BlockTheme.current().typography().boldWeight())
                .applyTo(dot);
        components.add(dot);
        return this;
    }

    public ExpressionLayoutBuilder withEnumConstantSelector(
            javafx.scene.control.ComboBox<String> selector) {
        components.add(selector);
        return this;
    }

    // ===== STYLING METHODS =====

    public ExpressionLayoutBuilder spacing(double spacing) {
        this.spacing = spacing;
        return this;
    }

    public ExpressionLayoutBuilder alignment(Pos alignment) {
        this.alignment = alignment;
        return this;
    }

    public ExpressionLayoutBuilder withStyleClass(String... classes) {
        styleClasses.addAll(List.of(classes));
        return this;
    }

    public ExpressionLayoutBuilder withInlineStyle(String style) {
        // Store for application during build
        return this;
    }

    public ExpressionLayoutBuilder asCompact() {
        this.spacing = 3.0;
        return this;
    }

    public ExpressionLayoutBuilder asSpaced() {
        this.spacing = 8.0;
        return this;
    }

    // ===== BUILD METHOD =====

    public HBox build() {
        HBox container = new HBox(spacing);
        container.setAlignment(alignment);
        styleClasses.forEach(c -> container.getStyleClass().add(c));
        container.getChildren().addAll(components);
        return container;
    }

    // ===== HELPER METHODS =====

    private Node createDropZone(CompletionContext context) {
        return DropZoneFactory.createExpressionDropZone(context);
    }

    // ===== NESTED BUILDER FOR ARGUMENTS =====

    public static class ArgumentsBuilder {
        private final List<ArgumentNode> arguments = new ArrayList<>();

        public static class ArgumentNode {
            String parameterName;
            Node valueNode;

            public ArgumentNode(String parameterName, Node valueNode) {
                this.parameterName = parameterName;
                this.valueNode = valueNode;
            }
        }

        public ArgumentsBuilder addArgument(String paramName, Node value) {
            arguments.add(new ArgumentNode(paramName, value));
            return this;
        }

        public ArgumentsBuilder addArgument(Node value) {
            arguments.add(new ArgumentNode(null, value));
            return this;
        }

        public HBox build() {
            HBox container = new HBox(5);
            container.setAlignment(Pos.CENTER_LEFT);

            container.getChildren().add(new Label("("));

            for (int i = 0; i < arguments.size(); i++) {
                if (i > 0) {
                    Label comma = new Label(", ");
                    container.getChildren().add(comma);
                }

                ArgumentNode arg = arguments.get(i);

                // Create argument container
                HBox argBox = new HBox(2);
                argBox.setAlignment(Pos.CENTER_LEFT);
                StyleBuilder.create()
                        .backgroundColor("rgba(255,255,255,0.1)")
                        .backgroundRadius(4)
                        .padding(2)
                        .applyTo(argBox);

                // Add parameter name if provided
                if (arg.parameterName != null) {
                    Label paramLabel = new Label(arg.parameterName + ":");
                    StyleBuilder.create()
                            .textColor("#aaa")
                            .fontSize(BlockTheme.current().typography().tiny())
                            .padding(0, 4, 0, 2)
                            .applyTo(paramLabel);
                    argBox.getChildren().add(paramLabel);
                }

                argBox.getChildren().add(arg.valueNode);
                container.getChildren().add(argBox);
            }

            container.getChildren().add(new Label(")"));

            return container;
        }
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\ui\builders\HeaderLayoutBuilder.java
=================================================================================

package com.botmaker.ui.builders;

import com.botmaker.lsp.CompletionContext;
import javafx.geometry.Pos;
import javafx.scene.Node;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Pane;
import javafx.scene.layout.Priority;
import javafx.scene.layout.Region;

import java.util.ArrayList;
import java.util.List;

public class HeaderLayoutBuilder {
    private final List<Node> leftContent = new ArrayList<>();
    private final List<Node> rightContent = new ArrayList<>();
    private Runnable onDelete;
    private double spacing = 5.0;
    private Pos alignment = Pos.CENTER_LEFT;

    public HeaderLayoutBuilder withKeyword(String text) {
        Label label = new Label(text);
        label.getStyleClass().add("keyword-label");
        leftContent.add(label);
        return this;
    }

    public HeaderLayoutBuilder withLabel(String text) {
        leftContent.add(new Label(text));
        return this;
    }

    public HeaderLayoutBuilder withExpressionSlot(
            com.botmaker.core.ExpressionBlock expr,
            CompletionContext context,
            String targetType) {
        if (expr != null) {
            leftContent.add(expr.getUINode(context));
        } else {
            leftContent.add(createDropZone(context));
        }
        return this;
    }

    public HeaderLayoutBuilder withChangeButton(Runnable onClick) {
        Button btn = new Button("↻");
        btn.getStyleClass().add("icon-button");
        btn.setOnAction(e -> onClick.run());
        leftContent.add(btn);
        return this;
    }

    public HeaderLayoutBuilder withAddButton(Runnable onClick) {
        Button btn = new Button("+");
        btn.getStyleClass().add("expression-add-button");
        btn.setOnAction(e -> onClick.run());
        leftContent.add(btn);
        return this;
    }

    public HeaderLayoutBuilder withDeleteButton(Runnable onDelete) {
        this.onDelete = onDelete;
        return this;
    }

    public HeaderLayoutBuilder withCustomNode(Node node) {
        leftContent.add(node);
        return this;
    }

    public HeaderLayoutBuilder withRightNode(Node node) {
        rightContent.add(node);
        return this;
    }

    public HeaderLayoutBuilder spacing(double spacing) {
        this.spacing = spacing;
        return this;
    }

    public HeaderLayoutBuilder alignment(Pos alignment) {
        this.alignment = alignment;
        return this;
    }

    // Terminal operation - builds and returns the Node
    public HBox build() {
        HBox container = new HBox(spacing);
        container.setAlignment(alignment);
        container.getChildren().addAll(leftContent);

        if (onDelete != null || !rightContent.isEmpty()) {
            Pane spacer = new Pane();
            HBox.setHgrow(spacer, Priority.ALWAYS);
            container.getChildren().add(spacer);

            container.getChildren().addAll(rightContent);

            if (onDelete != null) {
                Button deleteBtn = new Button("X");
                deleteBtn.setOnAction(e -> onDelete.run());
                container.getChildren().add(deleteBtn);
            }
        }

        return container;
    }

    // Chaining into body builder
    public BodyLayoutBuilder andBody() {
        HBox header = build();
        return new BodyLayoutBuilder(header);
    }

    // ===== HELPER METHODS =====

    /**
     * Creates a drop zone for expressions with drag-and-drop support
     */
    private Node createDropZone(CompletionContext context) {
        return DropZoneFactory.createExpressionDropZone(context);
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\ui\builders\LoopLayoutBuilder.java
=================================================================================

package com.botmaker.ui.builders;

import com.botmaker.core.BodyBlock;
import com.botmaker.core.ExpressionBlock;

import com.botmaker.lsp.CompletionContext;
import com.botmaker.util.TypeInfo;
import javafx.geometry.Insets;
import javafx.scene.layout.HBox;
import javafx.scene.layout.VBox;

public class LoopLayoutBuilder {
    private String keyword;
    private ExpressionBlock condition;
    private BodyBlock body;
    private CompletionContext context;
    private Runnable onDelete;
    private Runnable onConditionChange;
    private String conditionType = "boolean";

    // For do-while
    private String footerKeyword;

    public LoopLayoutBuilder withKeyword(String keyword) {
        this.keyword = keyword;
        return this;
    }

    public LoopLayoutBuilder withCondition(
            ExpressionBlock condition,
            CompletionContext context,
            String targetType) {
        this.condition = condition;
        this.context = context;
        this.conditionType = targetType;
        return this;
    }

    public LoopLayoutBuilder withBody(BodyBlock body, CompletionContext context) {
        this.body = body;
        this.context = context;
        return this;
    }

    public LoopLayoutBuilder withFooterKeyword(String keyword) {
        this.footerKeyword = keyword;
        return this;
    }

    public LoopLayoutBuilder withDeleteButton(Runnable onDelete) {
        this.onDelete = onDelete;
        return this;
    }

    public LoopLayoutBuilder withConditionChangeHandler(Runnable onChange) {
        this.onConditionChange = onChange;
        return this;
    }

    public VBox build() {
        VBox container = new VBox(5);

        // Header: keyword + condition (for while/for)
        if (keyword != null && footerKeyword == null) {
            HeaderLayoutBuilder headerBuilder = BlockLayout.header()
                    .withKeyword(keyword)
                    .withExpressionSlot(condition, context, conditionType);

            if (onConditionChange != null) {
                headerBuilder.withAddButton(onConditionChange);
            }

            if (onDelete != null) {
                headerBuilder.withDeleteButton(onDelete);
            }

            container.getChildren().add(headerBuilder.build());
        }
        // Header for do-while (just keyword)
        else if (keyword != null) {
            container.getChildren().add(
                    BlockLayout.header()
                            .withKeyword(keyword)
                            .withDeleteButton(onDelete)
                            .build()
            );
        }

        // Body
        if (body != null) {
            VBox bodyContainer = new VBox();
            bodyContainer.setPadding(new Insets(5, 0, 0, 20));
            bodyContainer.getChildren().add(body.getUINode(context));
            container.getChildren().add(bodyContainer);
        }

        // Footer (for do-while)
        if (footerKeyword != null) {
            HBox footer = BlockLayout.sentence()
                    .addKeyword(footerKeyword)
                    .addExpressionSlot(condition, context, TypeInfo.from(conditionType))
                    .build();
            container.getChildren().add(footer);
        }

        return container;
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\ui\builders\OperatorLayoutBuilder.java
=================================================================================

package com.botmaker.ui.builders;

import com.botmaker.core.ExpressionBlock;
import com.botmaker.lsp.CompletionContext;
import com.botmaker.ui.components.SelectorComponents;
import javafx.geometry.Pos;
import javafx.scene.control.Button;
import javafx.scene.control.ComboBox;
import javafx.scene.control.Label;
import javafx.scene.layout.HBox;

import java.util.function.Consumer;

public class OperatorLayoutBuilder {
    private ExpressionBlock leftOperand;
    private ExpressionBlock rightOperand;
    private String operator;
    private String[] operatorNames;
    private String[] operatorSymbols;
    private Consumer<String> onOperatorChange;
    private CompletionContext context;
    private String operandType = "number";

    public OperatorLayoutBuilder withLeftOperand(
            ExpressionBlock operand,
            CompletionContext context) {
        this.leftOperand = operand;
        this.context = context;
        return this;
    }

    public OperatorLayoutBuilder withRightOperand(
            ExpressionBlock operand,
            CompletionContext context) {
        this.rightOperand = operand;
        this.context = context;
        return this;
    }

    public OperatorLayoutBuilder withOperator(
            String operator,
            String[] names,
            String[] symbols,
            Consumer<String> onChange) {
        this.operator = operator;
        this.operatorNames = names;
        this.operatorSymbols = symbols;
        this.onOperatorChange = onChange;
        return this;
    }

    public OperatorLayoutBuilder withOperandType(String type) {
        this.operandType = type;
        return this;
    }

    public HBox build() {
        HBox container = new HBox(5);
        container.setAlignment(Pos.CENTER_LEFT);
        container.getStyleClass().add("binary-expression-block");

        HBox expressionBox = new HBox(5);
        expressionBox.setAlignment(Pos.CENTER_LEFT);

        // Left operand
        if (leftOperand != null) {
            expressionBox.getChildren().add(leftOperand.getUINode(context));
            Button changeLeft = createChangeButton();
            expressionBox.getChildren().add(changeLeft);
        }

        // Operator selector
        if (operatorNames != null && operatorSymbols != null) {
            ComboBox<String> selector = SelectorComponents.createOperatorSelector(
                    operatorNames, operatorSymbols, operator, onOperatorChange
            );
            selector.getStyleClass().add("math-operator-selector");
            expressionBox.getChildren().add(selector);
        } else {
            Label opLabel = new Label(operator);
            opLabel.getStyleClass().add("operator-label");
            expressionBox.getChildren().add(opLabel);
        }

        // Right operand
        if (rightOperand != null) {
            expressionBox.getChildren().add(rightOperand.getUINode(context));
            Button changeRight = createChangeButton();
            expressionBox.getChildren().add(changeRight);
        }

        container.getChildren().add(expressionBox);

        return container;
    }

    private Button createChangeButton() {
        Button btn = new Button("↻");
        btn.getStyleClass().add("icon-button");
        btn.setStyle("-fx-font-size: 8px; -fx-padding: 1px 3px;");
        return btn;
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\ui\builders\SentenceLayoutBuilder.java
=================================================================================

package com.botmaker.ui.builders;

import com.botmaker.core.ExpressionBlock;
import com.botmaker.lsp.CompletionContext;
import com.botmaker.ui.components.SelectorComponents;
import javafx.geometry.Pos;
import javafx.scene.Node;
import javafx.scene.control.ComboBox;
import javafx.scene.control.Label;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Region;

import java.util.ArrayList;
import java.util.List;
import java.util.function.Consumer;

public class SentenceLayoutBuilder {
    private final List<Node> nodes = new ArrayList<>();
    private double spacing = 5.0;
    private Pos alignment = Pos.CENTER_LEFT;

    public SentenceLayoutBuilder addKeyword(String text) {
        Label label = new Label(text);
        label.getStyleClass().add("keyword-label");
        nodes.add(label);
        return this;
    }

    public SentenceLayoutBuilder addLabel(String text) {
        nodes.add(new Label(text));
        return this;
    }

    public SentenceLayoutBuilder addNode(Node node) {
        nodes.add(node);
        return this;
    }

    /**
     * TypeInfo overload for addExpressionSlot
     */
    public SentenceLayoutBuilder addExpressionSlot(com.botmaker.core.ExpressionBlock expression,
                                                   com.botmaker.lsp.CompletionContext context,
                                                   com.botmaker.util.TypeInfo expectedType) {
        if (expression != null) {
            nodes.add(expression.getUINode(context));
        } else {
            javafx.scene.control.Label placeholder = new javafx.scene.control.Label("⟨expression⟩");
            placeholder.setStyle("-fx-text-fill: rgba(255,255,255,0.4); -fx-font-style: italic;");
            nodes.add(placeholder);
        }
        return this;
    }

    public SentenceLayoutBuilder addOperatorSelector(
            String[] names,
            String[] symbols,
            String current,
            Consumer<String> onChange) {
        ComboBox<String> selector = SelectorComponents.createOperatorSelector(
                names, symbols, current, onChange
        );
        nodes.add(selector);
        return this;
    }

    public SentenceLayoutBuilder spacing(double spacing) {
        this.spacing = spacing;
        return this;
    }

    public HBox build() {
        HBox container = new HBox(spacing);
        container.setAlignment(alignment);
        container.getChildren().addAll(nodes);
        return container;
    }

    private Node createDropZone(CompletionContext context) {
        return DropZoneFactory.createExpressionDropZone(context);
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\ui\components\BlockUIComponents.java
=================================================================================

package com.botmaker.ui.components;

import com.botmaker.ui.AddableExpression;
import com.botmaker.util.TypeInfo;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.geometry.Pos;
import javafx.scene.Node;
import javafx.scene.control.*;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Pane;
import javafx.scene.layout.Priority;

import java.util.List;
import java.util.Map;
import java.util.function.Consumer;
import java.util.stream.Collectors;

public class BlockUIComponents {

    public static Button createDeleteButton(Runnable onDelete) {
        Button btn = new Button("X");
        btn.setOnAction(e -> onDelete.run());
        return btn;
    }

    public static Button createAddButton(EventHandler<ActionEvent> handler) {
        Button btn = new Button("+");
        btn.getStyleClass().add("expression-add-button");
        btn.setOnAction(handler);
        return btn;
    }

    public static Button createChangeButton(EventHandler<ActionEvent> handler) {
        Button btn = new Button("↻");
        btn.getStyleClass().add("icon-button");
        btn.setOnAction(handler);
        return btn;
    }

    public static Label createKeywordLabel(String text) {
        Label label = new Label(text);
        label.getStyleClass().add("keyword-label");
        return label;
    }

    public static Label createTypeLabel(String type) {
        Label label = new Label(type);
        label.getStyleClass().add("type-label");
        return label;
    }

    public static Label createOperatorLabel(String operator) {
        Label label = new Label(operator);
        label.getStyleClass().add("operator-label");
        return label;
    }

    public static Pane createSpacer() {
        Pane spacer = new Pane();
        HBox.setHgrow(spacer, Priority.ALWAYS);
        return spacer;
    }

    public static HBox createHeaderRow(Runnable onDelete, Node... content) {
        HBox container = new HBox(5);
        container.setAlignment(Pos.CENTER_LEFT);
        if (content != null) container.getChildren().addAll(content);
        container.getChildren().addAll(createSpacer(), createDeleteButton(onDelete));
        return container;
    }

    /**
     * Standard menu creation
     */
    public static ContextMenu createExpressionTypeMenu(
            TypeInfo expectedType,
            Consumer<AddableExpression> onSelect) {
        return createExpressionTypeMenu(expectedType, false, onSelect);
    }

    /**
     * Categorized menu creation with constant filtering
     */
    public static ContextMenu createExpressionTypeMenu(
            TypeInfo expectedType,
            boolean constantOnly,
            Consumer<AddableExpression> onSelect) {

        ContextMenu menu = new ContextMenu();

        // 1. Get filtered list
        List<AddableExpression> available = AddableExpression.getForType(expectedType, constantOnly);

        // 2. Group by Category
        Map<AddableExpression.Category, List<AddableExpression>> grouped = available.stream()
                .collect(Collectors.groupingBy(AddableExpression::getCategory));

        // 3. Define Category Order
        AddableExpression.Category[] order = {
                AddableExpression.Category.LITERAL,
                AddableExpression.Category.REFERENCE,
                AddableExpression.Category.MATH,
                AddableExpression.Category.COMPARISON,
                AddableExpression.Category.LOGIC,
                AddableExpression.Category.STRUCTURE
        };

        boolean hasItems = false;

        for (AddableExpression.Category cat : order) {
            List<AddableExpression> items = grouped.get(cat);
            if (items == null || items.isEmpty()) continue;

            // Literals and References go to root (separated), others to sub-menus
            if (cat == AddableExpression.Category.LITERAL || cat == AddableExpression.Category.REFERENCE) {
                if (!menu.getItems().isEmpty()) menu.getItems().add(new SeparatorMenuItem());
                for (AddableExpression expr : items) {
                    menu.getItems().add(createItem(expr, onSelect));
                }
            } else {
                Menu subMenu = new Menu(cat.getLabel());
                for (AddableExpression expr : items) {
                    subMenu.getItems().add(createItem(expr, onSelect));
                }
                menu.getItems().add(subMenu);
            }
            hasItems = true;
        }

        if (!hasItems) {
            MenuItem empty = new MenuItem("(No options available)");
            empty.setDisable(true);
            menu.getItems().add(empty);
        }

        return menu;
    }

    private static MenuItem createItem(AddableExpression expr, Consumer<AddableExpression> onSelect) {
        MenuItem item = new MenuItem(expr.getDisplayName());
        item.setOnAction(e -> onSelect.accept(expr));
        return item;
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\ui\components\LayoutComponents.java
=================================================================================

package com.botmaker.ui.components;

import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.Node;
import javafx.scene.layout.HBox;
import javafx.scene.layout.VBox;

public class LayoutComponents {

    private static final Insets STANDARD_INDENTATION = new Insets(5, 0, 0, 20);

    /**
     * Creates a VBox representing a nested body of code (e.g., inside an If or Loop).
     * Applies standard indentation and specific style classes.
     */
    public static VBox createIndentedBody(Node content, String... styleClasses) {
        VBox container = new VBox();
        if (styleClasses != null) {
            container.getStyleClass().addAll(styleClasses);
        }
        container.setPadding(STANDARD_INDENTATION);
        if (content != null) {
            container.getChildren().add(content);
        }
        return container;
    }

    /**
     * Creates a horizontal row for building "sentences" (e.g., "for each [var] in [list]").
     */
    public static HBox createSentenceRow(Node... nodes) {
        HBox row = new HBox(5);
        row.setAlignment(Pos.CENTER_LEFT);
        if (nodes != null) {
            row.getChildren().addAll(nodes);
        }
        return row;
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\ui\components\PlaceholderComponents.java
=================================================================================

package com.botmaker.ui.components;

import com.botmaker.core.ExpressionBlock;
import com.botmaker.lsp.CompletionContext;
import javafx.scene.Node;

import java.util.function.Supplier;

public class PlaceholderComponents {

    /**
     * Returns the UI node for an expression if it exists, otherwise creates a Drop Zone.
     *
     * @param expression The expression block (can be null)
     * @param context The completion context needed to render the block
     * @param dropZoneFactory A supplier to create the drop zone (usually provided by AbstractCodeBlock)
     * @return The Node to display
     */
    public static Node createExpressionOrDropZone(
            ExpressionBlock expression,
            CompletionContext context,
            Supplier<Node> dropZoneFactory) {

        if (expression != null) {
            return expression.getUINode(context);
        } else {
            return dropZoneFactory.get();
        }
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\ui\components\SelectorComponents.java
=================================================================================

package com.botmaker.ui.components;

import javafx.scene.control.ComboBox;

import java.util.function.Consumer;

public class SelectorComponents {

    public static ComboBox<String> createOperatorSelector(String[] names, String[] symbols, String currentSymbol, Consumer<String> onSymbolChange) {
        ComboBox<String> selector = new ComboBox<>();
        selector.getItems().addAll(names);
        selector.getStyleClass().add("operator-selector"); // or math-operator-selector based on context
        selector.setEditable(false);

        // Find display name for current symbol
        String currentName = names[0];
        for (int i = 0; i < symbols.length; i++) {
            if (symbols[i].equals(currentSymbol)) {
                currentName = names[i];
                break;
            }
        }
        selector.setValue(currentName);

        selector.setOnAction(e -> {
            String selectedName = selector.getValue();
            String newSymbol = null;
            for (int i = 0; i < names.length; i++) {
                if (names[i].equals(selectedName)) {
                    newSymbol = symbols[i];
                    break;
                }
            }
            if (newSymbol != null && !newSymbol.equals(currentSymbol)) {
                onSymbolChange.accept(newSymbol);
            }
        });

        return selector;
    }

    public static ComboBox<String> createSimpleSelector(String[] options, String current, Consumer<String> onChange) {
        ComboBox<String> selector = new ComboBox<>();
        selector.getItems().addAll(options);
        selector.setValue(current);
        selector.setOnAction(e -> {
            if (!selector.getValue().equals(current)) {
                onChange.accept(selector.getValue());
            }
        });
        return selector;
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\ui\components\StyleComponents.java
=================================================================================

package com.botmaker.ui.components;

import javafx.geometry.Pos;
import javafx.scene.Node;
import javafx.scene.layout.HBox;

public class StyleComponents {

    /**
     * Creates a "Pill" shaped container (used for parameters and method calls).
     */
    public static HBox createPillContainer(String backgroundColor, Node... content) {
        HBox container = new HBox(4);
        container.setAlignment(Pos.CENTER_LEFT);
        // We use inline styles here because these often have dynamic colors,
        // but ideally this should map to CSS classes.
        container.setStyle(
                "-fx-background-color: " + backgroundColor + ";" +
                        "-fx-background-radius: 12;" +
                        "-fx-padding: 3 8 3 8;"
        );
        if (content != null) {
            container.getChildren().addAll(content);
        }
        return container;
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\ui\components\TextFieldComponents.java
=================================================================================

package com.botmaker.ui.components;

import javafx.scene.Cursor;
import javafx.scene.control.TextField;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Priority;

import java.util.function.Consumer;

public class TextFieldComponents {

    public static TextField createCommentField(String initialText, String prompt, Consumer<String> onCommit) {
        TextField field = new TextField(initialText != null ? initialText : "");
        field.setPromptText(prompt);
        field.getStyleClass().add("comment-text-field");
        HBox.setHgrow(field, Priority.ALWAYS);

        // Save on Focus Lost or Enter
        field.focusedProperty().addListener((obs, oldVal, newVal) -> {
            if (!newVal) onCommit.accept(field.getText());
        });
        field.setOnAction(e -> onCommit.accept(field.getText()));

        return field;
    }

    public static TextField createVariableNameField(String initialText, Consumer<String> onCommit) {
        TextField nameField = new TextField(initialText);
        nameField.getStyleClass().add("variable-name-field");
        nameField.setPrefWidth(100);

        nameField.focusedProperty().addListener((obs, oldVal, newVal) -> {
            if (!newVal) onCommit.accept(nameField.getText());
        });

        return nameField;
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\ui\theme\BlockTheme.java
=================================================================================

package com.botmaker.ui.theme;

/**
 * Centralized theme system for block styling.
 * Replaces scattered inline styles with consistent, reusable themes.
 */
public class BlockTheme {

    // Theme instances
    public static final BlockTheme DEFAULT = new BlockTheme();
    public static final BlockTheme DARK = createDarkTheme();
    public static final BlockTheme HIGH_CONTRAST = createHighContrastTheme();

    // Current active theme
    private static BlockTheme current = DEFAULT;

    // Color definitions
    private final ColorPalette colors;
    private final Typography typography;
    private final Spacing spacing;
    private final Effects effects;

    private BlockTheme() {
        this.colors = new ColorPalette();
        this.typography = new Typography();
        this.spacing = new Spacing();
        this.effects = new Effects();
    }

    public static BlockTheme current() {
        return current;
    }

    public static void setTheme(BlockTheme theme) {
        current = theme;
    }

    // Accessors
    public ColorPalette colors() { return colors; }
    public Typography typography() { return typography; }
    public Spacing spacing() { return spacing; }
    public Effects effects() { return effects; }

    // Factory methods for themes
    private static BlockTheme createDarkTheme() {
        BlockTheme theme = new BlockTheme();
        // Configure dark colors
        return theme;
    }

    private static BlockTheme createHighContrastTheme() {
        BlockTheme theme = new BlockTheme();
        // Configure high contrast colors
        return theme;
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\ui\theme\ColorPalette.java
=================================================================================

package com.botmaker.ui.theme;

import com.botmaker.ui.AddableBlock;

public class ColorPalette {
    // Category colors (matching your current palette)
    private String outputColor = "#3498DB";
    private String inputColor = "#9B59B6";
    private String variablesColor = "#F39C12";
    private String flowColor = "#E67E22";
    private String loopsColor = "#2ECC71";
    private String controlColor = "#E74C3C";
    private String functionsColor = "#8E44AD";
    private String utilityColor = "#7F8C8D";

    // UI element colors
    private String backgroundColor = "#FFFFFF";
    private String textColor = "#2C3E50";
    private String keywordColor = "#34495E";
    private String operatorColor = "#7F8C8D";
    private String typeColor = "#8E44AD";
    private String errorColor = "#E74C3C";
    private String warningColor = "#F39C12";
    private String successColor = "#2ECC71";

    // Accent colors
    private String primaryAccent = "#3498DB";
    private String secondaryAccent = "#95A5A6";
    private String hoverAccent = "#2980B9";

    // Getters for each color category
    public String forCategory(AddableBlock.BlockCategory category) {
        return switch (category) {
            case OUTPUT -> outputColor;
            case INPUT -> inputColor;
            case VARIABLES -> variablesColor;
            case FLOW -> flowColor;
            case LOOPS -> loopsColor;
            case CONTROL -> controlColor;
            case FUNCTIONS -> functionsColor;
            case UTILITY -> utilityColor;
        };
    }

    public String background() { return backgroundColor; }
    public String text() { return textColor; }
    public String keyword() { return keywordColor; }
    public String operator() { return operatorColor; }
    public String type() { return typeColor; }
    public String error() { return errorColor; }
    public String warning() { return warningColor; }
    public String success() { return successColor; }
    public String primary() { return primaryAccent; }
    public String hover() { return hoverAccent; }

    // Derived colors
    public String withOpacity(String color, double opacity) {
        // Convert hex to rgba
        return String.format("rgba(%s, %.2f)", hexToRgb(color), opacity);
    }

    public String lighten(String color, double amount) {
        // Lighten color by percentage
        return adjustBrightness(color, amount);
    }

    public String darken(String color, double amount) {
        // Darken color by percentage
        return adjustBrightness(color, -amount);
    }

    private String hexToRgb(String hex) {
        // Implementation
        return "...";
    }

    private String adjustBrightness(String color, double amount) {
        // Implementation
        return "...";
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\ui\theme\Effects.java
=================================================================================

package com.botmaker.ui.theme;

public class Effects {
    private double smallRadius = 4.0;
    private double normalRadius = 6.0;
    private double largeRadius = 10.0;
    private double pillRadius = 12.0;

    private String shadowSmall = "dropshadow(gaussian, rgba(0,0,0,0.1), 2, 0, 0, 1)";
    private String shadowMedium = "dropshadow(gaussian, rgba(0,0,0,0.15), 4, 0, 0, 2)";
    private String shadowLarge = "dropshadow(gaussian, rgba(0,0,0,0.2), 8, 0, 0, 4)";

    public double smallRadius() { return smallRadius; }
    public double normalRadius() { return normalRadius; }
    public double largeRadius() { return largeRadius; }
    public double pillRadius() { return pillRadius; }

    public String shadowSmall() { return shadowSmall; }
    public String shadowMedium() { return shadowMedium; }
    public String shadowLarge() { return shadowLarge; }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\ui\theme\Spacing.java
=================================================================================

package com.botmaker.ui.theme;

import javafx.geometry.Insets;

public class Spacing {
    private double tiny = 2.0;
    private double small = 5.0;
    private double normal = 10.0;
    private double medium = 15.0;
    private double large = 20.0;

    // Standard indentation
    private Insets standardIndent = new Insets(5, 0, 0, 20);

    public double tiny() { return tiny; }
    public double small() { return small; }
    public double normal() { return normal; }
    public double medium() { return medium; }
    public double large() { return large; }

    public Insets standardIndent() { return standardIndent; }
    public Insets custom(double top, double right, double bottom, double left) {
        return new Insets(top, right, bottom, left);
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\ui\theme\StyleBuilder.java
=================================================================================

package com.botmaker.ui.theme;

import com.botmaker.ui.AddableBlock;
import javafx.geometry.Insets;
import javafx.scene.Node;

/**
 * Fluent builder for applying styles to JavaFX nodes.
 * Replaces inline style strings with type-safe, themed styling.
 */
public class StyleBuilder {
    private final StringBuilder styleString = new StringBuilder();
    private final BlockTheme theme;

    private StyleBuilder(BlockTheme theme) {
        this.theme = theme;
    }

    public static StyleBuilder create() {
        return new StyleBuilder(BlockTheme.current());
    }

    public static StyleBuilder withTheme(BlockTheme theme) {
        return new StyleBuilder(theme);
    }

    // Background
    public StyleBuilder backgroundColor(String color) {
        styleString.append("-fx-background-color: ").append(color).append("; ");
        return this;
    }

    public StyleBuilder backgroundGradient(String from, String to) {
        styleString.append("-fx-background-color: linear-gradient(to bottom, ")
                .append(from).append(" 0%, ")
                .append(to).append(" 100%); ");
        return this;
    }

    // Text
    public StyleBuilder textColor(String color) {
        styleString.append("-fx-text-fill: ").append(color).append("; ");
        return this;
    }

    public StyleBuilder fontSize(double size) {
        styleString.append("-fx-font-size: ").append(size).append("px; ");
        return this;
    }

    public StyleBuilder fontWeight(String weight) {
        styleString.append("-fx-font-weight: ").append(weight).append("; ");
        return this;
    }

    public StyleBuilder fontFamily(String family) {
        styleString.append("-fx-font-family: ").append(family).append("; ");
        return this;
    }

    // Border
    public StyleBuilder borderColor(String color) {
        styleString.append("-fx-border-color: ").append(color).append("; ");
        return this;
    }

    public StyleBuilder borderWidth(double width) {
        styleString.append("-fx-border-width: ").append(width).append("px; ");
        return this;
    }

    public StyleBuilder borderWidth(double top, double right, double bottom, double left) {
        styleString.append("-fx-border-width: ")
                .append(top).append("px ")
                .append(right).append("px ")
                .append(bottom).append("px ")
                .append(left).append("px; ");
        return this;
    }

    public StyleBuilder borderRadius(double radius) {
        styleString.append("-fx-border-radius: ").append(radius).append("px; ");
        return this;
    }

    public StyleBuilder borderStyle(String style) {
        styleString.append("-fx-border-style: ").append(style).append("; ");
        return this;
    }

    // Effects
    public StyleBuilder backgroundRadius(double radius) {
        styleString.append("-fx-background-radius: ").append(radius).append("px; ");
        return this;
    }

    public StyleBuilder padding(double padding) {
        styleString.append("-fx-padding: ").append(padding).append("px; ");
        return this;
    }

    public StyleBuilder padding(double top, double right, double bottom, double left) {
        styleString.append("-fx-padding: ")
                .append(top).append("px ")
                .append(right).append("px ")
                .append(bottom).append("px ")
                .append(left).append("px; ");
        return this;
    }

    public StyleBuilder opacity(double opacity) {
        styleString.append("-fx-opacity: ").append(opacity).append("; ");
        return this;
    }

    public StyleBuilder cursor(String cursor) {
        styleString.append("-fx-cursor: ").append(cursor).append("; ");
        return this;
    }

    // Presets using theme
    public StyleBuilder asKeyword() {
        return this
                .textColor(theme.colors().keyword())
                .fontWeight(theme.typography().boldWeight())
                .fontSize(theme.typography().normal());
    }

    public StyleBuilder asType() {
        return this
                .textColor(theme.colors().type())
                .fontWeight(theme.typography().boldWeight())
                .fontSize(theme.typography().normal());
    }

    public StyleBuilder asOperator() {
        return this
                .textColor(theme.colors().operator())
                .fontSize(theme.typography().normal());
    }

    public StyleBuilder asBlockHeader(AddableBlock.BlockCategory category) {
        String color = theme.colors().forCategory(category);
        return this
                .backgroundColor(color)
                .textColor("#FFFFFF")
                .fontWeight(theme.typography().boldWeight())
                .padding(8, 10, 8, 10)
                .backgroundRadius(theme.effects().normalRadius());
    }

    public StyleBuilder asPill(String backgroundColor) {
        return this
                .backgroundColor(backgroundColor)
                .backgroundRadius(theme.effects().pillRadius())
                .padding(3, 8, 3, 8);
    }

    // Terminal operation - build and return style string
    public String build() {
        return styleString.toString();
    }

    // Terminal operation - apply to node
    public void applyTo(Node node) {
        node.setStyle(build());
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\ui\theme\Typography.java
=================================================================================

package com.botmaker.ui.theme;

public class Typography {
    // Font families
    private String primaryFont = "'Segoe UI', sans-serif";
    private String monoFont = "'Consolas', monospace";

    // Font sizes
    private double tinySize = 9.0;
    private double smallSize = 10.0;
    private double normalSize = 11.0;
    private double mediumSize = 13.0;
    private double largeSize = 16.0;
    private double headingSize = 20.0;

    // Font weights
    private String normalWeight = "normal";
    private String boldWeight = "bold";

    public String primaryFont() { return primaryFont; }
    public String monoFont() { return monoFont; }

    public double tiny() { return tinySize; }
    public double small() { return smallSize; }
    public double normal() { return normalSize; }
    public double medium() { return mediumSize; }
    public double large() { return largeSize; }
    public double heading() { return headingSize; }

    public String normalWeight() { return normalWeight; }
    public String boldWeight() { return boldWeight; }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\util\BlockLookupHelper.java
=================================================================================

package com.botmaker.util;

import com.botmaker.core.BodyBlock;
import com.botmaker.core.BlockWithChildren;
import com.botmaker.core.CodeBlock;
import com.botmaker.core.StatementBlock;

import java.util.Map;

/**
 * Helper class for looking up blocks in the block tree.
 */
public class BlockLookupHelper {

    /**
     * Finds a block by its ID in the node-to-block map.
     * @param blockId The ID of the block to find
     * @param nodeToBlockMap The map of AST nodes to CodeBlocks
     * @return The StatementBlock if found, null otherwise
     */
    public static StatementBlock findBlockById(String blockId, Map<?, CodeBlock> nodeToBlockMap) {
        if (blockId == null || nodeToBlockMap == null) {
            return null;
        }

        // Search through all blocks in the map
        for (CodeBlock block : nodeToBlockMap.values()) {
            if (block.getId().equals(blockId) && block instanceof StatementBlock) {
                return (StatementBlock) block;
            }
        }

        return null;
    }

    /**
     * Finds the BodyBlock that contains the given statement block.
     * @param targetBlock The statement block to find the parent for
     * @param nodeToBlockMap The map of AST nodes to CodeBlocks
     * @return The BodyBlock containing the statement, null if not found
     */
    public static BodyBlock findParentBody(StatementBlock targetBlock, Map<?, CodeBlock> nodeToBlockMap) {
        if (targetBlock == null || nodeToBlockMap == null) {
            return null;
        }

        // Search through all blocks to find which BodyBlock contains the target
        for (CodeBlock block : nodeToBlockMap.values()) {
            if (block instanceof BodyBlock) {
                BodyBlock bodyBlock = (BodyBlock) block;
                if (bodyBlock.getStatements().contains(targetBlock)) {
                    return bodyBlock;
                }
            }

            // Also check nested structures
            if (block instanceof BlockWithChildren) {
                BodyBlock found = findParentBodyInChildren(targetBlock, (BlockWithChildren) block);
                if (found != null) {
                    return found;
                }
            }
        }

        return null;
    }

    /**
     * Recursively searches for the parent body in a block's children.
     */
    private static BodyBlock findParentBodyInChildren(StatementBlock targetBlock, BlockWithChildren parent) {
        for (CodeBlock child : parent.getChildren()) {
            if (child instanceof BodyBlock) {
                BodyBlock bodyBlock = (BodyBlock) child;
                if (bodyBlock.getStatements().contains(targetBlock)) {
                    return bodyBlock;
                }
            }

            if (child instanceof BlockWithChildren) {
                BodyBlock found = findParentBodyInChildren(targetBlock, (BlockWithChildren) child);
                if (found != null) {
                    return found;
                }
            }
        }

        return null;
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\util\DefaultNames.java
=================================================================================

package com.botmaker.util;

/**
 * Provides sensible default names for auto-generated elements
 *
 * UPDATED: Uses TypeInfo for type classification
 */
public class DefaultNames {

    // Variable names by type
    public static final String DEFAULT_INT = "number";
    public static final String DEFAULT_DOUBLE = "decimal";
    public static final String DEFAULT_BOOLEAN = "flag";
    public static final String DEFAULT_STRING = "text";
    public static final String DEFAULT_VARIABLE = "variable";
    public static final String DEFAULT_ENUM = "value";

    /**
     * Get default name by type
     * UPDATED: Uses TypeInfo for classification
     */
    public static String forType(String typeName) {
        if (typeName == null) return DEFAULT_VARIABLE;

        // UPDATED: Use TypeInfo for proper type classification
        TypeInfo type = TypeInfo.from(typeName);

        // Get leaf type (unwrap arrays/collections)
        TypeInfo leafType = type.getLeafType();

        // Check type classifications
        if (leafType.isBoolean()) {
            return DEFAULT_BOOLEAN;
        }

        if (leafType.isString()) {
            return DEFAULT_STRING;
        }

        if (leafType.isNumeric()) {
            // Distinguish between integer and floating point
            String leafTypeName = leafType.getTypeName();
            if (leafTypeName.equals("double") || leafTypeName.equals("float") ||
                    leafTypeName.equals("Double") || leafTypeName.equals("Float")) {
                return DEFAULT_DOUBLE;
            }
            return DEFAULT_INT;
        }

        if (leafType.isEnum()) {
            return DEFAULT_ENUM;
        }

        return DEFAULT_VARIABLE;
    }

    /**
     * Get default name for enum type with the enum name as context
     * UPDATED: No changes needed - this method is already good
     */
    public static String forEnumType(String enumTypeName) {
        if (enumTypeName == null || enumTypeName.isEmpty()) {
            return DEFAULT_ENUM;
        }
        // Convert enum name to camelCase variable name
        // e.g., "Color" -> "color", "DayOfWeek" -> "dayOfWeek"
        String camelCase = Character.toLowerCase(enumTypeName.charAt(0)) + enumTypeName.substring(1);
        return camelCase;
    }

    private DefaultNames() {} // Prevent instantiation
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\util\TypeInfo.java
=================================================================================

package com.botmaker.util;

import org.eclipse.jdt.core.dom.*;
import java.util.Objects;

/**
 * Unified type representation for BotMaker.
 * Wraps ITypeBinding (authoritative) with String fallback for cases where bindings aren't resolved yet.
 *
 * Design principles:
 * - ITypeBinding is the source of truth when available
 * - String types are parsed/cached for backward compatibility
 * - Lazy computation of expensive properties (dimensions, leaf types)
 * - Immutable value object with clear equality semantics
 */
public class TypeInfo {

    // Core data
    private final ITypeBinding binding;        // Authoritative (can be null)
    private final String stringType;           // Fallback/cache (never null)

    // Cached computed values (lazy)
    private Integer cachedDimensions;
    private TypeInfo cachedLeafType;
    private Boolean cachedIsArray;
    private Boolean cachedIsEnum;
    private Boolean cachedIsPrimitive;

    // ========================================================================
    // FACTORY METHODS (Primary Creation Points)
    // ========================================================================

    /**
     * Creates TypeInfo from ITypeBinding (preferred method)
     */
    public static TypeInfo from(ITypeBinding binding) {
        if (binding == null) {
            return TypeInfo.UNKNOWN;
        }
        String stringRep = binding.getQualifiedName();
        return new TypeInfo(binding, stringRep);
    }

    /**
     * Creates TypeInfo from string type (fallback for unresolved types)
     */
    public static TypeInfo from(String typeName) {
        if (typeName == null || typeName.isBlank()) {
            return TypeInfo.UNKNOWN;
        }
        return new TypeInfo(null, typeName.trim());
    }

    /**
     * Creates TypeInfo from AST Type node
     */
    public static TypeInfo from(Type type) {
        if (type == null) return TypeInfo.UNKNOWN;
        ITypeBinding binding = type.resolveBinding();
        if (binding != null) {
            return from(binding);
        }
        // Fallback to string representation
        return from(type.toString());
    }

    /**
     * Creates TypeInfo from Expression
     */
    public static TypeInfo from(Expression expr) {
        if (expr == null) return TypeInfo.UNKNOWN;
        ITypeBinding binding = expr.resolveTypeBinding();
        if (binding != null) {
            return from(binding);
        }
        // Fallback to string representation
        return TypeInfo.UNKNOWN;
    }

    // Common type constants
    public static final TypeInfo UNKNOWN = new TypeInfo(null, "Object");
    public static final TypeInfo INT = new TypeInfo(null, "int");
    public static final TypeInfo DOUBLE = new TypeInfo(null, "double");
    public static final TypeInfo BOOLEAN = new TypeInfo(null, "boolean");
    public static final TypeInfo STRING = new TypeInfo(null, "String");
    public static final TypeInfo VOID = new TypeInfo(null, "void");

    // ========================================================================
    // CONSTRUCTOR (Private - use factory methods)
    // ========================================================================

    private TypeInfo(ITypeBinding binding, String stringType) {
        this.binding = binding;
        this.stringType = stringType;
    }

    // ========================================================================
    // CORE PROPERTIES
    // ========================================================================

    /**
     * Gets the ITypeBinding if available (may be null for unresolved types)
     */
    public ITypeBinding getBinding() {
        return binding;
    }

    /**
     * Gets the string representation of this type
     */
    public String getTypeName() {
        return stringType;
    }

    /**
     * Returns true if this type has resolved binding information
     */
    public boolean hasBinding() {
        return binding != null;
    }

    /**
     * Returns true if this type is fully unknown/unresolved
     */
    public boolean isUnknown() {
        return this == UNKNOWN || (binding == null && stringType.equals("Object"));
    }

    // ========================================================================
    // TYPE CLASSIFICATION
    // ========================================================================

    public boolean isArray() {
        if (cachedIsArray != null) return cachedIsArray;

        if (binding != null) {
            cachedIsArray = binding.isArray();
        } else {
            cachedIsArray = stringType.endsWith("[]");
        }
        return cachedIsArray;
    }

    public boolean isEnum() {
        if (cachedIsEnum != null) return cachedIsEnum;

        if (binding != null) {
            cachedIsEnum = binding.isEnum();
        } else {
            // Heuristic: uppercase first letter, not in primitives
            cachedIsEnum = Character.isUpperCase(stringType.charAt(0)) &&
                    !TypeCategories.isPrimitive(stringType);
        }
        return cachedIsEnum;
    }

    public boolean isPrimitive() {
        if (cachedIsPrimitive != null) return cachedIsPrimitive;

        if (binding != null) {
            cachedIsPrimitive = binding.isPrimitive();
        } else {
            cachedIsPrimitive = TypeCategories.isPrimitive(stringType);
        }
        return cachedIsPrimitive;
    }

    public boolean isNumeric() {
        return TypeCategories.isNumeric(this);
    }

    public boolean isBoolean() {
        return TypeCategories.isBoolean(this);
    }

    public boolean isString() {
        return TypeCategories.isString(this);
    }

    // ========================================================================
    // ARRAY OPERATIONS
    // ========================================================================

    /**
     * Gets the number of array dimensions (0 if not an array)
     */
    public int getArrayDimensions() {
        if (cachedDimensions != null) return cachedDimensions;

        if (binding != null && binding.isArray()) {
            // Use the fixed method from TypeManager
            cachedDimensions = TypeManager.getArrayDimensions(binding);
        } else if (stringType.endsWith("[]")) {
            // Count "[]" occurrences
            int count = 0;
            String temp = stringType;
            while (temp.endsWith("[]")) {
                count++;
                temp = temp.substring(0, temp.length() - 2);
            }
            cachedDimensions = count;
        } else {
            cachedDimensions = 0;
        }
        return cachedDimensions;
    }

    /**
     * Gets the leaf (element) type of an array, or this type if not an array
     */
    public TypeInfo getLeafType() {
        if (cachedLeafType != null) return cachedLeafType;

        if (!isArray()) {
            cachedLeafType = this;
            return this;
        }

        if (binding != null) {
            ITypeBinding leafBinding = TypeManager.getLeafTypeBinding(binding);
            cachedLeafType = leafBinding != null ? TypeInfo.from(leafBinding) : this;
        } else {
            // Parse string
            String temp = stringType;
            while (temp.endsWith("[]")) {
                temp = temp.substring(0, temp.length() - 2).trim();
            }
            cachedLeafType = TypeInfo.from(temp);
        }
        return cachedLeafType;
    }

    /**
     * Creates an array type from this type with specified dimensions
     */
    public TypeInfo asArray(int dimensions) {
        if (dimensions <= 0) return this;

        if (binding != null) {
            ITypeBinding leafBinding = isArray() ?
                    TypeManager.getLeafTypeBinding(binding) : binding;
            ITypeBinding arrayBinding = TypeManager.createArrayTypeWithDimensions(
                    leafBinding, dimensions);
            return TypeInfo.from(arrayBinding);
        } else {
            String leafType = getLeafType().getTypeName();
            String arrayType = leafType + "[]".repeat(dimensions);
            return TypeInfo.from(arrayType);
        }
    }

    // ========================================================================
    // TYPE COMPATIBILITY
    // ========================================================================

    /**
     * Checks if this type is compatible with (assignable to) another type
     */
    public boolean isCompatibleWith(TypeInfo other) {
        if (other == null || other.isUnknown() || this.isUnknown()) {
            return true; // Unknown types are compatible with everything
        }

        // Use binding-based comparison if both have bindings
        if (this.hasBinding() && other.hasBinding()) {
            return TypeManager.isCompatibleBinding(this.binding, other.binding);
        }

        // Fall back to string-based comparison
        return TypeCompatibility.areCompatible(this, other);
    }

    /**
     * Checks if this type matches another exactly
     */
    public boolean matches(TypeInfo other) {
        if (other == null) return false;
        if (this == other) return true;

        // Binding-based exact match
        if (this.hasBinding() && other.hasBinding()) {
            return this.binding.isEqualTo(other.binding);
        }

        // String-based match with normalization
        String thisNormalized = normalizeTypeName(this.stringType);
        String otherNormalized = normalizeTypeName(other.stringType);
        return thisNormalized.equals(otherNormalized);
    }

    private static String normalizeTypeName(String type) {
        // Remove java.lang prefix
        if (type.startsWith("java.lang.")) {
            type = type.substring(10);
        }
        // Convert wrappers to primitives for comparison
        return switch (type) {
            case "Integer" -> "int";
            case "Double" -> "double";
            case "Boolean" -> "boolean";
            case "Character" -> "char";
            case "Long" -> "long";
            case "Float" -> "float";
            case "Short" -> "short";
            case "Byte" -> "byte";
            default -> type;
        };
    }

    // ========================================================================
    // DISPLAY / DEBUGGING
    // ========================================================================

    /**
     * Gets a simple display name for UI (e.g., "int[]", "String", "MyEnum")
     */
    public String getDisplayName() {
        if (isArray()) {
            return getLeafType().getDisplayName() + "[]".repeat(getArrayDimensions());
        }

        // Remove package names for display
        String name = stringType;
        int lastDot = name.lastIndexOf('.');
        if (lastDot > 0) {
            name = name.substring(lastDot + 1);
        }
        return name;
    }

    /**
     * Gets a qualified name (e.g., "java.lang.String")
     */
    public String getQualifiedName() {
        return stringType;
    }

    @Override
    public String toString() {
        return "TypeInfo{" + stringType + (binding != null ? " [bound]" : " [unbound]") + "}";
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (!(obj instanceof TypeInfo)) return false;
        TypeInfo other = (TypeInfo) obj;

        // Use binding equality if both have bindings
        if (this.hasBinding() && other.hasBinding()) {
            return this.binding.isEqualTo(other.binding);
        }

        // Fall back to string comparison
        return normalizeTypeName(this.stringType)
                .equals(normalizeTypeName(other.stringType));
    }

    @Override
    public int hashCode() {
        return Objects.hash(normalizeTypeName(stringType));
    }

    // ========================================================================
    // HELPER CLASSES (Inner classes for organization)
    // ========================================================================

    /**
     * Type category checking (replaces UI type constants)
     */
    private static class TypeCategories {

        static boolean isPrimitive(String type) {
            return switch (type) {
                case "int", "double", "boolean", "char", "long", "float", "short", "byte" -> true;
                default -> false;
            };
        }

        static boolean isNumeric(TypeInfo type) {
            String name = type.getLeafType().getTypeName();
            return switch (name) {
                case "int", "double", "float", "long", "short", "byte",
                     "Integer", "Double", "Float", "Long", "Short", "Byte" -> true;
                default -> false;
            };
        }

        static boolean isBoolean(TypeInfo type) {
            String name = type.getLeafType().getTypeName();
            return name.equals("boolean") || name.equals("Boolean");
        }

        static boolean isString(TypeInfo type) {
            String name = type.getLeafType().getTypeName();
            return name.equals("String") || name.equals("char") || name.equals("Character");
        }
    }

    /**
     * Type compatibility logic (replaces TypeManager.isCompatible)
     */
    private static class TypeCompatibility {

        static boolean areCompatible(TypeInfo actual, TypeInfo expected) {
            // Arrays must match dimensions
            if (actual.isArray() != expected.isArray()) {
                return false;
            }

            if (actual.isArray()) {
                if (actual.getArrayDimensions() != expected.getArrayDimensions()) {
                    return false;
                }
                // Check leaf types
                return areCompatible(actual.getLeafType(), expected.getLeafType());
            }

            // Check category compatibility
            if (actual.isNumeric() && expected.isNumeric()) return true;
            if (actual.isBoolean() && expected.isBoolean()) return true;
            if (actual.isString() && expected.isString()) return true;

            // Exact match
            return actual.matches(expected);
        }
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\util\TypeManager.java
=================================================================================

package com.botmaker.util;

import org.eclipse.jdt.core.dom.*;

import java.util.List;
import java.util.Set;

/**
 * UPDATED TypeManager - Slim utility for AST/JDT-specific operations.
 *
 * REMOVED: All type logic moved to TypeInfo
 * KEPT: AST manipulation, UI helpers, compiler-specific operations
 *
 * Philosophy: TypeManager handles "how to work with Eclipse JDT AST"
 *            TypeInfo handles "what types are and how they relate"
 */
public class TypeManager {

    // ========================================================================
    // AST NODE CREATION (Keep - This is AST-specific, not type logic)
    // ========================================================================

    /**
     * Creates an AST Type node from TypeInfo
     */
    public static Type createTypeNode(AST ast, TypeInfo typeInfo) {
        return createTypeNode(ast, typeInfo.getTypeName());
    }

    /**
     * Creates an AST Type node from string type name
     * Handles primitives, arrays, and reference types
     */
    public static Type createTypeNode(AST ast, String typeName) {
        // Count array dimensions
        int dimensions = 0;
        String baseName = typeName;
        while (baseName.endsWith("[]")) {
            dimensions++;
            baseName = baseName.substring(0, baseName.length() - 2).trim();
        }

        // Create base type
        Type baseType;
        switch (baseName) {
            case "int": baseType = ast.newPrimitiveType(PrimitiveType.INT); break;
            case "double": baseType = ast.newPrimitiveType(PrimitiveType.DOUBLE); break;
            case "boolean": baseType = ast.newPrimitiveType(PrimitiveType.BOOLEAN); break;
            case "char": baseType = ast.newPrimitiveType(PrimitiveType.CHAR); break;
            case "long": baseType = ast.newPrimitiveType(PrimitiveType.LONG); break;
            case "float": baseType = ast.newPrimitiveType(PrimitiveType.FLOAT); break;
            case "short": baseType = ast.newPrimitiveType(PrimitiveType.SHORT); break;
            case "byte": baseType = ast.newPrimitiveType(PrimitiveType.BYTE); break;
            case "void": baseType = ast.newPrimitiveType(PrimitiveType.VOID); break;
            default: baseType = ast.newSimpleType(ast.newName(baseName)); break;
        }

        // Add array dimensions if needed
        if (dimensions > 0) {
            return ast.newArrayType(baseType, dimensions);
        }
        return baseType;
    }

    // ========================================================================
    // ENUM DETECTION IN COMPILATION UNIT (Keep - This searches AST structure)
    // ========================================================================

    /**
     * Searches CompilationUnit to verify if a type is actually an enum.
     * Complements TypeInfo.isEnum() which uses heuristics for unbound types.
     */
    public static boolean isEnumType(TypeInfo type, CompilationUnit cu) {
        // If we have binding, TypeInfo already knows
        if (type.hasBinding()) {
            return type.isEnum();
        }

        // Otherwise search the AST
        return findEnumDeclaration(cu, type.getLeafType().getTypeName()) != null;
    }

    /**
     * Finds an enum declaration by name in the compilation unit
     */
    public static EnumDeclaration findEnumDeclaration(CompilationUnit cu, String enumName) {
        if (cu == null || enumName == null) return null;

        // Search top-level types
        for (Object obj : cu.types()) {
            if (obj instanceof EnumDeclaration) {
                EnumDeclaration enumDecl = (EnumDeclaration) obj;
                if (enumDecl.getName().getIdentifier().equals(enumName)) {
                    return enumDecl;
                }
            }
            // Check class body declarations
            else if (obj instanceof TypeDeclaration) {
                TypeDeclaration typeDecl = (TypeDeclaration) obj;
                EnumDeclaration found = findEnumInTypeDeclaration(typeDecl, enumName);
                if (found != null) return found;
            }
        }
        return null;
    }

    private static EnumDeclaration findEnumInTypeDeclaration(TypeDeclaration typeDecl, String enumName) {
        for (Object bodyObj : typeDecl.bodyDeclarations()) {
            if (bodyObj instanceof EnumDeclaration) {
                EnumDeclaration enumDecl = (EnumDeclaration) bodyObj;
                if (enumDecl.getName().getIdentifier().equals(enumName)) {
                    return enumDecl;
                }
            }
        }
        return null;
    }

    /**
     * Gets all enum constant names from an enum declaration
     */
    public static List<String> getEnumConstantNames(EnumDeclaration enumDecl) {
        return enumDecl.enumConstants().stream()
                .map(obj -> ((EnumConstantDeclaration) obj).getName().getIdentifier())
                .toList();
    }

    // ========================================================================
    // UI HELPERS (Keep - These are UI/display concerns, not type logic)
    // ========================================================================

    /**
     * List of fundamental types for type selection menus
     */
    public static List<String> getFundamentalTypeNames() {
        return List.of("int", "double", "boolean", "String", "long", "float", "char");
    }

    /**
     * Filters out system/internal variables from user-visible lists
     */
    public static boolean isUserVariable(String variableName) {
        if (variableName == null || variableName.isEmpty()) return false;
        String cleanName = variableName.split(" ")[0].split(":")[0].trim();
        return !HIDDEN_VARIABLES.contains(cleanName) && !cleanName.startsWith("_");
    }

    private static final Set<String> HIDDEN_VARIABLES = Set.of(
            "args", "this", "super", "scanner", "class"
    );

    // ========================================================================
    // ITYPEBINDING INTERNALS (Keep - TypeInfo delegates to these)
    // ========================================================================

    /**
     * Gets array dimensions from ITypeBinding.
     * USED INTERNALLY BY TypeInfo - not typically called directly.
     *
     * This is the FIXED version that handles multi-dimensional arrays correctly.
     */
    public static int getArrayDimensions(ITypeBinding binding) {
        if (binding == null || !binding.isArray()) {
            return 0;
        }

        // METHOD 1: Try getDimensions() if available (JDT specific)
        try {
            int dims = binding.getDimensions();
            if (dims > 0) return dims;
        } catch (Exception ignored) {
            // Method not available, use fallback
        }

        // METHOD 2: Count dimensions by traversing
        int dimensions = 0;
        ITypeBinding current = binding;
        while (current != null && current.isArray()) {
            dimensions++;
            current = current.getElementType();
        }

        // METHOD 3: Parse qualified name as last resort
        if (dimensions == 0) {
            String qualifiedName = binding.getQualifiedName();
            while (qualifiedName.endsWith("[]")) {
                dimensions++;
                qualifiedName = qualifiedName.substring(0, qualifiedName.length() - 2);
            }
        }

        return dimensions;
    }

    /**
     * Gets the leaf (element) type of an array binding.
     * USED INTERNALLY BY TypeInfo - not typically called directly.
     */
    public static ITypeBinding getLeafTypeBinding(ITypeBinding binding) {
        if (binding == null || !binding.isArray()) {
            return binding;
        }

        ITypeBinding elementType = binding.getElementType();

        // If element type is still array, recurse
        if (elementType != null && elementType.isArray()) {
            return getLeafTypeBinding(elementType);
        }

        return elementType;
    }

    /**
     * Creates array type with specific dimensions from a leaf type.
     * USED INTERNALLY BY TypeInfo - not typically called directly.
     */
    public static ITypeBinding createArrayTypeWithDimensions(ITypeBinding leafType, int dimensions) {
        if (leafType == null || dimensions <= 0) {
            return leafType;
        }

        ITypeBinding result = leafType;
        // Create array incrementally, one dimension at a time
        for (int i = 0; i < dimensions; i++) {
            result = result.createArrayType(1);
        }

        return result;
    }

    /**
     * Checks if two bindings are assignment-compatible.
     * USED INTERNALLY BY TypeInfo - not typically called directly.
     */
    public static boolean isCompatibleBinding(ITypeBinding actualType, ITypeBinding expectedType) {
        if (expectedType == null) return true;
        if (actualType == null) return false;

        // Direct match
        if (actualType.isEqualTo(expectedType)) return true;

        // Check assignability
        if (actualType.isAssignmentCompatible(expectedType)) return true;

        // Check if both are arrays with compatible element types
        if (actualType.isArray() && expectedType.isArray()) {
            return isCompatibleBinding(
                    actualType.getElementType(),
                    expectedType.getElementType()
            );
        }

        return false;
    }

    // ========================================================================
    // DEPRECATED - Use TypeInfo instead
    // ========================================================================

    /**
     * @deprecated Use TypeInfo.from(typeName).isNumeric()
     */
    @Deprecated
    public static boolean isNumeric(String typeName) {
        return TypeInfo.from(typeName).isNumeric();
    }

    /**
     * @deprecated Use TypeInfo.from(typeName).isBoolean()
     */
    @Deprecated
    public static boolean isBoolean(String typeName) {
        return TypeInfo.from(typeName).isBoolean();
    }

    /**
     * @deprecated Use TypeInfo.from(typeName).isString()
     */
    @Deprecated
    public static boolean isString(String typeName) {
        return TypeInfo.from(typeName).isString();
    }

    /**
     * @deprecated Use TypeInfo.from(typeName).isPrimitive()
     */
    @Deprecated
    public static boolean isPrimitive(String typeName) {
        return TypeInfo.from(typeName).isPrimitive();
    }

    /**
     * @deprecated Use TypeInfo.from(typeName).isArray()
     */
    @Deprecated
    public static boolean isArray(String typeName) {
        return TypeInfo.from(typeName).isArray();
    }

    /**
     * @deprecated Use TypeInfo.from(typeName).getArrayDimensions()
     */
    @Deprecated
    public static int getListNestingLevel(String typeName) {
        return TypeInfo.from(typeName).getArrayDimensions();
    }

    /**
     * @deprecated Use TypeInfo.from(typeName).getLeafType().getTypeName()
     */
    @Deprecated
    public static String getLeafType(String typeName) {
        return TypeInfo.from(typeName).getLeafType().getTypeName();
    }

    /**
     * @deprecated Use actualType.isCompatibleWith(expectedType)
     */
    @Deprecated
    public static boolean isCompatible(String actual, String expected) {
        return TypeInfo.from(actual).isCompatibleWith(TypeInfo.from(expected));
    }

    /**
     * @deprecated Use TypeInfo.from(type).getDisplayName()
     */
    @Deprecated
    public static String getFriendlyTypeName(ITypeBinding typeBinding) {
        return TypeInfo.from(typeBinding).getDisplayName();
    }

    /**
     * @deprecated Primitive/wrapper conversion now handled in TypeInfo
     */
    @Deprecated
    public static String toWrapperType(String typeName) {
        return switch (typeName) {
            case "int" -> "Integer";
            case "double" -> "Double";
            case "boolean" -> "Boolean";
            case "char" -> "Character";
            case "long" -> "Long";
            case "float" -> "Float";
            case "short" -> "Short";
            case "byte" -> "Byte";
            default -> typeName;
        };
    }

    /**
     * @deprecated Primitive/wrapper conversion now handled in TypeInfo
     */
    @Deprecated
    public static String toPrimitiveType(String typeName) {
        return switch (typeName) {
            case "Integer" -> "int";
            case "Double" -> "double";
            case "Boolean" -> "boolean";
            case "Character" -> "char";
            case "Long" -> "long";
            case "Float" -> "float";
            case "Short" -> "short";
            case "Byte" -> "byte";
            default -> typeName;
        };
    }

}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\validation\DiagnosticsManager.java
=================================================================================

package com.botmaker.validation;

import com.botmaker.core.CodeBlock;
import javafx.application.Platform;
import org.eclipse.jdt.core.dom.ASTNode;
import org.eclipse.lsp4j.Diagnostic;
import org.eclipse.lsp4j.DiagnosticSeverity;
import org.eclipse.lsp4j.PublishDiagnosticsParams;

import java.util.*;

public class DiagnosticsManager {

    private Map<ASTNode, CodeBlock> nodeToBlockMap;
    private String sourceCode;
    private final Set<CodeBlock> blocksWithErrors = new HashSet<>();
    private List<Diagnostic> lastDiagnostics = new ArrayList<>();

    // NEW: Track line numbers to blocks for fallback matching
    private Map<Integer, Set<CodeBlock>> lineToBlocksMap = new HashMap<>();

    public List<Diagnostic> getDiagnostics() {
        return lastDiagnostics;
    }

    public boolean hasErrors() {
        if (lastDiagnostics == null || lastDiagnostics.isEmpty()) {
            return false;
        }
        return lastDiagnostics.stream().anyMatch(d -> {
            DiagnosticSeverity severity = d.getSeverity();
            return severity == null || severity == DiagnosticSeverity.Error;
        });
    }

    public void updateSource(Map<ASTNode, CodeBlock> nodeToBlockMap, String sourceCode) {
        this.nodeToBlockMap = nodeToBlockMap;
        this.sourceCode = sourceCode;

        // Build line-to-block mapping for fallback
        buildLineToBlockMap();
    }

    /**
     * Builds a map from line numbers to blocks for fallback matching
     * when AST node matching fails.
     */
    private void buildLineToBlockMap() {
        lineToBlocksMap.clear();

        if (nodeToBlockMap == null || sourceCode == null) {
            return;
        }

        for (Map.Entry<ASTNode, CodeBlock> entry : nodeToBlockMap.entrySet()) {
            ASTNode node = entry.getKey();
            CodeBlock block = entry.getValue();

            // Calculate which lines this node spans
            int startLine = getLineNumber(node.getStartPosition());
            int endLine = getLineNumber(node.getStartPosition() + node.getLength());

            // Add block to all lines it spans
            for (int line = startLine; line <= endLine; line++) {
                lineToBlocksMap.computeIfAbsent(line, k -> new HashSet<>()).add(block);
            }
        }
    }

    public void processDiagnostics(List<Diagnostic> diagnostics) {
        this.lastDiagnostics = diagnostics;

        // Clear previous errors
        for (CodeBlock block : blocksWithErrors) {
            block.clearError();
        }
        blocksWithErrors.clear();

        if (nodeToBlockMap == null) return;

        // Process new diagnostics
        for (Diagnostic diagnostic : diagnostics) {
            // Only show errors, not warnings (unless you want warnings too)
            if (diagnostic.getSeverity() != DiagnosticSeverity.Error) {
                continue;
            }

            Optional<CodeBlock> blockOpt = findBlockForDiagnostic(diagnostic);

            if (blockOpt.isPresent()) {
                CodeBlock block = blockOpt.get();

                // Use translated error message
                String userFriendlyMessage = ErrorTranslator.getShortSummary(diagnostic);
                String suggestion = ErrorTranslator.getSuggestion(diagnostic);

                block.setError(userFriendlyMessage + "\n" + suggestion);
                blocksWithErrors.add(block);
            } else {
                // Log unmapped diagnostics for debugging
                System.err.println("Warning: Could not map diagnostic to block: " +
                        diagnostic.getMessage() + " at line " +
                        (diagnostic.getRange().getStart().getLine() + 1));
            }
        }
    }

    /**
     * Finds the code block responsible for a diagnostic.
     * Uses multiple strategies for better matching.
     */
    public Optional<CodeBlock> findBlockForDiagnostic(Diagnostic diagnostic) {
        // Strategy 1: Precise AST node matching (best)
        Optional<CodeBlock> block = findBlockByASTNode(diagnostic);
        if (block.isPresent()) {
            return block;
        }

        // Strategy 2: Line-based fallback (good for edge cases)
        block = findBlockByLine(diagnostic);
        if (block.isPresent()) {
            return block;
        }

        // Strategy 3: Parent node search (for nested expressions)
        return findBlockByParentNode(diagnostic);
    }

    /**
     * Strategy 1: Find block by matching AST node ranges
     */
    private Optional<CodeBlock> findBlockByASTNode(Diagnostic diagnostic) {
        int startOffset = getOffsetFromPosition(diagnostic.getRange().getStart());
        int endOffset = getOffsetFromPosition(diagnostic.getRange().getEnd());

        // Find the most specific (smallest) block that contains the diagnostic range
        ASTNode bestNode = null;
        int bestLength = Integer.MAX_VALUE;

        for (ASTNode node : nodeToBlockMap.keySet()) {
            int nodeStart = node.getStartPosition();
            int nodeEnd = nodeStart + node.getLength();

            // Check if node contains the diagnostic range
            if (nodeStart <= startOffset && nodeEnd >= endOffset) {
                int nodeLength = node.getLength();

                // Prefer the smallest containing node
                if (nodeLength < bestLength) {
                    bestNode = node;
                    bestLength = nodeLength;
                }
            }
        }

        return Optional.ofNullable(bestNode).map(nodeToBlockMap::get);
    }

    /**
     * Strategy 2: Find block by line number (fallback)
     */
    private Optional<CodeBlock> findBlockByLine(Diagnostic diagnostic) {
        int line = diagnostic.getRange().getStart().getLine();

        Set<CodeBlock> blocksOnLine = lineToBlocksMap.get(line);
        if (blocksOnLine == null || blocksOnLine.isEmpty()) {
            return Optional.empty();
        }

        // If multiple blocks on same line, prefer the first one
        // (Could be improved with more sophisticated heuristics)
        return blocksOnLine.stream().findFirst();
    }

    /**
     * Strategy 3: Find block by searching parent nodes
     */
    private Optional<CodeBlock> findBlockByParentNode(Diagnostic diagnostic) {
        int startOffset = getOffsetFromPosition(diagnostic.getRange().getStart());

        // Find any node that contains the start position
        for (ASTNode node : nodeToBlockMap.keySet()) {
            int nodeStart = node.getStartPosition();
            int nodeEnd = nodeStart + node.getLength();

            if (nodeStart <= startOffset && nodeEnd >= startOffset) {
                return Optional.of(nodeToBlockMap.get(node));
            }
        }

        return Optional.empty();
    }

    /**
     * Converts LSP position to source code offset
     */
    private int getOffsetFromPosition(org.eclipse.lsp4j.Position pos) {
        int line = pos.getLine();
        int character = pos.getCharacter();
        int offset = 0;
        int currentLine = 0;

        if (sourceCode == null) return 0;

        while (currentLine < line && offset < sourceCode.length()) {
            if (sourceCode.charAt(offset) == '\n') {
                currentLine++;
            }
            offset++;
        }

        return offset + character;
    }

    /**
     * Gets line number from character offset
     */
    private int getLineNumber(int offset) {
        if (sourceCode == null || offset < 0) return 0;

        int line = 0;
        for (int i = 0; i < Math.min(offset, sourceCode.length()); i++) {
            if (sourceCode.charAt(i) == '\n') {
                line++;
            }
        }
        return line;
    }

    /**
     * Get all blocks that have errors (useful for UI highlighting)
     */
    public Set<CodeBlock> getBlocksWithErrors() {
        return Collections.unmodifiableSet(blocksWithErrors);
    }

    /**
     * Check if a specific block has errors
     */
    public boolean hasError(CodeBlock block) {
        return blocksWithErrors.contains(block);
    }

    /**
     * Get diagnostics for a specific block
     */
    public List<Diagnostic> getDiagnosticsForBlock(CodeBlock block) {
        if (lastDiagnostics == null || nodeToBlockMap == null) {
            return Collections.emptyList();
        }

        List<Diagnostic> blockDiagnostics = new ArrayList<>();

        for (Diagnostic diagnostic : lastDiagnostics) {
            Optional<CodeBlock> diagBlock = findBlockForDiagnostic(diagnostic);
            if (diagBlock.isPresent() && diagBlock.get() == block) {
                blockDiagnostics.add(diagnostic);
            }
        }

        return blockDiagnostics;
    }

    /**
     * Get a summary of all errors (useful for status bar)
     */
    public String getErrorSummary() {
        if (!hasErrors()) {
            return "✅ No errors";
        }

        long errorCount = lastDiagnostics.stream()
                .filter(d -> d.getSeverity() == DiagnosticSeverity.Error)
                .count();

        long warningCount = lastDiagnostics.stream()
                .filter(d -> d.getSeverity() == DiagnosticSeverity.Warning)
                .count();

        StringBuilder summary = new StringBuilder();
        if (errorCount > 0) {
            summary.append(String.format("❌ %d error%s", errorCount, errorCount == 1 ? "" : "s"));
        }
        if (warningCount > 0) {
            if (summary.length() > 0) summary.append(", ");
            summary.append(String.format("⚠️ %d warning%s", warningCount, warningCount == 1 ? "" : "s"));
        }

        return summary.toString();
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\validation\ErrorTranslator.java
=================================================================================

package com.botmaker.validation;

import org.eclipse.lsp4j.Diagnostic;
import org.eclipse.lsp4j.DiagnosticSeverity;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class ErrorTranslator {

    private static final Map<Integer, ErrorInfo> ERROR_MAPPINGS = new HashMap<>();
    private static final Pattern ERROR_CODE_PATTERN = Pattern.compile("\\b(\\d{7,})\\b");

    static class ErrorInfo {
        String userMessage;
        String suggestion;
        DiagnosticSeverity severity;

        ErrorInfo(String userMessage, String suggestion, DiagnosticSeverity severity) {
            this.userMessage = userMessage;
            this.suggestion = suggestion;
            this.severity = severity;
        }

        ErrorInfo(String userMessage, String suggestion) {
            this(userMessage, suggestion, DiagnosticSeverity.Error);
        }
    }

    static {
        // PRIORITY 1: Critical Errors (Must Handle)

        // 16777233 - TypeMismatch
        ERROR_MAPPINGS.put(16777233, new ErrorInfo(
                "Wrong type used: You're trying to use a {0} where a {1} is expected",
                "Check that you're using the right type of value (number, text, true/false, etc.)"
        ));

        // 570425394 - UndefinedName (Variable doesn't exist)
        ERROR_MAPPINGS.put(570425394, new ErrorInfo(
                "Variable or name '{0}' doesn't exist",
                "Did you forget to create this variable? Check for typos in the name."
        ));

        // 536870963 - UninitializedLocalVariable
        ERROR_MAPPINGS.put(536870963, new ErrorInfo(
                "Variable '{0}' is used before being given a value",
                "Set a value to this variable before using it."
        ));

        // 536870967 - RedefinedLocal (Duplicate variable)
        ERROR_MAPPINGS.put(536870967, new ErrorInfo(
                "A variable named '{0}' already exists",
                "Choose a different name or remove the duplicate variable."
        ));

        // 67108979 - ParameterMismatch
        ERROR_MAPPINGS.put(67108979, new ErrorInfo(
                "Wrong number of parameters: Expected {0} but got {1}",
                "Check how many inputs this function needs."
        ));

        // 603979884 - ShouldReturnValue
        ERROR_MAPPINGS.put(603979884, new ErrorInfo(
                "This function must return a value",
                "Add a return statement with a value at the end of the function."
        ));

        // PRIORITY 2: Type System Errors

        // 16777218 - UndefinedType
        ERROR_MAPPINGS.put(16777218, new ErrorInfo(
                "Type '{0}' cannot be found",
                "This type doesn't exist. Check for typos or missing imports."
        ));

        // 67108964 - UndefinedMethod
        ERROR_MAPPINGS.put(67108964, new ErrorInfo(
                "Method '{0}' doesn't exist",
                "Check the spelling of the method name or if it's available."
        ));

        // 33554502 - UndefinedField
        ERROR_MAPPINGS.put(33554502, new ErrorInfo(
                "Field '{0}' doesn't exist",
                "This field is not defined. Check the name and spelling."
        ));

        // PRIORITY 3: Syntax Errors (If user can edit code)

        // 1610612960 - MissingSemiColon
        ERROR_MAPPINGS.put(1610612960, new ErrorInfo(
                "Missing semicolon (;) at the end of the line",
                "Add a semicolon (;) at the end of this statement."
        ));

        // 1610612995 - UnterminatedString
        ERROR_MAPPINGS.put(1610612995, new ErrorInfo(
                "Text is missing a closing quote",
                "Add a closing quote (\") at the end of the text."
        ));

        // 1610612941 - ParsingErrorNoSuggestion
        ERROR_MAPPINGS.put(1610612941, new ErrorInfo(
                "Syntax error: The code structure is incorrect",
                "Check for missing brackets, parentheses, or other syntax issues."
        ));

        // 1610612956 - UnmatchedBracket
        ERROR_MAPPINGS.put(1610612956, new ErrorInfo(
                "Unmatched bracket - missing opening or closing bracket",
                "Check that all { } brackets are properly paired."
        ));

        // PRIORITY 4: Flow Control

        // 536870908 - InvalidBreak
        ERROR_MAPPINGS.put(536870908, new ErrorInfo(
                "'break' can only be used inside a loop or switch",
                "Move this break statement inside a loop block."
        ));

        // 536870909 - InvalidContinue
        ERROR_MAPPINGS.put(536870909, new ErrorInfo(
                "'continue' can only be used inside a loop",
                "Move this continue statement inside a loop block."
        ));

        // 536870161 - CodeCannotBeReached
        ERROR_MAPPINGS.put(536870161, new ErrorInfo(
                "This code will never run (unreachable code)",
                "Remove this code or fix the logic that prevents it from running.",
                DiagnosticSeverity.Warning
        ));

        // PRIORITY 5: Warnings

        // 536870973 - LocalVariableIsNeverUsed
        ERROR_MAPPINGS.put(536870973, new ErrorInfo(
                "Variable '{0}' is created but never used",
                "Remove this variable or use it somewhere in your code.",
                DiagnosticSeverity.Warning
        ));

        // 536870974 - ArgumentIsNeverUsed
        ERROR_MAPPINGS.put(536870974, new ErrorInfo(
                "Parameter '{0}' is never used",
                "Remove this parameter or use it in the function.",
                DiagnosticSeverity.Warning
        ));

        // 536871185 - AssignmentHasNoEffect
        ERROR_MAPPINGS.put(536871185, new ErrorInfo(
                "This assignment does nothing",
                "You're assigning a variable to itself. Remove this line or fix the logic.",
                DiagnosticSeverity.Warning
        ));
    }

    /**
     * Extracts the JDT error code from a diagnostic message
     */
    private static Integer extractErrorCode(String message) {
        Matcher matcher = ERROR_CODE_PATTERN.matcher(message);
        if (matcher.find()) {
            try {
                return Integer.parseInt(matcher.group(1));
            } catch (NumberFormatException e) {
                return null;
            }
        }
        return null;
    }

    /**
     * Translates diagnostics to user-friendly messages
     */
    public static String translate(List<Diagnostic> diagnostics) {
        if (diagnostics == null || diagnostics.isEmpty()) {
            return "✅ No errors found. Your code looks good!";
        }

        StringBuilder result = new StringBuilder();
        int errorCount = 0;
        int warningCount = 0;

        for (Diagnostic diagnostic : diagnostics) {
            if (diagnostic.getSeverity() == DiagnosticSeverity.Error) {
                errorCount++;
            } else if (diagnostic.getSeverity() == DiagnosticSeverity.Warning) {
                warningCount++;
            }
        }

        if (errorCount > 0) {
            result.append(String.format("❌ Found %d error%s:\n\n", errorCount, errorCount == 1 ? "" : "s"));
        }
        if (warningCount > 0) {
            result.append(String.format("⚠️  Found %d warning%s:\n\n", warningCount, warningCount == 1 ? "" : "s"));
        }

        for (Diagnostic diagnostic : diagnostics) {
            String icon = diagnostic.getSeverity() == DiagnosticSeverity.Error ? "❌" : "⚠️";
            int lineNumber = diagnostic.getRange().getStart().getLine() + 1;

            String translated = translateSingleDiagnostic(diagnostic);
            result.append(String.format("%s Line %d: %s\n\n", icon, lineNumber, translated));
        }

        return result.toString().trim();
    }

    /**
     * Translates a single diagnostic to a user-friendly message
     */
    public static String translateSingleDiagnostic(Diagnostic diagnostic) {
        String originalMessage = diagnostic.getMessage();

        // Try to extract error code
        Integer errorCode = extractErrorCode(originalMessage);

        if (errorCode != null && ERROR_MAPPINGS.containsKey(errorCode)) {
            ErrorInfo info = ERROR_MAPPINGS.get(errorCode);

            // Try to extract variable/type names from the original message
            String enrichedMessage = enrichMessage(info.userMessage, originalMessage);

            return String.format("%s\n   💡 %s", enrichedMessage, info.suggestion);
        }

        // Fallback: Try pattern matching for common error messages (backward compatibility)
        return translateByPattern(originalMessage);
    }

    /**
     * Enriches the user message with context from the original error message
     */
    private static String enrichMessage(String template, String originalMessage) {
        // Extract quoted strings (variable names, type names, etc.)
        Pattern quotedPattern = Pattern.compile("'([^']+)'|\"([^\"]+)\"");
        Matcher matcher = quotedPattern.matcher(originalMessage);

        int index = 0;
        String result = template;
        while (matcher.find() && result.contains("{" + index + "}")) {
            String value = matcher.group(1) != null ? matcher.group(1) : matcher.group(2);
            result = result.replace("{" + index + "}", "'" + value + "'");
            index++;
        }

        // Remove unreplaced placeholders
        result = result.replaceAll("\\{\\d+\\}", "the value");

        return result;
    }

    /**
     * Fallback pattern-based translation (for backward compatibility)
     */
    private static String translateByPattern(String message) {
        if (message.contains("cannot be resolved to a type")) {
            return "A type or class could not be found.\n   💡 Check for typos or if the type exists.";
        }
        if (message.contains("cannot be resolved")) {
            return "A variable, method, or name could not be found.\n   💡 Check for typos or if it was declared.";
        }
        if (message.contains("Syntax error, insert")) {
            try {
                String suggestion = message.split("insert \"")[1].split("\" to")[0];
                return String.format("Syntax error: Something is missing.\n   💡 Try adding '%s'", suggestion);
            } catch (Exception e) {
                return "Syntax error: Something is missing in the code structure.\n   💡 Check for missing semicolons, brackets, or parentheses.";
            }
        }
        if (message.contains("incompatible types") || message.contains("Type mismatch")) {
            return "Wrong type used: You're using a value of the wrong type.\n   💡 Make sure you're using the right kind of value (number, text, etc.)";
        }
        if (message.contains("might not have been initialized")) {
            return "Variable used before being set.\n   💡 Give this variable a value before using it.";
        }
        if (message.contains("is not a statement")) {
            return "This line is not a valid statement.\n   💡 It might be an incomplete expression or command.";
        }
        if (message.contains("Duplicate local variable")) {
            return "A variable with this name already exists.\n   💡 Choose a different name for this variable.";
        }

        // Return original message if no translation found
        return message;
    }

    /**
     * Get a short summary for UI display (e.g., tooltip)
     */
    public static String getShortSummary(Diagnostic diagnostic) {
        String originalMessage = diagnostic.getMessage();
        Integer errorCode = extractErrorCode(originalMessage);

        if (errorCode != null && ERROR_MAPPINGS.containsKey(errorCode)) {
            ErrorInfo info = ERROR_MAPPINGS.get(errorCode);
            return enrichMessage(info.userMessage, originalMessage);
        }

        // Fallback: Return first line of original message
        return originalMessage.split("\n")[0];
    }

    /**
     * Get just the suggestion part
     */
    public static String getSuggestion(Diagnostic diagnostic) {
        String originalMessage = diagnostic.getMessage();
        Integer errorCode = extractErrorCode(originalMessage);

        if (errorCode != null && ERROR_MAPPINGS.containsKey(errorCode)) {
            return ERROR_MAPPINGS.get(errorCode).suggestion;
        }

        return "Check your code for issues.";
    }
}


