=================================================================================
FILE: main/java/com/botmaker/blocks/BinaryExpressionBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractExpressionBlock;
import com.botmaker.core.ExpressionBlock;
import com.botmaker.lsp.CompletionContext;
import javafx.geometry.Pos;
import javafx.scene.Node;
import javafx.scene.control.Label;
import javafx.scene.layout.HBox;
import org.eclipse.jdt.core.dom.ITypeBinding;
import org.eclipse.jdt.core.dom.InfixExpression;

public class BinaryExpressionBlock extends AbstractExpressionBlock {

    private ExpressionBlock leftOperand;
    private ExpressionBlock rightOperand;
    private final String operator;
    private final ITypeBinding returnType;

    public BinaryExpressionBlock(String id, InfixExpression astNode) {
        super(id, astNode);
        this.operator = astNode.getOperator().toString();
        this.returnType = astNode.resolveTypeBinding();
    }

    public ExpressionBlock getLeftOperand() {
        return leftOperand;
    }

    public void setLeftOperand(ExpressionBlock leftOperand) {
        this.leftOperand = leftOperand;
    }

    public ExpressionBlock getRightOperand() {
        return rightOperand;
    }

    public void setRightOperand(ExpressionBlock rightOperand) {
        this.rightOperand = rightOperand;
    }

    public String getOperator() {
        return operator;
    }

    public ITypeBinding getReturnType() {
        return returnType;
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        HBox container = new HBox(5);
        container.setAlignment(Pos.CENTER_LEFT);
        container.getStyleClass().add("binary-expression-block");

        HBox expressionBox = new HBox(5);
        expressionBox.setAlignment(Pos.CENTER_LEFT);
        if (leftOperand != null) {
            expressionBox.getChildren().add(leftOperand.getUINode(context));
        }
        expressionBox.getChildren().add(new Label(operator));
        if (rightOperand != null) {
            expressionBox.getChildren().add(rightOperand.getUINode(context));
        }

        container.getChildren().add(expressionBox);

        String typeName = "unknown";
        if (returnType != null) {
            typeName = returnType.getName();
        }
        Label typeLabel = new Label("-> " + typeName);
        typeLabel.setStyle("-fx-font-style: italic; -fx-text-fill: #555;");
        container.getChildren().add(typeLabel);


        return container;
    }
}


=================================================================================
FILE: main/java/com/botmaker/blocks/IdentifierBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractExpressionBlock;
import com.botmaker.lsp.CompletionContext;
import javafx.application.Platform;
import javafx.scene.Cursor;
import javafx.scene.Node;
import javafx.scene.control.ContextMenu;
import javafx.scene.control.MenuItem;
import javafx.scene.control.Tooltip;
import javafx.scene.layout.HBox;
import javafx.scene.text.Text;
import org.eclipse.jdt.core.dom.SimpleName;
import org.eclipse.lsp4j.*;

import java.util.List;

public class IdentifierBlock extends AbstractExpressionBlock {
    private final String identifier;
    private boolean isUnedited = false; // Track if this is a default/auto-populated identifier
    private static final String UNEDITED_STYLE_CLASS = "unedited-identifier";

    public IdentifierBlock(String id, SimpleName astNode) {
        super(id, astNode);
        this.identifier = astNode.getIdentifier();
    }

    /**
     * Constructor for creating new IdentifierBlocks with default value
     */
    public IdentifierBlock(String id, SimpleName astNode, boolean markAsUnedited) {
        super(id, astNode);
        this.identifier = astNode.getIdentifier();
        this.isUnedited = markAsUnedited;
    }

    public String getIdentifier() {
        return identifier;
    }

    public boolean isUnedited() {
        return isUnedited;
    }

    public void markAsEdited() {
        this.isUnedited = false;
        if (uiNode != null) {
            uiNode.getStyleClass().remove(UNEDITED_STYLE_CLASS);
        }
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        Text text = new Text(this.identifier);
        HBox container = new HBox(text);
        container.setAlignment(javafx.geometry.Pos.CENTER_LEFT);
        container.getStyleClass().add("identifier-block");

        // Add unedited styling if applicable
        if (isUnedited) {
            container.getStyleClass().add(UNEDITED_STYLE_CLASS);
        }

        // Add visual cues for interaction
        container.setCursor(Cursor.HAND);

        String tooltipText = isUnedited
                ? "⚠️ Default variable name - Click to choose a variable or edit it"
                : "Click for variable suggestions";

        Tooltip tooltip = new Tooltip(tooltipText);
        Tooltip.install(container, tooltip);

        // Add the click handler for suggestions
        container.setOnMouseClicked(e -> {
            if (e.getClickCount() == 1) {
                requestSuggestions(container, context);
            }
        });

        // If this is unedited, automatically request suggestions once to auto-populate
        if (isUnedited) {
            Platform.runLater(() -> autoPopulateWithSuggestion(container, context));
        }

        return container;
    }

    /**
     * Automatically populate with the first available variable suggestion
     */
    private void autoPopulateWithSuggestion(Node uiNode, CompletionContext context) {
        try {
            Position pos = getPositionFromOffset(context.sourceCode(), this.astNode.getStartPosition());
            CompletionParams params = new CompletionParams(new TextDocumentIdentifier(context.docUri()), pos);

            context.server().getTextDocumentService().completion(params).thenAccept(result -> {
                if (result == null || (result.isLeft() && result.getLeft().isEmpty()) || (result.isRight() && result.getRight().getItems().isEmpty())) {
                    return; // No suggestions found, keep default value
                }

                List<CompletionItem> items = result.isLeft() ? result.getLeft() : result.getRight().getItems();

                // Find the first variable suggestion
                CompletionItem firstVariable = items.stream()
                        .filter(item -> item.getKind() == CompletionItemKind.Variable)
                        .findFirst()
                        .orElse(null);

                if (firstVariable != null) {
                    Platform.runLater(() -> {
                        // Auto-apply the first suggestion
                        applySuggestion(firstVariable, context);

                        // Update tooltip to reflect the auto-population
                        Tooltip newTooltip = new Tooltip("✓ Auto-selected variable - Click to change or confirm");
                        Tooltip.install(uiNode, newTooltip);
                    });
                }
            });
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private void requestSuggestions(Node uiNode, CompletionContext context) {
        try {
            Position pos = getPositionFromOffset(context.sourceCode(), this.astNode.getStartPosition());
            CompletionParams params = new CompletionParams(new TextDocumentIdentifier(context.docUri()), pos);

            context.server().getTextDocumentService().completion(params).thenAccept(result -> {
                if (result == null || (result.isLeft() && result.getLeft().isEmpty()) || (result.isRight() && result.getRight().getItems().isEmpty())) {
                    return; // No suggestions found
                }

                List<CompletionItem> items = result.isLeft() ? result.getLeft() : result.getRight().getItems();

                Platform.runLater(() -> {
                    ContextMenu menu = new ContextMenu();
                    for (CompletionItem item : items) {
                        // Filter for variables, as requested by the user
                        if (item.getKind() == CompletionItemKind.Variable) {
                            MenuItem mi = new MenuItem(item.getLabel());
                            mi.setOnAction(event -> {
                                applySuggestion(item, context);
                                markAsEdited(); // Mark as edited when user explicitly selects
                            });
                            menu.getItems().add(mi);
                        }
                    }
                    if (!menu.getItems().isEmpty()) {
                        menu.show(uiNode, javafx.geometry.Side.BOTTOM, 0, 0);
                    }
                });
            });
        } catch (Exception e) {
            e.printStackTrace(); // Log error
        }
    }

    private void applySuggestion(CompletionItem item, CompletionContext context) {
        try {
            String insertText = item.getInsertText() != null ? item.getInsertText() : item.getLabel();
            // The astNode for an IdentifierBlock is a SimpleName.
            context.codeEditor().replaceSimpleName((SimpleName) this.astNode, insertText);
        } catch (Exception e) {
            e.printStackTrace(); // Log error
        }
    }

    // Helper to convert a string offset to a line/character position
    private Position getPositionFromOffset(String code, int offset) {
        int line = 0;
        int lastNewline = -1;
        for (int i = 0; i < offset; i++) {
            if (code.charAt(i) == '\n') {
                line++;
                lastNewline = i;
            }
        }
        int character = offset - lastNewline - 1;
        return new Position(line, character);
    }
}

=================================================================================
FILE: main/java/com/botmaker/blocks/IfBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractStatementBlock;
import com.botmaker.core.BodyBlock;
import com.botmaker.core.CodeBlock;
import com.botmaker.core.ExpressionBlock;
import com.botmaker.lsp.CompletionContext;
import javafx.geometry.Pos;
import javafx.scene.Node;
import javafx.scene.control.Label;
import javafx.scene.layout.HBox;
import javafx.scene.layout.VBox;
import org.eclipse.jdt.core.dom.CompilationUnit;
import org.eclipse.jdt.core.dom.IfStatement;

public class IfBlock extends AbstractStatementBlock {

    private ExpressionBlock condition;
    private BodyBlock thenBody;
    private com.botmaker.core.StatementBlock elseStatement; // Can be null

    public IfBlock(String id, IfStatement astNode) {
        super(id, astNode);
    }

    public ExpressionBlock getCondition() {
        return condition;
    }

    public void setCondition(ExpressionBlock condition) {
        this.condition = condition;
    }

    public BodyBlock getThenBody() {
        return thenBody;
    }

    public void setThenBody(BodyBlock thenBody) {
        this.thenBody = thenBody;
    }

    public com.botmaker.core.StatementBlock getElseStatement() {
        return elseStatement;
    }

    public void setElseStatement(com.botmaker.core.StatementBlock elseStatement) {
        this.elseStatement = elseStatement;
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        VBox container = new VBox(5);
        container.getStyleClass().add("if-block");

        // Header: If + condition + delete button
        HBox header = new HBox(5);
        header.setAlignment(Pos.CENTER_LEFT);
        header.getChildren().add(new Label("If"));
        if (condition != null) {
            header.getChildren().add(condition.getUINode(context));
        } else {
            header.getChildren().add(createExpressionDropZone(context));
        }
        javafx.scene.layout.Pane spacer = new javafx.scene.layout.Pane();
        HBox.setHgrow(spacer, javafx.scene.layout.Priority.ALWAYS);
        javafx.scene.control.Button deleteButton = new javafx.scene.control.Button("X");
        deleteButton.setOnAction(e -> context.codeEditor().deleteStatement((org.eclipse.jdt.core.dom.Statement) this.astNode));
        header.getChildren().addAll(spacer, deleteButton);
        container.getChildren().add(header);

        // Then body
        if (thenBody != null) {
            Node thenBodyNode = thenBody.getUINode(context);
            thenBodyNode.getStyleClass().add("if-body");
            HBox.setHgrow(thenBodyNode, javafx.scene.layout.Priority.ALWAYS);
            container.getChildren().add(thenBodyNode);
        }

        // Else part
        if (elseStatement != null) {
            if (elseStatement instanceof com.botmaker.core.BodyBlock) {
                VBox elseContainer = new VBox(5);
                HBox elseHeader = new HBox(5);
                elseHeader.setAlignment(Pos.CENTER_LEFT);
                Label elseLabel = new Label("Else");
                javafx.scene.control.Button addElseIfButton = new javafx.scene.control.Button("+ if");
                addElseIfButton.setOnAction(e -> context.codeEditor().convertElseToElseIf((IfStatement) this.astNode));
                javafx.scene.layout.Pane elseSpacer = new javafx.scene.layout.Pane();
                HBox.setHgrow(elseSpacer, javafx.scene.layout.Priority.ALWAYS);
                javafx.scene.control.Button deleteElseButton = new javafx.scene.control.Button("X");
                deleteElseButton.setOnAction(e -> context.codeEditor().deleteElseFromIfStatement((IfStatement) this.astNode));
                elseHeader.getChildren().addAll(elseLabel, addElseIfButton, elseSpacer, deleteElseButton);

                Node elseBodyNode = elseStatement.getUINode(context);
                elseBodyNode.getStyleClass().add("if-body");
                HBox.setHgrow(elseBodyNode, javafx.scene.layout.Priority.ALWAYS);
                elseContainer.getChildren().addAll(elseHeader, elseBodyNode);
                container.getChildren().add(elseContainer);
            } else { // Assuming IfBlock
                HBox elseIfContainer = new HBox(5);
                elseIfContainer.setAlignment(Pos.CENTER_LEFT);
                elseIfContainer.getChildren().add(new Label("Else"));
                Node elseNode = elseStatement.getUINode(context);
                HBox.setHgrow(elseNode, javafx.scene.layout.Priority.ALWAYS);
                elseIfContainer.getChildren().add(elseNode);
                container.getChildren().add(elseIfContainer);
            }
        } else {
            javafx.scene.control.Button addElseButton = new javafx.scene.control.Button("+");
            addElseButton.setOnAction(e -> context.codeEditor().addElseToIfStatement((IfStatement) this.astNode));
            container.getChildren().add(addElseButton);
        }

        return container;
    }

    @Override
    public void highlight() {
        if (condition != null) {
            condition.highlight();
        } else {
            super.highlight();
        }
    }

    @Override
    public void unhighlight() {
        if (condition != null) {
            condition.unhighlight();
        } else {
            super.unhighlight();
        }
    }

    @Override
    public int getBreakpointLine(CompilationUnit cu) {
        // The breakpoint for an IfBlock should be on its condition.
        if (condition != null) {
            return condition.getBreakpointLine(cu);
        }
        return super.getBreakpointLine(cu);
    }

    @Override
    public CodeBlock getHighlightTarget() {
        return condition != null ? condition : this;
    }

    @Override
    public String getDetails() {
        String conditionDetails = (condition != null) ? condition.getDetails() : "no condition";
        return "If Statement (condition: " + conditionDetails + ")";
    }
}

=================================================================================
FILE: main/java/com/botmaker/blocks/LiteralBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractExpressionBlock;
import com.botmaker.lsp.CompletionContext;
import javafx.scene.Cursor;
import javafx.scene.Node;
import javafx.scene.control.TextField;
import javafx.scene.layout.HBox;
import javafx.scene.text.Text;
import org.eclipse.jdt.core.dom.Expression;

public class LiteralBlock<T> extends AbstractExpressionBlock {
    private final T value;

    public LiteralBlock(String id, Expression astNode, T value) {
        super(id, astNode);
        this.value = value;
    }

    public T getValue() {
        return value;
    }

    public Class<?> getValueType() {
        if (value == null) return null;
        return value.getClass();
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        String initialText = (value instanceof String) ? (String) value : String.valueOf(value);
        TextField textField = new TextField(initialText);

        if (initialText.isEmpty() && value instanceof String) {
            textField.setPromptText("Type a value...");
        }
        textField.setCursor(Cursor.TEXT);

        // Update when the text field loses focus, if the value has changed.
        textField.focusedProperty().addListener((obs, oldVal, newVal) -> {
            // newVal is false when focus is lost
            if (!newVal) {
                String newText = textField.getText();
                String oldText = (value instanceof String) ? (String) value : String.valueOf(value);

                if (!newText.equals(oldText)) {
                    // Handle the special synthetic case for an empty println
                    if (this.astNode instanceof org.eclipse.jdt.core.dom.MethodInvocation) {
                        org.eclipse.jdt.core.dom.MethodInvocation mi = (org.eclipse.jdt.core.dom.MethodInvocation) this.astNode;
                        context.codeEditor().addStringArgumentToMethodInvocation(mi, newText);
                    } else {
                        // This is the normal case for editing an existing literal
                        context.codeEditor().replaceLiteralValue((Expression) this.astNode, newText);
                    }
                }
            }
        });

        HBox container = new HBox(textField);
        container.setAlignment(javafx.geometry.Pos.CENTER_LEFT);
        container.getStyleClass().add("literal-block");
        return container;
    }
}


=================================================================================
FILE: main/java/com/botmaker/blocks/MainBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractCodeBlock;
import com.botmaker.core.BlockWithChildren;
import com.botmaker.core.BodyBlock;
import com.botmaker.core.CodeBlock;
import com.botmaker.lsp.CompletionContext;

import javafx.geometry.Insets;
import javafx.scene.Node;
import javafx.scene.control.Label;
import javafx.scene.layout.VBox;
import org.eclipse.jdt.core.dom.ASTNode;

import java.util.ArrayList;
import java.util.List;

public class MainBlock extends AbstractCodeBlock implements BlockWithChildren {

    private BodyBlock mainBody;

    public MainBlock(String id, ASTNode astNode) {
        super(id, astNode);
    }

    public void setMainBody(BodyBlock mainBody) {
        this.mainBody = mainBody;
    }

    @Override
    public List<CodeBlock> getChildren() {
        List<CodeBlock> children = new ArrayList<>();
        if (mainBody != null) {
            children.add(mainBody);
        }
        return children;
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        VBox container = new VBox(5);
        container.getStyleClass().add("main-block");
        container.setPadding(new Insets(10));

        Label header = new Label("Main");
        header.getStyleClass().add("main-block-header");
        container.getChildren().add(header);

        if (mainBody != null) {
            container.getChildren().add(mainBody.getUINode(context));
        }

        return container;
    }
}


=================================================================================
FILE: main/java/com/botmaker/blocks/PrintBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractStatementBlock;
import com.botmaker.core.ExpressionBlock;
import com.botmaker.lsp.CompletionContext;
import javafx.geometry.Pos;
import javafx.scene.Node;
import javafx.scene.layout.HBox;
import javafx.scene.text.Text;
import org.eclipse.jdt.core.dom.ExpressionStatement;
import org.eclipse.jdt.core.dom.MethodInvocation;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

public class PrintBlock extends AbstractStatementBlock {

    private final List<ExpressionBlock> arguments = new ArrayList<>();

    public PrintBlock(String id, ExpressionStatement astNode) {
        super(id, astNode);
    }

    public List<ExpressionBlock> getArguments() {
        return arguments;
    }

    public void addArgument(ExpressionBlock argument) {
        this.arguments.add(argument);
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        HBox container = new HBox(5);
        container.setAlignment(Pos.CENTER_LEFT);
        container.getStyleClass().add("print-block");

        container.getChildren().add(new Text("Print:"));

        if (arguments.isEmpty()) {
            container.getChildren().add(createExpressionDropZone(context));
        } else {
            for (ExpressionBlock arg : arguments) {
                container.getChildren().add(arg.getUINode(context));
            }
        }

        javafx.scene.control.Button addButton = new javafx.scene.control.Button("+");
        javafx.scene.control.ContextMenu contextMenu = new javafx.scene.control.ContextMenu();

        for (com.botmaker.ui.AddableExpression type : com.botmaker.ui.AddableExpression.values()) {
            javafx.scene.control.MenuItem menuItem = new javafx.scene.control.MenuItem(type.getDisplayName());
            menuItem.setOnAction(e -> {
                if (!arguments.isEmpty()) {
                    // We are assuming one argument for now
                    org.eclipse.jdt.core.dom.Expression toReplace = (org.eclipse.jdt.core.dom.Expression) arguments.get(0).getAstNode();
                    context.codeEditor().replaceExpression(toReplace, type);
                }
            });
            contextMenu.getItems().add(menuItem);
        }

        addButton.setOnAction(e -> contextMenu.show(addButton, javafx.geometry.Side.BOTTOM, 0, 0));
        container.getChildren().add(addButton);

        javafx.scene.control.Button deleteButton = new javafx.scene.control.Button("X");
        deleteButton.setOnAction(e -> {
            context.codeEditor().deleteStatement((org.eclipse.jdt.core.dom.Statement) this.astNode);
        });

        javafx.scene.layout.Pane spacer = new javafx.scene.layout.Pane();
        HBox.setHgrow(spacer, javafx.scene.layout.Priority.ALWAYS);

        container.getChildren().addAll(spacer, deleteButton);

        return container;
    }

    @Override
    public String getDetails() {
        String argsString = arguments.stream()
                .map(ExpressionBlock::getDetails)
                .collect(Collectors.joining(", "));
        return "Print Statement: " + argsString;
    }
}


=================================================================================
FILE: main/java/com/botmaker/blocks/VariableDeclarationBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractStatementBlock;
import com.botmaker.core.ExpressionBlock;
import com.botmaker.lsp.CompletionContext;
import com.botmaker.util.TypeManager;
import javafx.application.Platform;
import javafx.geometry.Pos;
import javafx.scene.Cursor;
import javafx.scene.Node;
import javafx.scene.control.*;
import javafx.scene.layout.HBox;
import org.eclipse.jdt.core.dom.Type;
import org.eclipse.jdt.core.dom.VariableDeclarationFragment;
import org.eclipse.jdt.core.dom.VariableDeclarationStatement;
import org.eclipse.lsp4j.*;

import java.util.List;

public class VariableDeclarationBlock extends AbstractStatementBlock {

    private final String variableName;
    private final Type variableType;
    private ExpressionBlock initializer;

    public VariableDeclarationBlock(String id, VariableDeclarationStatement astNode) {
        super(id, astNode);
        VariableDeclarationFragment fragment = (VariableDeclarationFragment) astNode.fragments().get(0);
        this.variableName = fragment.getName().getIdentifier();
        this.variableType = astNode.getType();
        this.initializer = null; // This will be set by the converter
    }

    public String getVariableName() {
        return variableName;
    }

    public Type getVariableType() {
        return variableType;
    }

    public ExpressionBlock getInitializer() {
        return initializer;
    }

    public void setInitializer(ExpressionBlock initializer) {
        this.initializer = initializer;
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        HBox container = new HBox(5);
        container.setAlignment(Pos.CENTER_LEFT);
        container.getStyleClass().add("variable-declaration-block");

        Label typeLabel = new Label(variableType.toString());
        typeLabel.getStyleClass().add("type-label");
        typeLabel.setCursor(Cursor.HAND);
        typeLabel.setOnMouseClicked(e -> requestTypeSuggestions(typeLabel, context));
        container.getChildren().add(typeLabel);

        TextField nameField = new TextField(variableName);
        nameField.focusedProperty().addListener((obs, oldVal, newVal) -> {
            if (!newVal) { // Focus lost
                String newName = nameField.getText();
                VariableDeclarationFragment fragment = (VariableDeclarationFragment) ((VariableDeclarationStatement) this.astNode).fragments().get(0);
                String currentName = fragment.getName().getIdentifier();

                if (!newName.equals(currentName)) {
                    context.codeEditor().replaceSimpleName(fragment.getName(), newName);
                }
            }
        });
        container.getChildren().add(nameField);

        container.getChildren().add(new Label("="));

        if (initializer != null) {
            container.getChildren().add(initializer.getUINode(context));
        } else {
            container.getChildren().add(createExpressionDropZone(context));
        }

        javafx.scene.control.Button deleteButton = new javafx.scene.control.Button("X");
        deleteButton.setOnAction(e -> {
            context.codeEditor().deleteStatement((org.eclipse.jdt.core.dom.Statement) this.astNode);
        });

        javafx.scene.layout.Pane spacer = new javafx.scene.layout.Pane();
        HBox.setHgrow(spacer, javafx.scene.layout.Priority.ALWAYS);

        container.getChildren().addAll(spacer, deleteButton);

        return container;
    }

    private void requestTypeSuggestions(Node uiNode, CompletionContext context) {
        try {
            Position pos = getPositionFromOffset(context.sourceCode(), this.variableType.getStartPosition());
            CompletionParams params = new CompletionParams(new TextDocumentIdentifier(context.docUri()), pos);

            context.server().getTextDocumentService().completion(params).thenAccept(result -> {
                Platform.runLater(() -> {
                    ContextMenu menu = new ContextMenu();

                    // Manually add fundamental types from TypeManager
                    for (String typeName : TypeManager.getFundamentalTypeNames()) {
                        CompletionItem dummyItem = new CompletionItem(typeName);
                        MenuItem mi = new MenuItem(typeName);
                        mi.setOnAction(event -> applyTypeSuggestion(dummyItem, context));
                        menu.getItems().add(mi);
                    }
                    menu.getItems().add(new SeparatorMenuItem());

                    // Add types from language server if any
                    if (result != null && (result.isRight() || (result.isLeft() && !result.getLeft().isEmpty()))) {
                        List<CompletionItem> items = result.isLeft() ? result.getLeft() : result.getRight().getItems();
                        for (CompletionItem item : items) {
                            CompletionItemKind kind = item.getKind();
                            // Filter for classes and interfaces suggested by the server
                            if (kind == CompletionItemKind.Class || kind == CompletionItemKind.Interface) {
                                // Avoid duplicating types we added manually
                                if (TypeManager.getFundamentalTypeNames().contains(item.getLabel())) continue;

                                MenuItem mi = new MenuItem(item.getLabel());
                                mi.setOnAction(event -> applyTypeSuggestion(item, context));
                                menu.getItems().add(mi);
                            }
                        }
                    }
                    menu.show(uiNode, javafx.geometry.Side.BOTTOM, 0, 0);
                });
            });
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private void applyTypeSuggestion(CompletionItem item, CompletionContext context) {
        try {
            String newTypeName = item.getInsertText() != null ? item.getInsertText() : item.getLabel();
            context.codeEditor().replaceVariableType((VariableDeclarationStatement) this.astNode, newTypeName);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private Position getPositionFromOffset(String code, int offset) {
        int line = 0;
        int lastNewline = -1;
        // Handle case where offset is at the beginning of the file
        if (offset == 0) {
            return new Position(0, 0);
        }
        for (int i = 0; i < offset; i++) {
            if (i >= code.length()) { // Boundary check
                return new Position(line, i - lastNewline - 1);
            }
            if (code.charAt(i) == '\n') {
                line++;
                lastNewline = i;
            }
        }
        int character = offset - lastNewline - 1;
        return new Position(line, character);
    }


    @Override
    public String getDetails() {
        String initializerText = initializer != null ? " = ..." : "";
        return "Variable Declaration: " + variableType.toString() + " " + variableName + initializerText;
    }
}

=================================================================================
FILE: main/java/com/botmaker/core/AbstractCodeBlock.java
=================================================================================

package com.botmaker.core;

import com.botmaker.lsp.CompletionContext;
import javafx.geometry.Pos;
import javafx.scene.Node;
import javafx.scene.control.Button;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Pane;
import javafx.scene.layout.Priority;
import javafx.scene.layout.Region;
import org.eclipse.jdt.core.dom.ASTNode;
import org.eclipse.jdt.core.dom.CompilationUnit;
import org.eclipse.jdt.core.dom.Statement;

public abstract class AbstractCodeBlock implements CodeBlock {
    protected final String id;
    protected final ASTNode astNode;
    protected Node uiNode; // A cached reference to the UI node
    private javafx.scene.control.Tooltip errorTooltip;

    public AbstractCodeBlock(String id, ASTNode astNode) {
        this.id = id;
        this.astNode = astNode;
    }

    @Override
    public String getId() {
        return id;
    }

    @Override
    public ASTNode getAstNode() {
        return astNode;
    }

    @Override
    public Node getUINode(CompletionContext context) {
        if (uiNode == null) {
            this.uiNode = createUINode(context);
        }
        return uiNode;
    }

    @Override
    public Node getUINode() {
        return uiNode;
    }


    @Override
    public void highlight() {
        if (uiNode != null) {
            if (!uiNode.getStyleClass().contains("highlighted")) {
                uiNode.getStyleClass().add("highlighted");
            }
        }
    }

    @Override
    public void unhighlight() {
        if (uiNode != null) {
            uiNode.getStyleClass().remove("highlighted");
        }
    }

    @Override
    public void setError(String message) {
        if (uiNode != null) {
            if (!uiNode.getStyleClass().contains("error-block")) {
                uiNode.getStyleClass().add("error-block");
            }
            if (errorTooltip == null) {
                errorTooltip = new javafx.scene.control.Tooltip(message);
                javafx.scene.control.Tooltip.install(uiNode, errorTooltip);
            } else {
                errorTooltip.setText(message);
            }
        }
    }

    @Override
    public void clearError() {
        if (uiNode != null) {
            uiNode.getStyleClass().remove("error-block");
            if (errorTooltip != null) {
                javafx.scene.control.Tooltip.uninstall(uiNode, errorTooltip);
                errorTooltip = null;
            }
        }
    }

    @Override
    public int getBreakpointLine(CompilationUnit cu) {
        if (cu == null || astNode == null) return -1;
        return cu.getLineNumber(astNode.getStartPosition());
    }

    @Override
    public CodeBlock getHighlightTarget() {
        return this; // Default behavior is to highlight the block itself.
    }

    @Override
    public String getDetails() {
        return this.getClass().getSimpleName() + " (ID: " + this.getId() + ")";
    }

    /**
     * Creates a standard placeholder for a missing expression, which acts as a drop target.
     * @param context The completion context containing the drag-and-drop manager.
     * @return A Node representing the drop zone.
     */
    protected Node createExpressionDropZone(CompletionContext context) {
        Region dropZone = new Region();
        context.dragAndDropManager().addExpressionDropHandlers(dropZone);
        return dropZone;
    }

    // Abstract method for subclasses to implement their specific UI creation logic.
    protected abstract Node createUINode(CompletionContext context);
}


=================================================================================
FILE: main/java/com/botmaker/core/AbstractExpressionBlock.java
=================================================================================

package com.botmaker.core;

import org.eclipse.jdt.core.dom.ASTNode;

public abstract class AbstractExpressionBlock extends AbstractCodeBlock implements ExpressionBlock {
    public AbstractExpressionBlock(String id, ASTNode astNode) {
        super(id, astNode);
    }
}


=================================================================================
FILE: main/java/com/botmaker/core/AbstractStatementBlock.java
=================================================================================

package com.botmaker.core;

import org.eclipse.jdt.core.dom.ASTNode;

public abstract class AbstractStatementBlock extends AbstractCodeBlock implements StatementBlock {
    public AbstractStatementBlock(String id, ASTNode astNode) {
        super(id, astNode);
    }
}


=================================================================================
FILE: main/java/com/botmaker/core/BlockWithChildren.java
=================================================================================

package com.botmaker.core;

import java.util.List;

public interface BlockWithChildren {
    List<CodeBlock> getChildren();
}


=================================================================================
FILE: main/java/com/botmaker/core/BodyBlock.java
=================================================================================

package com.botmaker.core;

import com.botmaker.core.AbstractStatementBlock;
import com.botmaker.lsp.CompletionContext;
import com.botmaker.ui.BlockDragAndDropManager;
import com.botmaker.ui.DropInfo;
import javafx.scene.Node;
import javafx.scene.layout.Priority;
import javafx.scene.layout.VBox;

import java.util.ArrayList;
import java.util.List;

public class BodyBlock extends AbstractStatementBlock implements BlockWithChildren {
    private final List<StatementBlock> statements = new ArrayList<>();
    private final BlockDragAndDropManager dragAndDropManager;

    public BodyBlock(String id, org.eclipse.jdt.core.dom.Block astNode, BlockDragAndDropManager dragAndDropManager) {
        super(id, astNode);
        this.dragAndDropManager = dragAndDropManager;
    }

    public void addStatement(StatementBlock statement) {
        statements.add(statement);
    }

    @Override
    public List<CodeBlock> getChildren() {
        return new ArrayList<>(statements);
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        VBox container = new VBox();
        container.getStyleClass().add("body-block");
        VBox.setVgrow(container, Priority.ALWAYS);

        if (statements.isEmpty()) {
            javafx.scene.control.Label placeholder = new javafx.scene.control.Label("Drag block here");
            placeholder.getStyleClass().add("empty-body-placeholder");
            placeholder.setMouseTransparent(true);
            container.getChildren().add(placeholder);
            container.setAlignment(javafx.geometry.Pos.CENTER);
            container.setMinHeight(30);
            dragAndDropManager.addEmptyBodyDropHandlers(container, this);
        } else {
            // Add a separator at the beginning
            container.getChildren().add(createSeparatorWithHandlers(this, 0));

            for (int i = 0; i < statements.size(); i++) {
                StatementBlock statement = statements.get(i);
                container.getChildren().add(statement.getUINode(context));
                // Add a separator after each statement
                container.getChildren().add(createSeparatorWithHandlers(this, i + 1));
            }
        }
        return container;
    }

    private Node createSeparatorWithHandlers(BodyBlock targetBody, int insertionIndex) {
        javafx.scene.layout.Region separator = dragAndDropManager.createSeparator();
        separator.getStyleClass().add("body-block-separator");
        StatementBlock adjacentBlock = (insertionIndex < statements.size()) ? statements.get(insertionIndex) : null;
        dragAndDropManager.addSeparatorDragHandlers(separator, targetBody, insertionIndex, adjacentBlock);
        return separator;
    }
}

=================================================================================
FILE: main/java/com/botmaker/core/CodeBlock.java
=================================================================================

package com.botmaker.core;

import com.botmaker.lsp.CompletionContext;
import javafx.scene.Node;
import org.eclipse.jdt.core.dom.ASTNode;

import org.eclipse.jdt.core.dom.CompilationUnit;

public interface CodeBlock {
    String getId();
    ASTNode getAstNode();
    Node getUINode(CompletionContext context);
    Node getUINode();
    void highlight();
    void unhighlight();
    int getBreakpointLine(CompilationUnit cu);
    CodeBlock getHighlightTarget();
    String getDetails();
    void setError(String message);
    void clearError();
}


=================================================================================
FILE: main/java/com/botmaker/core/ExpressionBlock.java
=================================================================================

package com.botmaker.core;

/**
 * A block that represents a value that can be evaluated.
 * Examples: a literal "hello", a variable `x`, a calculation `2 + 2`.
 */
public interface ExpressionBlock extends CodeBlock {
}


=================================================================================
FILE: main/java/com/botmaker/core/StatementBlock.java
=================================================================================

package com.botmaker.core;

/**
 * A block that represents a complete action or step in execution.
 * Examples: a variable declaration, an if-statement, a method call.
 */
public interface StatementBlock extends CodeBlock {
}


=================================================================================
FILE: main/java/com/botmaker/lsp/CompletionContext.java
=================================================================================

package com.botmaker.lsp;

import com.botmaker.Main;
import com.botmaker.parser.CodeEditor;
import com.botmaker.ui.BlockDragAndDropManager;
import org.eclipse.lsp4j.services.LanguageServer;

// Using a record for a simple, immutable data carrier to pass to UI creation.
public record CompletionContext(
        Main mainApp, // Reference to the main application
        CodeEditor codeEditor,
        LanguageServer server,
        String docUri,
        String sourceCode,
        long docVersion,
        BlockDragAndDropManager dragAndDropManager
) {}

=================================================================================
FILE: main/java/com/botmaker/lsp/IProblem.java
=================================================================================

package com.botmaker.lsp;


public interface IProblem {


    String[] getArguments();


    int getID();


    String getMessage();


    char[] getOriginatingFileName();


    int getSourceEnd();


    int getSourceLineNumber();


    int getSourceStart();


    boolean isError();


    boolean isWarning();


    boolean isInfo();


    void setSourceEnd(int sourceEnd);


    void setSourceLineNumber(int lineNumber);


    void setSourceStart(int sourceStart);


    int TypeRelated = 0x01000000;
    int FieldRelated = 0x02000000;
    int MethodRelated = 0x04000000;
    int ConstructorRelated = 0x08000000;
    int ImportRelated = 0x10000000;
    int Internal = 0x20000000;
    int Syntax = 0x40000000;
    /** @since 3.0 */
    int Javadoc = 0x80000000;
    /** @since 3.14 */
    int ModuleRelated = 0x00800000;
    /** @since 3.18 */
    int Compliance = 0x00400000;
    /** @since 3.20 */
    int PreviewRelated = 0x00200000;

    int IgnoreCategoriesMask = 0x1FFFFF;

    /*
     * Below are listed all available problem IDs. Note that this list could be augmented in the future,
     * as new features are added to the Java core implementation.
     *
     * Problem IDs must be kept unique even when their mask is stripped, since
     * the bare integer literal is used for message lookup in
     * /org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties.
     * Use this regex to find duplicates: (?s)(\+ \d+)\b.*\1\b
     */


    int Unclassified = 0;

    /**
     * General type related problems
     */
    int ObjectHasNoSuperclass = TypeRelated + 1;
    int UndefinedType = TypeRelated + 2;
    int NotVisibleType = TypeRelated + 3;
    int AmbiguousType = TypeRelated + 4;
    int UsingDeprecatedType = TypeRelated + 5;
    int InternalTypeNameProvided = TypeRelated + 6;
    /** @since 2.1 */
    int UnusedPrivateType = Internal + TypeRelated + 7;

    int IncompatibleTypesInEqualityOperator = TypeRelated + 15;
    int IncompatibleTypesInConditionalOperator = TypeRelated + 16;
    int TypeMismatch = TypeRelated + 17;
    /** @since 3.0 */
    int IndirectAccessToStaticType = Internal + TypeRelated + 18;

    /** @since 3.10 */
    int ReturnTypeMismatch = TypeRelated + 19;

    /**
     * Inner types related problems
     */
    int MissingEnclosingInstanceForConstructorCall = TypeRelated + 20;
    int MissingEnclosingInstance = TypeRelated + 21;
    int IncorrectEnclosingInstanceReference = TypeRelated + 22;
    int IllegalEnclosingInstanceSpecification = TypeRelated + 23;
    int CannotDefineStaticInitializerInLocalType = Internal + 24;
    int OuterLocalMustBeFinal = Internal + 25;
    int CannotDefineInterfaceInLocalType = Internal + 26;
    int IllegalPrimitiveOrArrayTypeForEnclosingInstance = TypeRelated + 27;
    /** @since 2.1 */
    int EnclosingInstanceInConstructorCall = Internal + 28;
    int AnonymousClassCannotExtendFinalClass = TypeRelated + 29;
    /** @since 3.1 */
    int CannotDefineAnnotationInLocalType = Internal + 30;
    /** @since 3.1 */
    int CannotDefineEnumInLocalType = Internal + 31;
    /** @since 3.1 */
    int NonStaticContextForEnumMemberType = Internal + 32;
    /** @since 3.3 */
    int TypeHidingType = TypeRelated + 33;
    /** @since 3.11 */
    int NotAnnotationType = TypeRelated + 34;

    // variables
    int UndefinedName = Internal + FieldRelated + 50;
    int UninitializedLocalVariable = Internal + 51;
    int VariableTypeCannotBeVoid = Internal + 52;
    /** @deprecated - problem is no longer generated, use {@link #CannotAllocateVoidArray} instead */
    int VariableTypeCannotBeVoidArray = Internal + 53;
    int CannotAllocateVoidArray = Internal + 54;
    // local variables
    int RedefinedLocal = Internal + 55;
    int RedefinedArgument = Internal + 56;
    // final local variables
    int DuplicateFinalLocalInitialization = Internal + 57;
    /** @since 2.1 */
    int NonBlankFinalLocalAssignment = Internal + 58;
    /** @since 3.2 */
    int ParameterAssignment = Internal + 59;
    int FinalOuterLocalAssignment = Internal + 60;
    int LocalVariableIsNeverUsed = Internal + 61;
    int ArgumentIsNeverUsed = Internal + 62;
    int BytecodeExceeds64KLimit = Internal + 63;
    int BytecodeExceeds64KLimitForClinit = Internal + 64;
    int TooManyArgumentSlots = Internal + 65;
    int TooManyLocalVariableSlots = Internal + 66;
    /** @since 2.1 */
    int TooManySyntheticArgumentSlots = Internal + 67;
    /** @since 2.1 */
    int TooManyArrayDimensions = Internal + 68;
    /** @since 2.1 */
    int BytecodeExceeds64KLimitForConstructor = Internal + 69;

    // fields
    int UndefinedField = FieldRelated + 70;
    int NotVisibleField = FieldRelated + 71;
    int AmbiguousField = FieldRelated + 72;
    int UsingDeprecatedField = FieldRelated + 73;
    int NonStaticFieldFromStaticInvocation = FieldRelated + 74;
    int ReferenceToForwardField = FieldRelated + Internal + 75;
    /** @since 2.1 */
    int NonStaticAccessToStaticField = Internal + FieldRelated + 76;
    /** @since 2.1 */
    int UnusedPrivateField = Internal + FieldRelated + 77;
    /** @since 3.0 */
    int IndirectAccessToStaticField = Internal + FieldRelated + 78;
    /** @since 3.0 */
    int UnqualifiedFieldAccess = Internal + FieldRelated + 79;
    int FinalFieldAssignment = FieldRelated + 80;
    int UninitializedBlankFinalField = FieldRelated + 81;
    int DuplicateBlankFinalFieldInitialization = FieldRelated + 82;
    /** @since 3.6 */
    int UnresolvedVariable = FieldRelated + 83;
    /** @since 3.10 */
    int NonStaticOrAlienTypeReceiver = MethodRelated + 84;

    /** @since 3.11 */
    int ExceptionParameterIsNeverUsed = Internal + 85;
    /** @since 3.17 */
    int BytecodeExceeds64KLimitForSwitchTable = Internal + 86;

    // variable hiding
    /** @since 3.0 */
    int LocalVariableHidingLocalVariable = Internal + 90;
    /** @since 3.0 */
    int LocalVariableHidingField = Internal + FieldRelated + 91;
    /** @since 3.0 */
    int FieldHidingLocalVariable = Internal + FieldRelated + 92;
    /** @since 3.0 */
    int FieldHidingField = Internal + FieldRelated + 93;
    /** @since 3.0 */
    int ArgumentHidingLocalVariable = Internal + 94;
    /** @since 3.0 */
    int ArgumentHidingField = Internal + 95;
    /** @since 3.1 */
    int MissingSerialVersion = Internal + 96;
    /** @since 3.10 */
    int LambdaRedeclaresArgument = Internal + 97;
    /** @since 3.10 */
    int LambdaRedeclaresLocal = Internal + 98;
    /** @since 3.10 */
    int LambdaDescriptorMentionsUnmentionable = 99;

    // methods
    int UndefinedMethod = MethodRelated + 100;
    int NotVisibleMethod = MethodRelated + 101;
    int AmbiguousMethod = MethodRelated + 102;
    int UsingDeprecatedMethod = MethodRelated + 103;
    int DirectInvocationOfAbstractMethod = MethodRelated + 104;
    int VoidMethodReturnsValue = MethodRelated + 105;
    int MethodReturnsVoid = MethodRelated + 106;
    int MethodRequiresBody = Internal + MethodRelated + 107;
    int ShouldReturnValue = Internal + MethodRelated + 108;
    int MethodButWithConstructorName = MethodRelated + 110;
    int MissingReturnType = TypeRelated + 111;
    int BodyForNativeMethod = Internal + MethodRelated + 112;
    int BodyForAbstractMethod = Internal + MethodRelated + 113;
    int NoMessageSendOnBaseType = MethodRelated + 114;
    int ParameterMismatch = MethodRelated + 115;
    int NoMessageSendOnArrayType = MethodRelated + 116;
    /** @since 2.1 */
    int NonStaticAccessToStaticMethod = Internal + MethodRelated + 117;
    /** @since 2.1 */
    int UnusedPrivateMethod = Internal + MethodRelated + 118;
    /** @since 3.0 */
    int IndirectAccessToStaticMethod = Internal + MethodRelated + 119;
    /** @since 3.4 */
    int MissingTypeInMethod = MethodRelated + 120;
    /** @since 3.7 */
    int MethodCanBeStatic = Internal + MethodRelated + 121;
    /** @since 3.7 */
    int MethodCanBePotentiallyStatic = Internal + MethodRelated + 122;
    /** @since 3.10 */
    int MethodReferenceSwingsBothWays = Internal + MethodRelated + 123;
    /** @since 3.10 */
    int StaticMethodShouldBeAccessedStatically = Internal + MethodRelated + 124;
    /** @since 3.10 */
    int InvalidArrayConstructorReference = Internal + MethodRelated + 125;
    /** @since 3.10 */
    int ConstructedArrayIncompatible = Internal + MethodRelated + 126;
    /** @since 3.10 */
    int DanglingReference = Internal + MethodRelated + 127;
    /** @since 3.10 */
    int IncompatibleMethodReference = Internal + MethodRelated + 128;

    // constructors
    /** @since 3.4 */
    int MissingTypeInConstructor = ConstructorRelated + 129;
    int UndefinedConstructor = ConstructorRelated + 130;
    int NotVisibleConstructor = ConstructorRelated + 131;
    int AmbiguousConstructor = ConstructorRelated + 132;
    int UsingDeprecatedConstructor = ConstructorRelated + 133;
    /** @since 2.1 */
    int UnusedPrivateConstructor = Internal + MethodRelated + 134;
    // explicit constructor calls
    int InstanceFieldDuringConstructorInvocation = ConstructorRelated + 135;
    int InstanceMethodDuringConstructorInvocation = ConstructorRelated + 136;
    int RecursiveConstructorInvocation = ConstructorRelated + 137;
    int ThisSuperDuringConstructorInvocation = ConstructorRelated + 138;
    /** @since 3.0 */
    int InvalidExplicitConstructorCall = ConstructorRelated + Syntax + 139;
    // implicit constructor calls
    int UndefinedConstructorInDefaultConstructor = ConstructorRelated + 140;
    int NotVisibleConstructorInDefaultConstructor = ConstructorRelated + 141;
    int AmbiguousConstructorInDefaultConstructor = ConstructorRelated + 142;
    int UndefinedConstructorInImplicitConstructorCall = ConstructorRelated + 143;
    int NotVisibleConstructorInImplicitConstructorCall = ConstructorRelated + 144;
    int AmbiguousConstructorInImplicitConstructorCall = ConstructorRelated + 145;
    int UnhandledExceptionInDefaultConstructor = TypeRelated + 146;
    int UnhandledExceptionInImplicitConstructorCall = TypeRelated + 147;

    // expressions
    /** @since 3.6 */
    int UnusedObjectAllocation = Internal + 148;
    /** @since 3.5 */
    int DeadCode = Internal + 149;
    int ArrayReferenceRequired = Internal + 150;
    int NoImplicitStringConversionForCharArrayExpression = Internal + 151;
    // constant expressions
    int StringConstantIsExceedingUtf8Limit = Internal + 152;
    int NonConstantExpression = Internal + 153;
    int NumericValueOutOfRange = Internal + 154;
    // cast expressions
    int IllegalCast = TypeRelated + 156;
    // allocations
    int InvalidClassInstantiation = TypeRelated + 157;
    int CannotDefineDimensionExpressionsWithInit = Internal + 158;
    int MustDefineEitherDimensionExpressionsOrInitializer = Internal + 159;
    // operators
    int InvalidOperator = Internal + 160;
    // statements
    int CodeCannotBeReached = Internal + 161;
    int CannotReturnInInitializer = Internal + 162;
    int InitializerMustCompleteNormally = Internal + 163;
    // assert
    int InvalidVoidExpression = Internal + 164;
    // try
    int MaskedCatch = TypeRelated + 165;
    int DuplicateDefaultCase = Internal + 166;
    int UnreachableCatch = TypeRelated + MethodRelated + 167;
    int UnhandledException = TypeRelated + 168;
    // switch
    int IncorrectSwitchType = TypeRelated + 169;
    int DuplicateCase = FieldRelated + 170;

    // labelled
    int DuplicateLabel = Internal + 171;
    int InvalidBreak = Internal + 172;
    int InvalidContinue = Internal + 173;
    int UndefinedLabel = Internal + 174;
    //synchronized
    int InvalidTypeToSynchronized = Internal + 175;
    int InvalidNullToSynchronized = Internal + 176;
    // throw
    int CannotThrowNull = Internal + 177;
    // assignment
    /** @since 2.1 */
    int AssignmentHasNoEffect = Internal + 178;
    /** @since 3.0 */
    int PossibleAccidentalBooleanAssignment = Internal + 179;
    /** @since 3.0 */
    int SuperfluousSemicolon = Internal + 180;
    /** @since 3.0 */
    int UnnecessaryCast = Internal + TypeRelated + 181;
    /** @deprecated - no longer generated, use {@link #UnnecessaryCast} instead
     *   @since 3.0 */
    int UnnecessaryArgumentCast = Internal + TypeRelated + 182;
    /** @since 3.0 */
    int UnnecessaryInstanceof = Internal + TypeRelated + 183;
    /** @since 3.0 */
    int FinallyMustCompleteNormally = Internal + 184;
    /** @since 3.0 */
    int UnusedMethodDeclaredThrownException = Internal + 185;
    /** @since 3.0 */
    int UnusedConstructorDeclaredThrownException = Internal + 186;
    /** @since 3.0 */
    int InvalidCatchBlockSequence = Internal + TypeRelated + 187;
    /** @since 3.0 */
    int EmptyControlFlowStatement = Internal + TypeRelated + 188;
    /** @since 3.0 */
    int UnnecessaryElse = Internal + 189;

    // inner emulation
    int NeedToEmulateFieldReadAccess = FieldRelated + 190;
    int NeedToEmulateFieldWriteAccess = FieldRelated + 191;
    int NeedToEmulateMethodAccess = MethodRelated + 192;
    int NeedToEmulateConstructorAccess = MethodRelated + 193;

    /** @since 3.2 */
    int FallthroughCase = Internal + 194;

    //inherited name hides enclosing name (sort of ambiguous)
    int InheritedMethodHidesEnclosingName = MethodRelated + 195;
    int InheritedFieldHidesEnclosingName = FieldRelated + 196;
    int InheritedTypeHidesEnclosingName = TypeRelated + 197;

    /** @since 3.1 */
    int IllegalUsageOfQualifiedTypeReference = Internal + Syntax + 198;

    // miscellaneous
    /** @since 3.2 */
    int UnusedLabel = Internal + 199;
    int ThisInStaticContext = Internal + 200;
    int StaticMethodRequested = Internal + MethodRelated + 201;
    int IllegalDimension = Internal + 202;
    /** @deprecated - problem is no longer generated */
    int InvalidTypeExpression = Internal + 203;
    int ParsingError = Syntax + Internal + 204;
    int ParsingErrorNoSuggestion = Syntax + Internal + 205;
    int InvalidUnaryExpression = Syntax + Internal + 206;

    // syntax errors
    int InterfaceCannotHaveConstructors = Syntax + Internal + 207;
    int ArrayConstantsOnlyInArrayInitializers = Syntax + Internal + 208;
    int ParsingErrorOnKeyword = Syntax + Internal + 209;
    int ParsingErrorOnKeywordNoSuggestion = Syntax + Internal + 210;

    /** @since 3.5 */
    int ComparingIdentical = Internal + 211;

    /** @since 3.22
     * @noreference preview feature error */
    int UnsafeCast = TypeRelated + 212;

    int UnmatchedBracket = Syntax + Internal + 220;
    int NoFieldOnBaseType = FieldRelated + 221;
    int InvalidExpressionAsStatement = Syntax + Internal + 222;
    /** @since 2.1 */
    int ExpressionShouldBeAVariable = Syntax + Internal + 223;
    /** @since 2.1 */
    int MissingSemiColon = Syntax + Internal + 224;
    /** @since 2.1 */
    int InvalidParenthesizedExpression = Syntax + Internal + 225;

    /** @since 3.10 */
    int NoSuperInInterfaceContext = Syntax + Internal + 226;

    /** @since 3.0 */
    int ParsingErrorInsertTokenBefore = Syntax + Internal + 230;
    /** @since 3.0 */
    int ParsingErrorInsertTokenAfter = Syntax + Internal + 231;
    /** @since 3.0 */
    int ParsingErrorDeleteToken = Syntax + Internal + 232;
    /** @since 3.0 */
    int ParsingErrorDeleteTokens = Syntax + Internal + 233;
    /** @since 3.0 */
    int ParsingErrorMergeTokens = Syntax + Internal + 234;
    /** @since 3.0 */
    int ParsingErrorInvalidToken = Syntax + Internal + 235;
    /** @since 3.0 */
    int ParsingErrorMisplacedConstruct = Syntax + Internal + 236;
    /** @since 3.0 */
    int ParsingErrorReplaceTokens = Syntax + Internal + 237;
    /** @since 3.0 */
    int ParsingErrorNoSuggestionForTokens = Syntax + Internal + 238;
    /** @since 3.0 */
    int ParsingErrorUnexpectedEOF = Syntax + Internal + 239;
    /** @since 3.0 */
    int ParsingErrorInsertToComplete = Syntax + Internal + 240;
    /** @since 3.0 */
    int ParsingErrorInsertToCompleteScope = Syntax + Internal + 241;
    /** @since 3.0 */
    int ParsingErrorInsertToCompletePhrase = Syntax + Internal + 242;

    // scanner errors
    int EndOfSource = Syntax + Internal + 250;
    int InvalidHexa = Syntax + Internal + 251;
    int InvalidOctal = Syntax + Internal + 252;
    int InvalidCharacterConstant = Syntax + Internal + 253;
    int InvalidEscape = Syntax + Internal + 254;
    int InvalidInput = Syntax + Internal + 255;
    int InvalidUnicodeEscape = Syntax + Internal + 256;
    int InvalidFloat = Syntax + Internal + 257;
    int NullSourceString = Syntax + Internal + 258;
    int UnterminatedString = Syntax + Internal + 259;
    int UnterminatedComment = Syntax + Internal + 260;
    int NonExternalizedStringLiteral = Internal + 261;
    /** @since 3.1 */
    int InvalidDigit = Syntax + Internal + 262;
    /** @since 3.1 */
    int InvalidLowSurrogate = Syntax + Internal + 263;
    /** @since 3.1 */
    int InvalidHighSurrogate = Syntax + Internal + 264;
    /** @since 3.2 */
    int UnnecessaryNLSTag = Internal + 265;
    /** @since 3.7.1 */
    int InvalidBinary = Syntax + Internal + 266;
    /** @since 3.7.1 */
    int BinaryLiteralNotBelow17 = Syntax + Internal + 267;
    /** @since 3.7.1 */
    int IllegalUnderscorePosition = Syntax + Internal + 268;
    /** @since 3.7.1 */
    int UnderscoresInLiteralsNotBelow17 = Syntax + Internal + 269;
    /** @since 3.7.1 */
    int IllegalHexaLiteral = Syntax + Internal + 270;

    /** @since 3.10 */
    int MissingTypeInLambda = MethodRelated + 271;
    /** @since 3.23  */
    int UnterminatedTextBlock = PreviewRelated + 272;
    // type related problems
    /** @since 3.1 */
    int DiscouragedReference = TypeRelated + 280;

    int InterfaceCannotHaveInitializers = TypeRelated + 300;
    int DuplicateModifierForType = TypeRelated + 301;
    int IllegalModifierForClass = TypeRelated + 302;
    int IllegalModifierForInterface = TypeRelated + 303;
    int IllegalModifierForMemberClass = TypeRelated + 304;
    int IllegalModifierForMemberInterface = TypeRelated + 305;
    int IllegalModifierForLocalClass = TypeRelated + 306;
    /** @since 3.1 */
    int ForbiddenReference = TypeRelated + 307;
    int IllegalModifierCombinationFinalAbstractForClass = TypeRelated + 308;
    int IllegalVisibilityModifierForInterfaceMemberType = TypeRelated + 309;
    int IllegalVisibilityModifierCombinationForMemberType = TypeRelated + 310;
    int IllegalStaticModifierForMemberType = TypeRelated + 311;
    int SuperclassMustBeAClass = TypeRelated + 312;
    int ClassExtendFinalClass = TypeRelated + 313;
    int DuplicateSuperInterface = TypeRelated + 314;
    int SuperInterfaceMustBeAnInterface = TypeRelated + 315;
    int HierarchyCircularitySelfReference = TypeRelated + 316;
    int HierarchyCircularity = TypeRelated + 317;
    int HidingEnclosingType = TypeRelated + 318;
    int DuplicateNestedType = TypeRelated + 319;
    int CannotThrowType = TypeRelated + 320;
    int PackageCollidesWithType = TypeRelated + 321;
    int TypeCollidesWithPackage = TypeRelated + 322;
    int DuplicateTypes = TypeRelated + 323;
    int IsClassPathCorrect = TypeRelated + 324; // see also IsClasspathCorrectWithReferencingType below
    int PublicClassMustMatchFileName = TypeRelated + 325;
    /** @deprecated - problem is no longer generated */
    int MustSpecifyPackage = Internal + 326;
    int HierarchyHasProblems = TypeRelated + 327;
    int PackageIsNotExpectedPackage = Internal + 328;
    /** @since 2.1 */
    int ObjectCannotHaveSuperTypes = Internal + 329;
    /** @since 3.1 */
    int ObjectMustBeClass = Internal + 330;
    /** @since 3.4 */
    int RedundantSuperinterface = TypeRelated + 331;
    /** @since 3.5 */
    int ShouldImplementHashcode = TypeRelated + 332;
    /** @since 3.5 */
    int AbstractMethodsInConcreteClass = TypeRelated + 333;

    /** @deprecated - problem is no longer generated, use {@link #UndefinedType} instead */
    int SuperclassNotFound =  TypeRelated + 329 + ProblemReasons.NotFound; // TypeRelated + 330
    /** @deprecated - problem is no longer generated, use {@link #NotVisibleType} instead */
    int SuperclassNotVisible =  TypeRelated + 329 + ProblemReasons.NotVisible; // TypeRelated + 331
    /** @deprecated - problem is no longer generated, use {@link #AmbiguousType} instead */
    int SuperclassAmbiguous =  TypeRelated + 329 + ProblemReasons.Ambiguous; // TypeRelated + 332
    /** @deprecated - problem is no longer generated, use {@link #InternalTypeNameProvided} instead */
    int SuperclassInternalNameProvided =  TypeRelated + 329 + ProblemReasons.InternalNameProvided; // TypeRelated + 333
    /** @deprecated - problem is no longer generated, use {@link #InheritedTypeHidesEnclosingName} instead */
    int SuperclassInheritedNameHidesEnclosingName =  TypeRelated + 329 + ProblemReasons.InheritedNameHidesEnclosingName; // TypeRelated + 334

    /** @deprecated - problem is no longer generated, use {@link #UndefinedType} instead */
    int InterfaceNotFound =  TypeRelated + 334 + ProblemReasons.NotFound; // TypeRelated + 335
    /** @deprecated - problem is no longer generated, use {@link #NotVisibleType} instead */
    int InterfaceNotVisible =  TypeRelated + 334 + ProblemReasons.NotVisible; // TypeRelated + 336
    /** @deprecated - problem is no longer generated, use {@link #AmbiguousType} instead */
    int InterfaceAmbiguous =  TypeRelated + 334 + ProblemReasons.Ambiguous; // TypeRelated + 337
    /** @deprecated - problem is no longer generated, use {@link #InternalTypeNameProvided} instead */
    int InterfaceInternalNameProvided =  TypeRelated + 334 + ProblemReasons.InternalNameProvided; // TypeRelated + 338
    /** @deprecated - problem is no longer generated, use {@link #InheritedTypeHidesEnclosingName} instead */
    int InterfaceInheritedNameHidesEnclosingName =  TypeRelated + 334 + ProblemReasons.InheritedNameHidesEnclosingName; // TypeRelated + 339

    // field related problems
    int DuplicateField = FieldRelated + 340;
    int DuplicateModifierForField = FieldRelated + 341;
    int IllegalModifierForField = FieldRelated + 342;
    int IllegalModifierForInterfaceField = FieldRelated + 343;
    int IllegalVisibilityModifierCombinationForField = FieldRelated + 344;
    int IllegalModifierCombinationFinalVolatileForField = FieldRelated + 345;
    int UnexpectedStaticModifierForField = FieldRelated + 346;
    /** @since 3.32 */
    int IsClassPathCorrectWithReferencingType = TypeRelated + 347;

    /** @deprecated - problem is no longer generated, use {@link #UndefinedType} instead */
    int FieldTypeNotFound =  FieldRelated + 349 + ProblemReasons.NotFound; // FieldRelated + 350
    /** @deprecated - problem is no longer generated, use {@link #NotVisibleType} instead */
    int FieldTypeNotVisible =  FieldRelated + 349 + ProblemReasons.NotVisible; // FieldRelated + 351
    /** @deprecated - problem is no longer generated, use {@link #AmbiguousType} instead */
    int FieldTypeAmbiguous =  FieldRelated + 349 + ProblemReasons.Ambiguous; // FieldRelated + 352
    /** @deprecated - problem is no longer generated, use {@link #InternalTypeNameProvided} instead */
    int FieldTypeInternalNameProvided =  FieldRelated + 349 + ProblemReasons.InternalNameProvided; // FieldRelated + 353
    /** @deprecated - problem is no longer generated, use {@link #InheritedTypeHidesEnclosingName} instead */
    int FieldTypeInheritedNameHidesEnclosingName =  FieldRelated + 349 + ProblemReasons.InheritedNameHidesEnclosingName; // FieldRelated + 354

    // method related problems
    int DuplicateMethod = MethodRelated + 355;
    int IllegalModifierForArgument = MethodRelated + 356;
    int DuplicateModifierForMethod = MethodRelated + 357;
    int IllegalModifierForMethod = MethodRelated + 358;
    int IllegalModifierForInterfaceMethod = MethodRelated + 359;
    int IllegalVisibilityModifierCombinationForMethod = MethodRelated + 360;
    int UnexpectedStaticModifierForMethod = MethodRelated + 361;
    int IllegalAbstractModifierCombinationForMethod = MethodRelated + 362;
    int AbstractMethodInAbstractClass = MethodRelated + 363;
    int ArgumentTypeCannotBeVoid = MethodRelated + 364;
    /** @deprecated - problem is no longer generated, use {@link #CannotAllocateVoidArray} instead */
    int ArgumentTypeCannotBeVoidArray = MethodRelated + 365;
    /** @deprecated - problem is no longer generated, use {@link #CannotAllocateVoidArray} instead */
    int ReturnTypeCannotBeVoidArray = MethodRelated + 366;
    int NativeMethodsCannotBeStrictfp = MethodRelated + 367;
    int DuplicateModifierForArgument = MethodRelated + 368;
    /** @since 3.5 */
    int IllegalModifierForConstructor = MethodRelated + 369;

    /** @deprecated - problem is no longer generated, use {@link #UndefinedType} instead */
    int ArgumentTypeNotFound =  MethodRelated + 369 + ProblemReasons.NotFound; // MethodRelated + 370
    /** @deprecated - problem is no longer generated, use {@link #NotVisibleType} instead */
    int ArgumentTypeNotVisible =  MethodRelated + 369 + ProblemReasons.NotVisible; // MethodRelated + 371
    /** @deprecated - problem is no longer generated, use {@link #AmbiguousType} instead */
    int ArgumentTypeAmbiguous =  MethodRelated + 369 + ProblemReasons.Ambiguous; // MethodRelated + 372
    /** @deprecated - problem is no longer generated, use {@link #InternalTypeNameProvided} instead */
    int ArgumentTypeInternalNameProvided =  MethodRelated + 369 + ProblemReasons.InternalNameProvided; // MethodRelated + 373
    /** @deprecated - problem is no longer generated, use {@link #InheritedTypeHidesEnclosingName} instead */
    int ArgumentTypeInheritedNameHidesEnclosingName =  MethodRelated + 369 + ProblemReasons.InheritedNameHidesEnclosingName; // MethodRelated + 374

    /** @deprecated - problem is no longer generated, use {@link #UndefinedType} instead */
    int ExceptionTypeNotFound =  MethodRelated + 374 + ProblemReasons.NotFound; // MethodRelated + 375
    /** @deprecated - problem is no longer generated, use {@link #NotVisibleType} instead */
    int ExceptionTypeNotVisible =  MethodRelated + 374 + ProblemReasons.NotVisible; // MethodRelated + 376
    /** @deprecated - problem is no longer generated, use {@link #AmbiguousType} instead */
    int ExceptionTypeAmbiguous =  MethodRelated + 374 + ProblemReasons.Ambiguous; // MethodRelated + 377
    /** @deprecated - problem is no longer generated, use {@link #InternalTypeNameProvided} instead */
    int ExceptionTypeInternalNameProvided =  MethodRelated + 374 + ProblemReasons.InternalNameProvided; // MethodRelated + 378
    /** @deprecated - problem is no longer generated, use {@link #InheritedTypeHidesEnclosingName} instead */
    int ExceptionTypeInheritedNameHidesEnclosingName =  MethodRelated + 374 + ProblemReasons.InheritedNameHidesEnclosingName; // MethodRelated + 379

    /** @deprecated - problem is no longer generated, use {@link #UndefinedType} instead */
    int ReturnTypeNotFound =  MethodRelated + 379 + ProblemReasons.NotFound; // MethodRelated + 380
    /** @deprecated - problem is no longer generated, use {@link #NotVisibleType} instead */
    int ReturnTypeNotVisible =  MethodRelated + 379 + ProblemReasons.NotVisible; // MethodRelated + 381
    /** @deprecated - problem is no longer generated, use {@link #AmbiguousType} instead */
    int ReturnTypeAmbiguous =  MethodRelated + 379 + ProblemReasons.Ambiguous; // MethodRelated + 382
    /** @deprecated - problem is no longer generated, use {@link #InternalTypeNameProvided} instead */
    int ReturnTypeInternalNameProvided =  MethodRelated + 379 + ProblemReasons.InternalNameProvided; // MethodRelated + 383
    /** @deprecated - problem is no longer generated, use {@link #InheritedTypeHidesEnclosingName} instead */
    int ReturnTypeInheritedNameHidesEnclosingName =  MethodRelated + 379 + ProblemReasons.InheritedNameHidesEnclosingName; // MethodRelated + 384

    // import related problems
    int ConflictingImport = ImportRelated + 385;
    int DuplicateImport = ImportRelated + 386;
    int CannotImportPackage = ImportRelated + 387;
    int UnusedImport = ImportRelated + 388;

    int ImportNotFound =  ImportRelated + 389 + ProblemReasons.NotFound; // ImportRelated + 390
    /** @deprecated - problem is no longer generated, use {@link #NotVisibleType} instead */
    int ImportNotVisible =  ImportRelated + 389 + ProblemReasons.NotVisible; // ImportRelated + 391
    /** @deprecated - problem is no longer generated, use {@link #AmbiguousType} instead */
    int ImportAmbiguous =  ImportRelated + 389 + ProblemReasons.Ambiguous; // ImportRelated + 392
    /** @deprecated - problem is no longer generated, use {@link #InternalTypeNameProvided} instead */
    int ImportInternalNameProvided =  ImportRelated + 389 + ProblemReasons.InternalNameProvided; // ImportRelated + 393
    /** @deprecated - problem is no longer generated, use {@link #InheritedTypeHidesEnclosingName} instead */
    int ImportInheritedNameHidesEnclosingName =  ImportRelated + 389 + ProblemReasons.InheritedNameHidesEnclosingName; // ImportRelated + 394

    /** @since 3.1 */
    int InvalidTypeForStaticImport =  ImportRelated + 391;

    // local variable related problems
    int DuplicateModifierForVariable = MethodRelated + 395;
    int IllegalModifierForVariable = MethodRelated + 396;
    /** @deprecated - problem is no longer generated, use {@link #RedundantNullCheckOnNonNullLocalVariable} instead */
    int LocalVariableCannotBeNull = Internal + 397; // since 3.3: semantics are LocalVariableRedundantCheckOnNonNull
    /** @deprecated - problem is no longer generated, use {@link #NullLocalVariableReference}, {@link #RedundantNullCheckOnNullLocalVariable} or {@link #RedundantLocalVariableNullAssignment} instead */
    int LocalVariableCanOnlyBeNull = Internal + 398; // since 3.3: split with LocalVariableRedundantCheckOnNull depending on context
    /** @deprecated - problem is no longer generated, use {@link #PotentialNullLocalVariableReference} instead */
    int LocalVariableMayBeNull = Internal + 399;

    // method verifier problems
    int AbstractMethodMustBeImplemented = MethodRelated + 400;
    int FinalMethodCannotBeOverridden = MethodRelated + 401;
    int IncompatibleExceptionInThrowsClause = MethodRelated + 402;
    int IncompatibleExceptionInInheritedMethodThrowsClause = MethodRelated + 403;
    int IncompatibleReturnType = MethodRelated + 404;
    int InheritedMethodReducesVisibility = MethodRelated + 405;
    int CannotOverrideAStaticMethodWithAnInstanceMethod = MethodRelated + 406;
    int CannotHideAnInstanceMethodWithAStaticMethod = MethodRelated + 407;
    int StaticInheritedMethodConflicts = MethodRelated + 408;
    int MethodReducesVisibility = MethodRelated + 409;
    int OverridingNonVisibleMethod = MethodRelated + 410;
    int AbstractMethodCannotBeOverridden = MethodRelated + 411;
    int OverridingDeprecatedMethod = MethodRelated + 412;
    /** @since 2.1 */
    int IncompatibleReturnTypeForNonInheritedInterfaceMethod = MethodRelated + 413;
    /** @since 2.1 */
    int IncompatibleExceptionInThrowsClauseForNonInheritedInterfaceMethod = MethodRelated + 414;
    /** @since 3.1 */
    int IllegalVararg = MethodRelated + 415;
    /** @since 3.3 */
    int OverridingMethodWithoutSuperInvocation = MethodRelated + 416;
    /** @since 3.5 */
    int MissingSynchronizedModifierInInheritedMethod= MethodRelated + 417;
    /** @since 3.5 */
    int AbstractMethodMustBeImplementedOverConcreteMethod = MethodRelated + 418;
    /** @since 3.5 */
    int InheritedIncompatibleReturnType = MethodRelated + 419;

    // code snippet support
    int CodeSnippetMissingClass = Internal + 420;
    int CodeSnippetMissingMethod = Internal + 421;
    int CannotUseSuperInCodeSnippet = Internal + 422;

    //constant pool
    int TooManyConstantsInConstantPool = Internal + 430;
    /** @since 2.1 */
    int TooManyBytesForStringConstant = Internal + 431;

    // static constraints
    /** @since 2.1 */
    int TooManyFields = Internal + 432;
    /** @since 2.1 */
    int TooManyMethods = Internal + 433;
    /** @since 3.7 */
    int TooManyParametersForSyntheticMethod = Internal + 434;

    // 1.4 features
    // assertion warning
    int UseAssertAsAnIdentifier = Internal + 440;

    // 1.5 features
    int UseEnumAsAnIdentifier = Internal + 441;
    /** @since 3.2 */
    int EnumConstantsCannotBeSurroundedByParenthesis = Syntax + Internal + 442;

    /** @since 3.10 */
    int IllegalUseOfUnderscoreAsAnIdentifier = Syntax + Internal + 443;
    /** @since 3.10 */
    int UninternedIdentityComparison = Syntax + Internal + 444;
    /** @since 3.24 */
    int ErrorUseOfUnderscoreAsAnIdentifier = Syntax + Internal + 445;

    // detected task
    /** @since 2.1 */
    int Task = Internal + 450;

    // local variables related problems, cont'd
    /** @since 3.3 */
    int NullLocalVariableReference = Internal + 451;
    /** @since 3.3 */
    int PotentialNullLocalVariableReference = Internal + 452;
    /** @since 3.3 */
    int RedundantNullCheckOnNullLocalVariable = Internal + 453;
    /** @since 3.3 */
    int NullLocalVariableComparisonYieldsFalse = Internal + 454;
    /** @since 3.3 */
    int RedundantLocalVariableNullAssignment = Internal + 455;
    /** @since 3.3 */
    int NullLocalVariableInstanceofYieldsFalse = Internal + 456;
    /** @since 3.3 */
    int RedundantNullCheckOnNonNullLocalVariable = Internal + 457;
    /** @since 3.3 */
    int NonNullLocalVariableComparisonYieldsFalse = Internal + 458;
    /** @since 3.9 */
    int PotentialNullUnboxing = Internal + 459;
    /** @since 3.9 */
    int NullUnboxing = Internal + 461;

    // block
    /** @since 3.0 */
    int UndocumentedEmptyBlock = Internal + 460;

    /*
     * Javadoc comments
     */
    /**
     * Problem signaled on an invalid URL reference.
     * Valid syntax example: @see "http://www.eclipse.org/"
     * @since 3.4
     */
    int JavadocInvalidSeeUrlReference = Javadoc + Internal + 462;
    /**
     * Problem warned on missing tag description.
     * @since 3.4
     */
    int JavadocMissingTagDescription = Javadoc + Internal + 463;
    /**
     * Problem warned on duplicated tag.
     * @since 3.3
     */
    int JavadocDuplicateTag = Javadoc + Internal + 464;
    /**
     * Problem signaled on an hidden reference due to a too low visibility level.
     * @since 3.3
     */
    int JavadocHiddenReference = Javadoc + Internal + 465;
    /**
     * Problem signaled on an invalid qualification for member type reference.
     * @since 3.3
     */
    int JavadocInvalidMemberTypeQualification = Javadoc + Internal + 466;
    /** @since 3.2 */
    int JavadocMissingIdentifier = Javadoc + Internal + 467;
    /** @since 3.2 */
    int JavadocNonStaticTypeFromStaticInvocation = Javadoc + Internal + 468;
    /** @since 3.1 */
    int JavadocInvalidParamTagTypeParameter = Javadoc + Internal + 469;
    /** @since 3.0 */
    int JavadocUnexpectedTag = Javadoc + Internal + 470;
    /** @since 3.0 */
    int JavadocMissingParamTag = Javadoc + Internal + 471;
    /** @since 3.0 */
    int JavadocMissingParamName = Javadoc + Internal + 472;
    /** @since 3.0 */
    int JavadocDuplicateParamName = Javadoc + Internal + 473;
    /** @since 3.0 */
    int JavadocInvalidParamName = Javadoc + Internal + 474;
    /** @since 3.0 */
    int JavadocMissingReturnTag = Javadoc + Internal + 475;
    /** @since 3.0 */
    int JavadocDuplicateReturnTag = Javadoc + Internal + 476;
    /** @since 3.0 */
    int JavadocMissingThrowsTag = Javadoc + Internal + 477;
    /** @since 3.0 */
    int JavadocMissingThrowsClassName = Javadoc + Internal + 478;
    /** @since 3.0 */
    int JavadocInvalidThrowsClass = Javadoc + Internal + 479;
    /** @since 3.0 */
    int JavadocDuplicateThrowsClassName = Javadoc + Internal + 480;
    /** @since 3.0 */
    int JavadocInvalidThrowsClassName = Javadoc + Internal + 481;
    /** @since 3.0 */
    int JavadocMissingSeeReference = Javadoc + Internal + 482;
    /** @since 3.0 */
    int JavadocInvalidSeeReference = Javadoc + Internal + 483;
    /**
     * Problem signaled on an invalid URL reference that does not conform to the href syntax.
     * Valid syntax example: @see <a href="http://www.eclipse.org/">Eclipse Home Page</a>
     * @since 3.0
     */
    int JavadocInvalidSeeHref = Javadoc + Internal + 484;
    /** @since 3.0 */
    int JavadocInvalidSeeArgs = Javadoc + Internal + 485;
    /** @since 3.0 */
    int JavadocMissing = Javadoc + Internal + 486;
    /** @since 3.0 */
    int JavadocInvalidTag = Javadoc + Internal + 487;
    /*
     * ID for field errors in Javadoc
     */
    /** @since 3.0 */
    int JavadocUndefinedField = Javadoc + Internal + 488;
    /** @since 3.0 */
    int JavadocNotVisibleField = Javadoc + Internal + 489;
    /** @since 3.0 */
    int JavadocAmbiguousField = Javadoc + Internal + 490;
    /** @since 3.0 */
    int JavadocUsingDeprecatedField = Javadoc + Internal + 491;
    /*
     * IDs for constructor errors in Javadoc
     */
    /** @since 3.0 */
    int JavadocUndefinedConstructor = Javadoc + Internal + 492;
    /** @since 3.0 */
    int JavadocNotVisibleConstructor = Javadoc + Internal + 493;
    /** @since 3.0 */
    int JavadocAmbiguousConstructor = Javadoc + Internal + 494;
    /** @since 3.0 */
    int JavadocUsingDeprecatedConstructor = Javadoc + Internal + 495;
    /*
     * IDs for method errors in Javadoc
     */
    /** @since 3.0 */
    int JavadocUndefinedMethod = Javadoc + Internal + 496;
    /** @since 3.0 */
    int JavadocNotVisibleMethod = Javadoc + Internal + 497;
    /** @since 3.0 */
    int JavadocAmbiguousMethod = Javadoc + Internal + 498;
    /** @since 3.0 */
    int JavadocUsingDeprecatedMethod = Javadoc + Internal + 499;
    /** @since 3.0 */
    int JavadocNoMessageSendOnBaseType = Javadoc + Internal + 500;
    /** @since 3.0 */
    int JavadocParameterMismatch = Javadoc + Internal + 501;
    /** @since 3.0 */
    int JavadocNoMessageSendOnArrayType = Javadoc + Internal + 502;
    /*
     * IDs for type errors in Javadoc
     */
    /** @since 3.0 */
    int JavadocUndefinedType = Javadoc + Internal + 503;
    /** @since 3.0 */
    int JavadocNotVisibleType = Javadoc + Internal + 504;
    /** @since 3.0 */
    int JavadocAmbiguousType = Javadoc + Internal + 505;
    /** @since 3.0 */
    int JavadocUsingDeprecatedType = Javadoc + Internal + 506;
    /** @since 3.0 */
    int JavadocInternalTypeNameProvided = Javadoc + Internal + 507;
    /** @since 3.0 */
    int JavadocInheritedMethodHidesEnclosingName = Javadoc + Internal + 508;
    /** @since 3.0 */
    int JavadocInheritedFieldHidesEnclosingName = Javadoc + Internal + 509;
    /** @since 3.0 */
    int JavadocInheritedNameHidesEnclosingTypeName = Javadoc + Internal + 510;
    /** @since 3.0 */
    int JavadocAmbiguousMethodReference = Javadoc + Internal + 511;
    /** @since 3.0 */
    int JavadocUnterminatedInlineTag = Javadoc + Internal + 512;
    /** @since 3.0 */
    int JavadocMalformedSeeReference = Javadoc + Internal + 513;
    /** @since 3.0 */
    int JavadocMessagePrefix = Internal + 514;

    /** @since 3.1 */
    int JavadocMissingHashCharacter = Javadoc + Internal + 515;
    /** @since 3.1 */
    int JavadocEmptyReturnTag = Javadoc + Internal + 516;
    /** @since 3.1 */
    int JavadocInvalidValueReference = Javadoc + Internal + 517;
    /** @since 3.1 */
    int JavadocUnexpectedText = Javadoc + Internal + 518;
    /** @since 3.1 */
    int JavadocInvalidParamTagName = Javadoc + Internal + 519;

    // see also JavadocNotAccessibleType below

    /*
     * IDs for module errors in Javadoc
     */
    /** @since 3.20 */
    int JavadocMissingUsesTag = Javadoc + Internal + 1800;
    /** @since 3.20 */
    int JavadocDuplicateUsesTag = Javadoc + Internal + 1801;
    /** @since 3.20 */
    int JavadocMissingUsesClassName = Javadoc + Internal + 1802;
    /** @since 3.20 */
    int JavadocInvalidUsesClassName = Javadoc + Internal + 1803;
    /** @since 3.20 */
    int JavadocInvalidUsesClass = Javadoc + Internal + 1804;
    /** @since 3.20 */
    int JavadocMissingProvidesTag = Javadoc + Internal + 1805;
    /** @since 3.20 */
    int JavadocDuplicateProvidesTag = Javadoc + Internal + 1806;
    /** @since 3.20 */
    int JavadocMissingProvidesClassName = Javadoc + Internal + 1807;
    /** @since 3.20 */
    int JavadocInvalidProvidesClassName = Javadoc + Internal + 1808;
    /** @since 3.20 */
    int JavadocInvalidProvidesClass = Javadoc + Internal + 1809;
    /** @since 3.24*/
    int JavadocInvalidModuleQualification = Javadoc + Internal + 1810;
    /** @since 3.29*/
    int JavadocInvalidModule = Javadoc + Internal + 1811;
    /** @since 3.30*/
    int JavadocInvalidSnippet = Javadoc + Internal + 1812;
    /** @since 3.30 */
    int JavadocInvalidSnippetMissingColon = Javadoc + Internal + 1813;
    /** @since 3.30 */
    int JavadocInvalidSnippetContentNewLine = Javadoc + Internal + 1814;
    /** @since 3.30 */
    int JavadocInvalidSnippetRegionNotClosed = Javadoc + Internal + 1815;
    /** @since 3.30 */
    int JavadocInvalidSnippetRegexSubstringTogether = Javadoc + Internal + 1816;
    /** @since 3.30 */
    int JavadocInvalidSnippetDuplicateRegions = Javadoc + Internal + 1817;

    /**
     * Generics
     */
    /** @since 3.1 */
    int DuplicateTypeVariable = Internal + 520;
    /** @since 3.1 */
    int IllegalTypeVariableSuperReference = Internal + 521;
    /** @since 3.1 */
    int NonStaticTypeFromStaticInvocation = Internal + 522;
    /** @since 3.1 */
    int ObjectCannotBeGeneric = Internal + 523;
    /** @since 3.1 */
    int NonGenericType = TypeRelated + 524;
    /** @since 3.1 */
    int IncorrectArityForParameterizedType = TypeRelated + 525;
    /** @since 3.1 */
    int TypeArgumentMismatch = TypeRelated + 526;
    /** @since 3.1 */
    int DuplicateMethodErasure = TypeRelated + 527;
    /** @since 3.1 */
    int ReferenceToForwardTypeVariable = TypeRelated + 528;
    /** @since 3.1 */
    int BoundMustBeAnInterface = TypeRelated + 529;
    /** @since 3.1 */
    int UnsafeRawConstructorInvocation = TypeRelated + 530;
    /** @since 3.1 */
    int UnsafeRawMethodInvocation = TypeRelated + 531;
    /** @since 3.1 */
    int UnsafeTypeConversion = TypeRelated + 532;
    /** @since 3.1 */
    int InvalidTypeVariableExceptionType = TypeRelated + 533;
    /** @since 3.1 */
    int InvalidParameterizedExceptionType = TypeRelated + 534;
    /** @since 3.1 */
    int IllegalGenericArray = TypeRelated + 535;
    /** @since 3.1 */
    int UnsafeRawFieldAssignment = TypeRelated + 536;
    /** @since 3.1 */
    int FinalBoundForTypeVariable = TypeRelated + 537;
    /** @since 3.1 */
    int UndefinedTypeVariable = Internal + 538;
    /** @since 3.1 */
    int SuperInterfacesCollide = TypeRelated + 539;
    /** @since 3.1 */
    int WildcardConstructorInvocation = TypeRelated + 540;
    /** @since 3.1 */
    int WildcardMethodInvocation = TypeRelated + 541;
    /** @since 3.1 */
    int WildcardFieldAssignment = TypeRelated + 542;
    /** @since 3.1 */
    int GenericMethodTypeArgumentMismatch = TypeRelated + 543;
    /** @since 3.1 */
    int GenericConstructorTypeArgumentMismatch = TypeRelated + 544;
    /** @since 3.1 */
    int UnsafeGenericCast = TypeRelated + 545;
    /** @since 3.1 */
    int IllegalInstanceofParameterizedType = Internal + 546;
    /** @since 3.1 */
    int IllegalInstanceofTypeParameter = Internal + 547;
    /** @since 3.1 */
    int NonGenericMethod = TypeRelated + 548;
    /** @since 3.1 */
    int IncorrectArityForParameterizedMethod = TypeRelated + 549;
    /** @since 3.1 */
    int ParameterizedMethodArgumentTypeMismatch = TypeRelated + 550;
    /** @since 3.1 */
    int NonGenericConstructor = TypeRelated + 551;
    /** @since 3.1 */
    int IncorrectArityForParameterizedConstructor = TypeRelated + 552;
    /** @since 3.1 */
    int ParameterizedConstructorArgumentTypeMismatch = TypeRelated + 553;
    /** @since 3.1 */
    int TypeArgumentsForRawGenericMethod = TypeRelated + 554;
    /** @since 3.1 */
    int TypeArgumentsForRawGenericConstructor = TypeRelated + 555;
    /** @since 3.1 */
    int SuperTypeUsingWildcard = TypeRelated + 556;
    /** @since 3.1 */
    int GenericTypeCannotExtendThrowable = TypeRelated + 557;
    /** @since 3.1 */
    int IllegalClassLiteralForTypeVariable = TypeRelated + 558;
    /** @since 3.1 */
    int UnsafeReturnTypeOverride = MethodRelated + 559;
    /** @since 3.1 */
    int MethodNameClash = MethodRelated + 560;
    /** @since 3.1 */
    int RawMemberTypeCannotBeParameterized = TypeRelated + 561;
    /** @since 3.1 */
    int MissingArgumentsForParameterizedMemberType = TypeRelated + 562;
    /** @since 3.1 */
    int StaticMemberOfParameterizedType = TypeRelated + 563;
    /** @since 3.1 */
    int BoundHasConflictingArguments = TypeRelated + 564;
    /** @since 3.1 */
    int DuplicateParameterizedMethods = MethodRelated + 565;
    /** @since 3.1 */
    int IllegalQualifiedParameterizedTypeAllocation = TypeRelated + 566;
    /** @since 3.1 */
    int DuplicateBounds = TypeRelated + 567;
    /** @since 3.1 */
    int BoundCannotBeArray = TypeRelated + 568;
    /** @since 3.1 */
    int UnsafeRawGenericConstructorInvocation = TypeRelated + 569;
    /** @since 3.1 */
    int UnsafeRawGenericMethodInvocation = TypeRelated + 570;
    /** @since 3.1 */
    int TypeParameterHidingType = TypeRelated + 571;
    /** @since 3.2 */
    int RawTypeReference = TypeRelated + 572;
    /** @since 3.2 */
    int NoAdditionalBoundAfterTypeVariable = TypeRelated + 573;
    /** @since 3.2 */
    int UnsafeGenericArrayForVarargs = MethodRelated + 574;
    /** @since 3.2 */
    int IllegalAccessFromTypeVariable = TypeRelated + 575;
    /** @since 3.3 */
    int TypeHidingTypeParameterFromType = TypeRelated + 576;
    /** @since 3.3 */
    int TypeHidingTypeParameterFromMethod = TypeRelated + 577;
    /** @since 3.3 */
    int InvalidUsageOfWildcard = Syntax + Internal + 578;
    /** @since 3.4 */
    int UnusedTypeArgumentsForMethodInvocation = MethodRelated + 579;

    /**
     * Foreach
     */
    /** @since 3.1 */
    int IncompatibleTypesInForeach = TypeRelated + 580;
    /** @since 3.1 */
    int InvalidTypeForCollection = Internal + 581;
    /** @since 3.6*/
    int InvalidTypeForCollectionTarget14 = Internal + 582;

    /** @since 3.7.1 */
    int DuplicateInheritedMethods = MethodRelated + 583;
    /** @since 3.8 */
    int MethodNameClashHidden = MethodRelated + 584;

    /** @since 3.9 */
    int UnsafeElementTypeConversion = TypeRelated + 585;
    /** @since 3.11 */
    int InvalidTypeArguments = MethodRelated + TypeRelated + 586;

    /**
     * 1.5 Syntax errors (when source level < 1.5)
     */
    /** @since 3.1 */
    int InvalidUsageOfTypeParameters = Syntax + Internal + 590;
    /** @since 3.1 */
    int InvalidUsageOfStaticImports = Syntax + Internal + 591;
    /** @since 3.1 */
    int InvalidUsageOfForeachStatements = Syntax + Internal + 592;
    /** @since 3.1 */
    int InvalidUsageOfTypeArguments = Syntax + Internal + 593;
    /** @since 3.1 */
    int InvalidUsageOfEnumDeclarations = Syntax + Internal + 594;
    /** @since 3.1 */
    int InvalidUsageOfVarargs = Syntax + Internal + 595;
    /** @since 3.1 */
    int InvalidUsageOfAnnotations = Syntax + Internal + 596;
    /** @since 3.1 */
    int InvalidUsageOfAnnotationDeclarations = Syntax + Internal + 597;
    /** @since 3.4 */
    int InvalidUsageOfTypeParametersForAnnotationDeclaration = Syntax + Internal + 598;
    /** @since 3.4 */
    int InvalidUsageOfTypeParametersForEnumDeclaration = Syntax + Internal + 599;
    /**
     * Annotation
     */
    /** @since 3.1 */
    int IllegalModifierForAnnotationMethod = MethodRelated + 600;
    /** @since 3.1 */
    int IllegalExtendedDimensions = MethodRelated + 601;
    /** @since 3.1 */
    int InvalidFileNameForPackageAnnotations = Syntax + Internal + 602;
    /** @since 3.1 */
    int IllegalModifierForAnnotationType = TypeRelated + 603;
    /** @since 3.1 */
    int IllegalModifierForAnnotationMemberType = TypeRelated + 604;
    /** @since 3.1 */
    int InvalidAnnotationMemberType = TypeRelated + 605;
    /** @since 3.1 */
    int AnnotationCircularitySelfReference = TypeRelated + 606;
    /** @since 3.1 */
    int AnnotationCircularity = TypeRelated + 607;
    /** @since 3.1 */
    int DuplicateAnnotation = TypeRelated + 608;
    /** @since 3.1 */
    int MissingValueForAnnotationMember = TypeRelated + 609;
    /** @since 3.1 */
    int DuplicateAnnotationMember = Internal + 610;
    /** @since 3.1 */
    int UndefinedAnnotationMember = MethodRelated + 611;
    /** @since 3.1 */
    int AnnotationValueMustBeClassLiteral = Internal + 612;
    /** @since 3.1 */
    int AnnotationValueMustBeConstant = Internal + 613;
    /** @deprecated - problem is no longer generated (code is legite)
     *   @since 3.1 */
    int AnnotationFieldNeedConstantInitialization = Internal + 614;
    /** @since 3.1 */
    int IllegalModifierForAnnotationField = Internal + 615;
    /** @since 3.1 */
    int AnnotationCannotOverrideMethod = MethodRelated + 616;
    /** @since 3.1 */
    int AnnotationMembersCannotHaveParameters = Syntax + Internal + 617;
    /** @since 3.1 */
    int AnnotationMembersCannotHaveTypeParameters = Syntax + Internal + 618;
    /** @since 3.1 */
    int AnnotationTypeDeclarationCannotHaveSuperclass = Syntax + Internal + 619;
    /** @since 3.1 */
    int AnnotationTypeDeclarationCannotHaveSuperinterfaces = Syntax + Internal + 620;
    /** @since 3.1 */
    int DuplicateTargetInTargetAnnotation = Internal + 621;
    /** @since 3.1 */
    int DisallowedTargetForAnnotation = TypeRelated + 622;
    /** @since 3.1 */
    int MethodMustOverride = MethodRelated + 623;
    /** @since 3.1 */
    int AnnotationTypeDeclarationCannotHaveConstructor = Syntax + Internal + 624;
    /** @since 3.1 */
    int AnnotationValueMustBeAnnotation = Internal + 625;
    /** @since 3.1 */
    int AnnotationTypeUsedAsSuperInterface = TypeRelated + 626;
    /** @since 3.1 */
    int MissingOverrideAnnotation = MethodRelated + 627;
    /** @since 3.1 */
    int FieldMissingDeprecatedAnnotation = Internal + 628;
    /** @since 3.1 */
    int MethodMissingDeprecatedAnnotation = Internal + 629;
    /** @since 3.1 */
    int TypeMissingDeprecatedAnnotation = Internal + 630;
    /** @since 3.1 */
    int UnhandledWarningToken = Internal + 631;
    /** @since 3.2 */
    int AnnotationValueMustBeArrayInitializer = Internal + 632;
    /** @since 3.3 */
    int AnnotationValueMustBeAnEnumConstant = Internal + 633;
    /** @since 3.3 */
    int MethodMustOverrideOrImplement = MethodRelated + 634;
    /** @since 3.4 */
    int UnusedWarningToken = Internal + 635;
    /** @since 3.6 */
    int MissingOverrideAnnotationForInterfaceMethodImplementation = MethodRelated + 636;
    /** @since 3.10 */
    int InvalidUsageOfTypeAnnotations = Syntax + Internal + 637;
    /** @since 3.10 */
    int DisallowedExplicitThisParameter = Syntax + Internal + 638;
    /** @since 3.10 */
    int MisplacedTypeAnnotations = Syntax + Internal + 639;
    /** @since 3.10 */
    int IllegalTypeAnnotationsInStaticMemberAccess = Internal + Syntax + 640;
    /** @since 3.10 */
    int IllegalUsageOfTypeAnnotations = Internal + Syntax + 641;
    /** @since 3.10 */
    int IllegalDeclarationOfThisParameter = Internal + Syntax + 642;
    /** @since 3.10 */
    int ExplicitThisParameterNotBelow18 = Internal + Syntax + 643;
    /** @since 3.10 */
    int DefaultMethodNotBelow18 = Internal + Syntax + 644;
    /** @since 3.10 */
    int LambdaExpressionNotBelow18 = Internal + Syntax + 645;
    /** @since 3.10 */
    int MethodReferenceNotBelow18 = Internal + Syntax + 646;
    /** @since 3.10 */
    int ConstructorReferenceNotBelow18 = Internal + Syntax + 647;
    /** @since 3.10 */
    int ExplicitThisParameterNotInLambda = Internal + Syntax + 648;
    /** @since 3.10 */
    int ExplicitAnnotationTargetRequired = TypeRelated + 649;
    /** @since 3.10 */
    int IllegalTypeForExplicitThis = Internal + Syntax + 650;
    /** @since 3.10 */
    int IllegalQualifierForExplicitThis = Internal + Syntax + 651;
    /** @since 3.10 */
    int IllegalQualifierForExplicitThis2 = Internal + Syntax + 652;
    /** @since 3.10 */
    int TargetTypeNotAFunctionalInterface = Internal + TypeRelated + 653;
    /** @since 3.10 */
    int IllegalVarargInLambda = Internal + TypeRelated + 654;
    /** @since 3.10 */
    int illFormedParameterizationOfFunctionalInterface = Internal + TypeRelated + 655;
    /** @since 3.10 */
    int lambdaSignatureMismatched = Internal + TypeRelated + 656;
    /** @since 3.10 */
    int lambdaParameterTypeMismatched = Internal + TypeRelated + 657;
    /** @since 3.10 */
    int IncompatibleLambdaParameterType = Internal + TypeRelated + 658;
    /** @since 3.10 */
    int NoGenericLambda = Internal + TypeRelated + 659;
    /**
     * More problems in generics
     */
    /** @since 3.4 */
    int UnusedTypeArgumentsForConstructorInvocation = MethodRelated + 660;
    /** @since 3.9 */
    int UnusedTypeParameter = TypeRelated + 661;
    /** @since 3.9 */
    int IllegalArrayOfUnionType = TypeRelated + 662;
    /** @since 3.10 */
    int OuterLocalMustBeEffectivelyFinal = Internal + 663;
    /** @since 3.10 */
    int InterfaceNotFunctionalInterface = Internal + TypeRelated + 664;
    /** @since 3.10 */
    int ConstructionTypeMismatch = Internal + TypeRelated + 665;
    /** @since 3.10 */
    int ToleratedMisplacedTypeAnnotations = Syntax + Internal + 666;
    /** @since 3.13*/
    int InterfaceSuperInvocationNotBelow18 = Internal + Syntax + 667;
    /** @since 3.13*/
    int InterfaceStaticMethodInvocationNotBelow18 = Internal + Syntax + 668;
    /** @since 3.14 */
    int FieldMustBeFinal = Internal + 669;


    /**
     * Null analysis for other kinds of expressions, syntactically nonnull
     */
    /** @since 3.9 */
    int NonNullExpressionComparisonYieldsFalse = Internal + 670;
    /** @since 3.9 */
    int RedundantNullCheckOnNonNullExpression = Internal + 671;
    /** @since 3.9 */
    int NullExpressionReference = Internal + 672;
    /** @since 3.9 */
    int PotentialNullExpressionReference = Internal + 673;

    /**
     * Corrupted binaries
     */
    /** @since 3.1 */
    int CorruptedSignature = Internal + 700;
    /**
     * Corrupted source
     */
    /** @since 3.2 */
    int InvalidEncoding = Internal + 701;
    /** @since 3.2 */
    int CannotReadSource = Internal + 702;

    /**
     * Autoboxing
     */
    /** @since 3.1 */
    int BoxingConversion = Internal + 720;
    /** @since 3.1 */
    int UnboxingConversion = Internal + 721;

    /**
     * Modifiers
     * @since 3.28
     */
    int StrictfpNotRequired = Syntax + Internal + 741;

    /**
     * Enum
     */
    /** @since 3.1 */
    int IllegalModifierForEnum = TypeRelated + 750;
    /** @since 3.1 */
    int IllegalModifierForEnumConstant = FieldRelated + 751;
    /** @deprecated - problem could not be reported, enums cannot be local takes precedence
     *   @since 3.1 */
    int IllegalModifierForLocalEnum = TypeRelated + 752;
    /** @since 3.1 */
    int IllegalModifierForMemberEnum = TypeRelated + 753;
    /** @since 3.1 */
    int CannotDeclareEnumSpecialMethod = MethodRelated + 754;
    /** @since 3.1 */
    int IllegalQualifiedEnumConstantLabel = FieldRelated + 755;
    /** @since 3.1 */
    int CannotExtendEnum = TypeRelated + 756;
    /** @since 3.1 */
    int CannotInvokeSuperConstructorInEnum = MethodRelated + 757;
    /** @since 3.1 */
    int EnumAbstractMethodMustBeImplemented = MethodRelated + 758;
    /** @since 3.1 */
    int EnumSwitchCannotTargetField = FieldRelated + 759;
    /** @since 3.1 */
    int IllegalModifierForEnumConstructor = MethodRelated + 760;
    /** @since 3.1 */
    int MissingEnumConstantCase = FieldRelated + 761;
    /** @since 3.2 */ // TODO need to fix 3.1.1 contribution (inline this constant on client side)
    int EnumStaticFieldInInInitializerContext = FieldRelated + 762;
    /** @since 3.4 */
    int EnumConstantMustImplementAbstractMethod = MethodRelated + 763;
    /** @since 3.5 */
    int EnumConstantCannotDefineAbstractMethod = MethodRelated + 764;
    /** @since 3.5 */
    int AbstractMethodInEnum = MethodRelated + 765;
    /** @since 3.8 */
    int MissingEnumDefaultCase = Internal + 766;
    /** @since 3.8 */
    int MissingDefaultCase = Internal + 767;
    /** @since 3.8 */
    int MissingEnumConstantCaseDespiteDefault = FieldRelated + 768;
    /** @since 3.8 */
    int UninitializedLocalVariableHintMissingDefault = Internal + 769;
    /** @since 3.8 */
    int UninitializedBlankFinalFieldHintMissingDefault = FieldRelated + 770;
    /** @since 3.8 */
    int ShouldReturnValueHintMissingDefault = MethodRelated + 771;

    /**
     * Var args
     */
    /** @since 3.1 */
    int IllegalExtendedDimensionsForVarArgs = Syntax + Internal + 800;
    /** @since 3.1 */
    int MethodVarargsArgumentNeedCast = MethodRelated + 801;
    /** @since 3.1 */
    int ConstructorVarargsArgumentNeedCast = ConstructorRelated + 802;
    /** @since 3.1 */
    int VarargsConflict = MethodRelated + 803;
    /** @since 3.7.1 */
    int SafeVarargsOnFixedArityMethod = MethodRelated + 804;
    /** @since 3.7.1 */
    int SafeVarargsOnNonFinalInstanceMethod = MethodRelated + 805;
    /** @since 3.7.1 */
    int PotentialHeapPollutionFromVararg = MethodRelated + 806;
    /** @since 3.8 */
    int VarargsElementTypeNotVisible = MethodRelated + 807;
    /** @since 3.8 */
    int VarargsElementTypeNotVisibleForConstructor = ConstructorRelated + 808;
    /** @since 3.10 */
    int ApplicableMethodOverriddenByInapplicable = MethodRelated + 809;

    /**
     * Javadoc Generic
     */
    /** @since 3.1 */
    int JavadocGenericMethodTypeArgumentMismatch = Javadoc + Internal + 850;
    /** @since 3.1 */
    int JavadocNonGenericMethod = Javadoc + Internal + 851;
    /** @since 3.1 */
    int JavadocIncorrectArityForParameterizedMethod = Javadoc + Internal + 852;
    /** @since 3.1 */
    int JavadocParameterizedMethodArgumentTypeMismatch = Javadoc + Internal + 853;
    /** @since 3.1 */
    int JavadocTypeArgumentsForRawGenericMethod = Javadoc + Internal + 854;
    /** @since 3.1 */
    int JavadocGenericConstructorTypeArgumentMismatch = Javadoc + Internal + 855;
    /** @since 3.1 */
    int JavadocNonGenericConstructor = Javadoc + Internal + 856;
    /** @since 3.1 */
    int JavadocIncorrectArityForParameterizedConstructor = Javadoc + Internal + 857;
    /** @since 3.1 */
    int JavadocParameterizedConstructorArgumentTypeMismatch = Javadoc + Internal + 858;
    /** @since 3.1 */
    int JavadocTypeArgumentsForRawGenericConstructor = Javadoc + Internal + 859;

    /**
     * Java 7 errors
     */
    /** @since 3.7.1 */
    int AssignmentToMultiCatchParameter = Internal + 870;
    /** @since 3.7.1 */
    int ResourceHasToImplementAutoCloseable = TypeRelated + 871;
    /** @since 3.7.1 */
    int AssignmentToResource = Internal + 872;
    /** @since 3.7.1 */
    int InvalidUnionTypeReferenceSequence = Internal + TypeRelated + 873;
    /** @since 3.7.1 */
    int AutoManagedResourceNotBelow17 = Syntax + Internal + 874;
    /** @since 3.7.1 */
    int MultiCatchNotBelow17 =  Syntax + Internal + 875;
    /** @since 3.7.1 */
    int PolymorphicMethodNotBelow17 = MethodRelated + 876;
    /** @since 3.7.1 */
    int IncorrectSwitchType17 = TypeRelated + 877;
    /** @since 3.7.1 */
    int CannotInferElidedTypes = TypeRelated + 878;
    /** @since 3.7.1 */
    int CannotUseDiamondWithExplicitTypeArguments = TypeRelated + 879;
    /** @since 3.7.1 */
    int CannotUseDiamondWithAnonymousClasses = TypeRelated + 880;
    /** @since 3.7.1 */
    int SwitchOnStringsNotBelow17 = TypeRelated + 881;	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=348492
    /** @since 3.7.1 */
    int UnhandledExceptionOnAutoClose =  TypeRelated + 882;
    /** @since 3.7.1 */
    int DiamondNotBelow17 =  TypeRelated + 883;
    /** @since 3.7.1 */
    int RedundantSpecificationOfTypeArguments = TypeRelated + 884;
    /** @since 3.8 */
    int PotentiallyUnclosedCloseable = Internal + 885;
    /** @since 3.8 */
    int PotentiallyUnclosedCloseableAtExit = Internal + 886;
    /** @since 3.8 */
    int UnclosedCloseable = Internal + 887;
    /** @since 3.8 */
    int UnclosedCloseableAtExit = Internal + 888;
    /** @since 3.8 */
    int ExplicitlyClosedAutoCloseable = Internal + 889;
    /** @since 3.8 */
    int SwitchOnEnumNotBelow15 = TypeRelated + 890;	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=360317
    /** @since 3.10 */
    int IntersectionCastNotBelow18 = TypeRelated + 891;
    /** @since 3.10 */
    int IllegalBasetypeInIntersectionCast = TypeRelated + 892;
    /** @since 3.10 */
    int IllegalArrayTypeInIntersectionCast = TypeRelated + 893;
    /** @since 3.10 */
    int DuplicateBoundInIntersectionCast = TypeRelated + 894;
    /** @deprecated This problem is no longer reported; number Of functional interface is not an issue, number of abstract methods is.
     * @since 3.10 */
    int MultipleFunctionalInterfaces = TypeRelated + 895;
    /** @since 3.10 */
    int StaticInterfaceMethodNotBelow18 = Internal + Syntax + 896;
    /** @since 3.10 */
    int DuplicateAnnotationNotMarkedRepeatable = TypeRelated + 897;
    /** @since 3.10 */
    int DisallowedTargetForContainerAnnotationType = TypeRelated + 898;
    /** @since 3.10 */
    int RepeatedAnnotationWithContainerAnnotation = TypeRelated + 899;

    /** @since 3.14 */
    int AutoManagedVariableResourceNotBelow9 = Syntax + Internal + 1351;
    /**
     * External problems -- These are problems defined by other plugins
     */

    /** @since 3.2 */
    int ExternalProblemNotFixable = 900;

    // indicates an externally defined problem that has a quick-assist processor
    // associated with it
    /** @since 3.2 */
    int ExternalProblemFixable = 901;

    /** @since 3.10 */
    int ContainerAnnotationTypeHasWrongValueType = TypeRelated + 902;
    /** @since 3.10 */
    int ContainerAnnotationTypeMustHaveValue = TypeRelated + 903;
    /** @since 3.10 */
    int ContainerAnnotationTypeHasNonDefaultMembers = TypeRelated + 904;
    /** @since 3.10 */
    int ContainerAnnotationTypeHasShorterRetention = TypeRelated + 905;
    /** @since 3.10 */
    int RepeatableAnnotationTypeTargetMismatch = TypeRelated + 906;
    /** @since 3.10 */
    int RepeatableAnnotationTypeIsDocumented = TypeRelated + 907;
    /** @since 3.10 */
    int RepeatableAnnotationTypeIsInherited = TypeRelated + 908;
    /** @since 3.10 */
    int RepeatableAnnotationWithRepeatingContainerAnnotation = TypeRelated + 909;

    /**
     * Errors/warnings from annotation based null analysis
     */
    /** @since 3.8 */
    int RequiredNonNullButProvidedNull = TypeRelated + 910;
    /** @since 3.8 */
    int RequiredNonNullButProvidedPotentialNull = TypeRelated + 911;
    /** @since 3.8 */
    int RequiredNonNullButProvidedUnknown = TypeRelated + 912;
    /** @since 3.8 */
    int MissingNonNullByDefaultAnnotationOnPackage = Internal + 913; // https://bugs.eclipse.org/bugs/show_bug.cgi?id=372012
    /** @since 3.8 */
    int IllegalReturnNullityRedefinition = MethodRelated + 914;
    /** @since 3.8 */
    int IllegalRedefinitionToNonNullParameter = MethodRelated + 915;
    /** @since 3.8 */
    int IllegalDefinitionToNonNullParameter = MethodRelated + 916;
    /** @since 3.8 */
    int ParameterLackingNonNullAnnotation = MethodRelated + 917;
    /** @since 3.8 */
    int ParameterLackingNullableAnnotation = MethodRelated + 918;
    /** @since 3.8 */
    int PotentialNullMessageSendReference = Internal + 919;
    /** @since 3.8 */
    int RedundantNullCheckOnNonNullMessageSend = Internal + 920;
    /** @since 3.8 */
    int CannotImplementIncompatibleNullness = Internal + 921;
    /** @since 3.8 */
    int RedundantNullAnnotation = MethodRelated + 922;
    /** @since 3.8 */
    int IllegalAnnotationForBaseType = TypeRelated + 923;
    /** @since 3.9 */
    int NullableFieldReference = FieldRelated + 924;
    /** @since 3.8 */
    int RedundantNullDefaultAnnotation = Internal + 925; // shouldn't actually occur any more after bug 366063
    /** @since 3.8 */
    int RedundantNullDefaultAnnotationPackage = Internal + 926;
    /** @since 3.8 */
    int RedundantNullDefaultAnnotationType = Internal + 927;
    /** @since 3.8 */
    int RedundantNullDefaultAnnotationMethod = Internal + 928;
    /** @since 3.8 */
    int ContradictoryNullAnnotations = Internal + 929;
    /** @since 3.8 */
    int MissingNonNullByDefaultAnnotationOnType = Internal + 930; // https://bugs.eclipse.org/bugs/show_bug.cgi?id=372012
    /** @since 3.8 */
    int RedundantNullCheckOnSpecdNonNullLocalVariable = Internal + 931;
    /** @since 3.8 */
    int SpecdNonNullLocalVariableComparisonYieldsFalse = Internal + 932;
    /** @since 3.8 */
    int RequiredNonNullButProvidedSpecdNullable = Internal + 933;
    /** @since 3.9 */
    int UninitializedNonNullField = FieldRelated + 934;
    /** @since 3.9 */
    int UninitializedNonNullFieldHintMissingDefault = FieldRelated + 935;
    /** @since 3.9 */
    int NonNullMessageSendComparisonYieldsFalse = Internal + 936;
    /** @since 3.9 */
    int RedundantNullCheckOnNonNullSpecdField = Internal + 937;
    /** @since 3.9 */
    int NonNullSpecdFieldComparisonYieldsFalse = Internal + 938;
    /** @since 3.9 */
    int ConflictingNullAnnotations = MethodRelated + 939;
    /** @since 3.9 */
    int ConflictingInheritedNullAnnotations = MethodRelated + 940;
    /** @since 3.10 */
    int RedundantNullCheckOnField = Internal + 941;
    /** @since 3.10 */
    int FieldComparisonYieldsFalse = Internal + 942;
    /** @since 3.14 */
    int RedundantNullDefaultAnnotationModule = Internal + 943;
    /** @since 3.19 */
    int RedundantNullCheckOnConstNonNullField = Internal + 944;
    /** @since 3.20 */
    int ConstNonNullFieldComparisonYieldsFalse = Internal + 945;
    /** @since 3.21 */
    int InheritedParameterLackingNonNullAnnotation = MethodRelated + 946;

    /** @since 3.10 */
    int ArrayReferencePotentialNullReference = Internal + 951;
    /** @since 3.10 */
    int DereferencingNullableExpression = Internal + 952;
    /** @since 3.10 */
    int NullityMismatchingTypeAnnotation = Internal + 953;
    /** @since 3.10 */
    int NullityMismatchingTypeAnnotationSuperHint = Internal + 954;
    /** @since 3.10 */
    int NullityUncheckedTypeAnnotationDetail = Internal + 955; // see also NullityUncheckedTypeAnnotation
    /** @since 3.10 */
    int NullityUncheckedTypeAnnotationDetailSuperHint = Internal + 956;
    /** @since 3.10 */
    int ReferenceExpressionParameterNullityMismatch = MethodRelated + 957;
    /** @since 3.10 */
    int ReferenceExpressionParameterNullityUnchecked = MethodRelated + 958;
    /** @since 3.10 */
    int ReferenceExpressionReturnNullRedef = MethodRelated + 959;
    /** @since 3.10 */
    int ReferenceExpressionReturnNullRedefUnchecked = MethodRelated + 960;
    /** @since 3.10 */
    int RedundantNullCheckAgainstNonNullType = Internal + 961;
    /** @since 3.10 */
    int NullAnnotationUnsupportedLocation = Internal + 962;
    /** @since 3.10 */
    int NullAnnotationUnsupportedLocationAtType = Internal + 963;
    /** @since 3.10 */
    int NullityMismatchTypeArgument = Internal + 964;
    /** @since 3.10 */
    int ContradictoryNullAnnotationsOnBound = Internal + 965;
    /** @since 3.10 */
    int ContradictoryNullAnnotationsInferred = Internal + 966;
    /** @since 3.10 */
    int UnsafeNullnessCast = Internal + 967;
    /** @since 3.10 */
    int NonNullDefaultDetailIsNotEvaluated = 968; // no longer reported
    /** @since 3.10 */
    int NullNotCompatibleToFreeTypeVariable = 969;
    /** @since 3.10 */
    int NullityMismatchAgainstFreeTypeVariable = 970;
    /** @since 3.11 */
    int ImplicitObjectBoundNoNullDefault = 971;
    /** @since 3.11 */
    int IllegalParameterNullityRedefinition = MethodRelated + 972;
    /** @since 3.11 */
    int ContradictoryNullAnnotationsInferredFunctionType = MethodRelated + 973;
    /** @since 3.11 */
    int IllegalReturnNullityRedefinitionFreeTypeVariable = MethodRelated + 974;
    /** @since 3.12 */
    int IllegalRedefinitionOfTypeVariable = 975;
    /** @since 3.12 */
    int UncheckedAccessOfValueOfFreeTypeVariable = 976;
    /** @since 3.12 */
    int UninitializedFreeTypeVariableField = 977;
    /** @since 3.12 */
    int UninitializedFreeTypeVariableFieldHintMissingDefault = 978;
    /** @since 3.12 */
    int RequiredNonNullButProvidedFreeTypeVariable = TypeRelated + 979;
    /** @since 3.12 */
    int NonNullTypeVariableFromLegacyMethod = TypeRelated + 980;
    /** @since 3.12 */
    int NonNullMethodTypeVariableFromLegacyMethod = TypeRelated + 981;
    /** @since 3.21 */
    int MissingNullAnnotationImplicitlyUsed = Internal + 982;
    /** @since 3.21 */
    int AnnotatedTypeArgumentToUnannotated = Internal + 983;
    /** @since 3.21 */
    int AnnotatedTypeArgumentToUnannotatedSuperHint = Internal + 984;
    /** @since 3.32 */
    int NonNullArrayContentNotInitialized = Internal + 985;
    /**
     * Both {@link #NullityUncheckedTypeAnnotationDetail} and {@link #NullityUncheckedTypeAnnotation}
     * signal that unchecked conversion is needed to pass a value between annotated and un-annotated code.
     * In the case of {@link #NullityUncheckedTypeAnnotationDetail} the mismatch was observed only on some
     * detail of the types involved (type arguments or array components), for which the UI does not (yet)
     * offer a quick fix, whereas {@link #NullityUncheckedTypeAnnotation} affects the toplevel type and thus
     * can be easily fixed by adding the appropriate null annotation.
     *
     * @since 3.36
     */
    int NullityUncheckedTypeAnnotation = Internal + 986;


    // Java 8 work
    /** @since 3.10 */
    int IllegalModifiersForElidedType = Internal + 1001;
    /** @since 3.10 */
    int IllegalModifiers = Internal + 1002;

    /** @since 3.10 */
    int IllegalTypeArgumentsInRawConstructorReference = TypeRelated + 1003;

    // more on lambdas:
    /** @since 3.18 */
    int MissingValueFromLambda = Internal + 1004;

    // default methods:
    /** @since 3.10 */
    int IllegalModifierForInterfaceMethod18 = MethodRelated + 1050;

    /** @since 3.10 */
    int DefaultMethodOverridesObjectMethod = MethodRelated + 1051;

    /** @since 3.10 */
    int InheritedDefaultMethodConflictsWithOtherInherited = MethodRelated + 1052;

    /** @since 3.10 */
    int DuplicateInheritedDefaultMethods = MethodRelated + 1053;

    /** @since 3.10 */
    int SuperAccessCannotBypassDirectSuper = TypeRelated + 1054;
    /** @since 3.10 */
    int SuperCallCannotBypassOverride = MethodRelated + 1055;
    /** @since 3.10 */
    int IllegalModifierCombinationForInterfaceMethod = MethodRelated + 1056;
    /** @since 3.10 */
    int IllegalStrictfpForAbstractInterfaceMethod = MethodRelated + 1057;
    /** @since 3.10 */
    int IllegalDefaultModifierSpecification = MethodRelated + 1058;
    /** @since 3.13 */
    int CannotInferInvocationType = TypeRelated + 1059;


    /** @since 3.13 */
    int TypeAnnotationAtQualifiedName = Internal + Syntax + 1060;

    /** @since 3.13 */
    int NullAnnotationAtQualifyingType = Internal + Syntax + 1061;

    /** @since 3.14*/
    int IllegalModifierForInterfaceMethod9 = MethodRelated + 1071;
    /** @since 3.14*/
    int IllegalModifierCombinationForPrivateInterfaceMethod9 = MethodRelated + 1070;
    /** @since 3.14 */
    int UndefinedModule = ModuleRelated + 1300;
    /** @since 3.14 */
    int DuplicateRequires = ModuleRelated + 1301;
    /** @since 3.14 */
    int DuplicateExports = ModuleRelated + 1302;
    /** @since 3.14 */
    int DuplicateUses = ModuleRelated + 1303;
    /** @since 3.14 */
    int DuplicateServices = ModuleRelated + 1304;
    /** @since 3.14 */
    int CyclicModuleDependency = ModuleRelated + 1305;
    /** @since 3.14 */
    int AbstractServiceImplementation = TypeRelated + 1306;
    /** @since 3.14 */
    int ProviderMethodOrConstructorRequiredForServiceImpl = TypeRelated + 1307;
    /** @since 3.14 */
    int ServiceImplDefaultConstructorNotPublic = TypeRelated + 1308;
    /** @since 3.14 */
    int NestedServiceImpl = TypeRelated + 1309;
    /** @since 3.14 */
    int ServiceImplNotDefinedByModule = TypeRelated + 1310;
    /** @since 3.14 */
    int PackageDoesNotExistOrIsEmpty = ModuleRelated + 1311;
    /** @since 3.14 */
    int NonDenotableTypeArgumentForAnonymousDiamond = TypeRelated + 1312;
    /** @since 3.14 */
    int DuplicateOpens = ModuleRelated + 1313;
    /** @since 3.14 */
    int DuplicateModuleRef = ModuleRelated + 1314;
    /** @since 3.14 */
    int InvalidOpensStatement = ModuleRelated + 1315;
    /** @since 3.14 */
    int InvalidServiceIntfType = ModuleRelated + 1316;
    /** @since 3.14 */
    int InvalidServiceImplType = ModuleRelated + 1317;
    /** @since 3.14 */
    int IllegalModifierForModule = ModuleRelated + 1318;
    /** @since 3.18 */
    int UndefinedModuleAddReads = ModuleRelated + 1319;
    /** @since 3.20 */
    int ExportingForeignPackage = ModuleRelated + 1320;


    /** @since 3.14 */
    int DuplicateResource = Internal + 1251;

    /** @since 3.37 */
    int ShouldMarkMethodAsOwning = Internal + 1260;
    /** @since 3.37 */
    int MandatoryCloseNotShown = Internal + 1261;
    /** @since 3.37 */
    int MandatoryCloseNotShownAtExit = Internal + 1262;
    /** @since 3.37 */
    int NotOwningResourceField = Internal + 1263;
    /** @since 3.37 */
    int OwningFieldInNonResourceClass = Internal + 1264;
    /** @since 3.37 */
    int OwningFieldShouldImplementClose = Internal + 1265;
    /** @since 3.37 */
    int OverrideReducingParamterOwning = Internal + 1266;
    /** @since 3.37 */
    int OverrideAddingReturnOwning = Internal + 1267;

    // terminally
    /** @since 3.14 */
    int UsingTerminallyDeprecatedType = TypeRelated + 1400;
    /** @since 3.14 */
    int UsingTerminallyDeprecatedMethod = MethodRelated + 1401;
    /** @since 3.14 */
    int UsingTerminallyDeprecatedConstructor = MethodRelated + 1402;
    /** @since 3.14 */
    int UsingTerminallyDeprecatedField = FieldRelated + 1403;
    /** @since 3.14 */
    int OverridingTerminallyDeprecatedMethod = MethodRelated + 1404;
    // with since
    /** @since 3.14 */
    int UsingDeprecatedSinceVersionType = TypeRelated + 1405;
    /** @since 3.14 */
    int UsingDeprecatedSinceVersionMethod = MethodRelated + 1406;
    /** @since 3.14 */
    int UsingDeprecatedSinceVersionConstructor = MethodRelated + 1407;
    /** @since 3.14 */
    int UsingDeprecatedSinceVersionField = FieldRelated + 1408;
    /** @since 3.14 */
    int OverridingDeprecatedSinceVersionMethod = MethodRelated + 1409;
    // terminally with since
    /** @since 3.14 */
    int UsingTerminallyDeprecatedSinceVersionType = TypeRelated + 1410;
    /** @since 3.14 */
    int UsingTerminallyDeprecatedSinceVersionMethod = MethodRelated + 1411;
    /** @since 3.14 */
    int UsingTerminallyDeprecatedSinceVersionConstructor = MethodRelated + 1412;
    /** @since 3.14 */
    int UsingTerminallyDeprecatedSinceVersionField = FieldRelated + 1413;
    /** @since 3.14 */
    int OverridingTerminallyDeprecatedSinceVersionMethod = MethodRelated + 1414;

    // unused constants:
    /** @since 3.14 */
    int UsingDeprecatedPackage = ModuleRelated + 1425;
    /** @since 3.14 */
    int UsingDeprecatedSinceVersionPackage = ModuleRelated + 1426;
    /** @since 3.14 */
    int UsingTerminallyDeprecatedPackage = ModuleRelated + 1427;
    /** @since 3.14 */
    int UsingTerminallyDeprecatedSinceVersionPackage = ModuleRelated + 1428;
    // deprecation of modules:
    /** @since 3.14 */
    int UsingDeprecatedModule = ModuleRelated + 1429;
    /** @since 3.14 */
    int UsingDeprecatedSinceVersionModule = ModuleRelated + 1430;
    /** @since 3.14 */
    int UsingTerminallyDeprecatedModule = ModuleRelated + 1431;
    /** @since 3.14 */
    int UsingTerminallyDeprecatedSinceVersionModule = ModuleRelated + 1432;

    /** @since 3.14 */
    int NotAccessibleType = TypeRelated + 1450;
    /** @since 3.14 */
    int NotAccessibleField = FieldRelated + 1451;
    /** @since 3.14 */
    int NotAccessibleMethod = MethodRelated + 1452;
    /** @since 3.14 */
    int NotAccessibleConstructor = MethodRelated + 1453;
    /** @since 3.14 */
    int NotAccessiblePackage = ImportRelated + 1454;
    /** @since 3.14 */
    int ConflictingPackageFromModules = ModuleRelated + 1455;
    /** @since 3.14 */
    int ConflictingPackageFromOtherModules = ModuleRelated + 1456;
    /** @since 3.14 */
    int NonPublicTypeInAPI = ModuleRelated + 1457;
    /** @since 3.14 */
    int NotExportedTypeInAPI = ModuleRelated + 1458;
    /** @since 3.14 */
    int MissingRequiresTransitiveForTypeInAPI = ModuleRelated + 1459;
    /** @since  3.14 */
    int UnnamedPackageInNamedModule = ModuleRelated + 1460;
    /** @since  3.14 */
    int UnstableAutoModuleName = ModuleRelated + 1461;
    /** @since  3.24 */
    int ConflictingPackageInModules = ModuleRelated + 1462;

    // doc variant of an above constant:
    /** @since 3.22 */
    int JavadocNotAccessibleType = Javadoc + NotAccessibleType;

    /** @since 3.13 */
    int RedundantNullDefaultAnnotationLocal = Internal + 1062;

    /** @since 3.13 */
    int RedundantNullDefaultAnnotationField = Internal + 1063;

    /** @since 3.10 */
    int GenericInferenceError = 1100; 	// FIXME: This is just a stop-gap measure, be more specific via https://bugs.eclipse.org/404675

    /** @deprecated - problem is no longer generated (implementation issue has been resolved)
     * @since 3.10 */
    int LambdaShapeComputationError = 1101;
    /** @since 3.13 */
    int ProblemNotAnalysed = 1102;
    /** @since 3.18 */
    int PreviewFeatureDisabled = Compliance + 1103;
    /** @since 3.18 */
    int PreviewFeatureUsed = Compliance + 1104;
    /** @since 3.18 */
    int PreviewFeatureNotSupported = Compliance + 1105;
    /** @since 3.20*/
    int PreviewFeaturesNotAllowed = PreviewRelated + 1106;
    /** @since 3.24*/
    int FeatureNotSupported = Compliance + 1107;
    /** @since 3.26*/
    int PreviewAPIUsed = Compliance + 1108;

    /** @since 3.13 */
    int UnlikelyCollectionMethodArgumentType = 1200;
    /** @since 3.13 */
    int UnlikelyEqualsArgumentType = 1201;

    /* Local-Variable Type Inference */
    /** @since 3.14 */
    int VarLocalMultipleDeclarators = Syntax + 1500; // ''var'' is not allowed in a compound declaration
    /** @since 3.14 */
    int VarLocalCannotBeArray = Syntax + 1501; // ''var'' is not allowed as an element type of an array
    /** @since 3.14 */
    int VarLocalReferencesItself = Syntax + 1502; // Declaration using ''var'' may not contin references to itself
    /** @since 3.14 */
    int VarLocalWithoutInitizalier = Syntax + 1503; // Cannot use ''var'' on variable without initializer
    /** @since 3.14 */
    int VarLocalInitializedToNull = TypeRelated + 1504; // Variable initialized to ''null'' needs an explicit target-type
    /** @since 3.14 */
    int VarLocalInitializedToVoid = TypeRelated + 1505; // Variable initializer is ''void'' -- cannot infer variable type
    /** @since 3.14 */
    int VarLocalCannotBeArrayInitalizers = TypeRelated + 1506; // Array initializer needs an explicit target-type
    /** @since 3.14 */
    int VarLocalCannotBeLambda = TypeRelated + 1507; // Lambda expression needs an explicit target-type
    /** @since 3.14 */
    int VarLocalCannotBeMethodReference = TypeRelated + 1508; // Method reference needs an explicit target-type
    /** @since 3.14 */
    int VarIsReserved = Syntax + 1509; // ''var'' is not a valid type name
    /** @since 3.14 */
    int VarIsReservedInFuture = Syntax + 1510; // ''var'' should not be used as an type name, since it is a reserved word from source level 10 on
    /** @since 3.14 */
    int VarIsNotAllowedHere = Syntax + 1511; // ''var'' is not allowed here
    /** @since 3.16 */
    int VarCannotBeMixedWithNonVarParams = Syntax + 1512; // ''var'' cannot be mixed with explicit or implicit parameters
    /** @since 3.35 */
    int VarCannotBeUsedWithTypeArguments = Syntax + 1513; // ''var'' cannot be used with type arguments (e.g. as in ''var<Integer> x = List.of(42)'')

    /** @since 3.18
     * @deprecated preview related error - will be removed
     * @noreference preview related error */
    int SwitchExpressionsIncompatibleResultExpressionTypes = TypeRelated + 1600;
    /** @since 3.18
     * @deprecated preview related error - will be removed
     * @noreference preview related error */
    int SwitchExpressionsEmptySwitchBlock = Internal + 1601;
    /** @since 3.18
     * @deprecated preview related error - will be removed
     * @noreference preview related error */
    int SwitchExpressionsNoResultExpression = TypeRelated + 1602;
    /** @since 3.18
     * @deprecated preview related error - will be removed
     * @noreference preview related error */
    int SwitchExpressionSwitchLabeledBlockCompletesNormally = Internal + 1603;
    /** @since 3.18
     * @deprecated preview related error - will be removed
     * @noreference preview related error */
    int SwitchExpressionLastStatementCompletesNormally = Internal + 1604;
    /** @since 3.18
     * @deprecated preview related error - will be removed
     * @noreference preview related error */
    int SwitchExpressionTrailingSwitchLabels = Internal + 1605;
    /** @since 3.18
     * @deprecated preview related error - will be removed
     * @noreference preview related error */
    int switchMixedCase = Syntax + 1606;
    /** @since 3.18
     * @deprecated preview related error - will be removed
     * @noreference preview related error */
    int SwitchExpressionMissingDefaultCase = Internal + 1607;
    /** @since 3.18
     * @deprecated preview related error - will be removed
     * @noreference preview related error */
    int SwitchExpressionBreakMissingValue = Internal + 1610;
    /** @since 3.18
     * @deprecated preview related error - will be removed
     * @noreference preview related error */
    int SwitchExpressionMissingEnumConstantCase = Internal + 1611;
    /** @since 3.18
     * @deprecated preview related error - will be removed
     * @noreference preview related error */
    int SwitchExpressionIllegalLastStatement = Internal + 1612;

    /* Java14 errors - begin */
    /** @since 3.21  */
    int SwitchExpressionsYieldIncompatibleResultExpressionTypes = TypeRelated + 1700;
    /** @since 3.21  */
    int SwitchExpressionsYieldEmptySwitchBlock = Syntax + 1701;
    /** @since 3.21  */
    int SwitchExpressionsYieldNoResultExpression = Internal + 1702;
    /** @since 3.21  */
    int SwitchExpressionaYieldSwitchLabeledBlockCompletesNormally = Internal + 1703;
    /** @since 3.21  */
    int SwitchExpressionsYieldLastStatementCompletesNormally = Internal + 1704;
    /** @since 3.21  */
    int SwitchExpressionsYieldTrailingSwitchLabels = Internal + 1705;
    /** @since 3.21  */
    int SwitchPreviewMixedCase = Syntax + 1706;
    /** @since 3.21  */
    int SwitchExpressionsYieldMissingDefaultCase = Syntax + 1707;
    /** @since 3.21  */
    int SwitchExpressionsYieldMissingValue = Syntax + 1708;
    /** @since 3.21  */
    int SwitchExpressionsYieldMissingEnumConstantCase = Syntax + 1709;
    /** @since 3.21  */
    int SwitchExpressionsYieldIllegalLastStatement = Internal + 1710;
    /** @since 3.21  */
    int SwitchExpressionsYieldBreakNotAllowed = Syntax + 1711;
    /** @since 3.21  */
    int SwitchExpressionsYieldUnqualifiedMethodWarning = Syntax + 1712;
    /** @since 3.21  */
    int SwitchExpressionsYieldUnqualifiedMethodError = Syntax + 1713;
    /** @since 3.21  */
    int SwitchExpressionsYieldOutsideSwitchExpression = Syntax + 1714;
    /** @since 3.21  */
    int SwitchExpressionsYieldRestrictedGeneralWarning = Internal + 1715;
    /** @since 3.21  */
    int SwitchExpressionsYieldIllegalStatement = Internal + 1716;
    /** @since 3.21  */
    int SwitchExpressionsYieldTypeDeclarationWarning = Internal + 1717;
    /** @since 3.21  */
    int SwitchExpressionsYieldTypeDeclarationError = Internal + 1718;
    /** @since 3.22 */
    int MultiConstantCaseLabelsNotSupported = Syntax + 1719;
    /** @since 3.22*/
    int ArrowInCaseStatementsNotSupported = Syntax + 1720;
    /** @since 3.22 */
    int SwitchExpressionsNotSupported = Syntax + 1721;
    /** @since 3.22 */
    int SwitchExpressionsBreakOutOfSwitchExpression  = Syntax + 1722;
    /** @since 3.22 */
    int SwitchExpressionsContinueOutOfSwitchExpression  = Syntax + 1723;
    /** @since 3.22 */
    int SwitchExpressionsReturnWithinSwitchExpression  = Syntax + 1724;

    /* Java 14 errors end */
    /* Java 15 errors begin */
    /* records - begin */

    /** @since 3.26 */
    int RecordIllegalModifierForInnerRecord = TypeRelated + 1730;
    /** @since 3.26 */
    int RecordIllegalModifierForRecord = TypeRelated + 1731;
    /** @since 3.26
     * JLS 14 Sec 8.10.1
     * it is always a compile-time error for a record header to declare a record component with the name
     * finalize, getClass, hashCode, notify, notifyAll, or toString. */
    int RecordIllegalComponentNameInRecord = TypeRelated + 1732;
    /** @since 3.26
     */
    int RecordNonStaticFieldDeclarationInRecord = TypeRelated + 1733;
    /** @since 3.26
     */
    int RecordAccessorMethodHasThrowsClause = TypeRelated + 1734;
    /** @since 3.26
     */
    int RecordCanonicalConstructorHasThrowsClause = TypeRelated + 1735;
    /** @since 3.26
     */
    int RecordCanonicalConstructorVisibilityReduced = TypeRelated + 1736;
    /** @since 3.26
     */
    int RecordMultipleCanonicalConstructors = TypeRelated + 1737;
    /** @since 3.26
     */
    int RecordCompactConstructorHasReturnStatement = TypeRelated + 1738;
    /** @since 3.26
     */
    int RecordDuplicateComponent = TypeRelated + 1739;
    /** @since 3.26
     */
    int RecordIllegalNativeModifierInRecord = TypeRelated + 1740;
    /** @since 3.26
     */
    int RecordInstanceInitializerBlockInRecord = TypeRelated + 1741;
    /** @since 3.26
     */
    int RestrictedTypeName = TypeRelated + 1742;
    /** @since 3.26
     */
    int RecordIllegalAccessorReturnType = TypeRelated + 1743;
    /** @since 3.26
     */
    int RecordAccessorMethodShouldNotBeGeneric = TypeRelated + 1744;
    /** @since 3.26
     */
    int RecordAccessorMethodShouldBePublic = TypeRelated + 1745;
    /** @since 3.26
     */
    int RecordCanonicalConstructorShouldNotBeGeneric = TypeRelated + 1746;
    /** @since 3.26
     */
    int RecordCanonicalConstructorHasReturnStatement = TypeRelated + 1747;
    /** @since 3.26
     */
    int RecordCanonicalConstructorHasExplicitConstructorCall = TypeRelated + 1748;
    /** @since 3.26
     */
    int RecordCompactConstructorHasExplicitConstructorCall = TypeRelated + 1749;
    /** @since 3.26
     */
    int RecordNestedRecordInherentlyStatic = TypeRelated + 1750;
    /** @since 3.26
     */
    int RecordAccessorMethodShouldNotBeStatic= TypeRelated + 1751;
    /** @since 3.26
     */
    int RecordCannotExtendRecord= TypeRelated + 1752;
    /** @since 3.26
     */
    int RecordComponentCannotBeVoid= TypeRelated + 1753;
    /** @since 3.26
     */
    int RecordIllegalVararg= TypeRelated + 1754;
    /** @since 3.26
     */
    int RecordStaticReferenceToOuterLocalVariable= TypeRelated + 1755;
    /** @since 3.26
     */
    int RecordCannotDefineRecordInLocalType= TypeRelated + 1756;
    /** @since 3.26
     */
    int RecordComponentsCannotHaveModifiers= TypeRelated + 1757;
    /** @since 3.26
     */
    int RecordIllegalParameterNameInCanonicalConstructor = TypeRelated + 1758;
    /** @since 3.26
     */
    int RecordIllegalExplicitFinalFieldAssignInCompactConstructor = TypeRelated + 1759;
    /** @since 3.26
     */
    int RecordMissingExplicitConstructorCallInNonCanonicalConstructor= TypeRelated + 1760;
    /** @since 3.26
     */
    int RecordIllegalStaticModifierForLocalClassOrInterface = TypeRelated + 1761;
    /** @since 3.26
     */
    int RecordIllegalModifierForLocalRecord = TypeRelated + 1762;
    /** @since 3.26
     */
    int RecordIllegalExtendedDimensionsForRecordComponent = Syntax + Internal + 1763;
    /** @since 3.26
     */
    int SafeVarargsOnSyntheticRecordAccessor = TypeRelated + 1764;


    /* records - end */
    /* Local and Nested Static Declarations - Begin */
    /** @since 3.28 */
    int LocalStaticsIllegalVisibilityModifierForInterfaceLocalType = TypeRelated + 1765;
    /** @since 3.28 */
    int IllegalModifierForLocalEnumDeclaration = TypeRelated + 1766;
    /** @since 3.28 */
    int ClassExtendFinalRecord = TypeRelated + 1767;
    /** @since 3.29 */
    int RecordErasureIncompatibilityInCanonicalConstructor = TypeRelated + 1768;
    /* records - end */


    /* instanceof pattern: */
    /** @since 3.22
     * @deprecated problem no longer generated */
    int PatternVariableNotInScope = PreviewRelated + 1780;
    /** @since 3.26
     */
    int PatternVariableRedefined = Internal + 1781;
    /** @since 3.26
     * @deprecated
     */
    int PatternSubtypeOfExpression = Internal + 1782;
    /** @since 3.26
     */
    int IllegalModifierForPatternVariable = Internal + 1783;
    /** @since 3.26
     */
    int PatternVariableRedeclared = Internal + 1784;

    /** @since 3.28
     */
    int DiscouragedValueBasedTypeSynchronization = Internal + 1820;

    /** @since 3.28 */
    int SealedMissingClassModifier = TypeRelated + 1850;
    /** @since 3.28 */
    int SealedDisAllowedNonSealedModifierInClass = TypeRelated + 1851;
    /** @since 3.28 */
    int SealedSuperClassDoesNotPermit = TypeRelated + 1852;
    /** @since 3.28 */
    int SealedSuperInterfaceDoesNotPermit = TypeRelated + 1853;
    /** @since 3.28 */
    int SealedMissingSealedModifier = TypeRelated + 1854;
    /** @since 3.28 */
    int SealedMissingInterfaceModifier = TypeRelated + 1855;
    /** @since 3.28 */
    int SealedDuplicateTypeInPermits = TypeRelated + 1856;
    /** @since 3.28 */
    int SealedNotDirectSuperClass = TypeRelated + 1857;
    /** @since 3.28 */
    int SealedPermittedTypeOutsideOfModule = TypeRelated + 1858;
    /** @since 3.28 */
    int SealedPermittedTypeOutsideOfPackage = TypeRelated + 1859;
    /** @since 3.28 */
    int SealedSealedTypeMissingPermits = TypeRelated + 1860;
    /** @since 3.28 */
    int SealedInterfaceIsSealedAndNonSealed = TypeRelated + 1861;
    /** @since 3.28 */
    int SealedDisAllowedNonSealedModifierInInterface = TypeRelated + 1862;
    /** @since 3.28 */
    int SealedNotDirectSuperInterface = TypeRelated + 1863;
    /** @since 3.28 */
    int SealedLocalDirectSuperTypeSealed = TypeRelated + 1864;
    /** @since 3.28 */
    int SealedAnonymousClassCannotExtendSealedType = TypeRelated + 1865;
    /** @since 3.28 */
    int SealedSuperTypeInDifferentPackage = TypeRelated + 1866;
    /** @since 3.28 */
    int SealedSuperTypeDisallowed = TypeRelated + 1867;
    /* Java15 errors - end */

    /**
     * @since 3.28
     * @noreference preview feature error
     */
    int LocalReferencedInGuardMustBeEffectivelyFinal = PreviewRelated + 1900;
    /** @since 3.28
     * @noreference preview feature error */
    int ConstantWithPatternIncompatible = PreviewRelated + 1901;
    /**
     * @since 3.28
     * @noreference preview feature error
     */
    int IllegalFallthroughToPattern = PreviewRelated + 1902;

    /** @since 3.28
     * @noreference preview feature error */
    int PatternDominated = PreviewRelated + 1906;
    /** @since 3.28
     * @noreference preview feature error */
    int IllegalTotalPatternWithDefault = PreviewRelated + 1907;
    /** @since 3.28
     * @noreference preview feature error */
    int EnhancedSwitchMissingDefault = PreviewRelated + 1908;
    /** @since 3.28
     * @noreference preview feature error */
    int DuplicateTotalPattern = PreviewRelated + 1909;

    /** @since 3.34
     * @noreference preview feature error */
    int PatternSwitchNullOnlyOrFirstWithDefault = PreviewRelated + 1920;

    /** @since 3.34
     * @noreference preview feature error */
    int PatternSwitchCaseDefaultOnlyAsSecond = PreviewRelated + 1921;

    /**
     * @since 3.34
     * @noreference preview feature error
     */
    int IllegalFallthroughFromAPattern = PreviewRelated + 1922;

    /** @since 3.28
     * @noreference preview feature error */
    int UnnecessaryNullCaseInSwitchOverNonNull = PreviewRelated + 1910;
    /** @since 3.28
     * @noreference preview feature error */
    int UnexpectedTypeinSwitchPattern = PreviewRelated + 1911;
    /**
     * @since 3.32
     * @noreference preview feature
     */
    int UnexpectedTypeinRecordPattern =  PreviewRelated + 1912;
    /**
     * @since 3.32
     * @noreference preview feature
     */
    int RecordPatternMismatch =  PreviewRelated + 1913;
    /**
     * @since 3.32
     * @noreference preview feature
     */
    int PatternTypeMismatch =  PreviewRelated + 1914;
    /**
     * @since 3.32
     * @noreference preview feature
     * @deprecated
     */
    int RawTypeInRecordPattern =  PreviewRelated + 1915;
    /**
     * @since 3.36
     * @noreference preview feature
     */
    int FalseConstantInGuard =  PreviewRelated + 1916;
    /**
     * @since 3.34
     * @noreference preview feature
     */
    int CannotInferRecordPatternTypes = PreviewRelated + 1940;

    /**
     * @since 3.36
     */
    int IllegalRecordPattern = TypeRelated + 1941;


    /**
     * @since 3.35
     */
    int SyntheticAccessorNotEnclosingMethod = MethodRelated + 1990;

    /**
     * @since 3.37
     * @noreference preview feature
     */
    int UnderscoreCannotBeUsedHere = PreviewRelated + 2000;
    /**
     * @since 3.37
     * @noreference preview feature
     */
    int UnnamedVariableMustHaveInitializer = PreviewRelated + 2001;
}


=================================================================================
FILE: main/java/com/botmaker/lsp/JdtLanguageServerLauncher.java
=================================================================================

package com.botmaker.lsp;

import org.eclipse.jdt.core.compiler.IProblem;
import org.eclipse.jdt.internal.compiler.IProblemFactory;
import org.eclipse.jdt.internal.compiler.lookup.ProblemReasons;
import org.eclipse.jdt.internal.compiler.problem.ProblemHandler;
import org.eclipse.jdt.internal.compiler.problem.ProblemReporter;
import org.eclipse.jdt.internal.core.builder.ProblemFactory;
import org.eclipse.lsp4j.*;
import org.eclipse.lsp4j.jsonrpc.Launcher;
import org.eclipse.lsp4j.launch.LSPLauncher;
import org.eclipse.lsp4j.services.LanguageClient;
import org.eclipse.lsp4j.services.LanguageServer;

import java.io.*;
import java.nio.file.*;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.function.Consumer;
import java.util.logging.Level;
import java.util.logging.Logger;

public class JdtLanguageServerLauncher {

    private final Process process;
    private final LanguageServer server;

    public JdtLanguageServerLauncher(Path jdtlsPath, Consumer<PublishDiagnosticsParams> diagnosticsConsumer) throws Exception {
        // Suppress LSP4J warnings about unsupported notifications
        Logger.getLogger("org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint").setLevel(Level.SEVERE);

        // Find the Equinox launcher JAR
        Path launcherJar = Files.list(jdtlsPath.resolve("plugins"))
                .filter(p -> p.getFileName().toString().startsWith("org.eclipse.equinox.launcher_"))
                .findFirst()
                .orElseThrow(() -> new RuntimeException("Launcher JAR not found"));

        String javaExecutable = Paths.get(System.getProperty("java.home"), "bin", "java").toString();
        Path projectDir = Paths.get("./projects");

        // Create a dedicated workspace data directory (not the project itself!)
        Path workspaceData = Paths.get(System.getProperty("user.home"), ".jdtls-workspace", "Demo");
        Files.createDirectories(workspaceData);

        // Build command with all necessary flags from VS Code implementation
        ProcessBuilder pb = new ProcessBuilder(
                javaExecutable,
                // Java 25 specific flags
                "-Djdk.xml.maxGeneralEntitySizeLimit=0",
                "-Djdk.xml.totalEntitySizeLimit=0",
                // Module system flags
                "--add-modules=ALL-SYSTEM",
                "--add-opens", "java.base/java.util=ALL-UNNAMED",
                "--add-opens", "java.base/java.lang=ALL-UNNAMED",
                "--add-opens", "java.base/sun.nio.fs=ALL-UNNAMED",
                // Eclipse/JDT configuration
                "-Declipse.application=org.eclipse.jdt.ls.core.id1",
                "-Dosgi.bundles.defaultStartLevel=4",
                "-Declipse.product=org.eclipse.jdt.ls.core.product",
                // Important: Disable automatic VM detection
                "-DDetectVMInstallationsJob.disabled=true",
                // Encoding
                "-Dfile.encoding=UTF-8",
                // Disable verbose logging
                "-Xlog:disable",
                // Memory settings
                "-Xmx1G",
                // Dependency collector (improves Maven/Gradle performance)
                "-Daether.dependencyCollector.impl=bf",
                // Suppress JavaFX warnings about restricted methods
                "--enable-native-access=javafx.graphics",
                // Logging (remove these for production, useful for debugging)
                "-Dlog.protocol=true",
                "-Dlog.level=ALL",
                // Launcher JAR
                "-jar", launcherJar.toString(),
                // Configuration directory
                "-configuration", jdtlsPath.resolve("config_linux").toString(),
                // Workspace data directory (NOT your project directory!)
                "-data", workspaceData.toString()
        );

        process = pb.start();

        // Log the error stream separately to see any server-side issues.
        new Thread(() -> {
            try (BufferedReader br = new BufferedReader(new InputStreamReader(process.getErrorStream()))) {
                String line;
                while ((line = br.readLine()) != null) {
                    System.err.println("[JDT LS ERR] " + line);
                }
            } catch (IOException ignored) {}
        }).start();

        // Connect LSP4J client to the process
        Launcher<LanguageServer> launcher = LSPLauncher.createClientLauncher(
                new SimpleLanguageClient(diagnosticsConsumer),
                process.getInputStream(),
                process.getOutputStream()
        );

        launcher.startListening();
        server = launcher.getRemoteProxy();

        // Initialize LSP params
        InitializeParams init = new InitializeParams();
        init.setProcessId((int) ProcessHandle.current().pid());

        // Set up client capabilities
        ClientCapabilities capabilities = new ClientCapabilities();
        WorkspaceClientCapabilities workspaceCaps = new WorkspaceClientCapabilities();
        workspaceCaps.setDidChangeConfiguration(new DidChangeConfigurationCapabilities(true));
        workspaceCaps.setWorkspaceFolders(true);
        capabilities.setWorkspace(workspaceCaps);

        TextDocumentClientCapabilities textDocCaps = new TextDocumentClientCapabilities();
        capabilities.setTextDocument(textDocCaps);

        init.setCapabilities(capabilities);

        // Add workspace folder - this should point to your actual project
        WorkspaceFolder folder = new WorkspaceFolder(projectDir.toUri().toString());
        init.setWorkspaceFolders(List.of(folder));
        init.setRootUri(folder.getUri());

        System.out.println("Workspace root: " + folder.getUri());
        System.out.println("Workspace data: " + workspaceData);

        // Initialize the server
        InitializeResult result = server.initialize(init).get();
        System.out.println("Server initialized: " + result.getCapabilities());

        // Send initialized notification
        server.initialized(new InitializedParams());
    }

    public LanguageServer getServer() {
        return server;
    }

    public void stop() {
        try { server.shutdown().get(); } catch (Exception ignored) {}
        server.exit();
        process.destroy();
    }

    // Minimal LSP client
    static class SimpleLanguageClient implements LanguageClient {
        private final Consumer<PublishDiagnosticsParams> diagnosticsConsumer;

        public SimpleLanguageClient(Consumer<PublishDiagnosticsParams> diagnosticsConsumer) {
            this.diagnosticsConsumer = diagnosticsConsumer;
        }

        @Override
        public void telemetryEvent(Object o) {
            System.out.println("[Telemetry] " + o);
        }

        @Override
        public void publishDiagnostics(PublishDiagnosticsParams diagnostics) {
            System.out.println("[Diagnostics] " + diagnostics.getUri() + " -> " + diagnostics.getDiagnostics().size() + " issues");
            if (diagnosticsConsumer != null) {
                diagnosticsConsumer.accept(diagnostics);
            }
        }

        @Override
        public void showMessage(MessageParams messageParams) {
            System.out.println("[Message] " + messageParams.getMessage());
        }

        @Override
        public CompletableFuture<MessageActionItem> showMessageRequest(ShowMessageRequestParams showMessageRequestParams) {
            System.out.println("[MessageRequest] " + showMessageRequestParams.getMessage());
            return CompletableFuture.completedFuture(null);
        }

        @Override
        public void logMessage(MessageParams messageParams) {
            System.out.println("[Log] " + messageParams.getMessage());
        }

        @Override
        public CompletableFuture<Void> registerCapability(RegistrationParams params) {
            System.out.println("[RegisterCapability] " + params.getRegistrations().size() + " capabilities");
            return CompletableFuture.completedFuture(null);
        }

        @Override
        public CompletableFuture<Void> unregisterCapability(UnregistrationParams params) {
            System.out.println("[UnregisterCapability] " + params.getUnregisterations().size() + " capabilities");
            return CompletableFuture.completedFuture(null);
        }
    }
}


=================================================================================
FILE: main/java/com/botmaker/lsp/ProblemReasons.java
=================================================================================

package com.botmaker.lsp;

public interface ProblemReasons {
    final int NoError = 0;
    final int NotFound = 1;
    final int NotVisible = 2;
    final int Ambiguous = 3;
    final int InternalNameProvided = 4; // used if an internal name is used in source
    final int InheritedNameHidesEnclosingName = 5;
    final int NonStaticReferenceInConstructorInvocation = 6;
    final int NonStaticReferenceInStaticContext = 7;
    final int ReceiverTypeNotVisible = 8;
    final int IllegalSuperTypeVariable = 9;
    final int ParameterBoundMismatch = 10; // for generic method
    final int TypeParameterArityMismatch = 11; // for generic method
    final int ParameterizedMethodTypeMismatch = 12; // for generic method
    final int TypeArgumentsForRawGenericMethod = 13; // for generic method
    final int InvalidTypeForStaticImport = 14;
    final int InvalidTypeForAutoManagedResource = 15;
    final int VarargsElementTypeNotVisible = 16;
    final int NoSuchSingleAbstractMethod = 17;
    final int NotAWellFormedParameterizedType = 18;
    // no longer in use: final int IntersectionHasMultipleFunctionalInterfaces = 19;
    final int NonStaticOrAlienTypeReceiver = 20;
    final int AttemptToBypassDirectSuper = 21; // super access within default method
    final int DefectiveContainerAnnotationType = 22;
    final int InvocationTypeInferenceFailure = 23;
    final int ApplicableMethodOverriddenByInapplicable = 24;
    final int ContradictoryNullAnnotations = 25;
    final int NoSuchMethodOnArray = 26;
    final int InferredApplicableMethodInapplicable = 27; // 18.5.1 ignores arguments not pertinent to applicability. When these are taken into consideration method could fail applicability
    final int NoProperEnclosingInstance = 28;
    final int InterfaceMethodInvocationNotBelow18 = 29;
    final int NotAccessible = 30; // JLS 6.6.1 - module aspects
    final int ErrorAlreadyReported = 31;
}

=================================================================================
FILE: main/java/com/botmaker/Main.java
=================================================================================

package com.botmaker;

import com.botmaker.blocks.MainBlock;
import com.botmaker.core.BodyBlock;
import com.botmaker.core.CodeBlock;
import com.botmaker.lsp.CompletionContext;
import com.botmaker.lsp.JdtLanguageServerLauncher;
import com.botmaker.parser.AstRewriter;
import com.botmaker.parser.BlockFactory;
import com.botmaker.parser.CodeEditor;
import com.botmaker.runtime.CodeExecutionService;
import com.botmaker.runtime.DebuggingManager;
import com.botmaker.ui.BlockDragAndDropManager;
import com.botmaker.ui.UIManager;
import javafx.application.Application;
import javafx.application.Platform;
import javafx.stage.Stage;
import org.eclipse.jdt.core.dom.ASTNode;
import org.eclipse.lsp4j.DidChangeTextDocumentParams;
import org.eclipse.lsp4j.DidOpenTextDocumentParams;
import org.eclipse.lsp4j.TextDocumentContentChangeEvent;
import org.eclipse.lsp4j.TextDocumentItem;
import org.eclipse.lsp4j.VersionedTextDocumentIdentifier;
import org.eclipse.lsp4j.services.LanguageServer;

import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class Main extends Application {

    private LanguageServer jdtServer;
    private final BlockFactory factory = new BlockFactory();
    private String docUri;
    private String currentCode;
    private long docVersion = 1;

    private Map<ASTNode, CodeBlock> nodeToBlockMap;
    private CodeBlock highlightedBlock;

    private UIManager uiManager;
    private CodeExecutionService executionService;
    private DebuggingManager debuggingManager;
    private BlockDragAndDropManager dragAndDropManager;
    private AstRewriter astRewriter;
    private CodeEditor codeEditor;
    private com.botmaker.validation.DiagnosticsManager diagnosticsManager;

    @Override
    public void start(Stage primaryStage) throws Exception {
        diagnosticsManager = new com.botmaker.validation.DiagnosticsManager();
        JdtLanguageServerLauncher launcher = new JdtLanguageServerLauncher(Paths.get("tools/jdt-language-server"), (params) -> {
            // This is called on a background thread.
            // We pass the params to the FX thread to do all UI work.
            Platform.runLater(() -> {
                diagnosticsManager.processDiagnostics(params.getDiagnostics());
                uiManager.updateErrors(diagnosticsManager.getDiagnostics());
                uiManager.getStatusLabel().setText(diagnosticsManager.getErrorSummary());
            });
        });
        jdtServer = launcher.getServer();

        astRewriter = new AstRewriter();
        codeEditor = new CodeEditor(this, astRewriter, factory);

        dragAndDropManager = new BlockDragAndDropManager(dropInfo ->
                codeEditor.addStatement(dropInfo.targetBody(), dropInfo.type(), dropInfo.insertionIndex()));

        uiManager = new UIManager(this, dragAndDropManager);
        primaryStage.setScene(uiManager.createScene());

        executionService = new CodeExecutionService(
                uiManager.getOutputArea()::appendText,
                uiManager.getOutputArea()::clear,
                uiManager.getOutputArea()::setText,
                uiManager.getStatusLabel()::setText,
                diagnosticsManager
        );

        debuggingManager = new DebuggingManager(
                executionService,
                uiManager.getStatusLabel()::setText,
                uiManager.getOutputArea()::appendText,
                uiManager.getOutputArea()::clear,
                uiManager::onDebuggerStarted,
                uiManager::onDebuggerPaused,
                uiManager::onDebuggerResumed,
                uiManager::onDebuggerFinished,
                this::highlightBlock,
                factory
        );

        Path docPath = Paths.get("./projects/src/main/java/com/demo/Demo.java").toAbsolutePath();
        docUri = docPath.toUri().toString();
        currentCode = Files.readString(docPath);

        jdtServer.getTextDocumentService().didOpen(new DidOpenTextDocumentParams(
                new TextDocumentItem(docUri, "java", (int) docVersion, currentCode)
        ));

        refreshUI(currentCode);

        primaryStage.setTitle("BotMaker Blocks");
        primaryStage.show();

        primaryStage.setOnCloseRequest(e -> {
            launcher.stop();
            Platform.exit();
        });
    }

    public void compileCode() {
        executionService.compileCode(currentCode);
    }

    public void runCode() {
        executionService.runCode(currentCode);
    }

    public void startDebugging() {
        debuggingManager.setNodeToBlockMap(nodeToBlockMap);
        debuggingManager.startDebugging(currentCode);
    }

    public void resumeDebugging() {
        debuggingManager.resume();
    }

    public void handleCodeUpdate(String newCode) {
        try {
            Files.writeString(Paths.get(new java.net.URI(docUri)), newCode);
        } catch (java.io.IOException | java.net.URISyntaxException e) {
            e.printStackTrace();
            Platform.runLater(() -> uiManager.getStatusLabel().setText("Error saving file: " + e.getMessage()));
        }

        this.docVersion++;
        jdtServer.getTextDocumentService().didChange(new DidChangeTextDocumentParams(
                new VersionedTextDocumentIdentifier(docUri, (int) docVersion),
                List.of(new TextDocumentContentChangeEvent(newCode))
        ));
        refreshUI(newCode);
    }

    private void refreshUI(String javaCode) {
        this.currentCode = javaCode;
        this.nodeToBlockMap = new HashMap<>();
        if (diagnosticsManager != null) {
            diagnosticsManager.updateSource(nodeToBlockMap, currentCode);
        }
        uiManager.getBlocksContainer().getChildren().clear();

        CompletionContext context = new CompletionContext(
                this,
                codeEditor,
                jdtServer,
                docUri,
                currentCode,
                docVersion,
                dragAndDropManager
        );

        MainBlock rootBlock = factory.convert(javaCode, nodeToBlockMap, dragAndDropManager);

        if (rootBlock != null) {
            uiManager.getBlocksContainer().getChildren().add(rootBlock.getUINode(context));
        }
        uiManager.getStatusLabel().setText("UI Refreshed.");
    }

    private void highlightBlock(CodeBlock block) {
        if (highlightedBlock != null) {
            highlightedBlock.unhighlight();
        }
        highlightedBlock = block;
        if (highlightedBlock != null) {
            highlightedBlock.highlight();
        }
    }

    public String getCurrentCode() {
        return currentCode;
    }

    public BlockFactory getBlockFactory() {
        return factory;
    }

    public LanguageServer getJdtServer() {
        return jdtServer;
    }

    public String getDocUri() {
        return docUri;
    }

    public com.botmaker.validation.DiagnosticsManager getDiagnosticsManager() {
        return diagnosticsManager;
    }

    public static void main(String[] args) {
        launch(args);
    }
}

=================================================================================
FILE: main/java/com/botmaker/parser/AstRewriter.java
=================================================================================

package com.botmaker.parser;

import com.botmaker.core.BodyBlock;
import com.botmaker.ui.AddableBlock;
import com.botmaker.util.TypeManager;
import org.eclipse.jdt.core.dom.*;
import org.eclipse.jdt.core.dom.rewrite.ASTRewrite;
import org.eclipse.jdt.core.dom.rewrite.ListRewrite;
import org.eclipse.jface.text.Document;
import org.eclipse.jface.text.IDocument;
import org.eclipse.text.edits.TextEdit;

public class AstRewriter {

    public String addStatement(CompilationUnit cu, String originalCode, BodyBlock targetBody, AddableBlock type, int index) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);

        Statement newStatement = createDefaultStatement(ast, type);
        if (newStatement == null) {
            return originalCode; // Or throw an exception
        }

        Block targetAstBlock = (Block) targetBody.getAstNode();
        ListRewrite listRewrite = rewriter.getListRewrite(targetAstBlock, Block.STATEMENTS_PROPERTY);
        listRewrite.insertAt(newStatement, index, null);

        IDocument document = new Document(originalCode);
        try {
            TextEdit edits = rewriter.rewriteAST(document, null);
            edits.apply(document);
            return document.get();
        } catch (Exception e) {
            e.printStackTrace();
            return originalCode; // Return original on failure
        }
    }

    public String replaceExpression(CompilationUnit cu, String originalCode, Expression toReplace, com.botmaker.ui.AddableExpression type) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);

        Expression newExpression = createDefaultExpression(ast, type);
        if (newExpression == null) {
            return originalCode;
        }

        rewriter.replace(toReplace, newExpression, null);

        IDocument document = new Document(originalCode);
        try {
            TextEdit edits = rewriter.rewriteAST(document, null);
            edits.apply(document);
            return document.get();
        } catch (Exception e) {
            e.printStackTrace();
            return originalCode; // Return original on failure
        }
    }

    public String replaceLiteral(CompilationUnit cu, String originalCode, Expression toReplace, String newLiteralValue) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);

        Expression newExpression;
        if (toReplace instanceof StringLiteral) {
            StringLiteral newString = ast.newStringLiteral();
            newString.setLiteralValue(newLiteralValue);
            newExpression = newString;
        } else if (toReplace instanceof NumberLiteral) {
            newExpression = ast.newNumberLiteral(newLiteralValue);
        } else if (toReplace instanceof BooleanLiteral) {
            newExpression = ast.newBooleanLiteral(Boolean.parseBoolean(newLiteralValue));
        } else {
            // Not a literal we can handle, return original code
            return originalCode;
        }

        rewriter.replace(toReplace, newExpression, null);

        IDocument document = new Document(originalCode);
        try {
            TextEdit edits = rewriter.rewriteAST(document, null);
            edits.apply(document);
            return document.get();
        } catch (Exception e) {
            e.printStackTrace();
            return originalCode;
        }
    }

    public String addArgumentToMethodInvocation(CompilationUnit cu, String originalCode, MethodInvocation mi, Expression newArgument) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);
        ListRewrite listRewrite = rewriter.getListRewrite(mi, MethodInvocation.ARGUMENTS_PROPERTY);
        listRewrite.insertLast(newArgument, null);

        IDocument document = new Document(originalCode);
        try {
            TextEdit edits = rewriter.rewriteAST(document, null);
            edits.apply(document);
            return document.get();
        } catch (Exception e) {
            e.printStackTrace();
            return originalCode; // Return original on failure
        }
    }

    public String replaceSimpleName(CompilationUnit cu, String originalCode, SimpleName toReplace, String newName) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);
        SimpleName newSimpleName = ast.newSimpleName(newName);
        rewriter.replace(toReplace, newSimpleName, null);

        IDocument document = new Document(originalCode);
        try {
            TextEdit edits = rewriter.rewriteAST(document, null);
            edits.apply(document);
            return document.get();
        } catch (Exception e) {
            e.printStackTrace();
            return originalCode;
        }
    }

    public String deleteNode(CompilationUnit cu, String originalCode, ASTNode toDelete) {
        ASTRewrite rewriter = ASTRewrite.create(cu.getAST());
        rewriter.remove(toDelete, null);

        IDocument document = new Document(originalCode);
        try {
            TextEdit edits = rewriter.rewriteAST(document, null);
            edits.apply(document);
            return document.get();
        } catch (Exception e) {
            e.printStackTrace();
            return originalCode;
        }
    }

    public String deleteElseFromIfStatement(CompilationUnit cu, String originalCode, IfStatement ifStatement) {
        ASTRewrite rewriter = ASTRewrite.create(cu.getAST());
        if (ifStatement.getElseStatement() != null) {
            rewriter.remove(ifStatement.getElseStatement(), null);
        } else {
            return originalCode;
        }
        IDocument document = new Document(originalCode);
        try {
            TextEdit edits = rewriter.rewriteAST(document, null);
            edits.apply(document);
            return document.get();
        } catch (Exception e) {
            e.printStackTrace();
            return originalCode;
        }
    }

    public String convertElseToElseIf(CompilationUnit cu, String originalCode, IfStatement ifStatement) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);
        Statement elseStatement = ifStatement.getElseStatement();
        if (elseStatement == null || elseStatement.getNodeType() != ASTNode.BLOCK) {
            return originalCode;
        }
        IfStatement newElseIf = ast.newIfStatement();
        newElseIf.setExpression(ast.newBooleanLiteral(true));
        newElseIf.setThenStatement((Block) ASTNode.copySubtree(ast, elseStatement));
        rewriter.replace(elseStatement, newElseIf, null);
        IDocument document = new Document(originalCode);
        try {
            TextEdit edits = rewriter.rewriteAST(document, null);
            edits.apply(document);
            return document.get();
        } catch (Exception e) {
            e.printStackTrace();
            return originalCode;
        }
    }

    public String addElseToIfStatement(CompilationUnit cu, String originalCode, IfStatement ifStatement) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);

        if (ifStatement.getElseStatement() == null) {
            Block elseBlock = ast.newBlock();
            rewriter.set(ifStatement, IfStatement.ELSE_STATEMENT_PROPERTY, elseBlock, null);
        } else {
            // else already exists, do nothing
            return originalCode;
        }

        IDocument document = new Document(originalCode);
        try {
            TextEdit edits = rewriter.rewriteAST(document, null);
            edits.apply(document);
            return document.get();
        } catch (Exception e) {
            e.printStackTrace();
            return originalCode;
        }
    }

    private Expression createDefaultExpression(AST ast, com.botmaker.ui.AddableExpression type) {
        switch (type) {
            case TEXT:
                StringLiteral newString = ast.newStringLiteral();
                newString.setLiteralValue("text");
                return newString;
            case VARIABLE:
                return ast.newSimpleName("defaultVar");
            default:
                return null;
        }
    }

    private Statement createDefaultStatement(AST ast, AddableBlock type) {
        switch (type) {
            case PRINT:
                // System.out.println("");
                MethodInvocation println = ast.newMethodInvocation();
                println.setExpression(ast.newQualifiedName(
                        ast.newSimpleName("System"),
                        ast.newSimpleName("out"))
                );
                println.setName(ast.newSimpleName("println"));
                StringLiteral emptyString = ast.newStringLiteral();
                emptyString.setLiteralValue("");
                println.arguments().add(emptyString);
                return ast.newExpressionStatement(println);

            case DECLARE_INT: {
                VariableDeclarationFragment fragment = ast.newVariableDeclarationFragment();
                fragment.setName(ast.newSimpleName("i"));
                fragment.setInitializer(ast.newNumberLiteral("0"));
                VariableDeclarationStatement varDecl = ast.newVariableDeclarationStatement(fragment);
                varDecl.setType(ast.newPrimitiveType(PrimitiveType.INT));
                return varDecl;
            }
            case DECLARE_DOUBLE: {
                VariableDeclarationFragment fragment = ast.newVariableDeclarationFragment();
                fragment.setName(ast.newSimpleName("d"));
                fragment.setInitializer(ast.newNumberLiteral("0.0"));
                VariableDeclarationStatement varDecl = ast.newVariableDeclarationStatement(fragment);
                varDecl.setType(ast.newPrimitiveType(PrimitiveType.DOUBLE));
                return varDecl;
            }
            case DECLARE_BOOLEAN: {
                VariableDeclarationFragment fragment = ast.newVariableDeclarationFragment();
                fragment.setName(ast.newSimpleName("b"));
                fragment.setInitializer(ast.newBooleanLiteral(false));
                VariableDeclarationStatement varDecl = ast.newVariableDeclarationStatement(fragment);
                varDecl.setType(ast.newPrimitiveType(PrimitiveType.BOOLEAN));
                return varDecl;
            }
            case DECLARE_STRING: {
                VariableDeclarationFragment fragment = ast.newVariableDeclarationFragment();
                fragment.setName(ast.newSimpleName("s"));
                fragment.setInitializer(ast.newStringLiteral());
                VariableDeclarationStatement varDecl = ast.newVariableDeclarationStatement(fragment);
                varDecl.setType(TypeManager.createTypeNode(ast, "String"));
                return varDecl;
            }

            case IF:
                // if (true) {}
                IfStatement ifStatement = ast.newIfStatement();
                ifStatement.setExpression(ast.newBooleanLiteral(true));
                ifStatement.setThenStatement(ast.newBlock());
                return ifStatement;

            default:
                return null;
        }
    }

    private Expression createDefaultInitializer(AST ast, String typeName) {
        switch (typeName) {
            case "int":
            case "long":
            case "short":
            case "byte":
                return ast.newNumberLiteral("0");
            case "double":
            case "float":
                return ast.newNumberLiteral("0.0");
            case "boolean":
                return ast.newBooleanLiteral(false);
            case "char":
                CharacterLiteral literal = ast.newCharacterLiteral();
                literal.setCharValue('a'); // Default char
                return literal;
            case "String":
                StringLiteral stringLiteral = ast.newStringLiteral();
                stringLiteral.setLiteralValue(""); // Default empty string
                return stringLiteral;
            default:
                // For any other object type, the safest default is null.
                return ast.newNullLiteral();
        }
    }

    public String replaceVariableType(CompilationUnit cu, String originalCode, VariableDeclarationStatement varDecl, String newTypeName) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);

        // 1. Create the new type node
        Type newType = TypeManager.createTypeNode(ast, newTypeName);
        rewriter.replace(varDecl.getType(), newType, null);

        // 2. Get the fragment and its current initializer
        if (!varDecl.fragments().isEmpty()) {
            VariableDeclarationFragment fragment = (VariableDeclarationFragment) varDecl.fragments().get(0);
            Expression currentInitializer = fragment.getInitializer();

            // 3. Create a new default initializer based on the new type
            Expression newInitializer = createDefaultInitializer(ast, newTypeName);

            // 4. Replace the old initializer if it exists and we have a new one
            if (currentInitializer != null && newInitializer != null) {
                rewriter.replace(currentInitializer, newInitializer, null);
            }
        }

        IDocument document = new Document(originalCode);
        try {
            TextEdit edits = rewriter.rewriteAST(document, null);
            edits.apply(document);
            return document.get();
        } catch (Exception e) {
            e.printStackTrace();
            return originalCode;
        }
    }
}


=================================================================================
FILE: main/java/com/botmaker/parser/BlockFactory.java
=================================================================================

package com.botmaker.parser;

import com.botmaker.blocks.*;
import com.botmaker.core.*;
import com.botmaker.ui.BlockDragAndDropManager;
import org.eclipse.jdt.core.dom.*;
import org.eclipse.jdt.core.dom.IMethodBinding;
import org.eclipse.jdt.core.dom.ITypeBinding;

import java.util.Map;
import java.util.Optional;

public class BlockFactory {

    private CompilationUnit ast;
    private boolean markNewIdentifiersAsUnedited = false;

    public MainBlock convert(String javaCode, Map<ASTNode, CodeBlock> nodeToBlockMap, BlockDragAndDropManager manager) {
        try {
            ASTParser parser = ASTParser.newParser(AST.getJLSLatest());
            parser.setSource(javaCode.toCharArray());
            parser.setResolveBindings(true);
            parser.setKind(ASTParser.K_COMPILATION_UNIT);
            parser.setUnitName("Demo.java");
            parser.setEnvironment(null, null, null, true);
            this.ast = (CompilationUnit) parser.createAST(null);

            MainMethodVisitor visitor = new MainMethodVisitor();
            ast.accept(visitor);

            return visitor.getMainMethodDeclaration()
                    .map(mainMethodDecl -> {
                        MainBlock mainBlock = new MainBlock("main_" + mainMethodDecl.hashCode(), mainMethodDecl);
                        nodeToBlockMap.put(mainMethodDecl, mainBlock);
                        visitor.getMainMethodBody().ifPresent(bodyAstNode -> {
                            BodyBlock bodyBlock = parseBodyBlock(bodyAstNode, nodeToBlockMap, manager);
                            mainBlock.setMainBody(bodyBlock);
                        });
                        return mainBlock;
                    })
                    .orElse(null);
        } finally {
            setMarkNewIdentifiersAsUnedited(false);
        }
    }

    /**
     * Enable marking of newly created identifiers as unedited
     * Call this before converting code that contains newly added blocks
     */
    public void setMarkNewIdentifiersAsUnedited(boolean mark) {
        this.markNewIdentifiersAsUnedited = mark;
    }

    private BodyBlock parseBodyBlock(Block astBlock, Map<ASTNode, CodeBlock> nodeToBlockMap, BlockDragAndDropManager manager) {
        System.out.println("Creating BodyBlock for: " + astBlock.hashCode());
        BodyBlock bodyBlock = new BodyBlock("body_" + astBlock.hashCode(), astBlock, manager);
        nodeToBlockMap.put(astBlock, bodyBlock);
        for (Object statementObj : astBlock.statements()) {
            Statement statement = (Statement) statementObj;
            parseStatement(statement, nodeToBlockMap, manager).ifPresent(bodyBlock::addStatement);
        }
        return bodyBlock;
    }

    private Optional<StatementBlock> parseStatement(Statement astStatement, Map<ASTNode, CodeBlock> nodeToBlockMap, BlockDragAndDropManager manager) {
        if (astStatement instanceof Block) {
            return Optional.of(parseBodyBlock((Block) astStatement, nodeToBlockMap, manager));
        }
        if (astStatement instanceof VariableDeclarationStatement) {
            return Optional.of(parseVariableDeclaration((VariableDeclarationStatement) astStatement, nodeToBlockMap));
        }
        if (astStatement instanceof IfStatement) {
            return Optional.of(parseIfStatement((IfStatement) astStatement, nodeToBlockMap, manager));
        }
        if (astStatement instanceof ExpressionStatement) {
            Expression expression = ((ExpressionStatement) astStatement).getExpression();
            if (isPrintStatement(expression)) {
                return Optional.of(parsePrintStatement((ExpressionStatement) astStatement, nodeToBlockMap));
            }
        }
        return Optional.empty();
    }

    private VariableDeclarationBlock parseVariableDeclaration(VariableDeclarationStatement astNode, Map<ASTNode, CodeBlock> nodeToBlockMap) {
        System.out.println("Creating VariableDeclarationBlock for: " + astNode);
        VariableDeclarationBlock varBlock = new VariableDeclarationBlock("var_" + astNode.hashCode(), astNode);
        nodeToBlockMap.put(astNode, varBlock);
        VariableDeclarationFragment fragment = (VariableDeclarationFragment) astNode.fragments().get(0);

        if (fragment.getInitializer() != null) {
            parseExpression(fragment.getInitializer(), nodeToBlockMap).ifPresent(varBlock::setInitializer);
        }
        return varBlock;
    }

    private IfBlock parseIfStatement(IfStatement astNode, Map<ASTNode, CodeBlock> nodeToBlockMap, BlockDragAndDropManager manager) {
        System.out.println("Creating IfBlock for: " + astNode);
        IfBlock ifBlock = new IfBlock("if_" + astNode.hashCode(), astNode);
        nodeToBlockMap.put(astNode, ifBlock);
        parseExpression(astNode.getExpression(), nodeToBlockMap).ifPresent(ifBlock::setCondition);

        if (astNode.getThenStatement() instanceof Block) {
            ifBlock.setThenBody(parseBodyBlock((Block) astNode.getThenStatement(), nodeToBlockMap, manager));
        }

        Statement elseStmt = astNode.getElseStatement();
        if (elseStmt != null) {
            parseStatement(elseStmt, nodeToBlockMap, manager).ifPresent(ifBlock::setElseStatement);
        }

        return ifBlock;
    }

    private PrintBlock parsePrintStatement(ExpressionStatement astNode, Map<ASTNode, CodeBlock> nodeToBlockMap) {
        System.out.println("Creating PrintBlock for: " + astNode);
        PrintBlock printBlock = new PrintBlock("print_" + astNode.hashCode(), astNode);
        nodeToBlockMap.put(astNode, printBlock);

        MethodInvocation methodInvocation = (MethodInvocation) astNode.getExpression();

        if (methodInvocation.arguments().isEmpty()) {
            System.out.println("Creating synthetic String LiteralBlock for empty println");
            LiteralBlock<String> block = new LiteralBlock<>("synthetic_string_" + astNode.hashCode(), methodInvocation, "");
            printBlock.addArgument(block);
        } else {
            for (Object arg : methodInvocation.arguments()) {
                parseExpression((Expression) arg, nodeToBlockMap).ifPresent(printBlock::addArgument);
            }
        }
        return printBlock;
    }

    private BinaryExpressionBlock parseBinaryExpression(InfixExpression astNode, Map<ASTNode, CodeBlock> nodeToBlockMap) {
        System.out.println("Creating BinaryExpressionBlock for: " + astNode);
        BinaryExpressionBlock binaryBlock = new BinaryExpressionBlock("binary_" + astNode.hashCode(), astNode);
        nodeToBlockMap.put(astNode, binaryBlock);
        parseExpression(astNode.getLeftOperand(), nodeToBlockMap).ifPresent(binaryBlock::setLeftOperand);
        parseExpression(astNode.getRightOperand(), nodeToBlockMap).ifPresent(binaryBlock::setRightOperand);
        return binaryBlock;
    }

    private Optional<ExpressionBlock> parseExpression(Expression astExpression, Map<ASTNode, CodeBlock> nodeToBlockMap) {
        if (astExpression instanceof StringLiteral) {
            System.out.println("Creating String LiteralBlock for: " + astExpression);
            StringLiteral literalNode = (StringLiteral) astExpression;
            LiteralBlock<String> block = new LiteralBlock<>("string_" + literalNode.hashCode(), literalNode, literalNode.getLiteralValue());
            nodeToBlockMap.put(astExpression, block);
            return Optional.of(block);
        }
        if (astExpression instanceof NumberLiteral) {
            System.out.println("Creating Number LiteralBlock for: " + astExpression);
            NumberLiteral literalNode = (NumberLiteral) astExpression;
            String token = literalNode.getToken();
            ExpressionBlock block;
            if (token.toLowerCase().endsWith("f")) {
                block = new LiteralBlock<>("float_" + literalNode.hashCode(), literalNode, Float.parseFloat(token));
            } else if (token.contains(".") || token.toLowerCase().endsWith("d")) {
                block = new LiteralBlock<>("double_" + literalNode.hashCode(), literalNode, Double.parseDouble(token));
            } else {
                block = new LiteralBlock<>("int_" + literalNode.hashCode(), literalNode, Integer.parseInt(token));
            }
            nodeToBlockMap.put(astExpression, block);
            return Optional.of(block);
        }
        if (astExpression instanceof BooleanLiteral) {
            System.out.println("Creating Boolean LiteralBlock for: " + astExpression);
            BooleanLiteral literalNode = (BooleanLiteral) astExpression;
            LiteralBlock<Boolean> block = new LiteralBlock<>("boolean_" + literalNode.hashCode(), literalNode, literalNode.booleanValue());
            nodeToBlockMap.put(astExpression, block);
            return Optional.of(block);
        }
        if (astExpression instanceof SimpleName) {
            // Do not convert type names into identifier blocks
            if (astExpression.getParent() instanceof Type) {
                return Optional.empty();
            }
            System.out.println("Creating IdentifierBlock for: " + astExpression);
            SimpleName simpleName = (SimpleName) astExpression;

            // Check if this identifier should be marked as unedited
            boolean shouldMarkAsUnedited = markNewIdentifiersAsUnedited &&
                    "defaultVar".equals(simpleName.getIdentifier());

            IdentifierBlock block = new IdentifierBlock("id_" + astExpression.hashCode(), simpleName, shouldMarkAsUnedited);
            nodeToBlockMap.put(astExpression, block);
            return Optional.of(block);
        }
        if (astExpression instanceof InfixExpression) {
            return Optional.of(parseBinaryExpression((InfixExpression) astExpression, nodeToBlockMap));
        }
        return Optional.empty();
    }

    private boolean isPrintStatement(Expression expression) {
        if (!(expression instanceof MethodInvocation)) {
            return false;
        }
        MethodInvocation method = (MethodInvocation) expression;

        if (!method.getName().getIdentifier().equals("println")) {
            return false;
        }

        if (method.arguments().isEmpty()) {
            return method.toString().startsWith("System.out.println");
        } else {
            Expression expr = method.getExpression();
            return expr != null && "System.out".equals(expr.toString());
        }
    }

    public CompilationUnit getCompilationUnit() {
        return ast;
    }

    private static class MainMethodVisitor extends ASTVisitor {
        private MethodDeclaration mainMethodDeclaration;

        @Override
        public boolean visit(MethodDeclaration node) {
            if ("main".equals(node.getName().getIdentifier())) {
                mainMethodDeclaration = node;
                return false;
            }
            return true;
        }

        public Optional<MethodDeclaration> getMainMethodDeclaration() {
            return Optional.ofNullable(mainMethodDeclaration);
        }

        public Optional<Block> getMainMethodBody() {
            return Optional.ofNullable(mainMethodDeclaration != null ? mainMethodDeclaration.getBody() : null);
        }
    }
}

=================================================================================
FILE: main/java/com/botmaker/parser/CodeEditor.java
=================================================================================

package com.botmaker.parser;

import com.botmaker.core.BodyBlock;
import com.botmaker.ui.AddableBlock;
import com.botmaker.ui.AddableExpression;
import javafx.application.Platform;
import org.eclipse.jdt.core.dom.*;
import com.botmaker.Main;

public class CodeEditor {

    private final Main mainApp;
    private final AstRewriter astRewriter;
    private final BlockFactory blockFactory;

    public CodeEditor(Main mainApp, AstRewriter astRewriter, BlockFactory blockFactory) {
        this.mainApp = mainApp;
        this.astRewriter = astRewriter;
        this.blockFactory = blockFactory;
    }

    private String getCurrentCode() {
        return mainApp.getCurrentCode();
    }

    private CompilationUnit getCompilationUnit() {
        return blockFactory.getCompilationUnit();
    }

    private void triggerUpdate(String newCode) {
        Platform.runLater(() -> mainApp.handleCodeUpdate(newCode));
    }

    public void replaceLiteralValue(Expression toReplace, String newLiteralValue) {
        String newCode = astRewriter.replaceLiteral(
                getCompilationUnit(),
                getCurrentCode(),
                toReplace,
                newLiteralValue
        );
        triggerUpdate(newCode);
    }

    public void addStringArgumentToMethodInvocation(MethodInvocation mi, String text) {
        AST ast = getCompilationUnit().getAST();
        StringLiteral newArg = ast.newStringLiteral();
        newArg.setLiteralValue(text);

        String newCode = astRewriter.addArgumentToMethodInvocation(
                getCompilationUnit(),
                getCurrentCode(),
                mi,
                newArg
        );
        triggerUpdate(newCode);
    }

    public void replaceExpression(Expression toReplace, AddableExpression type) {
        blockFactory.setMarkNewIdentifiersAsUnedited(true);
        String newCode = astRewriter.replaceExpression(
                getCompilationUnit(),
                getCurrentCode(),
                toReplace,
                type
        );
        triggerUpdate(newCode);
    }

    public void addStatement(BodyBlock targetBody, AddableBlock type, int index) {
        blockFactory.setMarkNewIdentifiersAsUnedited(true);
        String newCode = astRewriter.addStatement(
                getCompilationUnit(),
                getCurrentCode(),
                targetBody,
                type,
                index
        );
        triggerUpdate(newCode);
    }

    public void deleteElseFromIfStatement(IfStatement ifStmt) {
        String newCode = astRewriter.deleteElseFromIfStatement(getCompilationUnit(), getCurrentCode(), ifStmt);
        triggerUpdate(newCode);
    }

    public void convertElseToElseIf(IfStatement ifStmt) {
        String newCode = astRewriter.convertElseToElseIf(getCompilationUnit(), getCurrentCode(), ifStmt);
        triggerUpdate(newCode);
    }

    public void addElseToIfStatement(IfStatement ifStmt) {
        String newCode = astRewriter.addElseToIfStatement(
                getCompilationUnit(),
                getCurrentCode(),
                ifStmt
        );
        triggerUpdate(newCode);
    }

    public void replaceSimpleName(SimpleName toReplace, String newName) {
        String newCode = astRewriter.replaceSimpleName(
            getCompilationUnit(),
            getCurrentCode(),
            toReplace,
            newName
        );
        triggerUpdate(newCode);
    }

    public void deleteStatement(Statement toDelete) {
        String newCode = astRewriter.deleteNode(
                getCompilationUnit(),
                getCurrentCode(),
                toDelete
        );
        triggerUpdate(newCode);
    }

    public void replaceVariableType(VariableDeclarationStatement toReplace, String newTypeName) {
        String newCode = astRewriter.replaceVariableType(
            getCompilationUnit(),
            getCurrentCode(),
            toReplace,
            newTypeName
        );
        triggerUpdate(newCode);
    }
}

=================================================================================
FILE: main/java/com/botmaker/runtime/CodeExecutionService.java
=================================================================================

package com.botmaker.runtime;

import javafx.application.Platform;

import java.io.IOException;
import java.io.InputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Scanner;
import java.util.function.Consumer;

public class CodeExecutionService {

    private final Consumer<String> appendOutputConsumer;
    private final Runnable clearOutputConsumer;
    private final Consumer<String> statusConsumer;
    private final Consumer<String> setOutputConsumer;
    private final com.botmaker.validation.DiagnosticsManager diagnosticsManager;

    public CodeExecutionService(Consumer<String> appendOutputConsumer, Runnable clearOutputConsumer, Consumer<String> setOutputConsumer, Consumer<String> statusConsumer, com.botmaker.validation.DiagnosticsManager diagnosticsManager) {
        this.appendOutputConsumer = appendOutputConsumer;
        this.clearOutputConsumer = clearOutputConsumer;
        this.setOutputConsumer = setOutputConsumer;
        this.statusConsumer = statusConsumer;
        this.diagnosticsManager = diagnosticsManager;
    }

    public void runCode(String code) {
        if (diagnosticsManager.hasErrors()) {
            String translatedErrors = com.botmaker.validation.ErrorTranslator.translate(diagnosticsManager.getDiagnostics());
            System.err.println(translatedErrors);
            Platform.runLater(() -> {
                statusConsumer.accept("Run aborted due to errors.");
            });
            return; // Abort run
        }

        new Thread(() -> {
            try {
                if (!compileAndWait(code)) {
                    Platform.runLater(() -> statusConsumer.accept("Run aborted due to compilation failure."));
                    return;
                }

                Platform.runLater(() -> {
                    statusConsumer.accept("Running code...");
                    clearOutputConsumer.run();
                });

                String classPath = "build/compiled";
                String className = "Demo";
                String javaExecutable = Paths.get(System.getProperty("java.home"), "bin", "java").toString();

                ProcessBuilder pb = new ProcessBuilder(javaExecutable, "-cp", classPath, className);
                Process process = pb.start();

                redirectStream(process.getInputStream());
                redirectStream(process.getErrorStream());

                int exitCode = process.waitFor();
                Platform.runLater(() -> statusConsumer.accept("Run finished with exit code: " + exitCode));

            } catch (IOException | InterruptedException e) {
                Platform.runLater(() -> statusConsumer.accept("Run Error: " + e.getMessage()));
            }
        }).start();
    }

    public void compileCode(String code) {
        if (diagnosticsManager.hasErrors()) {
            String translatedErrors = com.botmaker.validation.ErrorTranslator.translate(diagnosticsManager.getDiagnostics());
            System.err.println(translatedErrors);
            Platform.runLater(() -> {
                statusConsumer.accept("Compilation failed. See errors above.");
            });
            return; // Abort compilation
        }

        new Thread(() -> {
            try {
                Platform.runLater(() -> setOutputConsumer.accept("Saving and compiling..."));
                if (compileAndWait(code)) {
                    Platform.runLater(() -> setOutputConsumer.accept("Compilation successful."));
                }
            } catch (IOException | InterruptedException e) {
                Platform.runLater(() -> setOutputConsumer.accept("Compilation Error: " + e.getMessage()));
            }
        }).start();
    }

    public boolean compileAndWait(String code) throws IOException, InterruptedException {
        Path sourceFile = Paths.get("projects/Demo.java");
        Files.writeString(sourceFile, code);

        String sourcePath = sourceFile.toString();
        String outDir = "build/compiled";
        Files.createDirectories(Paths.get(outDir));

        String javacExecutable = Paths.get(System.getProperty("java.home"), "bin", "javac").toString();
        // Add -g to include debug information for the debugger
        ProcessBuilder pb = new ProcessBuilder(javacExecutable, "-g", "-d", outDir, sourcePath);
        Process process = pb.start();

        String errors = new String(process.getErrorStream().readAllBytes());
        int exitCode = process.waitFor();

        if (exitCode == 0) {
            return true;
        } else {
            final String errorMessage = "Compilation Failed:\n" + errors;
            System.err.println(errorMessage);
            Platform.runLater(() -> {
                setOutputConsumer.accept(errorMessage);
            });
            return false;
        }
    }

    private void redirectStream(InputStream stream) {
        new Thread(() -> {
            try (Scanner s = new Scanner(stream)) {
                while (s.hasNextLine()) {
                    String line = s.nextLine();
                    Platform.runLater(() -> appendOutputConsumer.accept(line + "\n"));
                }
            }
        }).start();
    }
}


=================================================================================
FILE: main/java/com/botmaker/runtime/DebuggerService.java
=================================================================================

package com.botmaker.runtime;

import com.sun.jdi.*;
import com.sun.jdi.connect.AttachingConnector;
import com.sun.jdi.connect.Connector;
import com.sun.jdi.connect.IllegalConnectorArgumentsException;
import com.sun.jdi.event.*;
import com.sun.jdi.request.BreakpointRequest;
import com.sun.jdi.request.ClassPrepareRequest;
import com.sun.jdi.request.EventRequestManager;

import java.io.IOException;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CountDownLatch;
import java.util.function.Consumer;

public class DebuggerService {

    // ANSI escape codes for colors
    public static final String ANSI_RESET = "\u001B[0m";
    public static final String ANSI_BLUE = "\u001B[34m";
    public static final String ANSI_GREEN = "\u001B[32m";
    public static final String ANSI_YELLOW = "\u001B[33m";
    public static final String ANSI_RED = "\u001B[31m";

    private VirtualMachine vm;
    private Consumer<LocatableEvent> onPause;
    private Runnable onDisconnect;

    public void setOnPause(Consumer<LocatableEvent> onPause) {
        this.onPause = onPause;
    }

    public void setOnDisconnect(Runnable onDisconnect) {
        this.onDisconnect = onDisconnect;
    }

    public void connectAndRun(String mainClassName, int port, List<Integer> breakpointLines) throws IOException, IllegalConnectorArgumentsException, InterruptedException {
        VirtualMachineManager vmMgr = Bootstrap.virtualMachineManager();
        AttachingConnector connector = vmMgr.attachingConnectors().stream()
                .filter(c -> c.transport().name().equals("dt_socket"))
                .findFirst()
                .orElseThrow(() -> new RuntimeException("Socket attaching connector not found"));

        Map<String, Connector.Argument> arguments = connector.defaultArguments();
        arguments.get("port").setValue(String.valueOf(port));
        arguments.get("hostname").setValue("localhost");

        int maxRetries = 10;
        int retryDelayMs = 250;
        for (int i = 0; i < maxRetries; i++) {
            try {
                System.out.println(ANSI_BLUE + "Attaching to process on port " + port + " (Attempt " + (i + 1) + ")..." + ANSI_RESET);
                vm = connector.attach(arguments);
                System.out.println(ANSI_BLUE + "Attached to VM: " + vm.name() + ANSI_RESET);
                break; // Success, exit the loop
            } catch (IOException e) {
                if (e instanceof java.net.ConnectException && i < maxRetries - 1) {
                    System.out.println(ANSI_YELLOW + "Connection refused. Retrying in " + retryDelayMs + "ms..." + ANSI_RESET);
                    Thread.sleep(retryDelayMs);
                } else {
                    // For other IOExceptions or on the last retry, re-throw.
                    throw e;
                }
            }
        }

        EventRequestManager erm = vm.eventRequestManager();

        List<ReferenceType> classes = vm.classesByName(mainClassName);
        if (!classes.isEmpty()) {
            System.out.println(ANSI_YELLOW + "Class " + mainClassName + " is already loaded. Setting breakpoints immediately." + ANSI_RESET);
            setBreakpoints(classes.getFirst(), breakpointLines);
        } else {
            System.out.println(ANSI_YELLOW + "Class " + mainClassName + " is not loaded yet. Requesting notification for when it is." + ANSI_RESET);
            ClassPrepareRequest classPrepareRequest = erm.createClassPrepareRequest();
            classPrepareRequest.addClassFilter(mainClassName);
            classPrepareRequest.enable();
        }

        CountDownLatch listenerReadyLatch = new CountDownLatch(1);
        new Thread(() -> listenForEvents(listenerReadyLatch, mainClassName, breakpointLines)).start();

        System.out.println(ANSI_BLUE + "Waiting for debugger event listener to be ready..." + ANSI_RESET);
        listenerReadyLatch.await();

        System.out.println(ANSI_BLUE + "Listener is ready. Resuming VM to trigger class loading and hit initial breakpoint." + ANSI_RESET);
        vm.resume();
    }

    private void listenForEvents(CountDownLatch listenerReadyLatch, String mainClassName, List<Integer> breakpointLines) {
        if (vm == null) return;
        EventQueue eventQueue = vm.eventQueue();
        while (true) {
            try {
                if (listenerReadyLatch != null) {
                    listenerReadyLatch.countDown();
                    listenerReadyLatch = null;
                }

                EventSet eventSet = eventQueue.remove();
                boolean shouldResume = true;

                try {
                    for (Event event : eventSet) {
                        if (event instanceof BreakpointEvent) {
                            System.out.println(ANSI_GREEN + "---> Hit Breakpoint: " + event + ANSI_RESET);
                            if (onPause != null) {
                                onPause.accept((BreakpointEvent) event);
                            }
                            shouldResume = false; // PAUSE the VM
                        } else if (event instanceof ClassPrepareEvent) {
                            System.out.println(ANSI_YELLOW + "Class Prepared: " + ((ClassPrepareEvent) event).referenceType().name() + ANSI_RESET);
                            ClassPrepareEvent cpe = (ClassPrepareEvent) event;
                            if (cpe.referenceType().name().equals(mainClassName)) {
                                setBreakpoints(cpe.referenceType(), breakpointLines);
                            }
                        } else if (event instanceof VMDisconnectEvent) {
                            System.out.println(ANSI_RED + "VM Disconnected." + ANSI_RESET);
                            if (onDisconnect != null) {
                                onDisconnect.run();
                            }
                            return; // Exit thread
                        } else {
                            // Other events like VMStartEvent, ThreadStartEvent etc.
                            System.out.println(ANSI_BLUE + "JDI Event: " + event + ANSI_RESET);
                        }
                    }
                } finally {
                    if (shouldResume) {
                        eventSet.resume();
                    }
                }
            } catch (InterruptedException e) {
                System.out.println(ANSI_RED + "Event listener interrupted." + ANSI_RESET);
                return;
            } catch (VMDisconnectedException e) {
                System.out.println(ANSI_RED + "VM Disconnected. Exiting event listener." + ANSI_RESET);
                if (onDisconnect != null) {
                    onDisconnect.run();
                }
                return;
            } catch (Exception e) {
                System.out.println(ANSI_RED + "Exception in event loop: " + e.getMessage() + ANSI_RESET);
                e.printStackTrace();
            }
        }
    }

    private void setBreakpoints(ReferenceType refType, List<Integer> lines) {
        try {
            for (int lineNumber : lines) {
                List<Location> locations = refType.locationsOfLine(lineNumber);
                if (!locations.isEmpty()) {
                    Location loc = locations.get(0);
                    System.out.println(ANSI_YELLOW + "Setting breakpoint at: " + loc + ANSI_RESET);
                    BreakpointRequest bpReq = vm.eventRequestManager().createBreakpointRequest(loc);
                    bpReq.enable();
                } else {
                    System.out.println(ANSI_YELLOW + "Warning: Could not find a location for line " + lineNumber + ANSI_RESET);
                }
            }
        } catch (AbsentInformationException e) {
            System.err.println(ANSI_RED + "Could not set breakpoints. Compile the source with debug information (-g)." + ANSI_RESET);
        }
    }

    public void resume() {
        if (vm != null) {
            System.out.println(ANSI_BLUE + "Resuming VM..." + ANSI_RESET);
            vm.resume();
        }
    }
}


=================================================================================
FILE: main/java/com/botmaker/runtime/DebuggingManager.java
=================================================================================

package com.botmaker.runtime;

import com.botmaker.core.CodeBlock;
import com.botmaker.core.StatementBlock;
import com.botmaker.parser.BlockFactory;
import com.sun.jdi.connect.IllegalConnectorArgumentsException;
import com.sun.jdi.event.LocatableEvent;
import javafx.application.Platform;
import org.eclipse.jdt.core.dom.ASTNode;
import org.eclipse.jdt.core.dom.CompilationUnit;

import java.io.IOException;
import java.io.InputStream;
import java.net.ServerSocket;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Scanner;
import java.util.function.Consumer;

public class DebuggingManager {

    private final CodeExecutionService codeExecutionService;
    private final Consumer<String> statusConsumer;
    private final Consumer<String> appendOutputConsumer;
    private final Runnable clearOutputConsumer;
    private final Runnable onDebugStart;
    private final Runnable onPause;
    private final Runnable onResume;
    private final Runnable onDebugFinish;
    private final Consumer<CodeBlock> highlightConsumer;
    private final BlockFactory factory;
    private Map<ASTNode, CodeBlock> nodeToBlockMap; // This needs to be updated from Main

    private DebuggerService debuggerService;
    private Map<Integer, CodeBlock> lineToBlockMap;

    public DebuggingManager(CodeExecutionService codeExecutionService,
                            Consumer<String> statusConsumer,
                            Consumer<String> appendOutputConsumer,
                            Runnable clearOutputConsumer,
                            Runnable onDebugStart,
                            Runnable onPause,
                            Runnable onResume,
                            Runnable onDebugFinish,
                            Consumer<CodeBlock> highlightConsumer,
                            BlockFactory factory) {
        this.codeExecutionService = codeExecutionService;
        this.statusConsumer = statusConsumer;
        this.appendOutputConsumer = appendOutputConsumer;
        this.clearOutputConsumer = clearOutputConsumer;
        this.onDebugStart = onDebugStart;
        this.onPause = onPause;
        this.onResume = onResume;
        this.onDebugFinish = onDebugFinish;
        this.highlightConsumer = highlightConsumer;
        this.factory = factory;
    }

    public void setNodeToBlockMap(Map<ASTNode, CodeBlock> nodeToBlockMap) {
        this.nodeToBlockMap = nodeToBlockMap;
    }

    public void startDebugging(String code) {
        new Thread(() -> {
            try {
                if (!codeExecutionService.compileAndWait(code)) {
                    Platform.runLater(() -> statusConsumer.accept("Debug aborted due to compilation failure."));
                    return;
                }

                CompilationUnit cu = factory.getCompilationUnit();
                if (cu == null || nodeToBlockMap == null) {
                    Platform.runLater(() -> statusConsumer.accept("Error: Could not parse code to get breakpoints."));
                    return;
                }

                this.lineToBlockMap = new HashMap<>();
                for (CodeBlock block : nodeToBlockMap.values()) {
                    int line = block.getBreakpointLine(cu);
                    if (line > 0) {
                        if (!lineToBlockMap.containsKey(line) || block instanceof StatementBlock) {
                            lineToBlockMap.put(line, block);
                        }
                    }
                }
                List<Integer> breakpointLines = new ArrayList<>(this.lineToBlockMap.keySet());

                int freePort;
                try (ServerSocket socket = new ServerSocket(0)) {
                    freePort = socket.getLocalPort();
                }

                Platform.runLater(() -> {
                    statusConsumer.accept("Starting debugger on port " + freePort + "...");
                    onDebugStart.run();
                    clearOutputConsumer.run();
                });

                String classPath = "build/compiled";
                String className = "Demo";
                String javaExecutable = Paths.get(System.getProperty("java.home"), "bin", "java").toString();
                String debugAgent = String.format("-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=%d", freePort);

                ProcessBuilder pb = new ProcessBuilder(javaExecutable, debugAgent, "-cp", classPath, className);
                Process process = pb.start();

                redirectStream(process.getInputStream());
                redirectStream(process.getErrorStream());

                debuggerService = new DebuggerService();
                debuggerService.setOnPause(this::handlePauseEvent);
                debuggerService.setOnDisconnect(this::onDebugSessionFinished);
                debuggerService.connectAndRun(className, freePort, breakpointLines);

            } catch (IOException | IllegalConnectorArgumentsException | InterruptedException e) {
                Platform.runLater(() -> statusConsumer.accept("Debugger Error: " + e.getMessage()));
                e.printStackTrace();
            }
        }).start();
    }

    public void resume() {
        if (debuggerService != null) {
            Platform.runLater(onResume);
            debuggerService.resume();
        }
    }

    private void handlePauseEvent(LocatableEvent event) {
        Platform.runLater(() -> {
            onPause.run();
            int lineNumber = event.location().lineNumber();
            CodeBlock block = lineToBlockMap.get(lineNumber);

            if (block != null) {
                CodeBlock target = block.getHighlightTarget();
                highlightConsumer.accept(target);
                statusConsumer.accept("Paused at line: " + lineNumber);
            } else {
                statusConsumer.accept("Paused at line: " + lineNumber + " (No block found)");
            }
        });
    }

    private void onDebugSessionFinished() {
        Platform.runLater(() -> {
            statusConsumer.accept("Debug session finished.");
            onDebugFinish.run();
            highlightConsumer.accept(null); // Clear highlight
        });
    }

    private void redirectStream(InputStream stream) {
        new Thread(() -> {
            try (Scanner s = new Scanner(stream)) {
                while (s.hasNextLine()) {
                    String line = s.nextLine();
                    Platform.runLater(() -> appendOutputConsumer.accept(line + "\n"));
                }
            }
        }).start();
    }
}


=================================================================================
FILE: main/java/com/botmaker/ui/AddableBlock.java
=================================================================================

package com.botmaker.ui;

import com.botmaker.blocks.IfBlock;
import com.botmaker.blocks.PrintBlock;
import com.botmaker.blocks.VariableDeclarationBlock;
import com.botmaker.core.StatementBlock;

public enum AddableBlock {
    PRINT("Print", PrintBlock.class),
    IF("If", IfBlock.class),
    DECLARE_INT("Declare Int", VariableDeclarationBlock.class),
    DECLARE_DOUBLE("Declare Double", VariableDeclarationBlock.class),
    DECLARE_BOOLEAN("Declare Boolean", VariableDeclarationBlock.class),
    DECLARE_STRING("Declare String", VariableDeclarationBlock.class);

    private final String displayName;
    private final Class<? extends StatementBlock> blockClass;

    AddableBlock(String displayName, Class<? extends StatementBlock> blockClass) {
        this.displayName = displayName;
        this.blockClass = blockClass;
    }

    public String getDisplayName() {
        return displayName;
    }

    public Class<? extends StatementBlock> getBlockClass() {
        return blockClass;
    }
}


=================================================================================
FILE: main/java/com/botmaker/ui/AddableExpression.java
=================================================================================

package com.botmaker.ui;

public enum AddableExpression {
    TEXT("Text"),
    VARIABLE("Variable");

    private final String displayName;

    AddableExpression(String displayName) {
        this.displayName = displayName;
    }

    public String getDisplayName() {
        return displayName;
    }
}

=================================================================================
FILE: main/java/com/botmaker/ui/BlockDragAndDropManager.java
=================================================================================

package com.botmaker.ui;

import com.botmaker.core.BodyBlock;
import com.botmaker.core.StatementBlock;
import javafx.scene.Node;
import javafx.scene.input.ClipboardContent;
import javafx.scene.input.DataFormat;
import javafx.scene.input.Dragboard;
import javafx.scene.input.TransferMode;
import javafx.scene.layout.Region;

import java.util.function.Consumer;

public class BlockDragAndDropManager {

    public static final DataFormat ADDABLE_BLOCK_FORMAT = new DataFormat("application/x-java-addable-block");
    private final Consumer<DropInfo> onDrop;

    public BlockDragAndDropManager(Consumer<DropInfo> onDrop) {
        this.onDrop = onDrop;
    }

    /**
     * Makes a UI node draggable, associating it with a specific type of AddableBlock.
     * @param node The node to make draggable (e.g., a Label in the palette).
     * @param blockType The type of block this node represents.
     */
    public void makeDraggable(Node node, AddableBlock blockType) {
        node.setOnDragDetected(event -> {
            Dragboard db = node.startDragAndDrop(TransferMode.COPY);
            ClipboardContent content = new ClipboardContent();
            // Store the enum name as a string.
            content.put(ADDABLE_BLOCK_FORMAT, blockType.name());
            db.setContent(content);
            System.out.println("Drag detected for: " + blockType.name()); // For debugging
            event.consume();
        });
    }

    /**
     * Creates a thin, transparent region to act as a separator and drop target.
     */
    public Region createSeparator() {
        Region separator = new Region();
        separator.setMinHeight(8);
        separator.setStyle("-fx-background-color: transparent;");
        return separator;
    }

    /**
     * Adds all necessary drag-and-drop event handlers to a separator region.
     * @param separator The region to add handlers to.
     * @param insertionIndex The index in the list where a drop should occur.
     * @param adjacentBlock The block next to the separator, for context (can be null).
     */
    public void addSeparatorDragHandlers(Region separator, BodyBlock targetBody, int insertionIndex, StatementBlock adjacentBlock) {
        String defaultColor = "transparent";
        String hoverColor = "#007bff"; // A distinct blue

        separator.setOnDragEntered(event -> {
            if (event.getDragboard().hasContent(BlockDragAndDropManager.ADDABLE_BLOCK_FORMAT)) {
                separator.setStyle("-fx-background-color: " + hoverColor + ";");
                String logMessage = "Hovering insertion point at index: " + insertionIndex;
                if (adjacentBlock != null) {
                    logMessage += " (next to: " + adjacentBlock.getDetails() + ")";
                }
                System.out.println(logMessage);
            }
            event.consume();
        });

        separator.setOnDragExited(event -> {
            separator.setStyle("-fx-background-color: " + defaultColor );
            event.consume();
        });

        separator.setOnDragOver(event -> {
            if (event.getDragboard().hasContent(BlockDragAndDropManager.ADDABLE_BLOCK_FORMAT)) {
                event.acceptTransferModes(TransferMode.COPY);
            }
            event.consume();
        });

        separator.setOnDragDropped(event -> {
            Dragboard db = event.getDragboard();
            boolean success = false;
            if (db.hasContent(ADDABLE_BLOCK_FORMAT)) {
                String blockTypeName = (String) db.getContent(ADDABLE_BLOCK_FORMAT);
                AddableBlock type = AddableBlock.valueOf(blockTypeName);
                onDrop.accept(new DropInfo(type, targetBody, insertionIndex));
                success = true;
            }
            event.setDropCompleted(success);
            event.consume();
        });
    }

    public void addEmptyBodyDropHandlers(Region target, BodyBlock targetBody) {
        target.setOnDragEntered(event -> {
            if (event.getDragboard().hasContent(ADDABLE_BLOCK_FORMAT)) {
                target.getStyleClass().add("empty-body-drop-hover");
            }
            event.consume();
        });

        target.setOnDragExited(event -> {
            target.getStyleClass().remove("empty-body-drop-hover");
            event.consume();
        });

        target.setOnDragOver(event -> {
            if (event.getDragboard().hasContent(ADDABLE_BLOCK_FORMAT)) {
                event.acceptTransferModes(TransferMode.COPY);
            }
            event.consume();
        });

        target.setOnDragDropped(event -> {
            Dragboard db = event.getDragboard();
            boolean success = false;
            if (db.hasContent(ADDABLE_BLOCK_FORMAT)) {
                String blockTypeName = (String) db.getContent(ADDABLE_BLOCK_FORMAT);
                AddableBlock type = AddableBlock.valueOf(blockTypeName);
                onDrop.accept(new DropInfo(type, targetBody, 0)); // Always index 0 for empty body
                success = true;
            }
            event.setDropCompleted(success);
            event.consume();
        });
    }

    public void addExpressionDropHandlers(Region target) {
        String defaultStyle = "-fx-background-color: #f0f0f0; -fx-border-color: #c0c0c0; -fx-border-style: dashed; -fx-min-width: 50; -fx-min-height: 25;";
        String hoverStyle = defaultStyle + "-fx-border-color: #007bff;"; // Highlight with blue

        target.setStyle(defaultStyle);

        target.setOnDragEntered(event -> {
            if (event.getDragboard().hasContent(ADDABLE_BLOCK_FORMAT)) {
                target.setStyle(hoverStyle);
                System.out.println("Hovering expression slot.");
            }
            event.consume();
        });

        target.setOnDragExited(event -> {
            target.setStyle(defaultStyle);
            event.consume();
        });

        target.setOnDragOver(event -> {
            if (event.getDragboard().hasContent(ADDABLE_BLOCK_FORMAT)) {
                event.acceptTransferModes(TransferMode.COPY);
            }
            event.consume();
        });

        target.setOnDragDropped(event -> {
            Dragboard db = event.getDragboard();
            boolean success = false;
            if (db.hasContent(ADDABLE_BLOCK_FORMAT)) {
                // For now, we just acknowledge the drop and show a message.
                // In the future, we would need a different DataFormat for expressions.
                String blockTypeName = (String) db.getContent(ADDABLE_BLOCK_FORMAT);
                System.out.println("Cannot drop a Statement block ('" + blockTypeName + "') into an Expression slot.");
                // We'll still mark it as a "successful" drop to finalize the gesture.
                success = true;
            }
            event.setDropCompleted(success);
            event.consume();
        });
    }
}

=================================================================================
FILE: main/java/com/botmaker/ui/DropInfo.java
=================================================================================

package com.botmaker.ui;

import com.botmaker.core.BodyBlock;

public record DropInfo(AddableBlock type, BodyBlock targetBody, int insertionIndex) {
}


=================================================================================
FILE: main/java/com/botmaker/ui/UIManager.java
=================================================================================

package com.botmaker.ui;

import com.botmaker.Main;
import com.botmaker.core.CodeBlock;
import com.botmaker.validation.ErrorTranslator;
import javafx.animation.PauseTransition;
import javafx.geometry.Insets;
import javafx.geometry.Orientation;
import javafx.scene.Node;
import javafx.scene.Scene;
import javafx.scene.control.*;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Priority;
import javafx.scene.layout.VBox;
import javafx.util.Duration;
import org.eclipse.lsp4j.Diagnostic;
import org.eclipse.lsp4j.DiagnosticSeverity;

import java.util.List;

public class UIManager {

    private final Main mainApp;
    private final BlockDragAndDropManager dragAndDropManager;
    private VBox blocksContainer;
    private Label statusLabel;
    private TextArea outputArea;
    private Button debugButton;
    private Button resumeButton;
    private ScrollPane scrollPane;
    private ListView<Diagnostic> errorListView;
    private TabPane bottomTabPane;


    public UIManager(Main mainApp, BlockDragAndDropManager dragAndDropManager) {
        this.mainApp = mainApp;
        this.dragAndDropManager = dragAndDropManager;
    }

    private boolean isDarkMode = false;

    public Scene createScene() {
        blocksContainer = new VBox(10);
        statusLabel = new Label("Ready");
        statusLabel.setId("status-label");

        // Initialize the components for the tabs
        outputArea = new TextArea();
        outputArea.setEditable(false);

        errorListView = new ListView<>();
        errorListView.setPlaceholder(new Label("No errors to display."));

        errorListView.setCellFactory(lv -> new ListCell<>() {
            @Override
            protected void updateItem(Diagnostic diagnostic, boolean empty) {
                super.updateItem(diagnostic, empty);
                getStyleClass().removeAll("error-cell", "warning-cell");

                if (empty || diagnostic == null) {
                    setText(null);
                    setOnMouseClicked(null);
                } else {
                    String message = ErrorTranslator.getShortSummary(diagnostic);
                    int line = diagnostic.getRange().getStart().getLine() + 1;
                    setText(String.format("Line %d: %s", line, message));

                    if (diagnostic.getSeverity() == DiagnosticSeverity.Error) {
                        getStyleClass().add("error-cell");
                    } else if (diagnostic.getSeverity() == DiagnosticSeverity.Warning) {
                        getStyleClass().add("warning-cell");
                    }

                    setOnMouseClicked(event -> {
                        if (event.getClickCount() >= 1) { // Use single-click
                            mainApp.getDiagnosticsManager().findBlockForDiagnostic(diagnostic)
                                    .ifPresent(this::scrollToBlock);
                        }
                    });
                }
            }

            private void scrollToBlock(CodeBlock block) {
                Node uiNode = block.getUINode();
                if (uiNode == null) return;

                // --- Blinking Animation ---
                final String blinkStyle = "error-block-blink";
                if (!uiNode.getStyleClass().contains(blinkStyle)) { // Prevent multiple animations
                    uiNode.getStyleClass().add(blinkStyle);
                    PauseTransition blinkOff = new PauseTransition(Duration.seconds(1));
                    blinkOff.setOnFinished(event -> uiNode.getStyleClass().remove(blinkStyle));
                    blinkOff.play();
                }
                // --- End Animation ---

                uiNode.requestFocus();
                double containerHeight = blocksContainer.getBoundsInLocal().getHeight();
                double blockY = uiNode.getBoundsInParent().getMinY();
                double scrollPaneHeight = scrollPane.getViewportBounds().getHeight();
                double vValue = blockY / (containerHeight - scrollPaneHeight);
                scrollPane.setVvalue(Math.max(0, Math.min(1, vValue)));
            }
        });

        // Create the TabPane
        bottomTabPane = new TabPane();
        Tab terminalTab = new Tab("Terminal", outputArea);
        terminalTab.setClosable(false);
        Tab errorsTab = new Tab("Errors", errorListView);
        errorsTab.setClosable(false);
        bottomTabPane.getTabs().addAll(terminalTab, errorsTab);


        HBox palette = createBlockPalette();
        palette.getStyleClass().add("palette");

        Button compileButton = new Button("Compile");
        compileButton.setOnAction(e -> mainApp.compileCode());

        Button runButton = new Button("Run");
        runButton.setOnAction(e -> {
            bottomTabPane.getSelectionModel().select(terminalTab);
            mainApp.runCode();
        });

        debugButton = new Button("Debug");
        debugButton.setOnAction(e -> mainApp.startDebugging());

        resumeButton = new Button("Resume");
        resumeButton.setDisable(true);
        resumeButton.setOnAction(e -> mainApp.resumeDebugging());

        HBox buttonBox = new HBox(10, compileButton, runButton, debugButton, resumeButton);

        Button themeButton = new Button("Toggle Theme");
        HBox topBar = new HBox(10, themeButton);

        scrollPane = new ScrollPane(blocksContainer);
        scrollPane.setFitToWidth(true);

        // Create a SplitPane for resizable vertical layout
        SplitPane splitPane = new SplitPane();
        splitPane.setOrientation(Orientation.VERTICAL);
        splitPane.getItems().addAll(scrollPane, bottomTabPane);
        splitPane.setDividerPositions(0.7); // 70% for code blocks, 30% for tabs

        VBox.setVgrow(splitPane, Priority.ALWAYS); // Make the SplitPane grow to fill space

        VBox root = new VBox(10, topBar, palette, buttonBox, splitPane, statusLabel);
        root.setPadding(new Insets(10));

        Scene scene = new Scene(root, 600, 800);
        scene.getStylesheets().add(getClass().getResource("/com/botmaker/styles.css").toExternalForm());
        root.getStyleClass().add("light-theme");

        themeButton.setOnAction(e -> {
            isDarkMode = !isDarkMode;
            root.getStyleClass().remove(isDarkMode ? "light-theme" : "dark-theme");
            root.getStyleClass().add(isDarkMode ? "dark-theme" : "light-theme");
        });

        return scene;
    }

    private HBox createBlockPalette() {
        HBox palette = new HBox(10);
        palette.setPadding(new Insets(5));

        for (AddableBlock blockType : AddableBlock.values()) {
            Label blockLabel = new Label(blockType.getDisplayName());
            blockLabel.getStyleClass().add("palette-block-label");
            blockLabel.getStyleClass().add("palette-" + blockType.name().toLowerCase() + "-label");
            dragAndDropManager.makeDraggable(blockLabel, blockType);
            palette.getChildren().add(blockLabel);
        }
        return palette;
    }

    public VBox getBlocksContainer() {
        return blocksContainer;
    }

    public Label getStatusLabel() {
        return statusLabel;
    }

    public TextArea getOutputArea() {
        return outputArea;
    }

    public void updateErrors(List<Diagnostic> diagnostics) {
        if (diagnostics == null) {
            errorListView.getItems().clear();
        } else {
            errorListView.getItems().setAll(diagnostics);
        }
        // If there are errors, automatically switch to the errors tab
        if (diagnostics != null && !diagnostics.isEmpty()) {
            bottomTabPane.getSelectionModel().select(1); // Select the second tab (Errors)
        }
    }


    public void onDebuggerStarted() {
        debugButton.setDisable(true);
    }

    public void onDebuggerPaused() {
        resumeButton.setDisable(false);
    }

    public void onDebuggerResumed() {
        resumeButton.setDisable(true);
    }

    public void onDebuggerFinished() {
        debugButton.setDisable(false);
        resumeButton.setDisable(true);
    }
}

=================================================================================
FILE: main/java/com/botmaker/util/TypeManager.java
=================================================================================

package com.botmaker.util;

import org.eclipse.jdt.core.dom.AST;
import org.eclipse.jdt.core.dom.PrimitiveType;
import org.eclipse.jdt.core.dom.Type;

import java.util.List;

public class TypeManager {

    private static final List<String> FUNDAMENTAL_TYPES = List.of(
        "int", "double", "boolean", "String", "long", "float", "char", "short", "byte"
    );

    /**
     * Returns a list of fundamental Java type names (primitives + String).
     */
    public static List<String> getFundamentalTypeNames() {
        return FUNDAMENTAL_TYPES;
    }

    /**
     * Creates a JDT AST Type node from a string representation of the type name.
     * Handles both primitive types and class/interface names.
     *
     * @param ast The AST instance to use for creating the node.
     * @param typeName The name of the type (e.g., "int", "String", "java.util.List").
     * @return The constructed Type node.
     */
    public static Type createTypeNode(AST ast, String typeName) {
        switch (typeName) {
            case "int": return ast.newPrimitiveType(PrimitiveType.INT);
            case "double": return ast.newPrimitiveType(PrimitiveType.DOUBLE);
            case "boolean": return ast.newPrimitiveType(PrimitiveType.BOOLEAN);
            case "char": return ast.newPrimitiveType(PrimitiveType.CHAR);
            case "long": return ast.newPrimitiveType(PrimitiveType.LONG);
            case "float": return ast.newPrimitiveType(PrimitiveType.FLOAT);
            case "short": return ast.newPrimitiveType(PrimitiveType.SHORT);
            case "byte": return ast.newPrimitiveType(PrimitiveType.BYTE);
            default:
                // For non-primitives, ast.newName() can handle simple and qualified names.
                return ast.newSimpleType(ast.newName(typeName));
        }
    }
}


=================================================================================
FILE: main/java/com/botmaker/validation/DiagnosticsManager.java
=================================================================================

package com.botmaker.validation;

import com.botmaker.core.CodeBlock;
import javafx.application.Platform;
import org.eclipse.jdt.core.dom.ASTNode;
import org.eclipse.lsp4j.Diagnostic;
import org.eclipse.lsp4j.DiagnosticSeverity;
import org.eclipse.lsp4j.PublishDiagnosticsParams;

import java.util.*;

public class DiagnosticsManager {

    private Map<ASTNode, CodeBlock> nodeToBlockMap;
    private String sourceCode;
    private final Set<CodeBlock> blocksWithErrors = new HashSet<>();
    private List<Diagnostic> lastDiagnostics = new ArrayList<>();

    // NEW: Track line numbers to blocks for fallback matching
    private Map<Integer, Set<CodeBlock>> lineToBlocksMap = new HashMap<>();

    public List<Diagnostic> getDiagnostics() {
        return lastDiagnostics;
    }

    public boolean hasErrors() {
        if (lastDiagnostics == null || lastDiagnostics.isEmpty()) {
            return false;
        }
        return lastDiagnostics.stream().anyMatch(d -> {
            DiagnosticSeverity severity = d.getSeverity();
            return severity == null || severity == DiagnosticSeverity.Error;
        });
    }

    public void updateSource(Map<ASTNode, CodeBlock> nodeToBlockMap, String sourceCode) {
        this.nodeToBlockMap = nodeToBlockMap;
        this.sourceCode = sourceCode;

        // Build line-to-block mapping for fallback
        buildLineToBlockMap();
    }

    /**
     * Builds a map from line numbers to blocks for fallback matching
     * when AST node matching fails.
     */
    private void buildLineToBlockMap() {
        lineToBlocksMap.clear();

        if (nodeToBlockMap == null || sourceCode == null) {
            return;
        }

        for (Map.Entry<ASTNode, CodeBlock> entry : nodeToBlockMap.entrySet()) {
            ASTNode node = entry.getKey();
            CodeBlock block = entry.getValue();

            // Calculate which lines this node spans
            int startLine = getLineNumber(node.getStartPosition());
            int endLine = getLineNumber(node.getStartPosition() + node.getLength());

            // Add block to all lines it spans
            for (int line = startLine; line <= endLine; line++) {
                lineToBlocksMap.computeIfAbsent(line, k -> new HashSet<>()).add(block);
            }
        }
    }

    public void processDiagnostics(List<Diagnostic> diagnostics) {
        this.lastDiagnostics = diagnostics;

        // Clear previous errors
        for (CodeBlock block : blocksWithErrors) {
            block.clearError();
        }
        blocksWithErrors.clear();

        if (nodeToBlockMap == null) return;

        // Process new diagnostics
        for (Diagnostic diagnostic : diagnostics) {
            // Only show errors, not warnings (unless you want warnings too)
            if (diagnostic.getSeverity() != DiagnosticSeverity.Error) {
                continue;
            }

            Optional<CodeBlock> blockOpt = findBlockForDiagnostic(diagnostic);

            if (blockOpt.isPresent()) {
                CodeBlock block = blockOpt.get();

                // Use translated error message
                String userFriendlyMessage = ErrorTranslator.getShortSummary(diagnostic);
                String suggestion = ErrorTranslator.getSuggestion(diagnostic);

                block.setError(userFriendlyMessage + "\n" + suggestion);
                blocksWithErrors.add(block);
            } else {
                // Log unmapped diagnostics for debugging
                System.err.println("Warning: Could not map diagnostic to block: " +
                        diagnostic.getMessage() + " at line " +
                        (diagnostic.getRange().getStart().getLine() + 1));
            }
        }
    }

    /**
     * Finds the code block responsible for a diagnostic.
     * Uses multiple strategies for better matching.
     */
    public Optional<CodeBlock> findBlockForDiagnostic(Diagnostic diagnostic) {
        // Strategy 1: Precise AST node matching (best)
        Optional<CodeBlock> block = findBlockByASTNode(diagnostic);
        if (block.isPresent()) {
            return block;
        }

        // Strategy 2: Line-based fallback (good for edge cases)
        block = findBlockByLine(diagnostic);
        if (block.isPresent()) {
            return block;
        }

        // Strategy 3: Parent node search (for nested expressions)
        return findBlockByParentNode(diagnostic);
    }

    /**
     * Strategy 1: Find block by matching AST node ranges
     */
    private Optional<CodeBlock> findBlockByASTNode(Diagnostic diagnostic) {
        int startOffset = getOffsetFromPosition(diagnostic.getRange().getStart());
        int endOffset = getOffsetFromPosition(diagnostic.getRange().getEnd());

        // Find the most specific (smallest) block that contains the diagnostic range
        ASTNode bestNode = null;
        int bestLength = Integer.MAX_VALUE;

        for (ASTNode node : nodeToBlockMap.keySet()) {
            int nodeStart = node.getStartPosition();
            int nodeEnd = nodeStart + node.getLength();

            // Check if node contains the diagnostic range
            if (nodeStart <= startOffset && nodeEnd >= endOffset) {
                int nodeLength = node.getLength();

                // Prefer the smallest containing node
                if (nodeLength < bestLength) {
                    bestNode = node;
                    bestLength = nodeLength;
                }
            }
        }

        return Optional.ofNullable(bestNode).map(nodeToBlockMap::get);
    }

    /**
     * Strategy 2: Find block by line number (fallback)
     */
    private Optional<CodeBlock> findBlockByLine(Diagnostic diagnostic) {
        int line = diagnostic.getRange().getStart().getLine();

        Set<CodeBlock> blocksOnLine = lineToBlocksMap.get(line);
        if (blocksOnLine == null || blocksOnLine.isEmpty()) {
            return Optional.empty();
        }

        // If multiple blocks on same line, prefer the first one
        // (Could be improved with more sophisticated heuristics)
        return blocksOnLine.stream().findFirst();
    }

    /**
     * Strategy 3: Find block by searching parent nodes
     */
    private Optional<CodeBlock> findBlockByParentNode(Diagnostic diagnostic) {
        int startOffset = getOffsetFromPosition(diagnostic.getRange().getStart());

        // Find any node that contains the start position
        for (ASTNode node : nodeToBlockMap.keySet()) {
            int nodeStart = node.getStartPosition();
            int nodeEnd = nodeStart + node.getLength();

            if (nodeStart <= startOffset && nodeEnd >= startOffset) {
                return Optional.of(nodeToBlockMap.get(node));
            }
        }

        return Optional.empty();
    }

    /**
     * Converts LSP position to source code offset
     */
    private int getOffsetFromPosition(org.eclipse.lsp4j.Position pos) {
        int line = pos.getLine();
        int character = pos.getCharacter();
        int offset = 0;
        int currentLine = 0;

        if (sourceCode == null) return 0;

        while (currentLine < line && offset < sourceCode.length()) {
            if (sourceCode.charAt(offset) == '\n') {
                currentLine++;
            }
            offset++;
        }

        return offset + character;
    }

    /**
     * Gets line number from character offset
     */
    private int getLineNumber(int offset) {
        if (sourceCode == null || offset < 0) return 0;

        int line = 0;
        for (int i = 0; i < Math.min(offset, sourceCode.length()); i++) {
            if (sourceCode.charAt(i) == '\n') {
                line++;
            }
        }
        return line;
    }

    /**
     * Get all blocks that have errors (useful for UI highlighting)
     */
    public Set<CodeBlock> getBlocksWithErrors() {
        return Collections.unmodifiableSet(blocksWithErrors);
    }

    /**
     * Check if a specific block has errors
     */
    public boolean hasError(CodeBlock block) {
        return blocksWithErrors.contains(block);
    }

    /**
     * Get diagnostics for a specific block
     */
    public List<Diagnostic> getDiagnosticsForBlock(CodeBlock block) {
        if (lastDiagnostics == null || nodeToBlockMap == null) {
            return Collections.emptyList();
        }

        List<Diagnostic> blockDiagnostics = new ArrayList<>();

        for (Diagnostic diagnostic : lastDiagnostics) {
            Optional<CodeBlock> diagBlock = findBlockForDiagnostic(diagnostic);
            if (diagBlock.isPresent() && diagBlock.get() == block) {
                blockDiagnostics.add(diagnostic);
            }
        }

        return blockDiagnostics;
    }

    /**
     * Get a summary of all errors (useful for status bar)
     */
    public String getErrorSummary() {
        if (!hasErrors()) {
            return "✅ No errors";
        }

        long errorCount = lastDiagnostics.stream()
                .filter(d -> d.getSeverity() == DiagnosticSeverity.Error)
                .count();

        long warningCount = lastDiagnostics.stream()
                .filter(d -> d.getSeverity() == DiagnosticSeverity.Warning)
                .count();

        StringBuilder summary = new StringBuilder();
        if (errorCount > 0) {
            summary.append(String.format("❌ %d error%s", errorCount, errorCount == 1 ? "" : "s"));
        }
        if (warningCount > 0) {
            if (summary.length() > 0) summary.append(", ");
            summary.append(String.format("⚠️ %d warning%s", warningCount, warningCount == 1 ? "" : "s"));
        }

        return summary.toString();
    }
}

=================================================================================
FILE: main/java/com/botmaker/validation/ErrorTranslator.java
=================================================================================

package com.botmaker.validation;

import org.eclipse.lsp4j.Diagnostic;
import org.eclipse.lsp4j.DiagnosticSeverity;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class ErrorTranslator {

    private static final Map<Integer, ErrorInfo> ERROR_MAPPINGS = new HashMap<>();
    private static final Pattern ERROR_CODE_PATTERN = Pattern.compile("\\b(\\d{7,})\\b");

    static class ErrorInfo {
        String userMessage;
        String suggestion;
        DiagnosticSeverity severity;

        ErrorInfo(String userMessage, String suggestion, DiagnosticSeverity severity) {
            this.userMessage = userMessage;
            this.suggestion = suggestion;
            this.severity = severity;
        }

        ErrorInfo(String userMessage, String suggestion) {
            this(userMessage, suggestion, DiagnosticSeverity.Error);
        }
    }

    static {
        // PRIORITY 1: Critical Errors (Must Handle)

        // 16777233 - TypeMismatch
        ERROR_MAPPINGS.put(16777233, new ErrorInfo(
                "Wrong type used: You're trying to use a {0} where a {1} is expected",
                "Check that you're using the right type of value (number, text, true/false, etc.)"
        ));

        // 570425394 - UndefinedName (Variable doesn't exist)
        ERROR_MAPPINGS.put(570425394, new ErrorInfo(
                "Variable or name '{0}' doesn't exist",
                "Did you forget to create this variable? Check for typos in the name."
        ));

        // 536870963 - UninitializedLocalVariable
        ERROR_MAPPINGS.put(536870963, new ErrorInfo(
                "Variable '{0}' is used before being given a value",
                "Set a value to this variable before using it."
        ));

        // 536870967 - RedefinedLocal (Duplicate variable)
        ERROR_MAPPINGS.put(536870967, new ErrorInfo(
                "A variable named '{0}' already exists",
                "Choose a different name or remove the duplicate variable."
        ));

        // 67108979 - ParameterMismatch
        ERROR_MAPPINGS.put(67108979, new ErrorInfo(
                "Wrong number of parameters: Expected {0} but got {1}",
                "Check how many inputs this function needs."
        ));

        // 603979884 - ShouldReturnValue
        ERROR_MAPPINGS.put(603979884, new ErrorInfo(
                "This function must return a value",
                "Add a return statement with a value at the end of the function."
        ));

        // PRIORITY 2: Type System Errors

        // 16777218 - UndefinedType
        ERROR_MAPPINGS.put(16777218, new ErrorInfo(
                "Type '{0}' cannot be found",
                "This type doesn't exist. Check for typos or missing imports."
        ));

        // 67108964 - UndefinedMethod
        ERROR_MAPPINGS.put(67108964, new ErrorInfo(
                "Method '{0}' doesn't exist",
                "Check the spelling of the method name or if it's available."
        ));

        // 33554502 - UndefinedField
        ERROR_MAPPINGS.put(33554502, new ErrorInfo(
                "Field '{0}' doesn't exist",
                "This field is not defined. Check the name and spelling."
        ));

        // PRIORITY 3: Syntax Errors (If user can edit code)

        // 1610612960 - MissingSemiColon
        ERROR_MAPPINGS.put(1610612960, new ErrorInfo(
                "Missing semicolon (;) at the end of the line",
                "Add a semicolon (;) at the end of this statement."
        ));

        // 1610612995 - UnterminatedString
        ERROR_MAPPINGS.put(1610612995, new ErrorInfo(
                "Text is missing a closing quote",
                "Add a closing quote (\") at the end of the text."
        ));

        // 1610612941 - ParsingErrorNoSuggestion
        ERROR_MAPPINGS.put(1610612941, new ErrorInfo(
                "Syntax error: The code structure is incorrect",
                "Check for missing brackets, parentheses, or other syntax issues."
        ));

        // 1610612956 - UnmatchedBracket
        ERROR_MAPPINGS.put(1610612956, new ErrorInfo(
                "Unmatched bracket - missing opening or closing bracket",
                "Check that all { } brackets are properly paired."
        ));

        // PRIORITY 4: Flow Control

        // 536870908 - InvalidBreak
        ERROR_MAPPINGS.put(536870908, new ErrorInfo(
                "'break' can only be used inside a loop or switch",
                "Move this break statement inside a loop block."
        ));

        // 536870909 - InvalidContinue
        ERROR_MAPPINGS.put(536870909, new ErrorInfo(
                "'continue' can only be used inside a loop",
                "Move this continue statement inside a loop block."
        ));

        // 536870161 - CodeCannotBeReached
        ERROR_MAPPINGS.put(536870161, new ErrorInfo(
                "This code will never run (unreachable code)",
                "Remove this code or fix the logic that prevents it from running.",
                DiagnosticSeverity.Warning
        ));

        // PRIORITY 5: Warnings

        // 536870973 - LocalVariableIsNeverUsed
        ERROR_MAPPINGS.put(536870973, new ErrorInfo(
                "Variable '{0}' is created but never used",
                "Remove this variable or use it somewhere in your code.",
                DiagnosticSeverity.Warning
        ));

        // 536870974 - ArgumentIsNeverUsed
        ERROR_MAPPINGS.put(536870974, new ErrorInfo(
                "Parameter '{0}' is never used",
                "Remove this parameter or use it in the function.",
                DiagnosticSeverity.Warning
        ));

        // 536871185 - AssignmentHasNoEffect
        ERROR_MAPPINGS.put(536871185, new ErrorInfo(
                "This assignment does nothing",
                "You're assigning a variable to itself. Remove this line or fix the logic.",
                DiagnosticSeverity.Warning
        ));
    }

    /**
     * Extracts the JDT error code from a diagnostic message
     */
    private static Integer extractErrorCode(String message) {
        Matcher matcher = ERROR_CODE_PATTERN.matcher(message);
        if (matcher.find()) {
            try {
                return Integer.parseInt(matcher.group(1));
            } catch (NumberFormatException e) {
                return null;
            }
        }
        return null;
    }

    /**
     * Translates diagnostics to user-friendly messages
     */
    public static String translate(List<Diagnostic> diagnostics) {
        if (diagnostics == null || diagnostics.isEmpty()) {
            return "✅ No errors found. Your code looks good!";
        }

        StringBuilder result = new StringBuilder();
        int errorCount = 0;
        int warningCount = 0;

        for (Diagnostic diagnostic : diagnostics) {
            if (diagnostic.getSeverity() == DiagnosticSeverity.Error) {
                errorCount++;
            } else if (diagnostic.getSeverity() == DiagnosticSeverity.Warning) {
                warningCount++;
            }
        }

        if (errorCount > 0) {
            result.append(String.format("❌ Found %d error%s:\n\n", errorCount, errorCount == 1 ? "" : "s"));
        }
        if (warningCount > 0) {
            result.append(String.format("⚠️  Found %d warning%s:\n\n", warningCount, warningCount == 1 ? "" : "s"));
        }

        for (Diagnostic diagnostic : diagnostics) {
            String icon = diagnostic.getSeverity() == DiagnosticSeverity.Error ? "❌" : "⚠️";
            int lineNumber = diagnostic.getRange().getStart().getLine() + 1;

            String translated = translateSingleDiagnostic(diagnostic);
            result.append(String.format("%s Line %d: %s\n\n", icon, lineNumber, translated));
        }

        return result.toString().trim();
    }

    /**
     * Translates a single diagnostic to a user-friendly message
     */
    public static String translateSingleDiagnostic(Diagnostic diagnostic) {
        String originalMessage = diagnostic.getMessage();

        // Try to extract error code
        Integer errorCode = extractErrorCode(originalMessage);

        if (errorCode != null && ERROR_MAPPINGS.containsKey(errorCode)) {
            ErrorInfo info = ERROR_MAPPINGS.get(errorCode);

            // Try to extract variable/type names from the original message
            String enrichedMessage = enrichMessage(info.userMessage, originalMessage);

            return String.format("%s\n   💡 %s", enrichedMessage, info.suggestion);
        }

        // Fallback: Try pattern matching for common error messages (backward compatibility)
        return translateByPattern(originalMessage);
    }

    /**
     * Enriches the user message with context from the original error message
     */
    private static String enrichMessage(String template, String originalMessage) {
        // Extract quoted strings (variable names, type names, etc.)
        Pattern quotedPattern = Pattern.compile("'([^']+)'|\"([^\"]+)\"");
        Matcher matcher = quotedPattern.matcher(originalMessage);

        int index = 0;
        String result = template;
        while (matcher.find() && result.contains("{" + index + "}")) {
            String value = matcher.group(1) != null ? matcher.group(1) : matcher.group(2);
            result = result.replace("{" + index + "}", "'" + value + "'");
            index++;
        }

        // Remove unreplaced placeholders
        result = result.replaceAll("\\{\\d+\\}", "the value");

        return result;
    }

    /**
     * Fallback pattern-based translation (for backward compatibility)
     */
    private static String translateByPattern(String message) {
        if (message.contains("cannot be resolved to a type")) {
            return "A type or class could not be found.\n   💡 Check for typos or if the type exists.";
        }
        if (message.contains("cannot be resolved")) {
            return "A variable, method, or name could not be found.\n   💡 Check for typos or if it was declared.";
        }
        if (message.contains("Syntax error, insert")) {
            try {
                String suggestion = message.split("insert \"")[1].split("\" to")[0];
                return String.format("Syntax error: Something is missing.\n   💡 Try adding '%s'", suggestion);
            } catch (Exception e) {
                return "Syntax error: Something is missing in the code structure.\n   💡 Check for missing semicolons, brackets, or parentheses.";
            }
        }
        if (message.contains("incompatible types") || message.contains("Type mismatch")) {
            return "Wrong type used: You're using a value of the wrong type.\n   💡 Make sure you're using the right kind of value (number, text, etc.)";
        }
        if (message.contains("might not have been initialized")) {
            return "Variable used before being set.\n   💡 Give this variable a value before using it.";
        }
        if (message.contains("is not a statement")) {
            return "This line is not a valid statement.\n   💡 It might be an incomplete expression or command.";
        }
        if (message.contains("Duplicate local variable")) {
            return "A variable with this name already exists.\n   💡 Choose a different name for this variable.";
        }

        // Return original message if no translation found
        return message;
    }

    /**
     * Get a short summary for UI display (e.g., tooltip)
     */
    public static String getShortSummary(Diagnostic diagnostic) {
        String originalMessage = diagnostic.getMessage();
        Integer errorCode = extractErrorCode(originalMessage);

        if (errorCode != null && ERROR_MAPPINGS.containsKey(errorCode)) {
            ErrorInfo info = ERROR_MAPPINGS.get(errorCode);
            return enrichMessage(info.userMessage, originalMessage);
        }

        // Fallback: Return first line of original message
        return originalMessage.split("\n")[0];
    }

    /**
     * Get just the suggestion part
     */
    public static String getSuggestion(Diagnostic diagnostic) {
        String originalMessage = diagnostic.getMessage();
        Integer errorCode = extractErrorCode(originalMessage);

        if (errorCode != null && ERROR_MAPPINGS.containsKey(errorCode)) {
            return ERROR_MAPPINGS.get(errorCode).suggestion;
        }

        return "Check your code for issues.";
    }
}


