=================================================================================
FILE: ./src/main/java/com/botmaker/blocks/AssignmentBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractStatementBlock;
import com.botmaker.core.ExpressionBlock;
import com.botmaker.lsp.CompletionContext;
import com.botmaker.ui.AddableExpression;
import javafx.geometry.Pos;
import javafx.scene.Node;
import javafx.scene.control.Button;
import javafx.scene.control.ComboBox;
import javafx.scene.control.ContextMenu;
import javafx.scene.control.MenuItem;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Pane;
import javafx.scene.layout.Priority;
import org.eclipse.jdt.core.dom.*;



public class AssignmentBlock extends AbstractStatementBlock {

    private ExpressionBlock leftHandSide;
    private ExpressionBlock rightHandSide;
    private String operator;

    private static final String[] OPERATOR_NAMES = {
            "set to", "add", "subtract", "multiply by", "divide by", "increment", "decrement"
    };

    private static final String[] OPERATOR_SYMBOLS = {
            "=", "+=", "-=", "*=", "/=", "++", "--"
    };

    public AssignmentBlock(String id, ExpressionStatement astNode) {
        super(id, astNode);

        if (astNode.getExpression() instanceof Assignment) {
            Assignment assignment = (Assignment) astNode.getExpression();
            this.operator = assignment.getOperator().toString();
        } else if (astNode.getExpression() instanceof PostfixExpression) {
            PostfixExpression postfix = (PostfixExpression) astNode.getExpression();
            this.operator = postfix.getOperator().toString();
        } else if (astNode.getExpression() instanceof PrefixExpression) {
            PrefixExpression prefix = (PrefixExpression) astNode.getExpression();
            this.operator = prefix.getOperator().toString();
        } else {
            this.operator = "=";
        }
    }

    public ExpressionBlock getLeftHandSide() {
        return leftHandSide;
    }

    public void setLeftHandSide(ExpressionBlock leftHandSide) {
        this.leftHandSide = leftHandSide;
    }

    public ExpressionBlock getRightHandSide() {
        return rightHandSide;
    }

    public void setRightHandSide(ExpressionBlock rightHandSide) {
        this.rightHandSide = rightHandSide;
    }

    public String getOperator() {
        return operator;
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        HBox container = new HBox(5);
        container.setAlignment(Pos.CENTER_LEFT);
        container.getStyleClass().add("assignment-block");

        // Left hand side
        if (leftHandSide != null) {
            container.getChildren().add(leftHandSide.getUINode(context));
        }

        // Operator selector
        ComboBox<String> operatorSelector = new ComboBox<>();
        operatorSelector.getItems().addAll(OPERATOR_NAMES);
        operatorSelector.getStyleClass().add("operator-selector");
        operatorSelector.setEditable(false);

        String currentName = getOperatorDisplayName(operator);
        operatorSelector.setValue(currentName);

        operatorSelector.setOnAction(e -> {
            String selectedName = operatorSelector.getValue();
            String newOperator = getOperatorSymbol(selectedName);

            // Only update if it actually changed
            if (newOperator != null && !newOperator.equals(this.operator)) {
                this.operator = newOperator;

                if (this.astNode instanceof ExpressionStatement) {
                    org.eclipse.jdt.core.dom.Expression expr = ((ExpressionStatement) this.astNode).getExpression();
                    context.codeEditor().updateAssignmentOperator(expr, newOperator);
                }
            }
        });

        container.getChildren().add(operatorSelector);

        // Right hand side (only for non-increment/decrement)
        if (!operator.equals("++") && !operator.equals("--")) {
            if (rightHandSide != null) {
                container.getChildren().add(rightHandSide.getUINode(context));
            }

            // + Button for changing right side expression
            Button addButton = new Button("+");
            addButton.getStyleClass().add("expression-add-button");
            addButton.setOnAction(e -> showExpressionMenu(addButton, context));
            container.getChildren().add(addButton);
        }

        // Spacer and delete button
        Pane spacer = new Pane();
        HBox.setHgrow(spacer, Priority.ALWAYS);

        Button deleteButton = new Button("X");
        deleteButton.setOnAction(e -> {
            context.codeEditor().deleteStatement((org.eclipse.jdt.core.dom.Statement) this.astNode);
        });

        container.getChildren().addAll(spacer, deleteButton);

        return container;
    }

    private void showExpressionMenu(Button button, CompletionContext context) {
        ContextMenu menu = new ContextMenu();
        menu.setStyle("-fx-control-inner-background: white;");

        // FIXED: Determine the target type from the left-hand side
        String targetType = "any";
        if (leftHandSide != null && leftHandSide.getAstNode() != null) {
            org.eclipse.jdt.core.dom.Expression lhsExpr = (org.eclipse.jdt.core.dom.Expression) leftHandSide.getAstNode();
            org.eclipse.jdt.core.dom.ITypeBinding binding = lhsExpr.resolveTypeBinding();
            if (binding != null) {
                targetType = com.botmaker.util.TypeManager.determineUiType(binding.getName());
            }
        }

        // FIXED: Filter expressions based on target type
        for (com.botmaker.ui.AddableExpression type : com.botmaker.ui.AddableExpression.getForType(targetType)) {
            MenuItem menuItem = new MenuItem(type.getDisplayName());
            menuItem.setStyle("-fx-text-fill: black;");

            menuItem.setOnAction(e -> {
                if (rightHandSide != null) {
                    org.eclipse.jdt.core.dom.Expression toReplace = (org.eclipse.jdt.core.dom.Expression) rightHandSide.getAstNode();
                    context.codeEditor().replaceExpression(toReplace, type);
                }
            });
            menu.getItems().add(menuItem);
        }

        menu.show(button, javafx.geometry.Side.BOTTOM, 0, 0);
    }

    private String getOperatorDisplayName(String symbol) {
        for (int i = 0; i < OPERATOR_SYMBOLS.length; i++) {
            if (OPERATOR_SYMBOLS[i].equals(symbol)) {
                return OPERATOR_NAMES[i];
            }
        }
        return "set to";
    }

    private String getOperatorSymbol(String displayName) {
        for (int i = 0; i < OPERATOR_NAMES.length; i++) {
            if (OPERATOR_NAMES[i].equals(displayName)) {
                return OPERATOR_SYMBOLS[i];
            }
        }
        return "=";
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/blocks/BinaryExpressionBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractExpressionBlock;
import com.botmaker.core.ExpressionBlock;
import com.botmaker.lsp.CompletionContext;
import javafx.geometry.Pos;
import javafx.scene.Node;
import javafx.scene.control.ComboBox;
import javafx.scene.control.Label;
import javafx.scene.layout.HBox;
import org.eclipse.jdt.core.dom.ITypeBinding;
import org.eclipse.jdt.core.dom.InfixExpression;

public class BinaryExpressionBlock extends AbstractExpressionBlock {

    private ExpressionBlock leftOperand;
    private ExpressionBlock rightOperand;
    private String operator;
    private final ITypeBinding returnType;

    // Math operator display names (user-friendly)
    private static final String[] MATH_OPERATOR_NAMES = {
            "plus",         // +
            "minus",        // -
            "times",        // *
            "divided by",   // /
            "modulo"        // %
    };

    // Corresponding Java operators
    private static final String[] MATH_OPERATOR_SYMBOLS = {
            "+", "-", "*", "/", "%"
    };

    public BinaryExpressionBlock(String id, InfixExpression astNode) {
        super(id, astNode);
        this.operator = astNode.getOperator().toString();
        this.returnType = astNode.resolveTypeBinding();
    }

    public ExpressionBlock getLeftOperand() {
        return leftOperand;
    }

    public void setLeftOperand(ExpressionBlock leftOperand) {
        this.leftOperand = leftOperand;
    }

    public ExpressionBlock getRightOperand() {
        return rightOperand;
    }

    public void setRightOperand(ExpressionBlock rightOperand) {
        this.rightOperand = rightOperand;
    }

    public String getOperator() {
        return operator;
    }

    public ITypeBinding getReturnType() {
        return returnType;
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        HBox container = new HBox(5);
        container.setAlignment(Pos.CENTER_LEFT);
        container.getStyleClass().add("binary-expression-block");

        HBox expressionBox = new HBox(5);
        expressionBox.setAlignment(Pos.CENTER_LEFT);

        // Left operand
        if (leftOperand != null) {
            expressionBox.getChildren().add(leftOperand.getUINode(context));
        }

        // Check if this is a math operator or comparison/logical operator
        if (isMathOperator(operator)) {
            // Operator selector for math operations
            ComboBox<String> operatorSelector = new ComboBox<>();
            operatorSelector.getItems().addAll(MATH_OPERATOR_NAMES);
            operatorSelector.getStyleClass().add("math-operator-selector");

            // Set current operator
            String currentName = getOperatorDisplayName(operator);
            operatorSelector.setValue(currentName);

            // Handle operator change
            operatorSelector.setOnAction(e -> {
                String selectedName = operatorSelector.getValue();
                String newOperator = getOperatorSymbol(selectedName);
                if (newOperator != null && !newOperator.equals(operator)) {
                    this.operator = newOperator;
                    System.out.println("Math operator changed to: " + newOperator);
                    // Note: Operator change will take effect on next code regeneration
                }
            });

            expressionBox.getChildren().add(operatorSelector);
        } else {
            // For non-math operators (comparisons, logical), just show the symbol
            Label operatorLabel = new Label(operator);
            operatorLabel.getStyleClass().add("operator-label");
            expressionBox.getChildren().add(operatorLabel);
        }

        // Right operand
        if (rightOperand != null) {
            expressionBox.getChildren().add(rightOperand.getUINode(context));
        }

        container.getChildren().add(expressionBox);

        // Type indicator (optional, can be removed if too cluttered)
        String typeName = "unknown";
        if (returnType != null) {
            typeName = returnType.getName();
        }
        Label typeLabel = new Label("→ " + typeName);
        typeLabel.setStyle("-fx-font-style: italic; -fx-text-fill: #999; -fx-font-size: 10px;");
        container.getChildren().add(typeLabel);

        return container;
    }

    /**
     * Check if operator is a math operator
     */
    private boolean isMathOperator(String op) {
        for (String mathOp : MATH_OPERATOR_SYMBOLS) {
            if (mathOp.equals(op)) {
                return true;
            }
        }
        return false;
    }

    /**
     * Convert operator symbol to display name
     */
    private String getOperatorDisplayName(String symbol) {
        for (int i = 0; i < MATH_OPERATOR_SYMBOLS.length; i++) {
            if (MATH_OPERATOR_SYMBOLS[i].equals(symbol)) {
                return MATH_OPERATOR_NAMES[i];
            }
        }
        return symbol; // Return as-is if not found
    }

    /**
     * Convert display name to operator symbol
     */
    private String getOperatorSymbol(String displayName) {
        for (int i = 0; i < MATH_OPERATOR_NAMES.length; i++) {
            if (MATH_OPERATOR_NAMES[i].equals(displayName)) {
                return MATH_OPERATOR_SYMBOLS[i];
            }
        }
        return "+"; // default
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/blocks/BooleanLiteralBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractExpressionBlock;
import com.botmaker.lsp.CompletionContext;
import javafx.geometry.Pos;
import javafx.scene.Node;
import javafx.scene.control.ComboBox;
import javafx.scene.control.Label;
import javafx.scene.layout.StackPane;
import org.eclipse.jdt.core.dom.BooleanLiteral;

/**
 * Block for true/false values with improved UI (Toggle Switch style)
 */
public class BooleanLiteralBlock extends AbstractExpressionBlock {

    private boolean value;

    public BooleanLiteralBlock(String id, BooleanLiteral astNode) {
        super(id, astNode);
        this.value = astNode.booleanValue();
    }

    public boolean getValue() {
        return value;
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        StackPane root = new StackPane();
        root.getStyleClass().add("boolean-literal-block");

        // Define colors
        String trueColor = "#2ecc71"; // Emerald Green
        String falseColor = "#e74c3c"; // Alizarin Red
        String currentColor = value ? trueColor : falseColor;

        // 1. The invisible functional dropdown
        ComboBox<String> booleanSelector = new ComboBox<>();
        booleanSelector.getItems().addAll("true", "false");
        booleanSelector.setValue(value ? "true" : "false");

        // Make the combo box fill the area but be invisible
        // We use opacity 0 so the user can still click it, but sees the label behind it
        booleanSelector.setStyle("-fx-opacity: 0; -fx-cursor: hand;");
        booleanSelector.setMaxSize(Double.MAX_VALUE, Double.MAX_VALUE);

        // 2. The visible label (pill shape)
        Label displayLabel = new Label(value ? "TRUE" : "FALSE");
        displayLabel.setStyle(
                "-fx-text-fill: white; " +
                        "-fx-font-weight: bold; " +
                        "-fx-font-size: 11px; " +
                        "-fx-font-family: 'Segoe UI', sans-serif;" +
                        "-fx-padding: 3 10 3 10;" +
                        "-fx-background-color: " + currentColor + ";" +
                        "-fx-background-radius: 12;" // Pill shape
        );

        // Center the label
        StackPane.setAlignment(displayLabel, Pos.CENTER);

        // Handle value change
        booleanSelector.setOnAction(e -> {
            String selected = booleanSelector.getValue();
            boolean newValue = "true".equals(selected);

            if (newValue != value) {
                this.value = newValue;
                // Update logic
                context.codeEditor().replaceLiteralValue(
                        (org.eclipse.jdt.core.dom.Expression) this.astNode,
                        String.valueOf(newValue)
                );
                // Immediate UI feedback (before full rebuild)
                displayLabel.setText(newValue ? "TRUE" : "FALSE");
                displayLabel.setStyle(displayLabel.getStyle().replace(currentColor, newValue ? trueColor : falseColor));
            }
        });

        root.getChildren().addAll(displayLabel, booleanSelector);

        // Force specific size to look neat
        root.setMinWidth(60);
        root.setMaxHeight(24);

        return root;
    }

    @Override
    public String getDetails() {
        return "Boolean: " + value;
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/blocks/BreakBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractStatementBlock;
import com.botmaker.lsp.CompletionContext;
import javafx.geometry.Pos;
import javafx.scene.Node;
import javafx.scene.control.Label;
import javafx.scene.layout.HBox;
import org.eclipse.jdt.core.dom.BreakStatement;

public class BreakBlock extends AbstractStatementBlock {

    public BreakBlock(String id, BreakStatement astNode) {
        super(id, astNode);
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        HBox container = new HBox(5);
        container.setAlignment(Pos.CENTER_LEFT);
        container.getStyleClass().add("break-block");

        Label breakLabel = new Label("break");
        breakLabel.getStyleClass().add("keyword-label");

        // Add spacer and delete button
        javafx.scene.layout.Pane spacer = new javafx.scene.layout.Pane();
        HBox.setHgrow(spacer, javafx.scene.layout.Priority.ALWAYS);

        javafx.scene.control.Button deleteButton = new javafx.scene.control.Button("X");
        deleteButton.setOnAction(e -> {
            context.codeEditor().deleteStatement((org.eclipse.jdt.core.dom.Statement) this.astNode);
        });

        container.getChildren().addAll(breakLabel, spacer, deleteButton);
        return container;
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/blocks/CommentBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractStatementBlock;
import com.botmaker.lsp.CompletionContext;
import javafx.geometry.Pos;
import javafx.scene.Node;
import javafx.scene.control.Button;
import javafx.scene.control.TextField;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Pane;
import javafx.scene.layout.Priority;
import org.eclipse.jdt.core.dom.Comment;

public class CommentBlock extends AbstractStatementBlock {

    private String commentText;

    public CommentBlock(String id, Comment astNode, String commentText) {
        super(id, astNode);
        this.commentText = commentText;
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        HBox container = new HBox(5);
        container.setAlignment(Pos.CENTER_LEFT);
        container.getStyleClass().add("comment-block");

        // Simple user-friendly label
        javafx.scene.control.Label commentLabel = new javafx.scene.control.Label("Comment:");
        commentLabel.getStyleClass().add("comment-indicator");

        // Text Field
        TextField commentField = new TextField(commentText != null ? commentText : "");
        commentField.setPromptText("Write your note here...");
        commentField.getStyleClass().add("comment-text-field");
        HBox.setHgrow(commentField, Priority.ALWAYS);

        // Save on Focus Lost
        commentField.focusedProperty().addListener((obs, oldVal, newVal) -> {
            if (!newVal) {
                if (!commentField.getText().equals(commentText)) {
                    this.commentText = commentField.getText();
                    rebuildCode(context);
                }
            }
        });

        // Save on Enter
        commentField.setOnAction(e -> {
            this.commentText = commentField.getText();
            rebuildCode(context);
            container.requestFocus();
        });

        Pane spacer = new Pane();
        HBox.setHgrow(spacer, Priority.ALWAYS);

        // Delete Button
        Button deleteButton = new Button("X");
        deleteButton.setOnAction(e -> {
            context.codeEditor().deleteComment((Comment) this.astNode);
        });

        container.getChildren().addAll(commentLabel, commentField, spacer, deleteButton);
        return container;
    }

    private void rebuildCode(CompletionContext context) {
        javafx.application.Platform.runLater(() -> {
            context.codeEditor().updateComment((Comment) this.astNode, this.commentText);
        });
    }

    @Override
    public String getDetails() {
        return "Comment: " + (commentText != null ? commentText : "");
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/blocks/ComparisonExpressionBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractExpressionBlock;
import com.botmaker.core.ExpressionBlock;
import com.botmaker.lsp.CompletionContext;
import javafx.geometry.Pos;
import javafx.scene.Node;
import javafx.scene.control.ComboBox;
import javafx.scene.layout.HBox;
import org.eclipse.jdt.core.dom.ITypeBinding;
import org.eclipse.jdt.core.dom.InfixExpression;

public class ComparisonExpressionBlock extends AbstractExpressionBlock {

    private ExpressionBlock leftOperand;
    private ExpressionBlock rightOperand;
    private String operator;
    private final ITypeBinding returnType;

    // Operator display names (user-friendly)
    private static final String[] OPERATOR_NAMES = {
            "less than",                    // <
            "less than or equal",           // <=
            "greater than",                 // >
            "greater than or equal",        // >=
            "equal to",                     // ==
            "not equal to"                  // !=
    };

    // Corresponding Java operators
    private static final String[] OPERATOR_SYMBOLS = {
            "<", "<=", ">", ">=", "==", "!="
    };

    public ComparisonExpressionBlock(String id, InfixExpression astNode) {
        super(id, astNode);
        this.operator = astNode.getOperator().toString();
        this.returnType = astNode.resolveTypeBinding();
    }

    public ExpressionBlock getLeftOperand() {
        return leftOperand;
    }

    public void setLeftOperand(ExpressionBlock leftOperand) {
        this.leftOperand = leftOperand;
    }

    public ExpressionBlock getRightOperand() {
        return rightOperand;
    }

    public void setRightOperand(ExpressionBlock rightOperand) {
        this.rightOperand = rightOperand;
    }

    public String getOperator() {
        return operator;
    }

    public ITypeBinding getReturnType() {
        return returnType;
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        HBox container = new HBox(5);
        container.setAlignment(Pos.CENTER_LEFT);
        container.getStyleClass().add("comparison-expression-block");

        // Left operand
        if (leftOperand != null) {
            container.getChildren().add(leftOperand.getUINode(context));
        }

        // Operator selector - shows user-friendly names
        ComboBox<String> operatorSelector = new ComboBox<>();
        operatorSelector.getItems().addAll(OPERATOR_NAMES);
        operatorSelector.getStyleClass().add("comparison-operator-selector");

        // Set current operator
        String currentName = getOperatorDisplayName(operator);
        operatorSelector.setValue(currentName);

        // Handle operator change
        operatorSelector.setOnAction(e -> {
            String selectedName = operatorSelector.getValue();
            String newOperator = getOperatorSymbol(selectedName);
            if (newOperator != null && !newOperator.equals(operator)) {
                this.operator = newOperator;
                // Trigger code regeneration with new operator
                System.out.println("Comparison operator changed to: " + newOperator);
            }
        });

        container.getChildren().add(operatorSelector);

        // Right operand
        if (rightOperand != null) {
            container.getChildren().add(rightOperand.getUINode(context));
        }

        return container;
    }

    /**
     * Convert operator symbol to display name
     */
    private String getOperatorDisplayName(String symbol) {
        for (int i = 0; i < OPERATOR_SYMBOLS.length; i++) {
            if (OPERATOR_SYMBOLS[i].equals(symbol)) {
                return OPERATOR_NAMES[i];
            }
        }
        return "equal to"; // default
    }

    /**
     * Convert display name to operator symbol
     */
    private String getOperatorSymbol(String displayName) {
        for (int i = 0; i < OPERATOR_NAMES.length; i++) {
            if (OPERATOR_NAMES[i].equals(displayName)) {
                return OPERATOR_SYMBOLS[i];
            }
        }
        return "=="; // default
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/blocks/ContinueBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractStatementBlock;
import com.botmaker.lsp.CompletionContext;
import javafx.geometry.Pos;
import javafx.scene.Node;
import javafx.scene.control.Label;
import javafx.scene.layout.HBox;
import org.eclipse.jdt.core.dom.ContinueStatement;

public class ContinueBlock extends AbstractStatementBlock {

    public ContinueBlock(String id, ContinueStatement astNode) {
        super(id, astNode);
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        HBox container = new HBox(5);
        container.setAlignment(Pos.CENTER_LEFT);
        container.getStyleClass().add("continue-block");

        Label continueLabel = new Label("continue");
        continueLabel.getStyleClass().add("keyword-label");

        // Add spacer and delete button
        javafx.scene.layout.Pane spacer = new javafx.scene.layout.Pane();
        HBox.setHgrow(spacer, javafx.scene.layout.Priority.ALWAYS);

        javafx.scene.control.Button deleteButton = new javafx.scene.control.Button("X");
        deleteButton.setOnAction(e -> {
            context.codeEditor().deleteStatement((org.eclipse.jdt.core.dom.Statement) this.astNode);
        });

        container.getChildren().addAll(continueLabel, spacer, deleteButton);
        return container;
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/blocks/DoWhileBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractStatementBlock;
import com.botmaker.core.BodyBlock;
import com.botmaker.core.BlockWithChildren;
import com.botmaker.core.CodeBlock;
import com.botmaker.core.ExpressionBlock;
import com.botmaker.lsp.CompletionContext;
import com.botmaker.ui.BlockDragAndDropManager;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.Node;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Pane;
import javafx.scene.layout.Priority;
import javafx.scene.layout.VBox;
import org.eclipse.jdt.core.dom.DoStatement;

import java.util.ArrayList;
import java.util.List;

public class DoWhileBlock extends AbstractStatementBlock implements BlockWithChildren {

    private ExpressionBlock condition;
    private BodyBlock body;
    private final BlockDragAndDropManager dragAndDropManager;

    public DoWhileBlock(String id, DoStatement astNode, BlockDragAndDropManager dragAndDropManager) {
        super(id, astNode);
        this.dragAndDropManager = dragAndDropManager;
    }

    public ExpressionBlock getCondition() {
        return condition;
    }

    public void setCondition(ExpressionBlock condition) {
        this.condition = condition;
    }

    public BodyBlock getBody() {
        return body;
    }

    public void setBody(BodyBlock body) {
        this.body = body;
    }

    @Override
    public List<CodeBlock> getChildren() {
        List<CodeBlock> children = new ArrayList<>();
        if (body != null) children.add(body);
        if (condition != null) children.add(condition);
        return children;
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        VBox mainContainer = new VBox(5);
        mainContainer.getStyleClass().add("do-while-block");

        // Do header with delete button
        HBox doHeaderRow = new HBox(5);
        doHeaderRow.setAlignment(Pos.CENTER_LEFT);

        Label doLabel = new Label("do");
        doLabel.getStyleClass().add("keyword-label");

        // Add spacer and delete button
        Pane spacer = new Pane();
        HBox.setHgrow(spacer, Priority.ALWAYS);

        Button deleteButton = new Button("X");
        deleteButton.setOnAction(e -> {
            context.codeEditor().deleteStatement((org.eclipse.jdt.core.dom.Statement) this.astNode);
        });

        doHeaderRow.getChildren().addAll(doLabel, spacer, deleteButton);
        mainContainer.getChildren().add(doHeaderRow);

        // Body
        if (body != null) {
            VBox bodyContainer = new VBox();
            bodyContainer.getStyleClass().add("do-while-body");
            bodyContainer.setPadding(new Insets(5, 0, 0, 20));
            bodyContainer.getChildren().add(body.getUINode(context));
            mainContainer.getChildren().add(bodyContainer);
        }

        // While condition
        HBox whileCondition = new HBox(5);
        whileCondition.setAlignment(Pos.CENTER_LEFT);
        whileCondition.getStyleClass().add("do-while-condition");

        Label whileLabel = new Label("while");
        whileLabel.getStyleClass().add("keyword-label");

        whileCondition.getChildren().add(whileLabel);
        if (condition != null) {
            whileCondition.getChildren().add(condition.getUINode(context));
        }

        mainContainer.getChildren().add(whileCondition);

        return mainContainer;
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/blocks/ForBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractStatementBlock;
import com.botmaker.core.BodyBlock;
import com.botmaker.core.BlockWithChildren;
import com.botmaker.core.CodeBlock;
import com.botmaker.core.ExpressionBlock;
import com.botmaker.lsp.CompletionContext;
import com.botmaker.ui.BlockDragAndDropManager;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.Node;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Pane;
import javafx.scene.layout.Priority;
import javafx.scene.layout.VBox;
import org.eclipse.jdt.core.dom.EnhancedForStatement;

import java.util.ArrayList;
import java.util.List;

/**
 * ForEach loop block: for(Type variable : collection) { }
 */
public class ForBlock extends AbstractStatementBlock implements BlockWithChildren {

    private ExpressionBlock variable;
    private ExpressionBlock collection;
    private BodyBlock body;
    private final BlockDragAndDropManager dragAndDropManager;

    public ForBlock(String id, EnhancedForStatement astNode, BlockDragAndDropManager dragAndDropManager) {
        super(id, astNode);
        this.dragAndDropManager = dragAndDropManager;
    }

    public ExpressionBlock getVariable() {
        return variable;
    }

    public void setVariable(ExpressionBlock variable) {
        this.variable = variable;
    }

    public ExpressionBlock getCollection() {
        return collection;
    }

    public void setCollection(ExpressionBlock collection) {
        this.collection = collection;
    }

    public BodyBlock getBody() {
        return body;
    }

    public void setBody(BodyBlock body) {
        this.body = body;
    }

    @Override
    public List<CodeBlock> getChildren() {
        List<CodeBlock> children = new ArrayList<>();
        if (variable != null) children.add(variable);
        if (collection != null) children.add(collection);
        if (body != null) children.add(body);
        return children;
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        VBox mainContainer = new VBox(5);
        mainContainer.getStyleClass().add("for-block");

        // Header row with delete button
        HBox headerRow = new HBox(5);
        headerRow.setAlignment(Pos.CENTER_LEFT);

        // For each parts
        HBox header = new HBox(5);
        header.setAlignment(Pos.CENTER_LEFT);
        header.getStyleClass().add("for-header");

        Label forLabel = new Label("for each");
        forLabel.getStyleClass().add("keyword-label");

        header.getChildren().add(forLabel);

        if (variable != null) {
            header.getChildren().add(variable.getUINode(context));
        }

        Label inLabel = new Label("in");
        header.getChildren().add(inLabel);

        if (collection != null) {
            header.getChildren().add(collection.getUINode(context));
        }

        // Add spacer and delete button
        Pane spacer = new Pane();
        HBox.setHgrow(spacer, Priority.ALWAYS);

        Button deleteButton = new Button("X");
        deleteButton.setOnAction(e -> {
            context.codeEditor().deleteStatement((org.eclipse.jdt.core.dom.Statement) this.astNode);
        });

        headerRow.getChildren().addAll(header, spacer, deleteButton);
        mainContainer.getChildren().add(headerRow);

        // Body
        if (body != null) {
            VBox bodyContainer = new VBox();
            bodyContainer.getStyleClass().add("for-body");
            bodyContainer.setPadding(new Insets(5, 0, 0, 20));
            bodyContainer.getChildren().add(body.getUINode(context));
            mainContainer.getChildren().add(bodyContainer);
        }

        return mainContainer;
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/blocks/IdentifierBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractExpressionBlock;
import com.botmaker.lsp.CompletionContext;
import com.botmaker.util.TypeManager;
import javafx.application.Platform;
import javafx.scene.Cursor;
import javafx.scene.Node;
import javafx.scene.control.ContextMenu;
import javafx.scene.control.MenuItem;
import javafx.scene.control.Tooltip;
import javafx.scene.layout.HBox;
import javafx.scene.text.Text;
import org.eclipse.jdt.core.dom.*;
import org.eclipse.lsp4j.*;

import java.util.List;
import java.util.stream.Collectors;

public class IdentifierBlock extends AbstractExpressionBlock {
    private final String identifier;
    private boolean isUnedited = false;
    private static final String UNEDITED_STYLE_CLASS = "unedited-identifier";

    public IdentifierBlock(String id, SimpleName astNode) {
        this(id, astNode, false);
    }

    public IdentifierBlock(String id, SimpleName astNode, boolean markAsUnedited) {
        super(id, astNode);
        this.identifier = astNode.getIdentifier();
        this.isUnedited = markAsUnedited;
    }

    public String getIdentifier() { return identifier; }
    public boolean isUnedited() { return isUnedited; }

    public void markAsEdited() {
        this.isUnedited = false;
        if (uiNode != null) {
            uiNode.getStyleClass().remove(UNEDITED_STYLE_CLASS);
        }
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        Text text = new Text(this.identifier);
        HBox container = new HBox(text);
        container.setAlignment(javafx.geometry.Pos.CENTER_LEFT);
        container.getStyleClass().add("identifier-block");

        if (isUnedited) container.getStyleClass().add(UNEDITED_STYLE_CLASS);

        container.setCursor(Cursor.HAND);
        String tooltipText = isUnedited ? "⚠️ Default variable name - Click to choose" : "Click to change variable";
        Tooltip.install(container, new Tooltip(tooltipText));

        container.setOnMouseClicked(e -> {
            if (e.getClickCount() == 1) requestSuggestions(container, context);
        });

        return container;
    }

    private void requestSuggestions(Node uiNode, CompletionContext context) {
        try {
            Position pos = getPositionFromOffset(context.sourceCode(), this.astNode.getStartPosition());
            CompletionParams params = new CompletionParams(new TextDocumentIdentifier(context.docUri()), pos);

            // 1. Determine Expected Type with Parent Traversal
            String expectedType = determineExpectedType();
            System.out.println("[Debug] Suggestion Context -> Expected Type: " + expectedType);

            context.server().getTextDocumentService().completion(params).thenAccept(result -> {
                if (result == null || (result.isLeft() && result.getLeft().isEmpty()) ||
                        (result.isRight() && result.getRight().getItems().isEmpty())) {
                    return;
                }

                List<CompletionItem> items = result.isLeft() ? result.getLeft() : result.getRight().getItems();

                Platform.runLater(() -> {
                    ContextMenu menu = new ContextMenu();
                    menu.setStyle("-fx-control-inner-background: white;");

                    List<CompletionItem> filteredItems = items.stream()
                            // Only Variables and Fields
                            .filter(item -> item.getKind() == CompletionItemKind.Variable || item.getKind() == CompletionItemKind.Field)
                            // Filter hidden (args, scanner)
                            .filter(item -> TypeManager.isUserVariable(item.getLabel()))
                            // Filter by Type using TypeManager
                            .filter(item -> {
                                // Extract type info: prefer detail, fallback to label parsing
                                String typeInfo = item.getDetail();
                                if (typeInfo == null || typeInfo.isBlank()) {
                                    // Try to parse "name : type" from label
                                    if (item.getLabel().contains(" : ")) {
                                        String[] parts = item.getLabel().split(" : ");
                                        if (parts.length > 1) {
                                            typeInfo = parts[1].trim();
                                        }
                                    }
                                }

                                boolean match = TypeManager.isCompatible(typeInfo, expectedType);
                                return match;
                            })
                            .collect(Collectors.toList());

                    if (filteredItems.isEmpty()) {
                        MenuItem noVars = new MenuItem("(No " + (expectedType.equals("any") ? "" : expectedType + " ") + "variables found)");
                        noVars.setDisable(true);
                        noVars.setStyle("-fx-text-fill: #999;");
                        menu.getItems().add(noVars);
                    } else {
                        for (CompletionItem item : filteredItems) {
                            String label = item.getLabel();
                            String detail = item.getDetail();
                            if (detail == null && label.contains(" : ")) {
                                detail = label.split(" : ")[1].trim();
                            }

                            String display = label;
                            if (!label.contains(":") && detail != null && !detail.isEmpty()) {
                                display += " (" + getSimpleTypeName(detail) + ")";
                            }

                            MenuItem mi = new MenuItem(display);
                            mi.setStyle("-fx-text-fill: black;");
                            mi.setOnAction(event -> {
                                applySuggestion(item, context);
                                markAsEdited();
                            });
                            menu.getItems().add(mi);
                        }
                    }
                    menu.show(uiNode, javafx.geometry.Side.BOTTOM, 0, 0);
                });
            });
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * Walks up the AST skipping parentheses to find the true semantic parent.
     */
    private String determineExpectedType() {
        if (this.astNode == null) return TypeManager.UI_TYPE_ANY;

        ASTNode child = this.astNode;
        ASTNode parent = this.astNode.getParent();

        // 1. Skip Parentheses ((x))
        while (parent instanceof ParenthesizedExpression) {
            child = parent;
            parent = parent.getParent();
        }

        if (parent == null) return TypeManager.UI_TYPE_ANY;

        // 2. Boolean Contexts
        if (parent instanceof IfStatement) {
            if (((IfStatement) parent).getExpression() == child) return TypeManager.UI_TYPE_BOOLEAN;
        }
        if (parent instanceof WhileStatement) {
            if (((WhileStatement) parent).getExpression() == child) return TypeManager.UI_TYPE_BOOLEAN;
        }
        if (parent instanceof DoStatement) {
            if (((DoStatement) parent).getExpression() == child) return TypeManager.UI_TYPE_BOOLEAN;
        }

        // 3. Unary Contexts (Prefix/Postfix)
        if (parent instanceof PrefixExpression) {
            PrefixExpression.Operator op = ((PrefixExpression) parent).getOperator();
            if (op == PrefixExpression.Operator.NOT) {
                return TypeManager.UI_TYPE_BOOLEAN;
            }
            if (op == PrefixExpression.Operator.INCREMENT || op == PrefixExpression.Operator.DECREMENT ||
                    op == PrefixExpression.Operator.PLUS || op == PrefixExpression.Operator.MINUS) {
                return TypeManager.UI_TYPE_NUMBER;
            }
        }
        if (parent instanceof PostfixExpression) {
            return TypeManager.UI_TYPE_NUMBER;
        }

        // 4. Binary Contexts (Infix Expressions)
        if (parent instanceof InfixExpression) {
            InfixExpression infix = (InfixExpression) parent;
            InfixExpression.Operator op = infix.getOperator();

            if (op == InfixExpression.Operator.PLUS || op == InfixExpression.Operator.MINUS ||
                    op == InfixExpression.Operator.TIMES || op == InfixExpression.Operator.DIVIDE ||
                    op == InfixExpression.Operator.REMAINDER) {
                return TypeManager.UI_TYPE_NUMBER;
            }
            if (op == InfixExpression.Operator.LESS || op == InfixExpression.Operator.GREATER ||
                    op == InfixExpression.Operator.LESS_EQUALS || op == InfixExpression.Operator.GREATER_EQUALS) {
                return TypeManager.UI_TYPE_NUMBER;
            }
            if (op == InfixExpression.Operator.CONDITIONAL_AND || op == InfixExpression.Operator.CONDITIONAL_OR) {
                return TypeManager.UI_TYPE_BOOLEAN;
            }
        }

        // 5. Assignment (RHS must match LHS)
        if (parent instanceof Assignment) {
            Assignment assignment = (Assignment) parent;
            if (assignment.getRightHandSide() == child) {
                Expression lhs = assignment.getLeftHandSide();
                ITypeBinding binding = lhs.resolveTypeBinding();
                if (binding != null) {
                    if (TypeManager.isCompatible(binding, TypeManager.UI_TYPE_BOOLEAN)) return TypeManager.UI_TYPE_BOOLEAN;
                    if (TypeManager.isCompatible(binding, TypeManager.UI_TYPE_NUMBER)) return TypeManager.UI_TYPE_NUMBER;
                    if (TypeManager.isCompatible(binding, TypeManager.UI_TYPE_STRING)) return TypeManager.UI_TYPE_STRING;
                }
            }
        }

        // 6. Variable Declaration Initialization (Target must match Variable Type)
        // e.g. int x = [variable]
        if (parent instanceof VariableDeclarationFragment) {
            VariableDeclarationFragment frag = (VariableDeclarationFragment) parent;
            if (frag.getInitializer() == child) {
                ASTNode grandParent = frag.getParent();
                if (grandParent instanceof VariableDeclarationStatement) {
                    Type type = ((VariableDeclarationStatement) grandParent).getType();
                    return TypeManager.determineUiType(type.toString());
                }
            }
        }

        return TypeManager.UI_TYPE_ANY;
    }

    private String getSimpleTypeName(String detail) {
        if (detail == null) return "";
        if (TypeManager.isCompatible(detail, TypeManager.UI_TYPE_NUMBER)) return "number";
        if (TypeManager.isCompatible(detail, TypeManager.UI_TYPE_BOOLEAN)) return "bool";
        return detail;
    }

    private void applySuggestion(CompletionItem item, CompletionContext context) {
        try {
            String insertText = item.getInsertText() != null ? item.getInsertText() : item.getLabel();
            if (insertText.contains(" : ")) {
                insertText = insertText.split(" : ")[0];
            }
            context.codeEditor().replaceSimpleName((SimpleName) this.astNode, insertText);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private Position getPositionFromOffset(String code, int offset) {
        int line = 0;
        int lastNewline = -1;
        for (int i = 0; i < offset; i++) {
            if (code.charAt(i) == '\n') {
                line++;
                lastNewline = i;
            }
        }
        int character = offset - lastNewline - 1;
        return new Position(line, character);
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/blocks/IfBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractStatementBlock;
import com.botmaker.core.BodyBlock;
import com.botmaker.core.CodeBlock;
import com.botmaker.core.ExpressionBlock;
import com.botmaker.lsp.CompletionContext;
import javafx.geometry.Pos;
import javafx.scene.Node;
import javafx.scene.control.Button;
import javafx.scene.control.ContextMenu;
import javafx.scene.control.Label;
import javafx.scene.control.MenuItem;
import javafx.scene.layout.HBox;
import javafx.scene.layout.VBox;
import org.eclipse.jdt.core.dom.CompilationUnit;
import org.eclipse.jdt.core.dom.IfStatement;

public class IfBlock extends AbstractStatementBlock {

    private ExpressionBlock condition;
    private BodyBlock thenBody;
    private com.botmaker.core.StatementBlock elseStatement;

    public IfBlock(String id, IfStatement astNode) {
        super(id, astNode);
    }

    public ExpressionBlock getCondition() { return condition; }
    public void setCondition(ExpressionBlock condition) { this.condition = condition; }
    public BodyBlock getThenBody() { return thenBody; }
    public void setThenBody(BodyBlock thenBody) { this.thenBody = thenBody; }
    public com.botmaker.core.StatementBlock getElseStatement() { return elseStatement; }
    public void setElseStatement(com.botmaker.core.StatementBlock elseStatement) { this.elseStatement = elseStatement; }

    @Override
    protected Node createUINode(CompletionContext context) {
        VBox container = new VBox(5);
        container.getStyleClass().add("if-block");

        HBox header = new HBox(5);
        header.setAlignment(Pos.CENTER_LEFT);

        Label ifLabel = new Label("If");
        ifLabel.getStyleClass().add("keyword-label");
        header.getChildren().add(ifLabel);

        if (condition != null) {
            header.getChildren().add(condition.getUINode(context));
        } else {
            header.getChildren().add(createExpressionDropZone(context));
        }

        Button addButton = new Button("+");
        addButton.getStyleClass().add("expression-add-button");

        // UPDATED: Pass "boolean" as target type
        addButton.setOnAction(e -> showExpressionMenu(addButton, context, "boolean"));

        header.getChildren().add(addButton);

        javafx.scene.layout.Pane spacer = new javafx.scene.layout.Pane();
        HBox.setHgrow(spacer, javafx.scene.layout.Priority.ALWAYS);

        javafx.scene.control.Button deleteButton = new javafx.scene.control.Button("X");
        deleteButton.setOnAction(e -> context.codeEditor().deleteStatement((org.eclipse.jdt.core.dom.Statement) this.astNode));

        header.getChildren().addAll(spacer, deleteButton);
        container.getChildren().add(header);

        if (thenBody != null) {
            Node thenBodyNode = thenBody.getUINode(context);
            thenBodyNode.getStyleClass().add("if-body");
            HBox.setHgrow(thenBodyNode, javafx.scene.layout.Priority.ALWAYS);
            container.getChildren().add(thenBodyNode);
        }

        if (elseStatement != null) {
            if (elseStatement instanceof com.botmaker.core.BodyBlock) {
                VBox elseContainer = new VBox(5);
                HBox elseHeader = new HBox(5);
                elseHeader.setAlignment(Pos.CENTER_LEFT);
                Label elseLabel = new Label("Else");
                elseLabel.getStyleClass().add("keyword-label");
                javafx.scene.control.Button addElseIfButton = new javafx.scene.control.Button("+ if");
                addElseIfButton.setOnAction(e -> context.codeEditor().convertElseToElseIf((IfStatement) this.astNode));
                javafx.scene.layout.Pane elseSpacer = new javafx.scene.layout.Pane();
                HBox.setHgrow(elseSpacer, javafx.scene.layout.Priority.ALWAYS);
                javafx.scene.control.Button deleteElseButton = new javafx.scene.control.Button("X");
                deleteElseButton.setOnAction(e -> context.codeEditor().deleteElseFromIfStatement((IfStatement) this.astNode));
                elseHeader.getChildren().addAll(elseLabel, addElseIfButton, elseSpacer, deleteElseButton);

                Node elseBodyNode = elseStatement.getUINode(context);
                elseBodyNode.getStyleClass().add("if-body");
                HBox.setHgrow(elseBodyNode, javafx.scene.layout.Priority.ALWAYS);
                elseContainer.getChildren().addAll(elseHeader, elseBodyNode);
                container.getChildren().add(elseContainer);
            } else {
                HBox elseIfContainer = new HBox(5);
                elseIfContainer.setAlignment(Pos.CENTER_LEFT);
                Label elseLabel = new Label("Else");
                elseLabel.getStyleClass().add("keyword-label");
                elseIfContainer.getChildren().add(elseLabel);
                Node elseNode = elseStatement.getUINode(context);
                HBox.setHgrow(elseNode, javafx.scene.layout.Priority.ALWAYS);
                elseIfContainer.getChildren().add(elseNode);
                container.getChildren().add(elseIfContainer);
            }
        } else {
            javafx.scene.control.Button addElseButton = new javafx.scene.control.Button("+");
            addElseButton.setOnAction(e -> context.codeEditor().addElseToIfStatement((IfStatement) this.astNode));
            container.getChildren().add(addElseButton);
        }

        return container;
    }

    // UPDATED: Accepts targetType
    private void showExpressionMenu(Button button, CompletionContext context, String targetType) {
        ContextMenu menu = new ContextMenu();
        menu.setStyle("-fx-control-inner-background: white;");

        for (com.botmaker.ui.AddableExpression type : com.botmaker.ui.AddableExpression.getForType(targetType)) {
            MenuItem menuItem = new MenuItem(type.getDisplayName());
            menuItem.setStyle("-fx-text-fill: black;");

            menuItem.setOnAction(e -> {
                if (condition != null) {
                    org.eclipse.jdt.core.dom.Expression toReplace = (org.eclipse.jdt.core.dom.Expression) condition.getAstNode();
                    context.codeEditor().replaceExpression(toReplace, type);
                }
            });
            menu.getItems().add(menuItem);
        }

        menu.show(button, javafx.geometry.Side.BOTTOM, 0, 0);
    }

    @Override
    public void highlight() {
        if (condition != null) {
            condition.highlight();
        } else {
            super.highlight();
        }
    }

    @Override
    public void unhighlight() {
        if (condition != null) {
            condition.unhighlight();
        } else {
            super.unhighlight();
        }
    }

    @Override
    public int getBreakpointLine(CompilationUnit cu) {
        if (condition != null) {
            return condition.getBreakpointLine(cu);
        }
        return super.getBreakpointLine(cu);
    }

    @Override
    public CodeBlock getHighlightTarget() {
        return condition != null ? condition : this;
    }

    @Override
    public String getDetails() {
        String conditionDetails = (condition != null) ? condition.getDetails() : "no condition";
        return "If Statement (condition: " + conditionDetails + ")";
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/blocks/LibraryBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractCodeBlock;
import com.botmaker.core.BlockWithChildren;
import com.botmaker.core.CodeBlock;
import com.botmaker.lsp.CompletionContext;
import javafx.geometry.Insets;
import javafx.scene.Node;
import javafx.scene.control.Label;
import javafx.scene.layout.VBox;
import org.eclipse.jdt.core.dom.TypeDeclaration;

import java.util.ArrayList;
import java.util.List;

public class LibraryBlock extends AbstractCodeBlock implements BlockWithChildren {

    private final String className;
    private final List<MethodDeclarationBlock> methods = new ArrayList<>();

    public LibraryBlock(String id, TypeDeclaration astNode) {
        super(id, astNode);
        this.className = astNode.getName().getIdentifier();
    }

    public void addMethod(MethodDeclarationBlock method) {
        methods.add(method);
    }

    @Override
    public List<CodeBlock> getChildren() {
        return new ArrayList<>(methods);
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        VBox container = new VBox(10);
        container.getStyleClass().add("library-block");
        container.setPadding(new Insets(10));
        // Ensure background is set so white text (if any) is visible,
        // OR enforce text color to be dark.
        container.setStyle("-fx-background-color: #f4f6f9;");

        Label header = new Label("Library: " + className);
        // Using specific styling instead of generic main-block-header which might be designed for dark backgrounds
        header.setStyle("-fx-font-size: 18px; -fx-font-weight: bold; -fx-text-fill: #2c3e50; -fx-padding: 0 0 10 0;");

        container.getChildren().add(header);

        for (MethodDeclarationBlock method : methods) {
            container.getChildren().add(method.getUINode(context));
        }

        return container;
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/blocks/ListBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractExpressionBlock;
import com.botmaker.core.ExpressionBlock;
import com.botmaker.lsp.CompletionContext;
import com.botmaker.util.TypeManager;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.Node;
import javafx.scene.control.Button;
import javafx.scene.control.ContextMenu;
import javafx.scene.control.Label;
import javafx.scene.control.MenuItem;
import javafx.scene.layout.HBox;
import javafx.scene.layout.VBox;
import org.eclipse.jdt.core.dom.*;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * Visual block for lists.
 * Supports:
 * 1. Array Initializers: {1, 2, 3}
 * 2. List Factories: Arrays.asList(1, 2, 3) or List.of(1, 2, 3)
 */
public class ListBlock extends AbstractExpressionBlock {

    private final List<ExpressionBlock> elements = new ArrayList<>();
    private final boolean isFixedArray; // True if it's a {}, False if it's Arrays.asList

    public ListBlock(String id, ASTNode astNode) {
        super(id, astNode);
        this.isFixedArray = (astNode instanceof ArrayInitializer);
    }

    public void addElement(ExpressionBlock element) {
        this.elements.add(element);
    }

    public List<ExpressionBlock> getElements() {
        return elements;
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        // ... (Container and Style setup remains same)
        VBox container = new VBox(5);
        container.setAlignment(Pos.TOP_LEFT);
        container.getStyleClass().add("list-block");

        boolean isNested = (this.astNode.getParent() instanceof ArrayInitializer) ||
                (this.astNode.getParent() instanceof MethodInvocation);

        if (isNested) {
            container.setStyle("-fx-background-color: rgba(255,255,255,0.08); -fx-background-radius: 6; -fx-border-color: rgba(255,255,255,0.15); -fx-border-width: 1;");
            container.setPadding(new Insets(4, 6, 4, 6));
        } else {
            container.setPadding(new Insets(6, 10, 6, 10));
        }

        // --- Header Row ---
        HBox headerRow = new HBox(8);
        headerRow.setAlignment(Pos.CENTER_LEFT);

        // Calculate logic
        String itemType = determineItemType();
        // If itemType is "list", we are holding sub-lists.
        // If itemType is "boolean"/"number", we are holding values.

        String typeLabel = isFixedArray ? "Array" : "List";

        // Debug label helpful for verification:
        // Label listLabel = new Label(typeLabel + "<" + itemType + "> (" + elements.size() + ")");
        Label listLabel = new Label(typeLabel + " (" + elements.size() + ")");
        listLabel.getStyleClass().add("list-label");

        if (!isFixedArray) {
            listLabel.setStyle("-fx-text-fill: #aaddff;");
        }

        Button addButton = new Button("+");
        addButton.getStyleClass().add("expression-add-button");
        addButton.setStyle("-fx-font-size: 10px; -fx-padding: 2px 8px;");

        addButton.setOnAction(e -> showAddElementMenu(addButton, context, elements.size(), itemType));

        headerRow.getChildren().addAll(listLabel, addButton);
        container.getChildren().add(headerRow);

        // --- Elements ---
        if (elements.isEmpty()) {
            Label emptyLabel = new Label(" (empty) ");
            emptyLabel.setStyle("-fx-font-style: italic; -fx-text-fill: rgba(255,255,255,0.4); -fx-font-size: 10px;");
            container.getChildren().add(emptyLabel);
        } else {
            VBox elementsContainer = new VBox(3);
            elementsContainer.setPadding(new Insets(2, 0, 0, 12));

            for (int i = 0; i < elements.size(); i++) {
                // Pass itemType down so row knows what it contains
                HBox elementRow = createElementRow(i, elements.get(i), context, itemType);
                elementsContainer.getChildren().add(elementRow);
            }
            container.getChildren().add(elementsContainer);
        }

        return container;
    }

    /**
     * Determines the UI type of items inside this list (e.g., "number", "text", "boolean", "list").
     */
    /**
     * Logic to determine what kind of items this specific ListBlock should contain.
     * It walks up the AST to find the Variable Declaration, calculates total nesting depth,
     * calculates current depth, and decides if we need "list" or a leaf type.
     */
    private String determineItemType() {
        ASTNode current = this.astNode;
        ASTNode rootDefinition = null;
        int currentDepth = 0;

        // 1. Walk up to find the root definition and count current depth
        while (current != null) {
            // If we hit another Arrays.asList, we are one level deeper
            if (current instanceof MethodInvocation) {
                MethodInvocation mi = (MethodInvocation) current;
                if ("asList".equals(mi.getName().getIdentifier())) {
                    // If we aren't the starting node, increment depth
                    if (current != this.astNode) {
                        currentDepth++;
                    }
                }
            }

            // Found declaration: ArrayList<ArrayList<Boolean>> x = ...
            if (current instanceof VariableDeclarationFragment) {
                rootDefinition = current;
                break;
            }
            // Found declaration in standard usage
            if (current instanceof VariableDeclarationStatement) {
                rootDefinition = current;
                break;
            }
            // Found usage inside new ArrayList<>(...)
            if (current instanceof ClassInstanceCreation) {
                rootDefinition = current;
                break;
            }

            current = current.getParent();
        }

        // 2. Analyze the root type
        String rootTypeStr = "any";

        if (rootDefinition instanceof VariableDeclarationStatement) {
            rootTypeStr = ((VariableDeclarationStatement) rootDefinition).getType().toString();
        } else if (rootDefinition instanceof VariableDeclarationFragment) {
            ASTNode parent = rootDefinition.getParent();
            if (parent instanceof VariableDeclarationStatement) {
                rootTypeStr = ((VariableDeclarationStatement) parent).getType().toString();
            }
        } else if (rootDefinition instanceof ClassInstanceCreation) {
            rootTypeStr = ((ClassInstanceCreation) rootDefinition).getType().toString();
        }

        // 3. Calculate Dimensions
        // e.g. ArrayList<ArrayList<Boolean>> -> genericDepth = 2, leafType = "Boolean"
        int genericDepth = TypeManager.getListNestingLevel(rootTypeStr);
        String leafType = TypeManager.getLeafType(rootTypeStr); // e.g. "Boolean"


        // 4. Determine UI Type based on depth comparison
        // If genericDepth is 2 (List of List of Bool)
        // currentDepth 0 (Root) -> needs "list" (to make depth 1)
        // currentDepth 1 (Middle) -> needs leafType ("Boolean")

        // Note: The depth calculation depends on how the AST creates the structure.
        // Arrays.asList( Arrays.asList ( ... ) )
        // Root list is depth 0.

        int remainingLevels = genericDepth - 1 - currentDepth;

        if (remainingLevels > 0) {
            return "list";
        } else {
            return TypeManager.determineUiType(leafType);
        }
    }

    private HBox createElementRow(int index, ExpressionBlock element, CompletionContext context, String itemType) {
        HBox row = new HBox(6);
        row.setAlignment(Pos.CENTER_LEFT);

        Label indexLabel = new Label(String.valueOf(index));
        indexLabel.setStyle("-fx-font-family: monospace; -fx-text-fill: #666; -fx-font-size: 9px; -fx-min-width: 10px;");

        Node elementNode = element.getUINode(context);
        if (element instanceof ListBlock) {
            HBox.setHgrow(elementNode, javafx.scene.layout.Priority.ALWAYS);
        }

        Button changeButton = new Button("↻");
        changeButton.getStyleClass().add("icon-button");
        changeButton.setStyle("-fx-font-size: 8px; -fx-padding: 1px 4px; -fx-opacity: 0.3;");
        changeButton.setOnAction(e -> showChangeElementMenu(changeButton, context, index, itemType));

        Button deleteButton = new Button("✕");
        deleteButton.getStyleClass().add("icon-button");
        deleteButton.setStyle("-fx-font-size: 8px; -fx-padding: 1px 4px; -fx-text-fill: #ff5555; -fx-opacity: 0.3;");
        deleteButton.setOnAction(e -> deleteElement(index, context));

        row.setOnMouseEntered(e -> {
            changeButton.setStyle("-fx-font-size: 8px; -fx-padding: 1px 4px; -fx-opacity: 1.0;");
            deleteButton.setStyle("-fx-font-size: 8px; -fx-padding: 1px 4px; -fx-text-fill: #ff5555; -fx-opacity: 1.0;");
        });
        row.setOnMouseExited(e -> {
            changeButton.setStyle("-fx-font-size: 8px; -fx-padding: 1px 4px; -fx-opacity: 0.3;");
            deleteButton.setStyle("-fx-font-size: 8px; -fx-padding: 1px 4px; -fx-text-fill: #ff5555; -fx-opacity: 0.3;");
        });

        row.getChildren().addAll(indexLabel, elementNode, changeButton, deleteButton);
        return row;
    }

    private void showAddElementMenu(Button button, CompletionContext context, int insertIndex, String targetType) {
        ContextMenu menu = new ContextMenu();

        // Use getForType to filter the options
        for (com.botmaker.ui.AddableExpression type : com.botmaker.ui.AddableExpression.getForType(targetType)) {
            MenuItem menuItem = new MenuItem(type.getDisplayName());
            menuItem.setOnAction(e -> {
                context.codeEditor().addElementToList(this.astNode, type, insertIndex);
            });
            menu.getItems().add(menuItem);
        }
        menu.show(button, javafx.geometry.Side.BOTTOM, 0, 0);
    }

    private void showChangeElementMenu(Button button, CompletionContext context, int elementIndex, String targetType) {
        ContextMenu menu = new ContextMenu();

        // Use getForType to filter the options
        for (com.botmaker.ui.AddableExpression type : com.botmaker.ui.AddableExpression.getForType(targetType)) {
            MenuItem menuItem = new MenuItem(type.getDisplayName());
            menuItem.setOnAction(e -> {
                if (elementIndex < elements.size()) {
                    ExpressionBlock oldElement = elements.get(elementIndex);
                    context.codeEditor().replaceExpression(
                            (org.eclipse.jdt.core.dom.Expression) oldElement.getAstNode(),
                            type
                    );
                }
            });
            menu.getItems().add(menuItem);
        }
        menu.show(button, javafx.geometry.Side.BOTTOM, 0, 0);
    }

    private void deleteElement(int index, CompletionContext context) {
        if (index >= 0 && index < elements.size()) {
            context.codeEditor().deleteElementFromList(this.astNode, index);
        }
    }

    @Override
    public String getDetails() {
        return (isFixedArray ? "Array" : "List") + " (" + elements.size() + " items)";
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/blocks/LiteralBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractExpressionBlock;
import com.botmaker.lsp.CompletionContext;
import javafx.scene.Cursor;
import javafx.scene.Node;
import javafx.scene.control.TextField;
import javafx.scene.control.TextFormatter;
import javafx.scene.layout.HBox;
import org.eclipse.jdt.core.dom.Expression;

import java.math.BigDecimal;
import java.util.function.UnaryOperator;

public class LiteralBlock<T> extends AbstractExpressionBlock {
    private final T value;

    public LiteralBlock(String id, Expression astNode, T value) {
        super(id, astNode);
        this.value = value;
    }

    public T getValue() {
        return value;
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        String initialText = (value instanceof String) ? (String) value : String.valueOf(value);
        TextField textField = new TextField(initialText);

        if (initialText.isEmpty() && value instanceof String) {
            textField.setPromptText("Type a value...");
        }

        textField.setCursor(Cursor.TEXT);
        textField.getStyleClass().add("literal-text-field");

        // --- INPUT VALIDATION FILTER ---
        UnaryOperator<TextFormatter.Change> filter = createInputFilter();
        if (filter != null) {
            textField.setTextFormatter(new TextFormatter<>(filter));
        }

        // --- FOCUS LISTENER (Commit changes) ---
        textField.focusedProperty().addListener((obs, oldVal, newVal) -> {
            if (!newVal) { // Focus Lost
                String newText = textField.getText();
                String oldText = (value instanceof String) ? (String) value : String.valueOf(value);

                // Handle empty numbers / intermediate states gracefully
                if (isNumberType() && !isValidFinalNumber(newText)) {
                    textField.setText(oldText); // Revert invalid state
                    return;
                }

                // NEW: Normalize the number (Add 'f' for Float, 'L' for Long)
                String textToSave = normalizeNumberSuffix(newText);

                // Update UI to match saved text (e.g., show "3.5f" if user typed "3.5")
                if (!textToSave.equals(newText)) {
                    textField.setText(textToSave);
                }

                if (!textToSave.equals(oldText)) {
                    if (this.astNode instanceof org.eclipse.jdt.core.dom.MethodInvocation) {
                        org.eclipse.jdt.core.dom.MethodInvocation mi = (org.eclipse.jdt.core.dom.MethodInvocation) this.astNode;
                        context.codeEditor().addStringArgumentToMethodInvocation(mi, textToSave);
                    } else {
                        context.codeEditor().replaceLiteralValue((Expression) this.astNode, textToSave);
                    }
                }
            }
        });

        HBox container = new HBox(textField);
        container.setAlignment(javafx.geometry.Pos.CENTER_LEFT);
        container.getStyleClass().add("literal-block");
        return container;
    }

    /**
     * Automatically appends required Java suffixes (f, L) if missing.
     */
    private String normalizeNumberSuffix(String text) {
        if (value instanceof Float) {
            if (!text.toLowerCase().endsWith("f")) {
                return text + "f";
            }
        } else if (value instanceof Long) {
            if (!text.toLowerCase().endsWith("l")) {
                return text + "L"; // Use Uppercase L to avoid confusion with 1
            }
        }
        return text;
    }

    /**
     * Creates a filter based on the type of the value stored in this block.
     */
    private UnaryOperator<TextFormatter.Change> createInputFilter() {
        return change -> {
            String newText = change.getControlNewText();

            if (newText.isEmpty()) return change;

            // 1. INTEGER Types (Byte, Short, Integer, Long)
            if (value instanceof Integer || value instanceof Short || value instanceof Byte || value instanceof Long) {
                // Allow digits, minus, and L suffix for Longs
                String regex = (value instanceof Long) ? "-?[0-9]*[lL]?" : "-?[0-9]*";

                if (newText.matches(regex)) {
                    if (isWithinRange(newText, value.getClass())) {
                        return change;
                    }
                }
                return null;
            }

            // 2. FLOATING POINT Types (Float, Double)
            else if (value instanceof Double || value instanceof Float) {
                // Allow digits, dot, minus, and f/d suffixes
                if (newText.matches("-?[0-9]*\\.?[0-9]*[dDfF]?")) {
                    if (isWithinRange(newText, value.getClass())) {
                        return change;
                    }
                }
                return null;
            }

            // 3. STRING
            else if (value instanceof String) {
                String input = change.getText();
                if (input.contains("\"") || input.contains("\n") || input.contains("\r")) {
                    return null;
                }
                return change;
            }

            return change;
        };
    }

    /**
     * Checks if the text value fits within the MIN/MAX bounds of the target type.
     */
    private boolean isWithinRange(String text, Class<?> type) {
        // Allow intermediate states
        if (text.equals("-") || text.equals(".") || text.equals("-.")) return true;

        // Strip suffixes for parsing check
        String cleanText = text.replaceAll("[dDfFlL]$", "");
        if (cleanText.isEmpty()) return true;

        try {
            if (type == Byte.class) {
                long val = Long.parseLong(cleanText);
                return val >= Byte.MIN_VALUE && val <= Byte.MAX_VALUE;
            }
            if (type == Short.class) {
                long val = Long.parseLong(cleanText);
                return val >= Short.MIN_VALUE && val <= Short.MAX_VALUE;
            }
            if (type == Integer.class) {
                long val = Long.parseLong(cleanText);
                return val >= Integer.MIN_VALUE && val <= Integer.MAX_VALUE;
            }
            if (type == Long.class) {
                Long.parseLong(cleanText);
                return true;
            }
            if (type == Float.class) {
                double val = Double.parseDouble(cleanText);
                // Float.MAX_VALUE is huge, mostly we check for Infinity overflow
                return !Double.isInfinite(val);
            }
            if (type == Double.class) {
                BigDecimal val = new BigDecimal(cleanText);
                // Check if it fits in a double
                return !Double.isInfinite(val.doubleValue());
            }
        } catch (NumberFormatException e) {
            return false;
        }

        return true;
    }

    private boolean isValidFinalNumber(String text) {
        if (text.equals("-") || text.equals(".") || text.equals("-.")) return false;
        if (text.endsWith(".")) return false;
        return true;
    }

    private boolean isNumberType() {
        return value instanceof Number;
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/blocks/MainBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractCodeBlock;
import com.botmaker.core.BlockWithChildren;
import com.botmaker.core.BodyBlock;
import com.botmaker.core.CodeBlock;
import com.botmaker.lsp.CompletionContext;

import javafx.geometry.Insets;
import javafx.scene.Node;
import javafx.scene.control.Label;
import javafx.scene.layout.VBox;
import org.eclipse.jdt.core.dom.ASTNode;

import java.util.ArrayList;
import java.util.List;

public class MainBlock extends AbstractCodeBlock implements BlockWithChildren {

    private BodyBlock mainBody;

    public MainBlock(String id, ASTNode astNode) {
        super(id, astNode);
    }

    public void setMainBody(BodyBlock mainBody) {
        this.mainBody = mainBody;
    }

    @Override
    public List<CodeBlock> getChildren() {
        List<CodeBlock> children = new ArrayList<>();
        if (mainBody != null) {
            children.add(mainBody);
        }
        return children;
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        VBox container = new VBox(5);
        container.getStyleClass().add("main-block");
        container.setPadding(new Insets(10));

        Label header = new Label("Main");
        header.getStyleClass().add("main-block-header");
        container.getChildren().add(header);

        if (mainBody != null) {
            container.getChildren().add(mainBody.getUINode(context));
        }

        return container;
    }
}


=================================================================================
FILE: ./src/main/java/com/botmaker/blocks/MethodDeclarationBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractStatementBlock;
import com.botmaker.core.BlockWithChildren;
import com.botmaker.core.BodyBlock;
import com.botmaker.core.CodeBlock;
import com.botmaker.lsp.CompletionContext;
import com.botmaker.ui.BlockDragAndDropManager;
import com.botmaker.util.DefaultNames;
import com.botmaker.util.TypeManager;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.Node;
import javafx.scene.control.*;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Priority;
import javafx.scene.layout.Region;
import javafx.scene.layout.VBox;
import org.eclipse.jdt.core.dom.MethodDeclaration;
import org.eclipse.jdt.core.dom.SingleVariableDeclaration;

import java.util.Collections;
import java.util.List;

public class MethodDeclarationBlock extends AbstractStatementBlock implements BlockWithChildren {

    private final String methodName;
    private final String returnType;
    private BodyBlock body;

    public MethodDeclarationBlock(String id, MethodDeclaration astNode, BlockDragAndDropManager manager) {
        super(id, astNode);
        this.methodName = astNode.getName().getIdentifier();
        if (astNode.getReturnType2() != null) {
            this.returnType = astNode.getReturnType2().toString();
        } else {
            this.returnType = "void";
        }
    }

    public void setBody(BodyBlock body) {
        this.body = body;
    }

    @Override
    public List<CodeBlock> getChildren() {
        return body != null ? Collections.singletonList(body) : Collections.emptyList();
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        VBox container = new VBox(0); // 0 spacing, handled by padding
        container.getStyleClass().add("method-block");
        // CSS: .method-block { -fx-background-color: transparent; }

        // --- HEADER SECTION ---
        VBox headerBox = new VBox(5);
        headerBox.getStyleClass().add("method-header");
        // We will do inline styles here for immediate results, but moving to CSS is better
        // A nice purple/indigo for functions
        headerBox.setStyle(
                "-fx-background-color: #8E44AD; " +
                        "-fx-background-radius: 8 8 0 0; " +
                        "-fx-padding: 8 10 8 10;"
        );

        // Row 1: "Function [Name] returns [Type]"
        HBox topRow = new HBox(8);
        topRow.setAlignment(Pos.CENTER_LEFT);

        Label funcLabel = new Label("Function");
        funcLabel.setStyle("-fx-text-fill: rgba(255,255,255,0.8); -fx-font-weight: bold; -fx-font-size: 10px; -fx-text-transform: uppercase;");

        Label nameLabel = new Label(methodName);
        nameLabel.setStyle("-fx-text-fill: white; -fx-font-family: 'Segoe UI', sans-serif; -fx-font-weight: bold; -fx-font-size: 14px;");

        Region spacer = new Region();
        HBox.setHgrow(spacer, Priority.ALWAYS);

        Label returnsLabel = new Label("returns");
        returnsLabel.setStyle("-fx-text-fill: rgba(255,255,255,0.7); -fx-font-style: italic; -fx-font-size: 11px;");

        ComboBox<String> typeSelector = new ComboBox<>();
        typeSelector.getItems().add("void");
        typeSelector.getItems().addAll(TypeManager.getFundamentalTypeNames());
        typeSelector.setValue(returnType);
        typeSelector.setStyle("-fx-font-size: 11px; -fx-background-color: rgba(255,255,255,0.2); -fx-text-fill: white; -fx-background-radius: 4;");
        // Force the text inside combo to be visible (JavaFX Combobox styling can be tricky)
        typeSelector.setButtonCell(new ListCell<String>() {
            @Override
            protected void updateItem(String item, boolean empty) {
                super.updateItem(item, empty);
                if(empty || item == null) { setText(null); }
                else {
                    setText(item);
                    setStyle("-fx-text-fill: white;"); // Make selected text white
                }
            }
        });

        typeSelector.setOnAction(e -> {
            String selected = typeSelector.getValue();
            if (!selected.equals(returnType)) {
                context.codeEditor().setMethodReturnType((MethodDeclaration) this.astNode, selected);
            }
        });

        topRow.getChildren().addAll(funcLabel, nameLabel, spacer, returnsLabel, typeSelector);

        // Row 2: Parameters
        HBox paramRow = new HBox(6);
        paramRow.setAlignment(Pos.CENTER_LEFT);

        Label paramsLabel = new Label("Inputs:");
        paramsLabel.setStyle("-fx-text-fill: rgba(255,255,255,0.7); -fx-font-size: 11px;");
        paramRow.getChildren().add(paramsLabel);

        MethodDeclaration md = (MethodDeclaration) this.astNode;
        List<?> params = md.parameters();

        for (int i = 0; i < params.size(); i++) {
            SingleVariableDeclaration param = (SingleVariableDeclaration) params.get(i);
            Node paramNode = createParamNode(param, i, context);
            paramRow.getChildren().add(paramNode);
        }

        MenuButton addParamBtn = new MenuButton("+");
        addParamBtn.setStyle("-fx-font-size: 10px; -fx-padding: 2 6 2 6; -fx-background-color: rgba(255,255,255,0.2); -fx-text-fill: white; -fx-background-radius: 10;");

        for (String type : TypeManager.getFundamentalTypeNames()) {
            MenuItem item = new MenuItem(type);
            item.setOnAction(e -> {
                String defaultName = DefaultNames.forType(type);
                context.codeEditor().addParameterToMethod(
                        (MethodDeclaration) this.astNode, type, defaultName
                );
            });
            addParamBtn.getItems().add(item);
        }
        paramRow.getChildren().add(addParamBtn);

        headerBox.getChildren().addAll(topRow, paramRow);
        container.getChildren().add(headerBox);

        // --- BODY ---
        VBox bodyWrapper = new VBox();
        // Add a left border to visually connect header to body
        bodyWrapper.setStyle("-fx-border-color: #8E44AD; -fx-border-width: 0 0 0 4; -fx-background-color: rgba(142, 68, 173, 0.05);");

        if (body != null) {
            Node bodyNode = body.getUINode(context);
            VBox.setVgrow(bodyNode, Priority.ALWAYS);
            bodyWrapper.getChildren().add(bodyNode);
        }
        container.getChildren().add(bodyWrapper);

        return container;
    }

    private Node createParamNode(SingleVariableDeclaration param, int index, CompletionContext context) {
        HBox box = new HBox(4);
        box.setAlignment(Pos.CENTER_LEFT);
        // Pill style: Semi-transparent white background
        box.setStyle("-fx-background-color: rgba(255,255,255,0.9); -fx-background-radius: 12; -fx-padding: 3 8 3 8;");

        Label typeLabel = new Label(param.getType().toString());
        typeLabel.setStyle("-fx-text-fill: #8E44AD; -fx-font-weight: bold; -fx-font-size: 11px;");

        String currentName = param.getName().getIdentifier();
        TextField nameField = new TextField(currentName);

        // Make the TextField look like a label unless clicked
        nameField.setStyle(
                "-fx-background-color: transparent; " +
                        "-fx-padding: 0; " +
                        "-fx-font-size: 11px; " +
                        "-fx-text-fill: #333;"
        );
        nameField.setPrefWidth(Math.max(30, currentName.length() * 7));

        // When focused, add a subtle underline or border
        nameField.focusedProperty().addListener((obs, oldVal, newVal) -> {
            if (newVal) {
                nameField.setStyle("-fx-background-color: white; -fx-padding: 0; -fx-font-size: 11px; -fx-text-fill: black; -fx-border-color: #8E44AD; -fx-border-width: 0 0 1 0;");
            } else {
                // Lost focus - save and revert style
                nameField.setStyle("-fx-background-color: transparent; -fx-padding: 0; -fx-font-size: 11px; -fx-text-fill: #333;");
                String val = nameField.getText().trim();
                if (!val.isEmpty() && !val.equals(currentName)) {
                    context.codeEditor().renameMethodParameter((MethodDeclaration) this.astNode, index, val);
                } else {
                    nameField.setText(currentName);
                }
            }
        });

        nameField.setOnAction(e -> box.requestFocus()); // Commit on Enter

        Button deleteBtn = new Button("×");
        deleteBtn.setStyle("-fx-background-color: transparent; -fx-text-fill: #999; -fx-font-size: 12px; -fx-padding: 0; -fx-cursor: hand;");
        deleteBtn.setOnAction(e -> {
            context.codeEditor().deleteParameterFromMethod((MethodDeclaration) this.astNode, index);
        });
        // Hover effect for delete
        deleteBtn.setOnMouseEntered(e -> deleteBtn.setStyle("-fx-background-color: transparent; -fx-text-fill: #E74C3C; -fx-font-size: 12px; -fx-padding: 0; -fx-cursor: hand;"));
        deleteBtn.setOnMouseExited(e -> deleteBtn.setStyle("-fx-background-color: transparent; -fx-text-fill: #999; -fx-font-size: 12px; -fx-padding: 0; -fx-cursor: hand;"));

        box.getChildren().addAll(typeLabel, nameField, deleteBtn);
        return box;
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/blocks/MethodInvocationBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractExpressionBlock;
import com.botmaker.core.ExpressionBlock;
import com.botmaker.core.StatementBlock;
import com.botmaker.lsp.CompletionContext;
import com.botmaker.project.ProjectFile;
import com.botmaker.ui.AddableExpression;
import javafx.geometry.Pos;
import javafx.scene.Node;
import javafx.scene.control.*;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Priority;
import javafx.scene.layout.Region;
import org.eclipse.jdt.core.dom.*;

import java.util.ArrayList;
import java.util.List;

public class MethodInvocationBlock extends AbstractExpressionBlock implements StatementBlock {

    private String scopeName;
    private String methodName;
    private final List<ExpressionBlock> arguments = new ArrayList<>();
    private boolean isStatementContext = false;

    public MethodInvocationBlock(String id, ASTNode astNode) {
        super(id, resolveExpressionNode(astNode));

        if (astNode instanceof ExpressionStatement) {
            this.isStatementContext = true;
        }

        MethodInvocation mi = (MethodInvocation) this.astNode;
        this.methodName = mi.getName().getIdentifier();
        if (mi.getExpression() != null) {
            this.scopeName = mi.getExpression().toString();
        } else {
            this.scopeName = ""; // Local
        }
    }

    private static MethodInvocation resolveExpressionNode(ASTNode node) {
        if (node instanceof ExpressionStatement) {
            return (MethodInvocation) ((ExpressionStatement) node).getExpression();
        }
        return (MethodInvocation) node;
    }

    public void addArgument(ExpressionBlock arg) {
        arguments.add(arg);
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        HBox container = new HBox(6);
        container.setAlignment(Pos.CENTER_LEFT);
        container.getStyleClass().add("method-call-block");

        if (!isStatementContext) {
            container.setStyle("-fx-background-color: #34495E; -fx-background-radius: 12; -fx-padding: 3 8 3 8;");
        } else {
            container.setStyle("-fx-background-color: #34495E; -fx-background-radius: 4; -fx-padding: 5 10 5 10;");
        }

        Label callLabel = new Label("Call");
        callLabel.setStyle("-fx-text-fill: #aaa; -fx-font-weight: bold; -fx-font-size: 10px;");

        // --- Prepare Data ---
        String currentFileClass = "";
        if (context.applicationState() != null && context.applicationState().getActiveFile() != null) {
            currentFileClass = context.applicationState().getActiveFile().getClassName();
        }

        // --- File Selector ---
        ComboBox<String> fileSelector = new ComboBox<>();
        if (context.applicationState() != null) {
            for (ProjectFile file : context.applicationState().getAllFiles()) {
                fileSelector.getItems().add(file.getClassName());
            }
        }

        String displayValue = scopeName.isEmpty() ? currentFileClass : scopeName;
        if (!fileSelector.getItems().contains(displayValue)) {
            fileSelector.getItems().add(0, displayValue);
        }
        fileSelector.setValue(displayValue);
        fileSelector.setStyle("-fx-font-size: 11px; -fx-pref-width: 100px;");

        // --- Method Selector ---
        ComboBox<String> methodSelector = new ComboBox<>();
        methodSelector.setValue(methodName);
        methodSelector.setEditable(false);
        methodSelector.setStyle("-fx-font-size: 11px; -fx-pref-width: 120px; -fx-font-weight: bold;");

        final String finalCurrentFileClass = currentFileClass;

        // --- Logic to populate methods ---
        Runnable populateMethodList = () -> {
            String selectedFile = fileSelector.getValue();
            methodSelector.getItems().clear();

            ProjectFile targetFile = findProjectFile(context, selectedFile);

            if (targetFile != null) {
                ensureAstParsed(targetFile);

                if (targetFile.getAst() != null && !targetFile.getAst().types().isEmpty()) {
                    TypeDeclaration type = (TypeDeclaration) targetFile.getAst().types().get(0);
                    boolean isLocal = selectedFile.equals(finalCurrentFileClass);

                    for (MethodDeclaration md : type.getMethods()) {
                        int mods = md.getModifiers();
                        boolean isStatic = Modifier.isStatic(mods);
                        boolean isPublic = Modifier.isPublic(mods);

                        if (isLocal || (isPublic && isStatic)) {
                            methodSelector.getItems().add(md.getName().getIdentifier());
                        }
                    }
                }

                // NEW: Auto-select if only one option
                if (methodSelector.getItems().size() == 1) {
                    methodSelector.getSelectionModel().select(0);
                }
            }
        };

        // Listener: Update Code on Method Selection
        methodSelector.setOnAction(e -> {
            String newMethodName = methodSelector.getValue();
            if (newMethodName == null) return;

            String newScopeDisplay = fileSelector.getValue();
            String newScopeAST = newScopeDisplay.equals(finalCurrentFileClass) ? "" : newScopeDisplay;

            if (newMethodName.equals(methodName) && newScopeAST.equals(scopeName)) return;

            List<String> paramTypes = findParameterTypes(context, newScopeDisplay, newMethodName);

            context.codeEditor().updateMethodInvocation(
                    (MethodInvocation) this.astNode,
                    newScopeAST,
                    newMethodName,
                    paramTypes
            );
        });

        fileSelector.setOnAction(e -> {
            populateMethodList.run();
            methodSelector.show();
        });

        populateMethodList.run();

        container.getChildren().addAll(callLabel, fileSelector, new Label("."), methodSelector);

        // --- Arguments UI ---
        Label argsLabel = new Label("(");
        argsLabel.setStyle("-fx-text-fill: white;");
        container.getChildren().add(argsLabel);

        // Fetch parameter names for display labels
        List<String> paramNames = findParameterNames(context, displayValue, methodName);

        for (int i = 0; i < arguments.size(); i++) {
            ExpressionBlock arg = arguments.get(i);
            HBox argBox = new HBox(2);
            argBox.setAlignment(Pos.CENTER_LEFT);
            argBox.setStyle("-fx-background-color: rgba(255,255,255,0.1); -fx-background-radius: 4; -fx-padding: 2;");

            // Parameter Name Label
            if (i < paramNames.size()) {
                Label paramNameLabel = new Label(paramNames.get(i) + ":");
                paramNameLabel.setStyle("-fx-text-fill: #aaa; -fx-font-size: 9px; -fx-padding: 0 4 0 2;");
                argBox.getChildren().add(paramNameLabel);
            }

            argBox.getChildren().add(arg.getUINode(context));

            // Delete Button
            Button delBtn = new Button("×");
            delBtn.setStyle("-fx-background-color: transparent; -fx-text-fill: #E74C3C; -fx-font-size: 10px; -fx-padding: 0 0 0 2; -fx-cursor: hand;");
            int index = i;
            delBtn.setOnAction(e -> {
                // Use generic list deletion
                context.codeEditor().deleteElementFromList(this.astNode, index);
            });
            argBox.getChildren().add(delBtn);

            container.getChildren().add(argBox);
        }

        MenuButton addArgBtn = new MenuButton("+");
        addArgBtn.setStyle("-fx-font-size: 9px; -fx-padding: 2 4 2 4;");
        for (AddableExpression type : AddableExpression.values()) {
            MenuItem item = new MenuItem(type.getDisplayName());
            item.setOnAction(e -> {
                context.codeEditor().addArgumentToMethodInvocation(
                        (MethodInvocation) this.astNode,
                        type
                );
            });
            addArgBtn.getItems().add(item);
        }
        container.getChildren().add(addArgBtn);

        Label closeParen = new Label(")");
        closeParen.setStyle("-fx-text-fill: white;");
        container.getChildren().add(closeParen);

        if (isStatementContext) {
            Region spacer = new Region();
            HBox.setHgrow(spacer, Priority.ALWAYS);
            Button deleteButton = new Button("X");
            deleteButton.setOnAction(e -> context.codeEditor().deleteStatement((Statement) this.astNode.getParent()));
            container.getChildren().addAll(spacer, deleteButton);
        }

        return container;
    }

    // --- Helpers ---

    private ProjectFile findProjectFile(CompletionContext context, String className) {
        if (context.applicationState() == null) return null;
        for (ProjectFile file : context.applicationState().getAllFiles()) {
            if (file.getClassName().equals(className)) {
                return file;
            }
        }
        return null;
    }

    private void ensureAstParsed(ProjectFile file) {
        if (file.getAst() == null) {
            try {
                ASTParser parser = ASTParser.newParser(AST.getJLSLatest());
                parser.setSource(file.getContent().toCharArray());
                parser.setKind(ASTParser.K_COMPILATION_UNIT);
                CompilationUnit cu = (CompilationUnit) parser.createAST(null);
                file.setAst(cu);
            } catch (Exception ignored) {}
        }
    }

    private List<String> findParameterTypes(CompletionContext context, String className, String methodName) {
        List<String> types = new ArrayList<>();
        ProjectFile targetFile = findProjectFile(context, className);

        if (targetFile != null) {
            ensureAstParsed(targetFile);
            if (targetFile.getAst() != null && !targetFile.getAst().types().isEmpty()) {
                TypeDeclaration type = (TypeDeclaration) targetFile.getAst().types().get(0);
                for (MethodDeclaration md : type.getMethods()) {
                    if (md.getName().getIdentifier().equals(methodName)) {
                        for (Object p : md.parameters()) {
                            SingleVariableDeclaration param = (SingleVariableDeclaration) p;
                            types.add(param.getType().toString());
                        }
                        return types;
                    }
                }
            }
        }
        return types;
    }

    // NEW: Helper to get parameter names for UI labels
    private List<String> findParameterNames(CompletionContext context, String className, String methodName) {
        List<String> names = new ArrayList<>();
        ProjectFile targetFile = findProjectFile(context, className);

        if (targetFile != null) {
            ensureAstParsed(targetFile);
            if (targetFile.getAst() != null && !targetFile.getAst().types().isEmpty()) {
                TypeDeclaration type = (TypeDeclaration) targetFile.getAst().types().get(0);
                for (MethodDeclaration md : type.getMethods()) {
                    if (md.getName().getIdentifier().equals(methodName)) {
                        for (Object p : md.parameters()) {
                            SingleVariableDeclaration param = (SingleVariableDeclaration) p;
                            names.add(param.getName().getIdentifier());
                        }
                        return names;
                    }
                }
            }
        }
        return names;
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/blocks/PrintBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractStatementBlock;
import com.botmaker.core.ExpressionBlock;
import com.botmaker.lsp.CompletionContext;
import javafx.geometry.Pos;
import javafx.scene.Node;
import javafx.scene.layout.HBox;
import javafx.scene.text.Text;
import org.eclipse.jdt.core.dom.ExpressionStatement;
import org.eclipse.jdt.core.dom.MethodInvocation;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

public class PrintBlock extends AbstractStatementBlock {

    private final List<ExpressionBlock> arguments = new ArrayList<>();

    public PrintBlock(String id, ExpressionStatement astNode) {
        super(id, astNode);
    }

    public List<ExpressionBlock> getArguments() {
        return arguments;
    }

    public void addArgument(ExpressionBlock argument) {
        this.arguments.add(argument);
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        HBox container = new HBox(5);
        container.setAlignment(Pos.CENTER_LEFT);
        container.getStyleClass().add("print-block");

        container.getChildren().add(new Text("Print:"));

        if (arguments.isEmpty()) {
            container.getChildren().add(createExpressionDropZone(context));
        } else {
            for (ExpressionBlock arg : arguments) {
                container.getChildren().add(arg.getUINode(context));
            }
        }

        javafx.scene.control.Button addButton = new javafx.scene.control.Button("+");
        javafx.scene.control.ContextMenu contextMenu = new javafx.scene.control.ContextMenu();

        for (com.botmaker.ui.AddableExpression type : com.botmaker.ui.AddableExpression.values()) {
            javafx.scene.control.MenuItem menuItem = new javafx.scene.control.MenuItem(type.getDisplayName());
            menuItem.setOnAction(e -> {
                if (!arguments.isEmpty()) {
                    // We are assuming one argument for now
                    org.eclipse.jdt.core.dom.Expression toReplace = (org.eclipse.jdt.core.dom.Expression) arguments.get(0).getAstNode();
                    context.codeEditor().replaceExpression(toReplace, type);
                }
            });
            contextMenu.getItems().add(menuItem);
        }

        addButton.setOnAction(e -> contextMenu.show(addButton, javafx.geometry.Side.BOTTOM, 0, 0));
        container.getChildren().add(addButton);

        javafx.scene.control.Button deleteButton = new javafx.scene.control.Button("X");
        deleteButton.setOnAction(e -> {
            context.codeEditor().deleteStatement((org.eclipse.jdt.core.dom.Statement) this.astNode);
        });

        javafx.scene.layout.Pane spacer = new javafx.scene.layout.Pane();
        HBox.setHgrow(spacer, javafx.scene.layout.Priority.ALWAYS);

        container.getChildren().addAll(spacer, deleteButton);

        return container;
    }

    @Override
    public String getDetails() {
        String argsString = arguments.stream()
                .map(ExpressionBlock::getDetails)
                .collect(Collectors.joining(", "));
        return "Print Statement: " + argsString;
    }
}


=================================================================================
FILE: ./src/main/java/com/botmaker/blocks/ReadInputBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractStatementBlock;
import com.botmaker.core.ExpressionBlock;
import com.botmaker.lsp.CompletionContext;
import javafx.geometry.Pos;
import javafx.scene.Node;
import javafx.scene.control.Label;
import javafx.scene.layout.HBox;
import org.eclipse.jdt.core.dom.VariableDeclarationStatement;

public class ReadInputBlock extends AbstractStatementBlock {

    private ExpressionBlock variableName;
    private String inputType; // "nextLine", "nextInt", "nextDouble", etc.

    public ReadInputBlock(String id, VariableDeclarationStatement astNode, String inputType) {
        super(id, astNode);
        this.inputType = inputType;
    }

    public ExpressionBlock getVariableName() {
        return variableName;
    }

    public void setVariableName(ExpressionBlock variableName) {
        this.variableName = variableName;
    }

    public String getInputType() {
        return inputType;
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        HBox container = new HBox(5);
        container.setAlignment(Pos.CENTER_LEFT);
        container.getStyleClass().add("read-input-block");

        // Display based on input type
        Label typeLabel = new Label(getTypeDisplayName());
        typeLabel.getStyleClass().add("type-label");

        if (variableName != null) {
            container.getChildren().add(variableName.getUINode(context));
        }

        Label equalsLabel = new Label("=");
        Label scannerLabel = new Label("scanner." + inputType + "()");
        scannerLabel.getStyleClass().add("method-call-label");

        container.getChildren().addAll(typeLabel, equalsLabel, scannerLabel);

        // Add spacer and delete button
        javafx.scene.layout.Pane spacer = new javafx.scene.layout.Pane();
        HBox.setHgrow(spacer, javafx.scene.layout.Priority.ALWAYS);

        javafx.scene.control.Button deleteButton = new javafx.scene.control.Button("X");
        deleteButton.setOnAction(e -> {
            context.codeEditor().deleteStatement((org.eclipse.jdt.core.dom.Statement) this.astNode);
        });

        container.getChildren().addAll(spacer, deleteButton);

        return container;
    }

    private String getTypeDisplayName() {
        switch (inputType) {
            case "nextLine":
                return "String";
            case "nextInt":
                return "int";
            case "nextDouble":
                return "double";
            case "nextBoolean":
                return "boolean";
            default:
                return "var";
        }
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/blocks/ReturnBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractStatementBlock;
import com.botmaker.core.ExpressionBlock;
import com.botmaker.lsp.CompletionContext;
import com.botmaker.ui.AddableExpression;
import com.botmaker.util.TypeManager;
import javafx.geometry.Pos;
import javafx.scene.Node;
import javafx.scene.control.Button;
import javafx.scene.control.ContextMenu;
import javafx.scene.control.Label;
import javafx.scene.control.MenuItem;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Pane;
import javafx.scene.layout.Priority;
import org.eclipse.jdt.core.dom.ASTNode;
import org.eclipse.jdt.core.dom.MethodDeclaration;
import org.eclipse.jdt.core.dom.ReturnStatement;
import org.eclipse.jdt.core.dom.Statement;

public class ReturnBlock extends AbstractStatementBlock {

    private ExpressionBlock expression;

    public ReturnBlock(String id, ReturnStatement astNode) {
        super(id, astNode);
    }

    public void setExpression(ExpressionBlock expression) {
        this.expression = expression;
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        HBox container = new HBox(5);
        container.setAlignment(Pos.CENTER_LEFT);
        container.getStyleClass().add("return-block");

        Label returnLabel = new Label("return");
        returnLabel.getStyleClass().add("keyword-label");
        container.getChildren().add(returnLabel);

        // Determine parent method return type
        String methodReturnType = findParentMethodReturnType();
        boolean isVoid = "void".equals(methodReturnType);

        if (expression != null) {
            container.getChildren().add(expression.getUINode(context));

            // Allow changing it
            Button changeBtn = new Button("↻");
            changeBtn.getStyleClass().add("icon-button");
            changeBtn.setOnAction(e -> showExpressionMenu(changeBtn, context, methodReturnType));
            container.getChildren().add(changeBtn);

        } else if (!isVoid) {
            // Only show "Add" button if not void
            Button addButton = new Button("+");
            addButton.getStyleClass().add("expression-add-button");
            addButton.setOnAction(e -> showExpressionMenu(addButton, context, methodReturnType));
            container.getChildren().add(addButton);
        } else {
            // It's void and has no expression -> Just show implicit "void" label or nothing
            Label voidLabel = new Label("(void)");
            voidLabel.setStyle("-fx-text-fill: #aaa; -fx-font-size: 10px; -fx-font-style: italic;");
            container.getChildren().add(voidLabel);
        }

        // Spacer and Delete Button
        Pane spacer = new Pane();
        HBox.setHgrow(spacer, Priority.ALWAYS);

        Button deleteButton = new Button("X");
        deleteButton.setOnAction(e -> {
            context.codeEditor().deleteStatement((Statement) this.astNode);
        });

        container.getChildren().addAll(spacer, deleteButton);

        return container;
    }

    private String findParentMethodReturnType() {
        ASTNode current = this.astNode.getParent();
        while (current != null) {
            if (current instanceof MethodDeclaration) {
                MethodDeclaration md = (MethodDeclaration) current;
                if (md.getReturnType2() != null) {
                    return md.getReturnType2().toString();
                }
                return "void";
            }
            current = current.getParent();
        }
        return "void"; // Default safe fallback
    }

    private void showExpressionMenu(Button button, CompletionContext context, String targetType) {
        ContextMenu menu = new ContextMenu();

        // Convert Java type (e.g., int) to UI type (e.g., number)
        String uiType = TypeManager.determineUiType(targetType);

        for (AddableExpression type : AddableExpression.getForType(uiType)) {
            MenuItem menuItem = new MenuItem(type.getDisplayName());
            menuItem.setOnAction(e -> {
                context.codeEditor().setReturnExpression(
                        (ReturnStatement) this.astNode,
                        type
                );
            });
            menu.getItems().add(menuItem);
        }
        menu.show(button, javafx.geometry.Side.BOTTOM, 0, 0);
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/blocks/SwitchBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractStatementBlock;
import com.botmaker.core.BodyBlock;
import com.botmaker.core.BlockWithChildren;
import com.botmaker.core.CodeBlock;
import com.botmaker.core.ExpressionBlock;
import com.botmaker.lsp.CompletionContext;
import com.botmaker.ui.BlockDragAndDropManager;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.Node;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Pane;
import javafx.scene.layout.Priority;
import javafx.scene.layout.VBox;
import org.eclipse.jdt.core.dom.SwitchStatement;

import java.util.ArrayList;
import java.util.List;

public class SwitchBlock extends AbstractStatementBlock implements BlockWithChildren {

    private ExpressionBlock expression;
    private final List<SwitchCaseBlock> cases = new ArrayList<>();
    private final BlockDragAndDropManager dragAndDropManager;

    public SwitchBlock(String id, SwitchStatement astNode, BlockDragAndDropManager dragAndDropManager) {
        super(id, astNode);
        this.dragAndDropManager = dragAndDropManager;
    }

    public ExpressionBlock getExpression() {
        return expression;
    }

    public void setExpression(ExpressionBlock expression) {
        this.expression = expression;
    }

    public List<SwitchCaseBlock> getCases() {
        return cases;
    }

    public void addCase(SwitchCaseBlock caseBlock) {
        this.cases.add(caseBlock);
    }

    @Override
    public List<CodeBlock> getChildren() {
        List<CodeBlock> children = new ArrayList<>();
        if (expression != null) children.add(expression);
        children.addAll(cases);
        return children;
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        VBox mainContainer = new VBox(5);
        mainContainer.getStyleClass().add("switch-block");

        // Header row with delete button
        HBox headerRow = new HBox(5);
        headerRow.setAlignment(Pos.CENTER_LEFT);

        // Switch expression part
        HBox header = new HBox(5);
        header.setAlignment(Pos.CENTER_LEFT);
        header.getStyleClass().add("switch-header");

        Label switchLabel = new Label("switch");
        switchLabel.getStyleClass().add("keyword-label");

        header.getChildren().add(switchLabel);
        if (expression != null) {
            header.getChildren().add(expression.getUINode(context));
        }

        // Add spacer and delete button
        Pane spacer = new Pane();
        HBox.setHgrow(spacer, Priority.ALWAYS);

        Button deleteButton = new Button("X");
        deleteButton.setOnAction(e -> {
            context.codeEditor().deleteStatement((org.eclipse.jdt.core.dom.Statement) this.astNode);
        });

        headerRow.getChildren().addAll(header, spacer, deleteButton);
        mainContainer.getChildren().add(headerRow);

        // Cases
        VBox casesContainer = new VBox(5);
        casesContainer.getStyleClass().add("switch-cases");
        casesContainer.setPadding(new Insets(5, 0, 0, 20));

        for (SwitchCaseBlock caseBlock : cases) {
            casesContainer.getChildren().add(caseBlock.getUINode(context));
        }

        mainContainer.getChildren().add(casesContainer);

        return mainContainer;
    }

    /**
     * Inner class representing a single case in the switch
     */
    public static class SwitchCaseBlock extends AbstractStatementBlock implements BlockWithChildren {
        private ExpressionBlock caseExpression; // null for default case
        private BodyBlock body;
        private final BlockDragAndDropManager dragAndDropManager;

        public SwitchCaseBlock(String id, org.eclipse.jdt.core.dom.SwitchCase astNode, BlockDragAndDropManager dragAndDropManager) {
            super(id, astNode);
            this.dragAndDropManager = dragAndDropManager;
        }

        public void setCaseExpression(ExpressionBlock caseExpression) {
            this.caseExpression = caseExpression;
        }

        public void setBody(BodyBlock body) {
            this.body = body;
        }

        public boolean isDefault() {
            return caseExpression == null;
        }

        @Override
        public List<CodeBlock> getChildren() {
            List<CodeBlock> children = new ArrayList<>();
            if (caseExpression != null) children.add(caseExpression);
            if (body != null) children.add(body);
            return children;
        }

        @Override
        protected Node createUINode(CompletionContext context) {
            VBox container = new VBox(5);
            container.getStyleClass().add("switch-case-block");

            // Case label
            HBox caseHeader = new HBox(5);
            caseHeader.setAlignment(Pos.CENTER_LEFT);

            if (isDefault()) {
                Label defaultLabel = new Label("default:");
                defaultLabel.getStyleClass().add("keyword-label");
                caseHeader.getChildren().add(defaultLabel);
            } else {
                Label caseLabel = new Label("case");
                caseLabel.getStyleClass().add("keyword-label");
                caseHeader.getChildren().add(caseLabel);
                if (caseExpression != null) {
                    caseHeader.getChildren().add(caseExpression.getUINode(context));
                }
                Label colon = new Label(":");
                caseHeader.getChildren().add(colon);
            }

            container.getChildren().add(caseHeader);

            // Case body
            if (body != null) {
                VBox bodyContainer = new VBox();
                bodyContainer.getStyleClass().add("switch-case-body");
                bodyContainer.setPadding(new Insets(5, 0, 0, 20));
                bodyContainer.getChildren().add(body.getUINode(context));
                container.getChildren().add(bodyContainer);
            }

            return container;
        }
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/blocks/VariableDeclarationBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractStatementBlock;
import com.botmaker.core.ExpressionBlock;
import com.botmaker.lsp.CompletionContext;
import com.botmaker.ui.AddableExpression;
import com.botmaker.util.TypeManager;
import javafx.geometry.Pos;
import javafx.scene.Cursor;
import javafx.scene.Node;
import javafx.scene.control.*;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Priority;
import org.eclipse.jdt.core.dom.Type;
import org.eclipse.jdt.core.dom.VariableDeclarationFragment;
import org.eclipse.jdt.core.dom.VariableDeclarationStatement;

public class VariableDeclarationBlock extends AbstractStatementBlock {

    private final String variableName;
    private final Type variableType;
    private ExpressionBlock initializer;

    public VariableDeclarationBlock(String id, VariableDeclarationStatement astNode) {
        super(id, astNode);
        VariableDeclarationFragment fragment = (VariableDeclarationFragment) astNode.fragments().get(0);
        this.variableName = fragment.getName().getIdentifier();
        this.variableType = astNode.getType();
        this.initializer = null;
    }

    public void setInitializer(ExpressionBlock initializer) {
        this.initializer = initializer;
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        HBox container = new HBox(5);
        container.setAlignment(Pos.CENTER_LEFT);
        container.getStyleClass().add("variable-declaration-block");

        // --- TYPE SELECTOR ---
        Label typeLabel = new Label(getDisplayTypeName(variableType));
        typeLabel.getStyleClass().add("type-label");
        typeLabel.setCursor(Cursor.HAND);

        Tooltip tooltip = new Tooltip("Click to change type (ArrayList/Base)");
        Tooltip.install(typeLabel, tooltip);

        typeLabel.setOnMouseClicked(e -> showTypeMenu(typeLabel, context));
        container.getChildren().add(typeLabel);

        // --- NAME FIELD ---
        TextField nameField = new TextField(variableName);
        nameField.getStyleClass().add("variable-name-field");
        nameField.setPrefWidth(100);
        nameField.focusedProperty().addListener((obs, oldVal, newVal) -> {
            if (!newVal) {
                String newName = nameField.getText();
                VariableDeclarationFragment fragment = (VariableDeclarationFragment) ((VariableDeclarationStatement) this.astNode).fragments().get(0);
                String currentName = fragment.getName().getIdentifier();

                if (!newName.equals(currentName) && !newName.isEmpty()) {
                    context.codeEditor().replaceSimpleName(fragment.getName(), newName);
                }
            }
        });
        container.getChildren().add(nameField);

        // --- EQUALS ---
        Label equalsLabel = new Label("=");
        equalsLabel.getStyleClass().add("keyword-label");
        container.getChildren().add(equalsLabel);

        // --- INITIALIZER ---
        if (initializer != null) {
            // FIX: Prioritize rendering the initializer if it exists, especially if it's a ListBlock
            if (initializer instanceof ListBlock) {
                // Render the interactive list UI directly
                container.getChildren().add(initializer.getUINode(context));
            }
            else if (initializer.getAstNode() instanceof org.eclipse.jdt.core.dom.ArrayInitializer) {
                // Fallback for primitive arrays {1,2,3} to use bracket styling if not caught by ListBlock
                container.getChildren().add(createListDisplay(context));
            }
            else {
                // Standard expression
                container.getChildren().add(initializer.getUINode(context));
            }
        } else {
            // Only show placeholder if truly null (e.g. int x;)
            container.getChildren().add(createExpressionDropZone(context));
        }

        // --- ADD BUTTON ---
        Button addButton = new Button("+");
        addButton.getStyleClass().add("expression-add-button");

        // DYNAMIC TYPE FILTERING
        String uiTargetType = TypeManager.determineUiType(variableType.toString());
        addButton.setOnAction(e -> showExpressionMenu(addButton, context, uiTargetType));

        container.getChildren().add(addButton);

        // --- SPACER & DELETE ---
        javafx.scene.layout.Pane spacer = new javafx.scene.layout.Pane();
        HBox.setHgrow(spacer, Priority.ALWAYS);

        Button deleteButton = new Button("X");
        deleteButton.setOnAction(e -> {
            context.codeEditor().deleteStatement((org.eclipse.jdt.core.dom.Statement) this.astNode);
        });

        container.getChildren().addAll(spacer, deleteButton);

        return container;
    }

    private void showTypeMenu(Node anchor, CompletionContext context) {
        ContextMenu menu = new ContextMenu();

        String currentStr = variableType.toString();
        boolean isArrayListType = isArrayList(variableType);
        boolean isArray = variableType.isArrayType();

        final String baseType = extractBaseType(currentStr, isArrayListType, isArray);

        // 1. Toggle between ArrayList and Single Value
        MenuItem toggleList = new MenuItem(isArrayListType ? "Convert to Single Value" : "Convert to ArrayList");
        toggleList.setStyle("-fx-font-weight: bold;");
        toggleList.setOnAction(e -> {
            String newType;
            if (isArrayListType) {
                newType = baseType;
            } else {
                // FIX: Ensure wrapper type (e.g., Integer, Boolean) is used
                newType = "ArrayList<" + TypeManager.toWrapperType(baseType) + ">";
            }
            context.codeEditor().replaceVariableType((VariableDeclarationStatement) this.astNode, newType);
        });
        menu.getItems().add(toggleList);

        // Option for nested list
        if (isArrayListType) {
            MenuItem makeNested = new MenuItem("Make ArrayList of ArrayLists");
            makeNested.setOnAction(e -> {
                // FIX: Ensure inner type is also wrapped properly
                // Result: ArrayList<ArrayList<Boolean>>
                String newType = "ArrayList<ArrayList<" + TypeManager.toWrapperType(baseType) + ">>";
                context.codeEditor().replaceVariableType((VariableDeclarationStatement) this.astNode, newType);
            });
            menu.getItems().add(makeNested);
        }

        menu.getItems().add(new SeparatorMenuItem());

        // 2. Change Base Type
        Menu changeBaseMenu = new Menu("Change Base Type");
        for (String type : TypeManager.getFundamentalTypeNames()) {
            MenuItem item = new MenuItem(type);
            final String finalType = type;
            item.setOnAction(e -> {
                String newType;
                if (isArrayListType) {
                    // FIX: Ensure wrapper type is used when switching types in a list
                    newType = "ArrayList<" + TypeManager.toWrapperType(finalType) + ">";
                } else {
                    newType = finalType;
                }
                context.codeEditor().replaceVariableType((VariableDeclarationStatement) this.astNode, newType);
            });
            changeBaseMenu.getItems().add(item);
        }
        menu.getItems().add(changeBaseMenu);

        menu.show(anchor, javafx.geometry.Side.BOTTOM, 0, 0);
    }

    private String extractBaseType(String currentStr, boolean isArrayListType, boolean isArray) {
        if (isArrayListType) {
            if (currentStr.contains("<") && currentStr.contains(">")) {
                int start = currentStr.indexOf("<") + 1;
                int end = currentStr.lastIndexOf(">"); // Fix: use lastIndexOf for nested
                return currentStr.substring(start, end);
            }
        } else if (isArray) {
            return currentStr.replace("[]", "");
        }
        return currentStr;
    }

    private HBox createListDisplay(CompletionContext context) {
        HBox listBox = new HBox(3);
        listBox.setAlignment(Pos.CENTER_LEFT);
        listBox.getStyleClass().add("inline-list-display");

        Label openBracket = new Label("[");
        openBracket.setStyle("-fx-font-weight: bold; -fx-font-size: 14px;");
        listBox.getChildren().add(openBracket);

        if (initializer instanceof ListBlock) {
            // If it's a ListBlock but forced here (e.g. array), render it
            listBox.getChildren().add(initializer.getUINode(context));
        } else {
            listBox.getChildren().add(initializer.getUINode(context));
        }

        Label closeBracket = new Label("]");
        closeBracket.setStyle("-fx-font-weight: bold; -fx-font-size: 14px;");
        listBox.getChildren().add(closeBracket);

        return listBox;
    }

    private String getDisplayTypeName(Type type) {
        String typeName = type.toString();
        if (isArrayList(type)) {
            return typeName;
        }
        if (typeName.endsWith("[]")) {
            return typeName.replace("[]", " list");
        }
        return typeName;
    }

    private boolean isArrayList(Type type) {
        String typeName = type.toString();
        return typeName.startsWith("ArrayList<") || typeName.equals("ArrayList");
    }

    private void showExpressionMenu(Button button, CompletionContext context, String targetType) {
        ContextMenu menu = new ContextMenu();
        menu.setStyle("-fx-control-inner-background: white;");

        for (AddableExpression type : AddableExpression.getForType(targetType)) {
            MenuItem menuItem = new MenuItem(type.getDisplayName());
            menuItem.setStyle("-fx-text-fill: black;");

            menuItem.setOnAction(e -> {
                if (initializer != null) {
                    context.codeEditor().replaceExpression(
                            (org.eclipse.jdt.core.dom.Expression) initializer.getAstNode(),
                            type
                    );
                }
            });
            menu.getItems().add(menuItem);
        }
        menu.show(button, javafx.geometry.Side.BOTTOM, 0, 0);
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/blocks/WaitBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractStatementBlock;
import com.botmaker.core.ExpressionBlock;
import com.botmaker.lsp.CompletionContext;
import javafx.geometry.Pos;
import javafx.scene.Node;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Pane;
import javafx.scene.layout.Priority;
import org.eclipse.jdt.core.dom.Statement;

public class WaitBlock extends AbstractStatementBlock {

    private ExpressionBlock duration;

    public WaitBlock(String id, Statement astNode) {
        super(id, astNode);
    }

    public ExpressionBlock getDuration() {
        return duration;
    }

    public void setDuration(ExpressionBlock duration) {
        this.duration = duration;
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        HBox container = new HBox(5);
        container.setAlignment(Pos.CENTER_LEFT);
        container.getStyleClass().add("wait-block");

        Label waitLabel = new Label("Wait");
        waitLabel.getStyleClass().add("keyword-label");

        container.getChildren().add(waitLabel);

        if (duration != null) {
            container.getChildren().add(duration.getUINode(context));
        } else {
            container.getChildren().add(createExpressionDropZone(context));
        }

        Label msLabel = new Label("ms");
        msLabel.getStyleClass().add("keyword-label");
        container.getChildren().add(msLabel);

        // Spacer and Delete Button
        Pane spacer = new Pane();
        HBox.setHgrow(spacer, Priority.ALWAYS);

        Button deleteButton = new Button("X");
        deleteButton.setOnAction(e -> {
            context.codeEditor().deleteStatement((Statement) this.astNode);
        });

        container.getChildren().addAll(spacer, deleteButton);

        return container;
    }

    @Override
    public String getDetails() {
        return "Wait: " + (duration != null ? duration.getDetails() : "...");
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/blocks/WhileBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractStatementBlock;
import com.botmaker.core.BodyBlock;
import com.botmaker.core.BlockWithChildren;
import com.botmaker.core.CodeBlock;
import com.botmaker.core.ExpressionBlock;
import com.botmaker.lsp.CompletionContext;
import com.botmaker.ui.BlockDragAndDropManager;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.Node;
import javafx.scene.control.Button;
import javafx.scene.control.ContextMenu;
import javafx.scene.control.Label;
import javafx.scene.control.MenuItem;
import javafx.scene.layout.HBox;
import javafx.scene.layout.VBox;
import org.eclipse.jdt.core.dom.WhileStatement;

import java.util.ArrayList;
import java.util.List;

public class WhileBlock extends AbstractStatementBlock implements BlockWithChildren {

    private ExpressionBlock condition;
    private BodyBlock body;
    private final BlockDragAndDropManager dragAndDropManager;

    public WhileBlock(String id, WhileStatement astNode, BlockDragAndDropManager dragAndDropManager) {
        super(id, astNode);
        this.dragAndDropManager = dragAndDropManager;
    }

    public ExpressionBlock getCondition() { return condition; }
    public void setCondition(ExpressionBlock condition) { this.condition = condition; }
    public BodyBlock getBody() { return body; }
    public void setBody(BodyBlock body) { this.body = body; }

    @Override
    public List<CodeBlock> getChildren() {
        List<CodeBlock> children = new ArrayList<>();
        if (condition != null) children.add(condition);
        if (body != null) children.add(body);
        return children;
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        VBox mainContainer = new VBox(5);
        mainContainer.getStyleClass().add("while-block");

        HBox headerRow = new HBox(5);
        headerRow.setAlignment(Pos.CENTER_LEFT);

        HBox header = new HBox(5);
        header.setAlignment(Pos.CENTER_LEFT);
        header.getStyleClass().add("while-header");

        Label whileLabel = new Label("while");
        whileLabel.getStyleClass().add("keyword-label");
        header.getChildren().add(whileLabel);

        if (condition != null) {
            header.getChildren().add(condition.getUINode(context));
        }

        Button addButton = new Button("+");
        addButton.getStyleClass().add("expression-add-button");

        // UPDATED: Pass expected type
        addButton.setOnAction(e -> showExpressionMenu(addButton, context, "boolean"));

        header.getChildren().add(addButton);

        javafx.scene.layout.Pane spacer = new javafx.scene.layout.Pane();
        HBox.setHgrow(spacer, javafx.scene.layout.Priority.ALWAYS);

        javafx.scene.control.Button deleteButton = new javafx.scene.control.Button("X");
        deleteButton.setOnAction(e -> {
            context.codeEditor().deleteStatement((org.eclipse.jdt.core.dom.Statement) this.astNode);
        });

        headerRow.getChildren().addAll(header, spacer, deleteButton);
        mainContainer.getChildren().add(headerRow);

        if (body != null) {
            VBox bodyContainer = new VBox();
            bodyContainer.getStyleClass().add("while-body");
            bodyContainer.setPadding(new Insets(5, 0, 0, 20));
            bodyContainer.getChildren().add(body.getUINode(context));
            mainContainer.getChildren().add(bodyContainer);
        }

        return mainContainer;
    }

    // UPDATED: Now accepts targetType and filters the enum
    private void showExpressionMenu(Button button, CompletionContext context, String targetType) {
        ContextMenu menu = new ContextMenu();
        menu.setStyle("-fx-control-inner-background: white;");

        // Use the filter method we created in Step 1
        for (com.botmaker.ui.AddableExpression type : com.botmaker.ui.AddableExpression.getForType(targetType)) {
            MenuItem menuItem = new MenuItem(type.getDisplayName());
            menuItem.setStyle("-fx-text-fill: black;");

            menuItem.setOnAction(e -> {
                if (condition != null) {
                    org.eclipse.jdt.core.dom.Expression toReplace = (org.eclipse.jdt.core.dom.Expression) condition.getAstNode();
                    context.codeEditor().replaceExpression(toReplace, type);
                }
            });
            menu.getItems().add(menuItem);
        }

        menu.show(button, javafx.geometry.Side.BOTTOM, 0, 0);
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/config/ApplicationConfig.java
=================================================================================

package com.botmaker.config;

import java.nio.file.Path;
import java.nio.file.Paths;

/**
 * Application configuration.
 * Encapsulates all configuration values in one place.
 */
public class ApplicationConfig {

    // Language Server Configuration
    private final Path jdtServerPath;
    private final Path projectPath;
    private final Path workspaceDataPath;

    // Project Configuration
    private final Path sourceFilePath;
    private final Path compiledOutputPath;
    private final String mainClassName;

    // Java Configuration
    private final String javaHome;
    private final String javaExecutable;
    private final String javacExecutable;

    // UI Configuration
    private final int initialWidth;
    private final int initialHeight;

    // Debug Configuration
    private final boolean enableEventLogging;

    private ApplicationConfig(Builder builder) {
        this.jdtServerPath = builder.jdtServerPath;
        this.projectPath = builder.projectPath;
        this.workspaceDataPath = builder.workspaceDataPath;
        this.sourceFilePath = builder.sourceFilePath;
        this.compiledOutputPath = builder.compiledOutputPath;
        this.mainClassName = builder.mainClassName;
        this.javaHome = builder.javaHome;
        this.javaExecutable = builder.javaExecutable;
        this.javacExecutable = builder.javacExecutable;
        this.initialWidth = builder.initialWidth;
        this.initialHeight = builder.initialHeight;
        this.enableEventLogging = builder.enableEventLogging;
    }

    // Getters

    public Path getJdtServerPath() {
        return jdtServerPath;
    }

    public Path getProjectPath() {
        return projectPath;
    }

    public Path getWorkspaceDataPath() {
        return workspaceDataPath;
    }

    public Path getSourceFilePath() {
        return sourceFilePath;
    }

    public Path getCompiledOutputPath() {
        return compiledOutputPath;
    }

    public String getMainClassName() {
        return mainClassName;
    }

    public String getJavaHome() {
        return javaHome;
    }

    public String getJavaExecutable() {
        return javaExecutable;
    }

    public String getJavacExecutable() {
        return javacExecutable;
    }

    public int getInitialWidth() {
        return initialWidth;
    }

    public int getInitialHeight() {
        return initialHeight;
    }

    public boolean isEnableEventLogging() {
        return enableEventLogging;
    }

    /**
     * Creates a default configuration based on current environment
     */
    public static ApplicationConfig createDefault() {
        // Fallback - normally we use forProject()
        String defaultProjectName = "BotMaker";
        return forProject(defaultProjectName);
    }

    /**
     * Creates configuration for a specific project
     * @param projectName The project name (also used as main class name)
     */
    public static ApplicationConfig forProject(String projectName) {
        String javaHome = System.getProperty("java.home");
        String packageName = projectName.toLowerCase();
        String mainClassName = projectName; // Project name IS the main class name

        return new Builder()
                .jdtServerPath(Paths.get("tools/jdt-language-server"))
                .projectPath(Paths.get("projects", projectName))
                .workspaceDataPath(Paths.get(System.getProperty("user.home"), ".jdtls-workspace", projectName))
                .sourceFilePath(Paths.get("projects", projectName, "src/main/java/com", packageName, mainClassName + ".java"))
                .compiledOutputPath(Paths.get("projects", projectName, "build/classes/java/main"))
                .mainClassName("com." + packageName + "." + mainClassName)
                .javaHome(javaHome)
                .javaExecutable(Paths.get(javaHome, "bin", "java").toString())
                .javacExecutable(Paths.get(javaHome, "bin", "javac").toString())
                .initialWidth(600)
                .initialHeight(800)
                .enableEventLogging(false)
                .build();
    }

    /**
     * Builder for ApplicationConfig
     */
    public static class Builder {
        private Path jdtServerPath;
        private Path projectPath;
        private Path workspaceDataPath;
        private Path sourceFilePath;
        private Path compiledOutputPath;
        private String mainClassName;
        private String javaHome;
        private String javaExecutable;
        private String javacExecutable;
        private int initialWidth = 600;
        private int initialHeight = 800;
        private boolean enableEventLogging = false;

        public Builder jdtServerPath(Path jdtServerPath) {
            this.jdtServerPath = jdtServerPath;
            return this;
        }

        public Builder projectPath(Path projectPath) {
            this.projectPath = projectPath;
            return this;
        }

        public Builder workspaceDataPath(Path workspaceDataPath) {
            this.workspaceDataPath = workspaceDataPath;
            return this;
        }

        public Builder sourceFilePath(Path sourceFilePath) {
            this.sourceFilePath = sourceFilePath;
            return this;
        }

        public Builder compiledOutputPath(Path compiledOutputPath) {
            this.compiledOutputPath = compiledOutputPath;
            return this;
        }

        public Builder mainClassName(String mainClassName) {
            this.mainClassName = mainClassName;
            return this;
        }

        public Builder javaHome(String javaHome) {
            this.javaHome = javaHome;
            return this;
        }

        public Builder javaExecutable(String javaExecutable) {
            this.javaExecutable = javaExecutable;
            return this;
        }

        public Builder javacExecutable(String javacExecutable) {
            this.javacExecutable = javacExecutable;
            return this;
        }

        public Builder initialWidth(int initialWidth) {
            this.initialWidth = initialWidth;
            return this;
        }

        public Builder initialHeight(int initialHeight) {
            this.initialHeight = initialHeight;
            return this;
        }

        public Builder enableEventLogging(boolean enableEventLogging) {
            this.enableEventLogging = enableEventLogging;
            return this;
        }

        public ApplicationConfig build() {
            // Validate required fields
            if (jdtServerPath == null) {
                throw new IllegalStateException("jdtServerPath is required");
            }
            if (projectPath == null) {
                throw new IllegalStateException("projectPath is required");
            }
            if (mainClassName == null) {
                throw new IllegalStateException("mainClassName is required");
            }

            return new ApplicationConfig(this);
        }
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/config/Constants.java
=================================================================================

package com.botmaker.config;

/**
 * Application-wide constants
 */
public class Constants {

    // Debugger Configuration
    public static final int DEBUGGER_MAX_CONNECT_RETRIES = 10;
    public static final int DEBUGGER_RETRY_DELAY_MS = 250;
    public static final int DEBUGGER_SHUTDOWN_TIMEOUT_SECONDS = 2;
    public static final int DEBUGGER_EXIT_DELAY_MS = 500;

    // Thread Sleep Times
    public static final int SHORT_SLEEP_MS = 500;

    // JVM Options
    public static final String JVM_MAX_HEAP = "-Xmx1G";
    public static final String JVM_ENTITY_SIZE_LIMIT = "-Djdk.xml.maxGeneralEntitySizeLimit=0";
    public static final String JVM_TOTAL_ENTITY_SIZE_LIMIT = "-Djdk.xml.totalEntitySizeLimit=0";

    // LSP Configuration
    public static final String LSP_DETECT_VM_DISABLED = "-DDetectVMInstallationsJob.disabled=true";
    public static final String LSP_FILE_ENCODING = "-Dfile.encoding=UTF-8";
    public static final String LSP_LOG_DISABLE = "-Xlog:disable";
    public static final String LSP_DEPENDENCY_COLLECTOR = "-Daether.dependencyCollector.impl=bf";

    // Debug Flags (disable for production)
    public static final boolean LSP_LOG_PROTOCOL = true;
    public static final String LSP_LOG_LEVEL = "ALL";

    private Constants() {} // Prevent instantiation
}

=================================================================================
FILE: ./src/main/java/com/botmaker/core/AbstractCodeBlock.java
=================================================================================

package com.botmaker.core;

import com.botmaker.lsp.CompletionContext;
import javafx.beans.binding.Bindings;
import javafx.geometry.Insets;
import javafx.scene.Node;
import javafx.scene.control.ContextMenu;
import javafx.scene.control.MenuItem;
import javafx.scene.control.Tooltip;
import javafx.scene.layout.Pane;
import javafx.scene.layout.Region;
import javafx.scene.paint.Color;
import javafx.scene.shape.Circle;
import org.eclipse.jdt.core.dom.ASTNode;
import org.eclipse.jdt.core.dom.CompilationUnit;

public abstract class AbstractCodeBlock implements CodeBlock {
    protected final String id;
    protected final ASTNode astNode;

    protected Node uiNode;
    private javafx.scene.control.Tooltip errorTooltip;

    // Breakpoint State
    protected boolean isBreakpoint = false;
    private Circle breakpointCircle;

    // Constants
    private static final double GUTTER_PADDING = 12.0; // Space reserved on the left
    private static final double CIRCLE_RADIUS = 4.0;

    public AbstractCodeBlock(String id, ASTNode astNode) {
        this.id = id;
        this.astNode = astNode;
    }

    @Override
    public String getId() { return id; }

    @Override
    public ASTNode getAstNode() { return astNode; }

    @Override
    public Node getUINode(CompletionContext context) {
        if (uiNode == null) {
            // 1. Create the standard UI
            this.uiNode = createUINode(context);

            // 2. Inject the visual Gutter (Padding + Circle)
            if (uiNode instanceof Region) {
                Region region = (Region) uiNode;

                // Add left padding to make room for the circle
                Insets existing = region.getPadding();
                region.setPadding(new Insets(
                        existing.getTop(),
                        existing.getRight(),
                        existing.getBottom(),
                        existing.getLeft() + GUTTER_PADDING
                ));

                // If the UI node allows children (Pane), add the floating circle
                if (uiNode instanceof Pane) {
                    Pane pane = (Pane) uiNode;

                    breakpointCircle = new Circle(CIRCLE_RADIUS, Color.RED);
                    breakpointCircle.setManaged(false); // Don't affect flow layout
                    breakpointCircle.setVisible(false); // Hidden by default

                    // Position: Center vertically, placed inside the left padding
                    // x = (Padding / 2) roughly centers it in the gutter
                    breakpointCircle.setLayoutX(GUTTER_PADDING / 2 + existing.getLeft());
                    breakpointCircle.centerYProperty().bind(pane.heightProperty().divide(2));

                    pane.getChildren().add(breakpointCircle);
                }
            }

            // 3. Setup Interaction
            setupBreakpointInteraction();

            // 4. Discovery Tooltip
            Tooltip tip = new Tooltip("Right-click to toggle breakpoint");
            Tooltip.install(uiNode, tip);
        }

        updateBreakpointVisuals();
        return uiNode;
    }

    private void setupBreakpointInteraction() {
        if (uiNode == null) return;

        ContextMenu contextMenu = new ContextMenu();
        MenuItem toggleBpItem = new MenuItem("Toggle Breakpoint");
        toggleBpItem.setOnAction(ev -> toggleBreakpoint());
        contextMenu.getItems().add(toggleBpItem);

        uiNode.setOnContextMenuRequested(e -> {
            toggleBpItem.setText(isBreakpoint ? "Remove Breakpoint 🔴" : "Add Breakpoint ⚪");
            contextMenu.show(uiNode, e.getScreenX(), e.getScreenY());
            e.consume();
        });
    }

    @Override
    public Node getUINode() { return uiNode; }

    @Override
    public void highlight() {
        if (uiNode != null && !uiNode.getStyleClass().contains("highlighted")) {
            uiNode.getStyleClass().add("highlighted");
        }
    }

    @Override
    public void unhighlight() {
        if (uiNode != null) {
            uiNode.getStyleClass().remove("highlighted");
        }
    }

    @Override
    public void setError(String message) {
        if (uiNode != null) {
            if (!uiNode.getStyleClass().contains("error-block")) {
                uiNode.getStyleClass().add("error-block");
            }
            if (errorTooltip == null) {
                errorTooltip = new Tooltip(message);
                Tooltip.install(uiNode, errorTooltip);
            } else {
                errorTooltip.setText(message);
            }
        }
    }

    @Override
    public void clearError() {
        if (uiNode != null) {
            uiNode.getStyleClass().remove("error-block");
            if (errorTooltip != null) {
                Tooltip.uninstall(uiNode, errorTooltip);
                errorTooltip = null;
            }
        }
    }

    @Override
    public int getBreakpointLine(CompilationUnit cu) {
        if (cu == null || astNode == null) return -1;
        return cu.getLineNumber(astNode.getStartPosition());
    }

    @Override
    public CodeBlock getHighlightTarget() { return this; }

    @Override
    public String getDetails() {
        return this.getClass().getSimpleName() + " (ID: " + this.getId() + ")";
    }

    @Override
    public boolean isBreakpoint() { return isBreakpoint; }

    @Override
    public void setBreakpoint(boolean enabled) {
        this.isBreakpoint = enabled;
        updateBreakpointVisuals();
    }

    @Override
    public void toggleBreakpoint() {
        setBreakpoint(!isBreakpoint);
        if (uiNode != null) {
            uiNode.fireEvent(new com.botmaker.ui.BlockEvent.BreakpointToggleEvent(this, isBreakpoint));
        }
    }

    private void updateBreakpointVisuals() {
        // Update the circle visibility
        if (breakpointCircle != null) {
            breakpointCircle.setVisible(isBreakpoint);
        }

        // Optional: Keep the red border as secondary reinforcement, or remove if circle is enough
        if (uiNode != null) {
            String style = uiNode.getStyle();
            String borderStyle = "-fx-border-color: #e74c3c; -fx-border-width: 0 0 0 2; -fx-border-style: solid;";

            if (isBreakpoint) {
                if (!style.contains("-fx-border-color: #e74c3c")) {
                    uiNode.setStyle(style + borderStyle);
                }
            } else {
                uiNode.setStyle(style.replace(borderStyle, ""));
            }
        }
    }

    protected Node createExpressionDropZone(CompletionContext context) {
        Region dropZone = new Region();
        context.dragAndDropManager().addExpressionDropHandlers(dropZone);
        return dropZone;
    }

    protected abstract Node createUINode(CompletionContext context);
}

=================================================================================
FILE: ./src/main/java/com/botmaker/core/AbstractExpressionBlock.java
=================================================================================

package com.botmaker.core;

import org.eclipse.jdt.core.dom.ASTNode;

public abstract class AbstractExpressionBlock extends AbstractCodeBlock implements ExpressionBlock {
    public AbstractExpressionBlock(String id, ASTNode astNode) {
        super(id, astNode);
    }
}


=================================================================================
FILE: ./src/main/java/com/botmaker/core/AbstractStatementBlock.java
=================================================================================

package com.botmaker.core;

import org.eclipse.jdt.core.dom.ASTNode;

public abstract class AbstractStatementBlock extends AbstractCodeBlock implements StatementBlock {
    public AbstractStatementBlock(String id, ASTNode astNode) {
        super(id, astNode);
    }
}


=================================================================================
FILE: ./src/main/java/com/botmaker/core/BlockWithChildren.java
=================================================================================

package com.botmaker.core;

import java.util.List;

public interface BlockWithChildren {
    List<CodeBlock> getChildren();
}


=================================================================================
FILE: ./src/main/java/com/botmaker/core/BodyBlock.java
=================================================================================

package com.botmaker.core;

import com.botmaker.core.AbstractStatementBlock;
import com.botmaker.lsp.CompletionContext;
import com.botmaker.ui.BlockDragAndDropManager;
import javafx.scene.Cursor;
import javafx.scene.Node;
import javafx.scene.layout.Priority;
import javafx.scene.layout.VBox;

import java.util.ArrayList;
import java.util.List;

public class BodyBlock extends AbstractStatementBlock implements BlockWithChildren {
    private final List<StatementBlock> statements = new ArrayList<>();
    private final BlockDragAndDropManager dragAndDropManager;

    public BodyBlock(String id, org.eclipse.jdt.core.dom.Block astNode, BlockDragAndDropManager dragAndDropManager) {
        super(id, astNode);
        this.dragAndDropManager = dragAndDropManager;
    }

    public void addStatement(StatementBlock statement) {
        statements.add(statement);
    }

    public List<StatementBlock> getStatements() {
        return new ArrayList<>(statements);
    }

    public void removeStatement(StatementBlock statement) {
        statements.remove(statement);
    }

    public void insertStatement(int index, StatementBlock statement) {
        if (index < 0 || index > statements.size()) {
            throw new IndexOutOfBoundsException("Index: " + index + ", Size: " + statements.size());
        }
        statements.add(index, statement);
    }

    @Override
    public List<CodeBlock> getChildren() {
        return new ArrayList<>(statements);
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        VBox container = new VBox();
        container.getStyleClass().add("body-block");
        VBox.setVgrow(container, Priority.ALWAYS);

        if (statements.isEmpty()) {
            javafx.scene.control.Label placeholder = new javafx.scene.control.Label("Drag block here");
            placeholder.getStyleClass().add("empty-body-placeholder");
            placeholder.setMouseTransparent(true);
            container.getChildren().add(placeholder);
            container.setAlignment(javafx.geometry.Pos.CENTER);
            container.setMinHeight(30);
            dragAndDropManager.addEmptyBodyDropHandlers(container, this);
        } else {
            // Add a separator at the beginning
            container.getChildren().add(createSeparatorWithHandlers(this, 0));

            for (int i = 0; i < statements.size(); i++) {
                StatementBlock statement = statements.get(i);
                Node statementNode = statement.getUINode(context);

                // Make the statement block draggable for repositioning
                makeStatementDraggable(statementNode, statement);

                container.getChildren().add(statementNode);
                // Add a separator after each statement
                container.getChildren().add(createSeparatorWithHandlers(this, i + 1));
            }
        }
        return container;
    }

    /**
     * Makes a statement block's UI node draggable so it can be repositioned.
     */
    private void makeStatementDraggable(Node statementNode, StatementBlock statement) {
        // Add visual cue that the block is draggable
        statementNode.setOnMouseEntered(e -> {
            statementNode.setCursor(Cursor.OPEN_HAND);
        });

        statementNode.setOnMouseExited(e -> {
            statementNode.setCursor(Cursor.DEFAULT);
        });

        // Register with the drag and drop manager
        dragAndDropManager.makeBlockMovable(statementNode, statement, this);
    }

    private Node createSeparatorWithHandlers(BodyBlock targetBody, int insertionIndex) {
        javafx.scene.layout.Region separator = dragAndDropManager.createSeparator();
        separator.getStyleClass().add("body-block-separator");
        StatementBlock adjacentBlock = (insertionIndex < statements.size()) ? statements.get(insertionIndex) : null;
        dragAndDropManager.addSeparatorDragHandlers(separator, targetBody, insertionIndex, adjacentBlock);
        return separator;
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/core/CodeBlock.java
=================================================================================

package com.botmaker.core;

import com.botmaker.lsp.CompletionContext;
import javafx.scene.Node;
import org.eclipse.jdt.core.dom.ASTNode;
import org.eclipse.jdt.core.dom.CompilationUnit;

public interface CodeBlock {
    String getId();
    ASTNode getAstNode();
    Node getUINode(CompletionContext context);
    Node getUINode();

    // Visual State
    void highlight();
    void unhighlight();
    void setError(String message);
    void clearError();

    // Breakpoint Logic
    void setBreakpoint(boolean enabled);
    boolean isBreakpoint();
    void toggleBreakpoint();

    // Debugging
    int getBreakpointLine(CompilationUnit cu);
    CodeBlock getHighlightTarget();
    String getDetails();
}

=================================================================================
FILE: ./src/main/java/com/botmaker/core/ExpressionBlock.java
=================================================================================

package com.botmaker.core;

/**
 * A block that represents a value that can be evaluated.
 * Examples: a literal "hello", a variable `x`, a calculation `2 + 2`.
 */
public interface ExpressionBlock extends CodeBlock {
}


=================================================================================
FILE: ./src/main/java/com/botmaker/core/StatementBlock.java
=================================================================================

package com.botmaker.core;

/**
 * A block that represents a complete action or step in execution.
 * Examples: a variable declaration, an if-statement, a method call.
 */
public interface StatementBlock extends CodeBlock {
}


=================================================================================
FILE: ./src/main/java/com/botmaker/di/DependencyContainer.java
=================================================================================

package com.botmaker.di;

import java.util.HashMap;
import java.util.Map;
import java.util.function.Supplier;

/**
 * Simple dependency injection container.
 * Manages service lifecycle and provides dependency resolution.
 * Phase 3: Fixed ConcurrentModificationException
 */
public class DependencyContainer {

    private final Map<Class<?>, Object> singletons = new HashMap<>();
    private final Map<Class<?>, Supplier<?>> factories = new HashMap<>();

    /**
     * Register a singleton instance
     */
    public <T> void registerSingleton(Class<T> type, T instance) {
        if (instance == null) {
            throw new IllegalArgumentException("Instance cannot be null");
        }
        singletons.put(type, instance);
    }

    /**
     * Register a factory for creating instances
     */
    public <T> void registerFactory(Class<T> type, Supplier<T> factory) {
        if (factory == null) {
            throw new IllegalArgumentException("Factory cannot be null");
        }
        factories.put(type, factory);
    }

    /**
     * Register a lazy singleton using a factory
     * The instance will be created on first access and cached
     */
    public <T> void registerLazySingleton(Class<T> type, Supplier<T> factory) {
        if (factory == null) {
            throw new IllegalArgumentException("Factory cannot be null");
        }
        factories.put(type, factory);
    }

    /**
     * Resolve a dependency
     */
    @SuppressWarnings("unchecked")
    public <T> T resolve(Class<T> type) {
        // Check if we have a singleton instance
        Object instance = singletons.get(type);
        if (instance != null) {
            return (T) instance;
        }

        // Check if we have a factory
        Supplier<?> factory = factories.get(type);
        if (factory != null) {
            // PHASE 3 FIX: Create instance first, then cache it
            // This avoids ConcurrentModificationException
            T newInstance = (T) factory.get();

            // Cache the instance for future use
            singletons.put(type, newInstance);

            // Remove the factory since we don't need it anymore
            // (optional - keeps memory clean)
            factories.remove(type);

            return newInstance;
        }

        throw new IllegalStateException("No registration found for type: " + type.getName());
    }

    /**
     * Check if a type is registered
     */
    public boolean isRegistered(Class<?> type) {
        return singletons.containsKey(type) || factories.containsKey(type);
    }

    /**
     * Remove a registration
     */
    public void unregister(Class<?> type) {
        singletons.remove(type);
        factories.remove(type);
    }

    /**
     * Clear all registrations
     */
    public void clear() {
        singletons.clear();
        factories.clear();
    }

    /**
     * Get count of registered types
     */
    public int getRegistrationCount() {
        return singletons.size() + factories.size();
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/events/AbstractApplicationEvent.java
=================================================================================

package com.botmaker.events;

/**
 * Abstract base class for events that provides common functionality
 */
public abstract class AbstractApplicationEvent implements ApplicationEvent {
    private final long timestamp;
    private final String source;

    protected AbstractApplicationEvent() {
        this(null);
    }

    protected AbstractApplicationEvent(String source) {
        this.timestamp = System.currentTimeMillis();
        this.source = source != null ? source : getClass().getSimpleName();
    }

    @Override
    public long getTimestamp() {
        return timestamp;
    }

    @Override
    public String getSource() {
        return source;
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/events/ApplicationEvent.java
=================================================================================

package com.botmaker.events;

/**
 * Base interface for all application events.
 * Events represent things that have happened in the application.
 */
public interface ApplicationEvent {
    /**
     * Timestamp when the event was created
     */
    long getTimestamp();

    /**
     * Optional source identifier for debugging
     */
    default String getSource() {
        return getClass().getSimpleName();
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/events/CoreApplicationEvents.java
=================================================================================

package com.botmaker.events;

import com.botmaker.core.AbstractCodeBlock;
import com.botmaker.core.CodeBlock;
import org.eclipse.lsp4j.Diagnostic;
import java.util.Collections;
import java.util.List;

public class CoreApplicationEvents {



    public static class CodeUpdatedEvent extends AbstractApplicationEvent {
        private final String newCode;
        private final String previousCode;
        public CodeUpdatedEvent(String newCode, String previousCode) {
            this.newCode = newCode;
            this.previousCode = previousCode;
        }
        public String getNewCode() { return newCode; }
        public String getPreviousCode() { return previousCode; }
    }

    public static class DiagnosticsUpdatedEvent extends AbstractApplicationEvent {
        private final List<Diagnostic> diagnostics;
        public DiagnosticsUpdatedEvent(List<Diagnostic> diagnostics) {
            this.diagnostics = diagnostics != null ? List.copyOf(diagnostics) : Collections.emptyList();
        }
        public List<Diagnostic> getDiagnostics() { return diagnostics; }
    }

    public static class UIRefreshRequestedEvent extends AbstractApplicationEvent {
        private final String code;
        public UIRefreshRequestedEvent(String code) { this.code = code; }
        public String getCode() { return code; }
    }

    public static class BlockHighlightEvent extends AbstractApplicationEvent {
        private final CodeBlock block;
        public BlockHighlightEvent(CodeBlock block) { this.block = block; }
        public CodeBlock getBlock() { return block; }
    }

    public static class CompilationRequestedEvent extends AbstractApplicationEvent {}
    public static class ExecutionRequestedEvent extends AbstractApplicationEvent {}
    public static class DebugStartRequestedEvent extends AbstractApplicationEvent {}

    public static class DebugSessionStartedEvent extends AbstractApplicationEvent {}
    public static class DebugSessionResumedEvent extends AbstractApplicationEvent {}
    public static class DebugSessionFinishedEvent extends AbstractApplicationEvent {}

    public static class DebugSessionPausedEvent extends AbstractApplicationEvent {
        private final int lineNumber;
        private final CodeBlock block;
        public DebugSessionPausedEvent(int lineNumber, CodeBlock block) {
            this.lineNumber = lineNumber;
            this.block = block;
        }
        public int getLineNumber() { return lineNumber; }
        public CodeBlock getBlock() { return block; }
    }

    public static class StatusMessageEvent extends AbstractApplicationEvent {
        private final String message;
        public StatusMessageEvent(String message) { this.message = message; }
        public String getMessage() { return message; }
    }

    // Inside CoreApplicationEvents class
    public static class UIBlocksUpdatedEvent extends AbstractApplicationEvent {
        // CHANGED: From MainBlock to com.botmaker.core.AbstractCodeBlock
        private final AbstractCodeBlock rootBlock;

        public UIBlocksUpdatedEvent(AbstractCodeBlock rootBlock) {
            super("CodeEditorService");
            this.rootBlock = rootBlock;
        }

        public AbstractCodeBlock getRootBlock() { return rootBlock; }
    }

    public static class OutputAppendedEvent extends AbstractApplicationEvent {
        private final String text;
        public OutputAppendedEvent(String text) { this.text = text; }
        public String getText() { return text; }
    }

    public static class OutputClearedEvent extends AbstractApplicationEvent {}
    public static class OutputSetEvent extends AbstractApplicationEvent {
        private final String text;
        public OutputSetEvent(String text) { this.text = text; }
        public String getText() { return text; }
    }

    public static class UndoRequestedEvent extends AbstractApplicationEvent {
        public UndoRequestedEvent() { super("User"); }
    }

    public static class RedoRequestedEvent extends AbstractApplicationEvent {
        public RedoRequestedEvent() { super("User"); }
    }

    /**
     * Fired whenever the history stack changes (to enable/disable UI buttons)
     */
    public static class HistoryStateChangedEvent extends AbstractApplicationEvent {
        private final boolean canUndo;
        private final boolean canRedo;

        public HistoryStateChangedEvent(boolean canUndo, boolean canRedo) {
            this.canUndo = canUndo;
            this.canRedo = canRedo;
        }

        public boolean canUndo() { return canUndo; }
        public boolean canRedo() { return canRedo; }
    }


    // ADD THESE EVENT CLASSES TO CoreApplicationEvents.java:

    /**
     * Fired when a user requests to stop the currently running program
     */
    public static class StopRunRequestedEvent extends AbstractApplicationEvent {
        public StopRunRequestedEvent() {
            super("User");
        }
    }

    /**
     * Fired when a program starts executing (not debugging)
     */
    public static class ProgramStartedEvent extends AbstractApplicationEvent {
        public ProgramStartedEvent() {
            super("ExecutionService");
        }
    }

    /**
     * Fired when a program stops executing (completed or terminated)
     */
    public static class ProgramStoppedEvent extends AbstractApplicationEvent {
        public ProgramStoppedEvent() {
            super("ExecutionService");
        }
    }
    /**
     * Fired when a user wants to step over the current line
     */
    public static class DebugStepOverRequestedEvent extends AbstractApplicationEvent {
        public DebugStepOverRequestedEvent() {
            super("User");
        }
    }

    public static class DebugStopRequestedEvent extends AbstractApplicationEvent {
        public DebugStopRequestedEvent() {
            super("User");
        }
    }

    /**
     * Fired when a user wants to continue execution until the next breakpoint
     */
    public static class DebugContinueRequestedEvent extends AbstractApplicationEvent {
        public DebugContinueRequestedEvent() {
            super("User");
        }
    }

    /**
     * Fired when a user toggles a breakpoint on a block
     */
    public static class BreakpointToggledEvent extends AbstractApplicationEvent {
        private final CodeBlock block;
        private final boolean isEnabled;

        public BreakpointToggledEvent(CodeBlock block, boolean isEnabled) {
            super("User");
            this.block = block;
            this.isEnabled = isEnabled;
        }

        public CodeBlock getBlock() { return block; }
        public boolean isEnabled() { return isEnabled; }
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/events/EventBus.java
=================================================================================

package com.botmaker.events;

import javafx.application.Platform;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.function.Consumer;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * Central event bus for application-wide event communication.
 * Thread-safe and supports both synchronous and asynchronous event delivery.
 */
public class EventBus {
    private static final Logger LOGGER = Logger.getLogger(EventBus.class.getName());

    private final Map<Class<? extends ApplicationEvent>, List<EventHandler<?>>> handlers;
    // NEW: List for listeners that want to receive EVERY event (like the Event Log)
    private final List<Consumer<ApplicationEvent>> globalListeners;
    private final boolean enableLogging;

    public EventBus() {
        this(false);
    }

    public EventBus(boolean enableLogging) {
        this.handlers = new ConcurrentHashMap<>();
        this.globalListeners = new CopyOnWriteArrayList<>(); // NEW
        this.enableLogging = enableLogging;
    }

    /**
     * Subscribe to events of a specific type
     */
    public <T extends ApplicationEvent> void subscribe(Class<T> eventType, Consumer<T> handler) {
        subscribe(eventType, handler, false);
    }

    /**
     * Subscribe to events with option to run on JavaFX thread
     */
    public <T extends ApplicationEvent> void subscribe(
            Class<T> eventType,
            Consumer<T> handler,
            boolean runOnFxThread) {

        handlers.computeIfAbsent(eventType, k -> new CopyOnWriteArrayList<>())
                .add(new EventHandler<>(handler, runOnFxThread));

        if (enableLogging) {
            LOGGER.info("Subscribed to " + eventType.getSimpleName());
        }
    }

    /**
     * NEW: Subscribe to ALL events passing through the bus.
     * Useful for logging and debugging consoles.
     */
    public void subscribeAll(Consumer<ApplicationEvent> listener) {
        globalListeners.add(listener);
    }

    /**
     * Publish an event to all subscribers
     */
    public void publish(ApplicationEvent event) {
        if (event == null) {
            return;
        }

        if (enableLogging) {
            LOGGER.info("Publishing: " + event.getSource());
        }

        // 1. Notify specific handlers
        Class<? extends ApplicationEvent> eventType = event.getClass();
        List<EventHandler<?>> eventHandlers = handlers.get(eventType);

        if (eventHandlers != null && !eventHandlers.isEmpty()) {
            for (EventHandler<?> handler : eventHandlers) {
                try {
                    handler.handle(event);
                } catch (Exception e) {
                    LOGGER.log(Level.SEVERE, "Error handling event: " + eventType.getSimpleName(), e);
                }
            }
        } else if (enableLogging) {
            LOGGER.warning("No specific handlers for event: " + eventType.getSimpleName());
        }

        // 2. NEW: Notify global listeners
        for (Consumer<ApplicationEvent> globalListener : globalListeners) {
            try {
                globalListener.accept(event);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }

    /**
     * Unsubscribe a specific handler from an event type
     */
    public <T extends ApplicationEvent> void unsubscribe(Class<T> eventType, Consumer<T> handler) {
        List<EventHandler<?>> eventHandlers = handlers.get(eventType);
        if (eventHandlers != null) {
            eventHandlers.removeIf(h -> h.getHandler() == handler);
        }
    }

    /**
     * Clear all handlers for a specific event type
     */
    public void clearHandlers(Class<? extends ApplicationEvent> eventType) {
        handlers.remove(eventType);
    }

    /**
     * Clear all handlers
     */
    public void clearAllHandlers() {
        handlers.clear();
        globalListeners.clear(); // NEW
    }

    public int getHandlerCount(Class<? extends ApplicationEvent> eventType) {
        List<EventHandler<?>> eventHandlers = handlers.get(eventType);
        return eventHandlers != null ? eventHandlers.size() : 0;
    }

    private static class EventHandler<T extends ApplicationEvent> {
        private final Consumer<T> handler;
        private final boolean runOnFxThread;

        EventHandler(Consumer<T> handler, boolean runOnFxThread) {
            this.handler = handler;
            this.runOnFxThread = runOnFxThread;
        }

        @SuppressWarnings("unchecked")
        void handle(ApplicationEvent event) {
            if (runOnFxThread && !Platform.isFxApplicationThread()) {
                Platform.runLater(() -> handler.accept((T) event));
            } else {
                handler.accept((T) event);
            }
        }

        Consumer<T> getHandler() {
            return handler;
        }
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/init/AppDependencyConfigurator.java
=================================================================================

package com.botmaker.init;

import com.botmaker.config.ApplicationConfig;
import com.botmaker.di.DependencyContainer;
import com.botmaker.events.EventBus;
import com.botmaker.parser.AstRewriter;
import com.botmaker.parser.BlockFactory;
import com.botmaker.parser.NodeCreator;
import com.botmaker.runtime.CodeExecutionService;
import com.botmaker.services.*;
import com.botmaker.state.ApplicationState;
import com.botmaker.ui.BlockDragAndDropManager;
import com.botmaker.ui.UIManager;
import com.botmaker.validation.DiagnosticsManager;
import javafx.stage.Stage;

public class AppDependencyConfigurator {

    public static void configure(DependencyContainer container, ApplicationConfig config, Stage primaryStage) {
        // Core Config & State
        container.registerSingleton(ApplicationConfig.class, config);
        container.registerSingleton(ApplicationState.class, new ApplicationState());
        container.registerSingleton(EventBus.class, new EventBus(config.isEnableEventLogging()));

        // Parsing & AST
        container.registerSingleton(BlockFactory.class, new BlockFactory());
        container.registerSingleton(NodeCreator.class, new NodeCreator());
        container.registerLazySingleton(AstRewriter.class, () ->
                new AstRewriter(container.resolve(NodeCreator.class)));

        // UI Helpers & Validation
        container.registerSingleton(DiagnosticsManager.class, new DiagnosticsManager());
        container.registerSingleton(BlockDragAndDropManager.class, new BlockDragAndDropManager(null));

        // Services
        registerServices(container);

        // UI Manager (Requires Stage)
        container.registerLazySingleton(UIManager.class, () -> {
            return new UIManager(
                    container.resolve(BlockDragAndDropManager.class),
                    container.resolve(EventBus.class),
                    container.resolve(CodeEditorService.class),
                    container.resolve(DiagnosticsManager.class),
                    primaryStage,
                    // New Dependencies:
                    container.resolve(ApplicationConfig.class),
                    container.resolve(ApplicationState.class)
            );
        });
    }

    private static void registerServices(DependencyContainer container) {
        container.registerLazySingleton(LanguageServerService.class, () ->
                new LanguageServerService(
                        container.resolve(ApplicationConfig.class),
                        container.resolve(ApplicationState.class),
                        container.resolve(EventBus.class),
                        container.resolve(DiagnosticsManager.class)
                )
        );

        container.registerLazySingleton(CodeExecutionService.class, () -> {
            EventBus eventBus = container.resolve(EventBus.class);
            return new CodeExecutionService(
                    text -> eventBus.publish(new com.botmaker.events.CoreApplicationEvents.OutputAppendedEvent(text)),
                    () -> eventBus.publish(new com.botmaker.events.CoreApplicationEvents.OutputClearedEvent()),
                    text -> eventBus.publish(new com.botmaker.events.CoreApplicationEvents.OutputSetEvent(text)),
                    msg -> eventBus.publish(new com.botmaker.events.CoreApplicationEvents.StatusMessageEvent(msg)),
                    container.resolve(DiagnosticsManager.class),
                    container.resolve(ApplicationConfig.class),
                    container.resolve(ApplicationState.class) // <--- ADD THIS
            );
        });

        container.registerLazySingleton(CodeEditorService.class, () ->
                new CodeEditorService(
                        container.resolve(ApplicationConfig.class),
                        container.resolve(ApplicationState.class),
                        container.resolve(EventBus.class),
                        container.resolve(BlockFactory.class),
                        container.resolve(AstRewriter.class),
                        container.resolve(BlockDragAndDropManager.class),
                        container.resolve(LanguageServerService.class),
                        container.resolve(DiagnosticsManager.class)
                )
        );

        container.registerLazySingleton(ExecutionService.class, () ->
                new ExecutionService(
                        container.resolve(ApplicationConfig.class),
                        container.resolve(ApplicationState.class),
                        container.resolve(EventBus.class),
                        container.resolve(CodeExecutionService.class),
                        container.resolve(DiagnosticsManager.class)
                )
        );

        container.registerLazySingleton(DebuggingService.class, () ->
                new DebuggingService(
                        container.resolve(ApplicationState.class),
                        container.resolve(EventBus.class),
                        container.resolve(CodeExecutionService.class),
                        container.resolve(BlockFactory.class),
                        container.resolve(ApplicationConfig.class)
                )
        );
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/init/AppServiceInitializer.java
=================================================================================

package com.botmaker.init;

import com.botmaker.core.BodyBlock;
import com.botmaker.core.StatementBlock;
import com.botmaker.di.DependencyContainer;
import com.botmaker.services.*;
import com.botmaker.state.ApplicationState;
import com.botmaker.ui.BlockDragAndDropManager;
import com.botmaker.ui.UIManager;
import com.botmaker.util.BlockLookupHelper;

public class AppServiceInitializer {

    public static void initialize(DependencyContainer container) throws Exception {
        // 1. Initialize Language Server
        LanguageServerService lss = container.resolve(LanguageServerService.class);
        lss.initialize();

        // 2. Resolve Services needed for wiring
        CodeEditorService codeEditorService = container.resolve(CodeEditorService.class);
        ApplicationState state = container.resolve(ApplicationState.class);
        BlockDragAndDropManager dragAndDropManager = container.resolve(BlockDragAndDropManager.class);

        // 3. Wire up Drag and Drop Logic
        setupDragAndDropCallbacks(dragAndDropManager, codeEditorService, state);

        // 4. Ensure other services are instantiated
        container.resolve(ExecutionService.class);
        container.resolve(DebuggingService.class);
        container.resolve(UIManager.class);
    }

    private static void setupDragAndDropCallbacks(BlockDragAndDropManager manager,
                                                  CodeEditorService editorService,
                                                  ApplicationState state) {
        // Handle adding new blocks
        manager.setCallback(dropInfo ->
                editorService.getCodeEditor().addStatement(
                        dropInfo.targetBody(),
                        dropInfo.type(),
                        dropInfo.insertionIndex()
                )
        );

        // Handle moving existing blocks
        manager.setMoveCallback(moveInfo -> {
            StatementBlock blockToMove = BlockLookupHelper.findBlockById(
                    moveInfo.blockId(),
                    state.getNodeToBlockMap()
            );

            if (blockToMove != null) {
                BodyBlock sourceBody = BlockLookupHelper.findParentBody(
                        blockToMove,
                        state.getNodeToBlockMap()
                );

                if (sourceBody != null) {
                    editorService.getCodeEditor().moveStatement(
                            blockToMove,
                            sourceBody,
                            moveInfo.targetBody(),
                            moveInfo.insertionIndex()
                    );
                }
            }
        });
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/lsp/CompletionContext.java
=================================================================================

package com.botmaker.lsp;

import com.botmaker.parser.CodeEditor;
import com.botmaker.state.ApplicationState; // Import State
import com.botmaker.ui.BlockDragAndDropManager;
import org.eclipse.lsp4j.services.LanguageServer;

public record CompletionContext(
        CodeEditor codeEditor,
        LanguageServer server,
        String docUri,
        String sourceCode,
        long docVersion,
        BlockDragAndDropManager dragAndDropManager,
        ApplicationState applicationState // Added field
) {
}

=================================================================================
FILE: ./src/main/java/com/botmaker/lsp/JdtLanguageServerLauncher.java
=================================================================================

package com.botmaker.lsp;

import com.botmaker.config.Constants;
import org.eclipse.lsp4j.jsonrpc.Launcher;
import org.eclipse.lsp4j.launch.LSPLauncher;
import org.eclipse.lsp4j.services.LanguageClient;
import org.eclipse.lsp4j.services.LanguageServer;
import org.eclipse.lsp4j.*;

import java.io.*;
import java.nio.file.*;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.function.Consumer;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.stream.Stream;

public class JdtLanguageServerLauncher {

    private final Process process;
    private final LanguageServer server;

    public JdtLanguageServerLauncher(
            Path jdtlsPath,
            Path projectPath,
            Path workspaceData,
            Consumer<PublishDiagnosticsParams> diagnosticsConsumer) throws Exception {

        // --- LOGGING START ---
        System.out.println("Initializing JDT LS...");
        System.out.println("  JDT Path: " + jdtlsPath);
        System.out.println("  Project: " + projectPath);
        System.out.println("  Workspace: " + workspaceData);
        // --- LOGGING END ---

        // Suppress LSP4J warnings about unsupported notifications
        Logger.getLogger("org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint").setLevel(Level.SEVERE);
        Logger.getLogger("org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer").setLevel(Level.SEVERE);

        // Find the Equinox launcher JAR
        Path launcherJar = Files.list(jdtlsPath.resolve("plugins"))
                .filter(p -> p.getFileName().toString().startsWith("org.eclipse.equinox.launcher_"))
                .findFirst()
                .orElseThrow(() -> new RuntimeException("Launcher JAR not found"));

        String javaExecutable = Paths.get(System.getProperty("java.home"), "bin", "java").toString();

        // USE the projectPath parameter (not hardcoded)
        Path projectDir = projectPath.toAbsolutePath().normalize();

        // USE the workspaceData parameter (not hardcoded)
        Files.createDirectories(workspaceData);

        // Build command with all necessary flags from VS Code implementation
        List<String> command = new ArrayList<>(Arrays.asList(
                javaExecutable,
                // Java 25 specific flags
                Constants.JVM_ENTITY_SIZE_LIMIT,
                Constants.JVM_TOTAL_ENTITY_SIZE_LIMIT,
                // Module system flags
                "--add-modules=ALL-SYSTEM",
                "--add-opens", "java.base/java.util=ALL-UNNAMED",
                "--add-opens", "java.base/java.lang=ALL-UNNAMED",
                "--add-opens", "java.base/sun.nio.fs=ALL-UNNAMED",
                // Eclipse/JDT configuration
                "-Declipse.application=org.eclipse.jdt.ls.core.id1",
                "-Dosgi.bundles.defaultStartLevel=4",
                "-Declipse.product=org.eclipse.jdt.ls.core.product",
                Constants.LSP_DETECT_VM_DISABLED,
                Constants.LSP_FILE_ENCODING,
                Constants.LSP_LOG_DISABLE,
                Constants.JVM_MAX_HEAP,
                Constants.LSP_DEPENDENCY_COLLECTOR,
                "--enable-native-access=javafx.graphics"
        ));

        // Add debug logging conditionally
        if (Constants.LSP_LOG_PROTOCOL) {
            command.add("-Dlog.protocol=true");
            command.add("-Dlog.level=" + Constants.LSP_LOG_LEVEL);
        }

        command.addAll(Arrays.asList(
                "-jar", launcherJar.toString(),
                "-configuration", jdtlsPath.resolve("config_linux").toString(),
                "-data", workspaceData.toAbsolutePath().normalize().toString()
        ));

        ProcessBuilder pb = new ProcessBuilder(command);
        process = pb.start();

        // Log the error stream separately to see any server-side issues.
        new Thread(() -> {
            try (BufferedReader br = new BufferedReader(new InputStreamReader(process.getErrorStream()))) {
                String line;
                while ((line = br.readLine()) != null) {
                    System.err.println("[JDT LS ERR] " + line);
                }
            } catch (IOException ignored) {}
        }).start();

        // Connect LSP4J client to the process
        Launcher<LanguageServer> launcher = LSPLauncher.createClientLauncher(
                new SimpleLanguageClient(diagnosticsConsumer),
                process.getInputStream(),
                process.getOutputStream()
        );

        launcher.startListening();
        server = launcher.getRemoteProxy();

        // Initialize LSP params
        InitializeParams init = new InitializeParams();
        init.setProcessId((int) ProcessHandle.current().pid());

        // Set up client capabilities
        ClientCapabilities capabilities = new ClientCapabilities();
        WorkspaceClientCapabilities workspaceCaps = new WorkspaceClientCapabilities();
        workspaceCaps.setDidChangeConfiguration(new DidChangeConfigurationCapabilities(true));
        workspaceCaps.setWorkspaceFolders(true);
        capabilities.setWorkspace(workspaceCaps);

        TextDocumentClientCapabilities textDocCaps = new TextDocumentClientCapabilities();
        capabilities.setTextDocument(textDocCaps);

        init.setCapabilities(capabilities);

        // Add workspace folder - this should point to your actual project
        WorkspaceFolder folder = new WorkspaceFolder(projectDir.toUri().toString());
        init.setWorkspaceFolders(List.of(folder));
        init.setRootUri(folder.getUri());

        System.out.println("Workspace root: " + folder.getUri());
        System.out.println("Workspace data: " + workspaceData);

        // Initialize the server
        InitializeResult result = server.initialize(init).get();
        System.out.println("Server initialized: " + result.getCapabilities());

        // Send initialized notification
        server.initialized(new InitializedParams());
    }

    public LanguageServer getServer() {
        return server;
    }

    public void stop() {
        try { server.shutdown().get(); } catch (Exception ignored) {}
        server.exit();
        process.destroy();
    }

    /**
     * Forcefully deletes the workspace cache directory.
     * Call this BEFORE creating the launcher if you suspect corruption.
     */
    public static void cleanupWorkspace(Path workspaceData) {
        if (!Files.exists(workspaceData)) return;

        System.out.println("Cleaning up JDT workspace cache: " + workspaceData);
        try (Stream<Path> walk = Files.walk(workspaceData)) {
            walk.sorted(Comparator.reverseOrder())
                    .map(Path::toFile)
                    .forEach(File::delete);
            System.out.println("Cache cleared successfully.");
        } catch (IOException e) {
            System.err.println("Failed to clear workspace cache: " + e.getMessage());
            // Try to delete at least the lock file
            try {
                Files.deleteIfExists(workspaceData.resolve(".metadata/.lock"));
                System.out.println("Deleted .lock file as fallback.");
            } catch (IOException ex) {
                ex.printStackTrace();
            }
        }
    }

    // Minimal LSP client
    static class SimpleLanguageClient implements LanguageClient {
        private final Consumer<PublishDiagnosticsParams> diagnosticsConsumer;

        public SimpleLanguageClient(Consumer<PublishDiagnosticsParams> diagnosticsConsumer) {
            this.diagnosticsConsumer = diagnosticsConsumer;
        }

        @Override
        public void telemetryEvent(Object o) {
            System.out.println("[Telemetry] " + o);
        }

        @Override
        public void publishDiagnostics(PublishDiagnosticsParams diagnostics) {
            System.out.println("[Diagnostics] " + diagnostics.getUri() + " -> " + diagnostics.getDiagnostics().size() + " issues");
            if (diagnosticsConsumer != null) {
                diagnosticsConsumer.accept(diagnostics);
            }
        }

        @Override
        public void showMessage(MessageParams messageParams) {
            System.out.println("[Message] " + messageParams.getMessage());
        }

        @Override
        public CompletableFuture<MessageActionItem> showMessageRequest(ShowMessageRequestParams showMessageRequestParams) {
            System.out.println("[MessageRequest] " + showMessageRequestParams.getMessage());
            return CompletableFuture.completedFuture(null);
        }

        @Override
        public void logMessage(MessageParams messageParams) {
            System.out.println("[Log] " + messageParams.getMessage());
        }

        @Override
        public CompletableFuture<Void> registerCapability(RegistrationParams params) {
            System.out.println("[RegisterCapability] " + params.getRegistrations().size() + " capabilities");
            return CompletableFuture.completedFuture(null);
        }

        @Override
        public CompletableFuture<Void> unregisterCapability(UnregistrationParams params) {
            System.out.println("[UnregisterCapability] " + params.getUnregisterations().size() + " capabilities");
            return CompletableFuture.completedFuture(null);
        }
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/Main.java
=================================================================================

package com.botmaker;

import com.botmaker.config.ApplicationConfig;
import com.botmaker.di.DependencyContainer;
import com.botmaker.init.AppDependencyConfigurator;
import com.botmaker.init.AppServiceInitializer;
import com.botmaker.project.ProjectConfig;
import com.botmaker.services.CodeEditorService;
import com.botmaker.services.LanguageServerService;
import com.botmaker.ui.ProjectSelectionScreen;
import com.botmaker.ui.UIManager;
import javafx.application.Application;
import javafx.application.Platform;
import javafx.scene.control.Alert;
import javafx.stage.Stage;

import java.nio.file.Files;
import java.nio.file.Paths;

public class Main extends Application {

    private DependencyContainer container;
    private LanguageServerService languageServerService;

    @Override
    public void start(Stage primaryStage) {
        String lastProject = ProjectConfig.getLastOpened();

        // Check if last project exists and auto-load
        if (lastProject != null && projectExists(lastProject)) {
            System.out.println("Auto-loading last project: " + lastProject);
            openProject(primaryStage, lastProject, false);
        } else {
            showProjectSelection(primaryStage);
        }
    }

    private void showProjectSelection(Stage primaryStage) {
        ProjectSelectionScreen selectionScreen = new ProjectSelectionScreen(
                primaryStage,
                (projectName, clearCache) -> openProject(primaryStage, projectName, clearCache)
        );

        primaryStage.setScene(selectionScreen.createScene());
        primaryStage.setTitle("BotMaker - Select Project");
        primaryStage.show();
    }

    private void openProject(Stage primaryStage, String projectName, boolean clearCache) {
        try {
            ProjectConfig.updateLastOpened(projectName);
            ApplicationConfig config = ApplicationConfig.forProject(projectName);

            // 1. Configure Container
            container = new DependencyContainer();
            AppDependencyConfigurator.configure(container, config, primaryStage);

            // 2. Handle Cache Flag
            if (clearCache) {
                container.resolve(LanguageServerService.class).setShouldClearCache(true);
            }

            // 3. Initialize Services & Wiring
            AppServiceInitializer.initialize(container);

            // 4. Keep reference for shutdown
            this.languageServerService = container.resolve(LanguageServerService.class);

            // 5. Setup UI
            UIManager uiManager = container.resolve(UIManager.class);
            uiManager.setOnSelectProject(v -> shutdownAndShowSelector(primaryStage));

            primaryStage.setScene(uiManager.createScene());
            primaryStage.setTitle("BotMaker Blocks - " + projectName);

            // 6. Load Code
            container.resolve(CodeEditorService.class).loadInitialCode();

            primaryStage.setOnCloseRequest(e -> {
                e.consume();
                performShutdown();
            });

            primaryStage.show();

        } catch (Exception e) {
            e.printStackTrace();
            showErrorDialog("Error opening project: " + e.getMessage());
            showProjectSelection(primaryStage);
        }
    }

    private void shutdownAndShowSelector(Stage primaryStage) {
        // Non-terminal shutdown (just stop LSP, keep JVM alive)
        if (languageServerService != null) {
            languageServerService.shutdown();
            languageServerService = null;
        }
        showProjectSelection(primaryStage);
    }

    private void performShutdown() {
        new Thread(() -> {
            try {
                if (languageServerService != null) {
                    System.out.println("Shutting down Language Server...");
                    languageServerService.shutdown();
                }
            } catch (Exception ex) {
                System.err.println("Error during shutdown: " + ex.getMessage());
            } finally {
                Platform.runLater(() -> {
                    Platform.exit();
                    System.exit(0);
                });
            }
        }).start();
    }

    private boolean projectExists(String projectName) {
        return Files.exists(Paths.get("projects", projectName)) &&
                Files.exists(Paths.get("projects", projectName, "build.gradle"));
    }

    private void showErrorDialog(String message) {
        Alert alert = new Alert(Alert.AlertType.ERROR);
        alert.setTitle("Error");
        alert.setHeaderText("Failed to open project");
        alert.setContentText(message);
        alert.showAndWait();
    }

    public static void main(String[] args) {
        launch(args);
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/parser/AstRewriter.java
=================================================================================

package com.botmaker.parser;

import com.botmaker.core.BodyBlock;
import com.botmaker.core.StatementBlock;
import com.botmaker.ui.AddableBlock;
import com.botmaker.ui.AddableExpression;
import com.botmaker.util.TypeManager;
import org.eclipse.jdt.core.dom.*;
import org.eclipse.jdt.core.dom.rewrite.*;
import org.eclipse.jface.text.Document;
import org.eclipse.jface.text.IDocument;
import org.eclipse.text.edits.TextEdit;

import java.util.ArrayList;
import java.util.List;

/**
 * Handles modifying existing Java code via AST Rewriting.
 * Delegates node creation to NodeCreator.
 */
public class AstRewriter {

    private final NodeCreator nodeCreator;

    public AstRewriter(NodeCreator nodeCreator) {
        this.nodeCreator = nodeCreator;
    }

    public String moveStatement(CompilationUnit cu, String originalCode, StatementBlock blockToMove, BodyBlock sourceBody, BodyBlock targetBody, int targetIndex) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);
        Statement statement = (Statement) blockToMove.getAstNode();
        Block sourceBlock = (Block) sourceBody.getAstNode();
        Block targetBlock = (Block) targetBody.getAstNode();

        ListRewrite sourceListRewrite = rewriter.getListRewrite(sourceBlock, Block.STATEMENTS_PROPERTY);
        ListRewrite targetListRewrite = rewriter.getListRewrite(targetBlock, Block.STATEMENTS_PROPERTY);

        if (sourceBody == targetBody) {
            int currentIndex = sourceBlock.statements().indexOf(statement);
            if (currentIndex == targetIndex) return originalCode;
        }

        Statement copiedStatement = (Statement) ASTNode.copySubtree(ast, statement);
        sourceListRewrite.remove(statement, null);
        targetListRewrite.insertAt(copiedStatement, targetIndex, null);

        return applyRewrite(rewriter, originalCode);
    }

    public String addStatement(CompilationUnit cu, String originalCode, BodyBlock targetBody, AddableBlock type, int index) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);

        Statement newStatement;
        if (type == AddableBlock.COMMENT) {
            newStatement = (Statement) rewriter.createStringPlaceholder("// Comment", ASTNode.EMPTY_STATEMENT);
        } else {
            newStatement = nodeCreator.createDefaultStatement(ast, type, cu, rewriter);
        }

        if (newStatement == null) return originalCode;

        Block targetAstBlock = (Block) targetBody.getAstNode();
        ListRewrite listRewrite = rewriter.getListRewrite(targetAstBlock, Block.STATEMENTS_PROPERTY);
        listRewrite.insertAt(newStatement, index, null);

        return applyRewrite(rewriter, originalCode);
    }

    public String replaceExpression(CompilationUnit cu, String originalCode, Expression toReplace, AddableExpression type) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);
        Expression newExpression = nodeCreator.createDefaultExpression(ast, type, cu, rewriter);
        if (newExpression == null) return originalCode;

        rewriter.replace(toReplace, newExpression, null);
        return applyRewrite(rewriter, originalCode);
    }

    public String replaceLiteral(CompilationUnit cu, String originalCode, Expression toReplace, String newLiteralValue) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);
        Expression newExpression;

        if (toReplace instanceof StringLiteral) {
            StringLiteral newString = ast.newStringLiteral();
            newString.setLiteralValue(newLiteralValue);
            newExpression = newString;
        } else if (toReplace instanceof NumberLiteral) {
            newExpression = ast.newNumberLiteral(newLiteralValue);
        } else if (toReplace instanceof BooleanLiteral) {
            newExpression = ast.newBooleanLiteral(Boolean.parseBoolean(newLiteralValue));
        } else {
            return originalCode;
        }
        rewriter.replace(toReplace, newExpression, null);
        return applyRewrite(rewriter, originalCode);
    }

    public String updateComment(String originalCode, Comment commentNode, String newText) {
        try {
            IDocument document = new Document(originalCode);
            String replacement = newText.contains("\n") ? "/* " + newText + " */" : "// " + newText;
            document.replace(commentNode.getStartPosition(), commentNode.getLength(), replacement);
            return document.get();
        } catch (Exception e) {
            e.printStackTrace();
            return originalCode;
        }
    }

    public String deleteComment(String originalCode, Comment commentNode) {
        try {
            IDocument document = new Document(originalCode);
            document.replace(commentNode.getStartPosition(), commentNode.getLength(), "");
            return document.get();
        } catch (Exception e) {
            e.printStackTrace();
            return originalCode;
        }
    }

    public String addArgumentToMethodInvocation(CompilationUnit cu, String originalCode, MethodInvocation mi, Expression newArgument) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);
        ListRewrite listRewrite = rewriter.getListRewrite(mi, MethodInvocation.ARGUMENTS_PROPERTY);
        listRewrite.insertLast(newArgument, null);
        return applyRewrite(rewriter, originalCode);
    }

    public String replaceSimpleName(CompilationUnit cu, String originalCode, SimpleName toReplace, String newName) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);
        rewriter.replace(toReplace, ast.newSimpleName(newName), null);
        return applyRewrite(rewriter, originalCode);
    }

    public String deleteNode(CompilationUnit cu, String originalCode, ASTNode toDelete) {
        ASTRewrite rewriter = ASTRewrite.create(cu.getAST());
        rewriter.remove(toDelete, null);
        return applyRewrite(rewriter, originalCode);
    }

    public String replaceVariableType(CompilationUnit cu, String originalCode, VariableDeclarationStatement varDecl, String newTypeName) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);

        if (newTypeName.contains("ArrayList")) {
            ImportManager.addImport(cu, rewriter, "java.util.ArrayList");
            ImportManager.addImport(cu, rewriter, "java.util.List");
        }

        Type newType = TypeManager.createTypeNode(ast, newTypeName);
        rewriter.replace(varDecl.getType(), newType, null);

        if (!varDecl.fragments().isEmpty()) {
            VariableDeclarationFragment fragment = (VariableDeclarationFragment) varDecl.fragments().get(0);
            Expression currentInitializer = fragment.getInitializer();
            Expression newInitializer = null;

            List<Expression> valuesToPreserve = new ArrayList<>();
            String oldLeaf = TypeManager.getLeafType(varDecl.getType().toString());
            String newLeaf = TypeManager.getLeafType(newTypeName);

            if (oldLeaf.equals(newLeaf) && currentInitializer != null) {
                collectLeafValues(currentInitializer, valuesToPreserve);
            }

            if (newTypeName.startsWith("ArrayList<")) {
                newInitializer = nodeCreator.createRecursiveListInitializer(ast, newTypeName, cu, rewriter, valuesToPreserve);
            } else if (newTypeName.endsWith("[]")) {
                ArrayCreation creation = ast.newArrayCreation();
                creation.setType((ArrayType) TypeManager.createTypeNode(ast, newTypeName));
                ArrayInitializer ai = ast.newArrayInitializer();
                if (!valuesToPreserve.isEmpty()) {
                    for(Expression val : valuesToPreserve) ai.expressions().add(ASTNode.copySubtree(ast, val));
                }
                creation.setInitializer(ai);
                newInitializer = creation;
            } else {
                newInitializer = !valuesToPreserve.isEmpty() ?
                        (Expression) ASTNode.copySubtree(ast, valuesToPreserve.get(0)) :
                        nodeCreator.createDefaultInitializer(ast, newTypeName);
            }

            if (newInitializer != null) {
                rewriter.replace(currentInitializer, newInitializer, null);
            }
        }
        return applyRewrite(rewriter, originalCode);
    }

    public String addElementToList(CompilationUnit cu, String originalCode, ASTNode listNode, AddableExpression type, int insertIndex) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);
        Expression newElement = nodeCreator.createDefaultExpression(ast, type, cu, rewriter);
        if (newElement == null) return originalCode;

        if (listNode instanceof ArrayInitializer) {
            rewriter.getListRewrite(listNode, ArrayInitializer.EXPRESSIONS_PROPERTY).insertAt(newElement, insertIndex, null);
        } else if (listNode instanceof MethodInvocation) {
            rewriter.getListRewrite(listNode, MethodInvocation.ARGUMENTS_PROPERTY).insertAt(newElement, insertIndex, null);
        }
        return applyRewrite(rewriter, originalCode);
    }

    public String deleteElementFromList(CompilationUnit cu, String originalCode, ASTNode listNode, int elementIndex) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);
        List<?> expressions;
        ChildListPropertyDescriptor property;

        if (listNode instanceof ArrayInitializer) {
            expressions = ((ArrayInitializer) listNode).expressions();
            property = ArrayInitializer.EXPRESSIONS_PROPERTY;
        } else if (listNode instanceof MethodInvocation) {
            expressions = ((MethodInvocation) listNode).arguments();
            property = MethodInvocation.ARGUMENTS_PROPERTY;
        } else {
            return originalCode;
        }

        if (elementIndex >= 0 && elementIndex < expressions.size()) {
            rewriter.getListRewrite(listNode, property).remove((ASTNode) expressions.get(elementIndex), null);
        }
        return applyRewrite(rewriter, originalCode);
    }

    public String convertElseToElseIf(CompilationUnit cu, String originalCode, IfStatement ifStatement) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);
        Statement elseStatement = ifStatement.getElseStatement();
        if (elseStatement != null && elseStatement.getNodeType() == ASTNode.BLOCK) {
            IfStatement newElseIf = ast.newIfStatement();
            newElseIf.setExpression(ast.newBooleanLiteral(true));
            newElseIf.setThenStatement((Block) ASTNode.copySubtree(ast, elseStatement));
            rewriter.replace(elseStatement, newElseIf, null);
        }
        return applyRewrite(rewriter, originalCode);
    }

    public String addElseToIfStatement(CompilationUnit cu, String originalCode, IfStatement ifStatement) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);
        if (ifStatement.getElseStatement() == null) {
            rewriter.set(ifStatement, IfStatement.ELSE_STATEMENT_PROPERTY, ast.newBlock(), null);
        }
        return applyRewrite(rewriter, originalCode);
    }

    public String deleteElseFromIfStatement(CompilationUnit cu, String originalCode, IfStatement ifStatement) {
        ASTRewrite rewriter = ASTRewrite.create(cu.getAST());
        if (ifStatement.getElseStatement() != null) {
            rewriter.remove(ifStatement.getElseStatement(), null);
        }
        return applyRewrite(rewriter, originalCode);
    }

    // Assignment Operators
    public String replaceAssignmentOperator(CompilationUnit cu, String originalCode, Assignment assignment, Assignment.Operator newOp) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);
        Assignment newAssignment = ast.newAssignment();
        newAssignment.setLeftHandSide((Expression) ASTNode.copySubtree(ast, assignment.getLeftHandSide()));
        newAssignment.setRightHandSide((Expression) ASTNode.copySubtree(ast, assignment.getRightHandSide()));
        newAssignment.setOperator(newOp);
        rewriter.replace(assignment, newAssignment, null);
        return applyRewrite(rewriter, originalCode);
    }

    public String replacePrefixOperator(CompilationUnit cu, String originalCode, PrefixExpression prefix, PrefixExpression.Operator newOp) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);
        PrefixExpression newPrefix = ast.newPrefixExpression();
        newPrefix.setOperand((Expression) ASTNode.copySubtree(ast, prefix.getOperand()));
        newPrefix.setOperator(newOp);
        rewriter.replace(prefix, newPrefix, null);
        return applyRewrite(rewriter, originalCode);
    }

    public String replacePostfixOperator(CompilationUnit cu, String originalCode, PostfixExpression postfix, PostfixExpression.Operator newOp) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);
        PostfixExpression newPostfix = ast.newPostfixExpression();
        newPostfix.setOperand((Expression) ASTNode.copySubtree(ast, postfix.getOperand()));
        newPostfix.setOperator(newOp);
        rewriter.replace(postfix, newPostfix, null);
        return applyRewrite(rewriter, originalCode);
    }

    // Private helpers
    private String applyRewrite(ASTRewrite rewriter, String originalCode) {
        IDocument document = new Document(originalCode);
        try {
            TextEdit edits = rewriter.rewriteAST(document, null);
            edits.apply(document);
            return document.get();
        } catch (Exception e) {
            e.printStackTrace();
            return originalCode;
        }
    }


    /**
     * Updates a method call's scope, name, and synchronizes its arguments to match the target definition.
     */
    public String updateMethodInvocation(CompilationUnit cu, String originalCode, MethodInvocation mi,
                                         String newScope, String newMethodName, List<String> newParamTypes) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);

        // 1. Update Scope (File/Class Name)
        if (newScope == null || newScope.isEmpty() || newScope.equals("Local")) {
            if (mi.getExpression() != null) {
                rewriter.remove(mi.getExpression(), null);
            }
        } else {
            SimpleName newScopeNode = ast.newSimpleName(newScope);
            if (mi.getExpression() == null) {
                rewriter.set(mi, MethodInvocation.EXPRESSION_PROPERTY, newScopeNode, null);
            } else {
                rewriter.replace(mi.getExpression(), newScopeNode, null);
            }
        }

        // 2. Update Method Name
        if (!mi.getName().getIdentifier().equals(newMethodName)) {
            rewriter.replace(mi.getName(), ast.newSimpleName(newMethodName), null);
        }

        // 3. Sync Arguments (Adaptive Parameters)
        ListRewrite argsRewrite = rewriter.getListRewrite(mi, MethodInvocation.ARGUMENTS_PROPERTY);
        List<?> currentArgs = mi.arguments();

        // Logic: Match count.
        // If target has MORE params -> Add default values.
        // If target has FEWER params -> Remove extra arguments.

        int targetCount = newParamTypes.size();
        int currentCount = currentArgs.size();

        if (currentCount > targetCount) {
            // Remove excess
            for (int i = currentCount - 1; i >= targetCount; i--) {
                argsRewrite.remove((ASTNode) currentArgs.get(i), null);
            }
        } else if (currentCount < targetCount) {
            // Add missing defaults based on type
            for (int i = currentCount; i < targetCount; i++) {
                String typeName = newParamTypes.get(i);
                Expression defaultExpr = nodeCreator.createDefaultInitializer(ast, typeName);
                argsRewrite.insertLast(defaultExpr, null);
            }
        }

        return applyRewrite(rewriter, originalCode);
    }

    public String addArgumentToMethodInvocation(CompilationUnit cu, String originalCode, MethodInvocation mi, AddableExpression type) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);
        ListRewrite listRewrite = rewriter.getListRewrite(mi, MethodInvocation.ARGUMENTS_PROPERTY);

        Expression newArg = nodeCreator.createDefaultExpression(ast, type, cu, rewriter);
        if (newArg != null) {
            listRewrite.insertLast(newArg, null);
        }
        return applyRewrite(rewriter, originalCode);
    }

    public String renameMethodParameter(CompilationUnit cu, String originalCode, MethodDeclaration method, int index, String newName) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);
        List<?> params = method.parameters();

        if (index >= 0 && index < params.size()) {
            SingleVariableDeclaration param = (SingleVariableDeclaration) params.get(index);
            SimpleName newNameNode = ast.newSimpleName(newName);
            rewriter.replace(param.getName(), newNameNode, null);
        }

        return applyRewrite(rewriter, originalCode);
    }

    public String setMethodReturnType(CompilationUnit cu, String originalCode, MethodDeclaration method, String newTypeName) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);

        Type newType;
        if ("void".equals(newTypeName)) {
            newType = ast.newPrimitiveType(PrimitiveType.VOID);
        } else {
            newType = TypeManager.createTypeNode(ast, newTypeName);
        }

        rewriter.replace(method.getReturnType2(), newType, null);
        return applyRewrite(rewriter, originalCode);
    }

    public String addParameterToMethod(CompilationUnit cu, String originalCode, MethodDeclaration method, String typeName, String paramName) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);
        ListRewrite listRewrite = rewriter.getListRewrite(method, MethodDeclaration.PARAMETERS_PROPERTY);

        SingleVariableDeclaration newParam = ast.newSingleVariableDeclaration();
        newParam.setType(TypeManager.createTypeNode(ast, typeName));
        newParam.setName(ast.newSimpleName(paramName));

        listRewrite.insertLast(newParam, null);
        return applyRewrite(rewriter, originalCode);
    }

    public String deleteParameterFromMethod(CompilationUnit cu, String originalCode, MethodDeclaration method, int index) {
        ASTRewrite rewriter = ASTRewrite.create(cu.getAST());
        ListRewrite listRewrite = rewriter.getListRewrite(method, MethodDeclaration.PARAMETERS_PROPERTY);
        List<?> params = method.parameters();

        if (index >= 0 && index < params.size()) {
            listRewrite.remove((ASTNode) params.get(index), null);
        }
        return applyRewrite(rewriter, originalCode);
    }

    public String setReturnExpression(CompilationUnit cu, String originalCode, ReturnStatement returnStmt, AddableExpression type) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);

        Expression newExpr = nodeCreator.createDefaultExpression(ast, type, cu, rewriter);
        if (newExpr == null) return originalCode;

        if (returnStmt.getExpression() == null) {
            rewriter.set(returnStmt, ReturnStatement.EXPRESSION_PROPERTY, newExpr, null);
        } else {
            rewriter.replace(returnStmt.getExpression(), newExpr, null);
        }
        return applyRewrite(rewriter, originalCode);
    }

    private void collectLeafValues(Expression expr, List<Expression> accumulator) {
        if (expr == null) return;
        boolean isContainer = false;

        if (expr instanceof ClassInstanceCreation) {
            ClassInstanceCreation cic = (ClassInstanceCreation) expr;
            if (cic.getType().toString().startsWith("ArrayList") && !cic.arguments().isEmpty()) {
                isContainer = true;
                collectLeafValues((Expression) cic.arguments().get(0), accumulator);
            }
        } else if (expr instanceof MethodInvocation) {
            MethodInvocation mi = (MethodInvocation) expr;
            String name = mi.getName().getIdentifier();
            if (name.equals("asList") || name.equals("of")) {
                isContainer = true;
                for (Object arg : mi.arguments()) collectLeafValues((Expression) arg, accumulator);
            }
        } else if (expr instanceof ArrayInitializer) {
            isContainer = true;
            for (Object e : ((ArrayInitializer) expr).expressions()) collectLeafValues((Expression) e, accumulator);
        } else if (expr instanceof ArrayCreation) {
            isContainer = true;
            if (((ArrayCreation) expr).getInitializer() != null) collectLeafValues(((ArrayCreation) expr).getInitializer(), accumulator);
        }

        if (!isContainer) accumulator.add(expr);
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/parser/BlockFactory.java
=================================================================================

package com.botmaker.parser;

import com.botmaker.blocks.*;
import com.botmaker.core.*;
import com.botmaker.ui.BlockDragAndDropManager;
import com.botmaker.util.BlockIdPrefix;
import org.eclipse.jdt.core.dom.*;

import java.util.*;

public class BlockFactory {

    private CompilationUnit ast;
    private String currentSourceCode;
    private List<Comment> allComments;
    private boolean markNewIdentifiersAsUnedited = false;
    private BlockParser blockParser;

    // CHANGED: Return type is AbstractCodeBlock (parent of MainBlock and LibraryBlock)
    public AbstractCodeBlock convert(String javaCode, Map<ASTNode, CodeBlock> nodeToBlockMap, BlockDragAndDropManager manager) {
        this.currentSourceCode = javaCode;
        this.blockParser = new BlockParser(this, manager, markNewIdentifiersAsUnedited);

        try {
            ASTParser parser = ASTParser.newParser(AST.getJLSLatest());
            parser.setSource(javaCode.toCharArray());
            parser.setKind(ASTParser.K_COMPILATION_UNIT);
            parser.setResolveBindings(true);
            parser.setUnitName("Unit.java"); // Name doesn't matter for parsing structure
            parser.setEnvironment(null, null, null, true);
            this.ast = (CompilationUnit) parser.createAST(null);

            this.allComments = new ArrayList<>();
            for (Object obj : ast.getCommentList()) {
                if (obj instanceof Comment && !(obj instanceof Javadoc)) allComments.add((Comment) obj);
            }

            if (ast.types().isEmpty()) return null;

            TypeDeclaration typeDecl = (TypeDeclaration) ast.types().get(0);

            // Check for Main Method
            MethodDeclaration mainMethod = findMainMethod(typeDecl);

            if (mainMethod != null) {
                // It's a Main File
                MainBlock mainBlock = new MainBlock(BlockIdPrefix.generate(BlockIdPrefix.MAIN, mainMethod), mainMethod);
                nodeToBlockMap.put(mainMethod, mainBlock);
                if (mainMethod.getBody() != null) {
                    BodyBlock bodyBlock = parseBodyBlock(mainMethod.getBody(), nodeToBlockMap, manager);
                    mainBlock.setMainBody(bodyBlock);
                }
                return mainBlock;
            } else {
                // It's a Library File (Standard Class)
                LibraryBlock libBlock = new LibraryBlock(BlockIdPrefix.generate("lib_", typeDecl), typeDecl);
                nodeToBlockMap.put(typeDecl, libBlock);

                for (MethodDeclaration method : typeDecl.getMethods()) {
                    MethodDeclarationBlock methodBlock = new MethodDeclarationBlock(
                            BlockIdPrefix.generate("func_", method), method, manager);
                    nodeToBlockMap.put(method, methodBlock);

                    if (method.getBody() != null) {
                        methodBlock.setBody(parseBodyBlock(method.getBody(), nodeToBlockMap, manager));
                    }
                    libBlock.addMethod(methodBlock);
                }
                return libBlock;
            }

        } finally {
            setMarkNewIdentifiersAsUnedited(false);
        }
    }

    private MethodDeclaration findMainMethod(TypeDeclaration type) {
        for (MethodDeclaration method : type.getMethods()) {
            if ("main".equals(method.getName().getIdentifier()) &&
                    Modifier.isStatic(method.getModifiers()) &&
                    method.parameters().size() == 1) { // Simplified check
                return method;
            }
        }
        return null;
    }

    // ... (Existing parseBodyBlock, parseStatement, etc. remain exactly the same) ...
    public void setMarkNewIdentifiersAsUnedited(boolean mark) { this.markNewIdentifiersAsUnedited = mark; }
    public BodyBlock parseBodyBlock(Block astBlock, Map<ASTNode, CodeBlock> nodeToBlockMap, BlockDragAndDropManager manager) {
        // [Existing implementation...]
        // COPY YOUR PREVIOUS IMPLEMENTATION HERE
        BodyBlock bodyBlock = new BodyBlock(BlockIdPrefix.generate(BlockIdPrefix.BODY, astBlock), astBlock, manager);
        nodeToBlockMap.put(astBlock, bodyBlock);

        List<CodeBlock> allChildren = new ArrayList<>();
        for (Object statementObj : astBlock.statements()) {
            blockParser.parseStatement((Statement) statementObj, nodeToBlockMap).ifPresent(allChildren::add);
        }
        // [Comment handling logic...]
        int blockStart = astBlock.getStartPosition() + 1;
        int blockEnd = astBlock.getStartPosition() + astBlock.getLength() - 1;

        for (Comment comment : allComments) {
            int cPos = comment.getStartPosition();
            if (cPos > blockStart && cPos < blockEnd) {
                boolean isInsideChild = false;
                for (Object stmtObj : astBlock.statements()) {
                    Statement s = (Statement) stmtObj;
                    if (cPos >= s.getStartPosition() && cPos <= s.getStartPosition() + s.getLength()) {
                        isInsideChild = true;
                        break;
                    }
                }
                if (!isInsideChild) {
                    allChildren.add(parseCommentBlock(comment, nodeToBlockMap));
                }
            }
        }

        allChildren.sort(Comparator.comparingInt(b -> b.getAstNode().getStartPosition()));
        for (CodeBlock cb : allChildren) {
            if (cb instanceof StatementBlock) bodyBlock.addStatement((StatementBlock) cb);
        }
        return bodyBlock;
    }

    // ... Copy parseStatement, parseExpression, parseCommentBlock, isPrintStatement, isReadInputStatement, getCompilationUnit
    // NO CHANGES NEEDED TO THEM
    public Optional<StatementBlock> parseStatement(Statement stmt, Map<ASTNode, CodeBlock> map, BlockDragAndDropManager manager) {
        return blockParser.parseStatement(stmt, map);
    }

    public Optional<ExpressionBlock> parseExpression(Expression expr, Map<ASTNode, CodeBlock> map) {
        return blockParser.parseExpression(expr, map);
    }

    private CommentBlock parseCommentBlock(Comment astNode, Map<ASTNode, CodeBlock> nodeToBlockMap) {
        String text = "Comment";
        if (currentSourceCode != null) {
            try {
                String raw = currentSourceCode.substring(astNode.getStartPosition(), astNode.getStartPosition() + astNode.getLength());
                text = astNode.isLineComment() ? raw.substring(2).trim() : raw.substring(2, raw.length() - 2).trim();
            } catch (Exception ignored) {}
        }
        CommentBlock commentBlock = new CommentBlock(BlockIdPrefix.generate(BlockIdPrefix.COMMENT, astNode), astNode, text);
        nodeToBlockMap.put(astNode, commentBlock);
        return commentBlock;
    }

    public boolean isPrintStatement(Expression expression) {
        if (!(expression instanceof MethodInvocation)) return false;
        MethodInvocation method = (MethodInvocation) expression;
        if (!method.getName().getIdentifier().equals("println")) return false;
        return method.getExpression() != null && "System.out".equals(method.getExpression().toString());
    }

    public boolean isReadInputStatement(VariableDeclarationStatement varDecl) {
        if (varDecl.fragments().isEmpty()) return false;
        VariableDeclarationFragment fragment = (VariableDeclarationFragment) varDecl.fragments().get(0);
        if (!(fragment.getInitializer() instanceof MethodInvocation)) return false;
        MethodInvocation mi = (MethodInvocation) fragment.getInitializer();
        return mi.getExpression() instanceof SimpleName &&
                ((SimpleName) mi.getExpression()).getIdentifier().equals("scanner");
    }

    public CompilationUnit getCompilationUnit() { return ast; }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/parser/BlockIdPrefix.java
=================================================================================

package com.botmaker.util;

/**
 * Constants for block ID prefixes
 */
public class BlockIdPrefix {
    public static final String MAIN = "main_";
    public static final String BODY = "body_";
    public static final String VARIABLE = "var_";
    public static final String IF = "if_";
    public static final String WHILE = "while_";
    public static final String FOR = "for_";
    public static final String BREAK = "break_";
    public static final String CONTINUE = "continue_";
    public static final String ASSIGNMENT = "assign_";
    public static final String INCREMENT = "inc_";
    public static final String DECREMENT = "dec_";
    public static final String READ_INPUT = "read_";
    public static final String PRINT = "print_";
    public static final String BINARY = "binary_";
    public static final String STRING = "string_";
    public static final String NUMBER_FLOAT = "float_";
    public static final String NUMBER_DOUBLE = "double_";
    public static final String NUMBER_INT = "int_";
    public static final String BOOLEAN = "boolean_";
    public static final String IDENTIFIER = "id_";
    public static final String SYNTHETIC_STRING = "synthetic_string_";
    public static final String DO_WHILE = "do_while_";
    public static final String SWITCH = "switch_";
    public static final String RETURN = "return_";
    public static final String COMMENT = "comment_";
    public static final String WAIT = "wait_";
    public static final String LIST = "list_";

    private BlockIdPrefix() {} // Prevent instantiation

    /**
     * Generate ID with prefix and hash
     */
    public static String generate(String prefix, Object node) {
        return prefix + node.hashCode();
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/parser/BlockParser.java
=================================================================================

package com.botmaker.parser;

import com.botmaker.blocks.*;
import com.botmaker.core.BodyBlock;
import com.botmaker.core.CodeBlock;
import com.botmaker.core.ExpressionBlock;
import com.botmaker.core.StatementBlock;
import com.botmaker.ui.BlockDragAndDropManager;
import com.botmaker.util.BlockIdPrefix;
import org.eclipse.jdt.core.dom.*;

import java.util.List;
import java.util.Map;
import java.util.Optional;

/**
 * Handles converting specific AST nodes into UI Blocks.
 */
public class BlockParser {

    private final BlockFactory factory;
    private final BlockDragAndDropManager manager;
    private final boolean markNewIdentifiersAsUnedited;

    public BlockParser(BlockFactory factory, BlockDragAndDropManager manager, boolean markNewIdentifiersAsUnedited) {
        this.factory = factory;
        this.manager = manager;
        this.markNewIdentifiersAsUnedited = markNewIdentifiersAsUnedited;
    }

    public Optional<StatementBlock> parseStatement(Statement stmt, Map<ASTNode, CodeBlock> map) {
        if (stmt instanceof Block) return Optional.of(factory.parseBodyBlock((Block) stmt, map, manager));
        if (stmt instanceof VariableDeclarationStatement) return parseVariableDecl((VariableDeclarationStatement) stmt, map);
        if (stmt instanceof IfStatement) return parseIf((IfStatement) stmt, map);
        if (stmt instanceof WhileStatement) return parseWhile((WhileStatement) stmt, map);
        if (stmt instanceof EnhancedForStatement) return parseFor((EnhancedForStatement) stmt, map);
        if (stmt instanceof DoStatement) return parseDoWhile((DoStatement) stmt, map);
        if (stmt instanceof SwitchStatement) return parseSwitch((SwitchStatement) stmt, map);
        if (stmt instanceof BreakStatement) return Optional.of(new BreakBlock(BlockIdPrefix.generate(BlockIdPrefix.BREAK, stmt), (BreakStatement) stmt));
        if (stmt instanceof ContinueStatement) return Optional.of(new ContinueBlock(BlockIdPrefix.generate(BlockIdPrefix.CONTINUE, stmt), (ContinueStatement) stmt));
        if (stmt instanceof ReturnStatement) return parseReturn((ReturnStatement) stmt, map);
        if (stmt instanceof TryStatement) return parseTry((TryStatement) stmt, map);
        if (stmt instanceof ExpressionStatement) return parseExprStmt((ExpressionStatement) stmt, map);

        return Optional.empty();
    }

    private Optional<StatementBlock> parseReturn(ReturnStatement stmt, Map<ASTNode, CodeBlock> map) {
        ReturnBlock block = new ReturnBlock(BlockIdPrefix.generate(BlockIdPrefix.RETURN, stmt), stmt);
        map.put(stmt, block);

        if (stmt.getExpression() != null) {
            factory.parseExpression(stmt.getExpression(), map).ifPresent(block::setExpression);
        }
        return Optional.of(block);
    }

    private Optional<StatementBlock> parseExprStmt(ExpressionStatement stmt, Map<ASTNode, CodeBlock> map) {
        Expression expr = stmt.getExpression();
        if (factory.isPrintStatement(expr)) return parsePrint(stmt, map);
        if (expr instanceof Assignment) return parseAssignment(stmt, map);
        if (expr instanceof PostfixExpression || expr instanceof PrefixExpression) {
            // Treated as assignments for increment/decrement
            AssignmentBlock block = new AssignmentBlock(BlockIdPrefix.generate(BlockIdPrefix.ASSIGNMENT, stmt), stmt);
            map.put(stmt, block);
            if (expr instanceof PostfixExpression) factory.parseExpression(((PostfixExpression) expr).getOperand(), map).ifPresent(block::setLeftHandSide);
            if (expr instanceof PrefixExpression) factory.parseExpression(((PrefixExpression) expr).getOperand(), map).ifPresent(block::setLeftHandSide);
            return Optional.of(block);
        }

        if (expr instanceof MethodInvocation) {
            MethodInvocationBlock block = new MethodInvocationBlock(
                    BlockIdPrefix.generate("call_", stmt), stmt);
            map.put(stmt, block);

            MethodInvocation mi = (MethodInvocation) expr;
            // Parse arguments
            for (Object arg : mi.arguments()) {
                factory.parseExpression((Expression) arg, map).ifPresent(block::addArgument);
            }
            return Optional.of(block);
        }

        return Optional.empty();
    }

    private Optional<StatementBlock> parseVariableDecl(VariableDeclarationStatement stmt, Map<ASTNode, CodeBlock> map) {
        if (factory.isReadInputStatement(stmt)) {
            VariableDeclarationFragment frag = (VariableDeclarationFragment) stmt.fragments().get(0);
            MethodInvocation mi = (MethodInvocation) frag.getInitializer();
            ReadInputBlock block = new ReadInputBlock(BlockIdPrefix.generate(BlockIdPrefix.READ_INPUT, stmt), stmt, mi.getName().getIdentifier());
            map.put(stmt, block);
            factory.parseExpression(frag.getName(), map).ifPresent(block::setVariableName);
            return Optional.of(block);
        } else {
            VariableDeclarationBlock block = new VariableDeclarationBlock(BlockIdPrefix.generate(BlockIdPrefix.VARIABLE, stmt), stmt);
            map.put(stmt, block);
            VariableDeclarationFragment frag = (VariableDeclarationFragment) stmt.fragments().get(0);
            if (frag.getInitializer() != null) {
                factory.parseExpression(frag.getInitializer(), map).ifPresent(block::setInitializer);
            }
            return Optional.of(block);
        }
    }

    private Optional<StatementBlock> parseIf(IfStatement stmt, Map<ASTNode, CodeBlock> map) {
        IfBlock block = new IfBlock(BlockIdPrefix.generate(BlockIdPrefix.IF, stmt), stmt);
        map.put(stmt, block);
        factory.parseExpression(stmt.getExpression(), map).ifPresent(block::setCondition);
        if (stmt.getThenStatement() instanceof Block) {
            block.setThenBody(factory.parseBodyBlock((Block) stmt.getThenStatement(), map, manager));
        }
        if (stmt.getElseStatement() != null) {
            factory.parseStatement(stmt.getElseStatement(), map, manager).ifPresent(block::setElseStatement);
        }
        return Optional.of(block);
    }

    private Optional<StatementBlock> parseWhile(WhileStatement stmt, Map<ASTNode, CodeBlock> map) {
        WhileBlock block = new WhileBlock(BlockIdPrefix.generate(BlockIdPrefix.WHILE, stmt), stmt, manager);
        map.put(stmt, block);
        factory.parseExpression(stmt.getExpression(), map).ifPresent(block::setCondition);
        if (stmt.getBody() instanceof Block) block.setBody(factory.parseBodyBlock((Block) stmt.getBody(), map, manager));
        return Optional.of(block);
    }

    private Optional<StatementBlock> parseFor(EnhancedForStatement stmt, Map<ASTNode, CodeBlock> map) {
        ForBlock block = new ForBlock(BlockIdPrefix.generate(BlockIdPrefix.FOR, stmt), stmt, manager);
        map.put(stmt, block);
        if (stmt.getParameter() != null) factory.parseExpression(stmt.getParameter().getName(), map).ifPresent(block::setVariable);
        if (stmt.getExpression() != null) factory.parseExpression(stmt.getExpression(), map).ifPresent(block::setCollection);
        if (stmt.getBody() instanceof Block) block.setBody(factory.parseBodyBlock((Block) stmt.getBody(), map, manager));
        return Optional.of(block);
    }

    private Optional<StatementBlock> parseDoWhile(DoStatement stmt, Map<ASTNode, CodeBlock> map) {
        DoWhileBlock block = new DoWhileBlock(BlockIdPrefix.generate(BlockIdPrefix.DO_WHILE, stmt), stmt, manager);
        map.put(stmt, block);
        factory.parseExpression(stmt.getExpression(), map).ifPresent(block::setCondition);
        if (stmt.getBody() instanceof Block) block.setBody(factory.parseBodyBlock((Block) stmt.getBody(), map, manager));
        return Optional.of(block);
    }

    private Optional<StatementBlock> parseSwitch(SwitchStatement stmt, Map<ASTNode, CodeBlock> map) {
        SwitchBlock block = new SwitchBlock(BlockIdPrefix.generate(BlockIdPrefix.SWITCH, stmt), stmt, manager);
        map.put(stmt, block);
        if (stmt.getExpression() != null) factory.parseExpression(stmt.getExpression(), map).ifPresent(block::setExpression);

        BodyBlock currentBody = null;
        SwitchBlock.SwitchCaseBlock currentCase = null;

        for (Object obj : stmt.statements()) {
            Statement s = (Statement) obj;
            if (s instanceof SwitchCase) {
                SwitchCase sc = (SwitchCase) s;
                currentCase = new SwitchBlock.SwitchCaseBlock(BlockIdPrefix.generate(BlockIdPrefix.SWITCH + "_case_", sc), sc, manager);
                map.put(sc, currentCase);
                if (!sc.isDefault() && !sc.expressions().isEmpty()) {
                    factory.parseExpression((Expression) sc.expressions().get(0), map).ifPresent(currentCase::setCaseExpression);
                }
                currentBody = new BodyBlock(BlockIdPrefix.generate(BlockIdPrefix.BODY, sc), factory.getCompilationUnit().getAST().newBlock(), manager);
                currentCase.setBody(currentBody);
                block.addCase(currentCase);
            } else if (currentBody != null) {
                factory.parseStatement(s, map, manager).ifPresent(currentBody::addStatement);
            }
        }
        return Optional.of(block);
    }

    private Optional<StatementBlock> parsePrint(ExpressionStatement stmt, Map<ASTNode, CodeBlock> map) {
        PrintBlock block = new PrintBlock(BlockIdPrefix.generate(BlockIdPrefix.PRINT, stmt), stmt);
        map.put(stmt, block);
        MethodInvocation mi = (MethodInvocation) stmt.getExpression();
        if (mi.arguments().isEmpty()) {
            block.addArgument(new LiteralBlock<>(BlockIdPrefix.generate(BlockIdPrefix.SYNTHETIC_STRING, stmt), mi, ""));
        } else {
            for (Object arg : mi.arguments()) factory.parseExpression((Expression) arg, map).ifPresent(block::addArgument);
        }
        return Optional.of(block);
    }

    private Optional<StatementBlock> parseAssignment(ExpressionStatement stmt, Map<ASTNode, CodeBlock> map) {
        AssignmentBlock block = new AssignmentBlock(BlockIdPrefix.generate(BlockIdPrefix.ASSIGNMENT, stmt), stmt);
        map.put(stmt, block);
        Assignment a = (Assignment) stmt.getExpression();
        factory.parseExpression(a.getLeftHandSide(), map).ifPresent(block::setLeftHandSide);
        factory.parseExpression(a.getRightHandSide(), map).ifPresent(block::setRightHandSide);
        return Optional.of(block);
    }

    private Optional<StatementBlock> parseTry(TryStatement stmt, Map<ASTNode, CodeBlock> map) {
        if (isWait(stmt)) {
            WaitBlock block = new WaitBlock(BlockIdPrefix.generate(BlockIdPrefix.WAIT, stmt), stmt);
            map.put(stmt, block);
            Statement inner = (Statement) stmt.getBody().statements().get(0);
            MethodInvocation mi = (MethodInvocation) ((ExpressionStatement) inner).getExpression();
            if (!mi.arguments().isEmpty()) factory.parseExpression((Expression) mi.arguments().get(0), map).ifPresent(block::setDuration);
            return Optional.of(block);
        }
        return Optional.empty();
    }

    private boolean isWait(TryStatement stmt) {
        if (stmt.getBody().statements().size() != 1) return false;
        Statement first = (Statement) stmt.getBody().statements().get(0);
        if (!(first instanceof ExpressionStatement)) return false;
        Expression e = ((ExpressionStatement) first).getExpression();
        return e instanceof MethodInvocation &&
                "sleep".equals(((MethodInvocation) e).getName().getIdentifier()) &&
                "Thread".equals(((MethodInvocation) e).getExpression().toString());
    }

    public Optional<ExpressionBlock> parseExpression(Expression expr, Map<ASTNode, CodeBlock> map) {
        if (expr instanceof StringLiteral) {
            LiteralBlock<String> b = new LiteralBlock<>(BlockIdPrefix.generate(BlockIdPrefix.STRING, expr), expr, ((StringLiteral) expr).getLiteralValue());
            map.put(expr, b);
            return Optional.of(b);
        }
        if (expr instanceof MethodInvocation) {
            MethodInvocation mi = (MethodInvocation) expr;
            MethodInvocationBlock block = new MethodInvocationBlock(
                    BlockIdPrefix.generate("call_expr_", expr), expr);

            map.put(expr, block);

            for (Object arg : mi.arguments()) {
                factory.parseExpression((Expression) arg, map).ifPresent(block::addArgument);
            }
            return Optional.of(block);
        }
        if (expr instanceof NumberLiteral) {
            String t = ((NumberLiteral) expr).getToken();
            ExpressionBlock b;
            if (t.toLowerCase().endsWith("f")) b = new LiteralBlock<>(BlockIdPrefix.generate(BlockIdPrefix.NUMBER_FLOAT, expr), expr, Float.parseFloat(t));
            else if (t.contains(".") || t.toLowerCase().endsWith("d")) b = new LiteralBlock<>(BlockIdPrefix.generate(BlockIdPrefix.NUMBER_DOUBLE, expr), expr, Double.parseDouble(t));
            else b = new LiteralBlock<>(BlockIdPrefix.generate(BlockIdPrefix.NUMBER_INT, expr), expr, Integer.parseInt(t));
            map.put(expr, b);
            return Optional.of(b);
        }
        if (expr instanceof BooleanLiteral) {
            BooleanLiteralBlock b = new BooleanLiteralBlock(BlockIdPrefix.generate(BlockIdPrefix.BOOLEAN, expr), (BooleanLiteral) expr);
            map.put(expr, b);
            return Optional.of(b);
        }
        if (expr instanceof SimpleName) {
            if (expr.getParent() instanceof Type) return Optional.empty();
            IdentifierBlock b = new IdentifierBlock(BlockIdPrefix.generate(BlockIdPrefix.IDENTIFIER, expr), (SimpleName) expr, markNewIdentifiersAsUnedited);
            map.put(expr, b);
            return Optional.of(b);
        }
        if (expr instanceof InfixExpression) {
            BinaryExpressionBlock b = new BinaryExpressionBlock(BlockIdPrefix.generate(BlockIdPrefix.BINARY, expr), (InfixExpression) expr);
            map.put(expr, b);
            factory.parseExpression(((InfixExpression) expr).getLeftOperand(), map).ifPresent(b::setLeftOperand);
            factory.parseExpression(((InfixExpression) expr).getRightOperand(), map).ifPresent(b::setRightOperand);
            return Optional.of(b);
        }
        if (isListStructure(expr)) {
            ListBlock b = new ListBlock(BlockIdPrefix.generate(BlockIdPrefix.LIST, expr), expr);
            map.put(expr, b);
            List<Expression> items = getListItems(expr);
            for (Expression item : items) factory.parseExpression(item, map).ifPresent(b::addElement);
            return Optional.of(b);
        }
        return Optional.empty();
    }

    private boolean isListStructure(Expression expr) {
        if (expr instanceof ArrayInitializer) return true;
        if (expr instanceof MethodInvocation) {
            MethodInvocation mi = (MethodInvocation) expr;
            String scope = mi.getExpression() != null ? mi.getExpression().toString() : "";
            return (scope.equals("Arrays") && mi.getName().getIdentifier().equals("asList")) ||
                    (scope.equals("List") && mi.getName().getIdentifier().equals("of"));
        }
        return false;
    }

    @SuppressWarnings("unchecked")
    private List<Expression> getListItems(Expression expr) {
        if (expr instanceof ArrayInitializer) return ((ArrayInitializer) expr).expressions();
        if (expr instanceof MethodInvocation) return ((MethodInvocation) expr).arguments();
        return List.of();
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/parser/CodeEditor.java
=================================================================================

package com.botmaker.parser;

import com.botmaker.state.*;
import com.botmaker.core.BodyBlock;
import com.botmaker.core.StatementBlock;
import com.botmaker.events.CoreApplicationEvents;
import com.botmaker.events.EventBus;
import com.botmaker.ui.AddableBlock;
import com.botmaker.ui.AddableExpression;
import org.eclipse.jdt.core.dom.*;

import java.util.List;

public class CodeEditor {

    private final ApplicationState state;
    private final EventBus eventBus;
    private final AstRewriter astRewriter;
    private final BlockFactory blockFactory;

    public CodeEditor(ApplicationState state, EventBus eventBus,
                      AstRewriter astRewriter, BlockFactory blockFactory) {
        this.state = state;
        this.eventBus = eventBus;
        this.astRewriter = astRewriter;
        this.blockFactory = blockFactory;
    }

    private String getCurrentCode() {
        return state.getCurrentCode();
    }

    private CompilationUnit getCompilationUnit() {
        return state.getCompilationUnit().orElse(null);
    }

    private void triggerUpdate(String newCode) {
        String previousCode = getCurrentCode();
        eventBus.publish(new CoreApplicationEvents.CodeUpdatedEvent(newCode, previousCode));
    }

    public void updateMethodInvocation(MethodInvocation mi, String newScope, String newMethodName, List<String> newParamTypes) {
        blockFactory.setMarkNewIdentifiersAsUnedited(true);
        String newCode = astRewriter.updateMethodInvocation(
                getCompilationUnit(),
                getCurrentCode(),
                mi,
                newScope,
                newMethodName,
                newParamTypes
        );
        triggerUpdate(newCode);
    }

    // Add this method
    public void addArgumentToMethodInvocation(MethodInvocation mi, AddableExpression type) {
        blockFactory.setMarkNewIdentifiersAsUnedited(true);
        String newCode = astRewriter.addArgumentToMethodInvocation(
                getCompilationUnit(),
                getCurrentCode(),
                mi,
                type
        );
        triggerUpdate(newCode);
    }

    public void moveStatement(StatementBlock blockToMove, BodyBlock sourceBody,
                              BodyBlock targetBody, int targetIndex) {
        String newCode = astRewriter.moveStatement(
                getCompilationUnit(),
                getCurrentCode(),
                blockToMove,
                sourceBody,
                targetBody,
                targetIndex
        );
        triggerUpdate(newCode);
    }

    public void replaceLiteralValue(Expression toReplace, String newLiteralValue) {
        String newCode = astRewriter.replaceLiteral(
                getCompilationUnit(),
                getCurrentCode(),
                toReplace,
                newLiteralValue
        );
        triggerUpdate(newCode);
    }

    public void addStringArgumentToMethodInvocation(MethodInvocation mi, String text) {
        CompilationUnit cu = getCompilationUnit();
        if (cu == null) return;

        AST ast = cu.getAST();
        StringLiteral newArg = ast.newStringLiteral();
        newArg.setLiteralValue(text);

        String newCode = astRewriter.addArgumentToMethodInvocation(
                cu,
                getCurrentCode(),
                mi,
                newArg
        );
        triggerUpdate(newCode);
    }


    public void renameMethodParameter(MethodDeclaration method, int index, String newName) {
        String newCode = astRewriter.renameMethodParameter(
                getCompilationUnit(),
                getCurrentCode(),
                method,
                index,
                newName
        );
        triggerUpdate(newCode);
    }

    public void setMethodReturnType(MethodDeclaration method, String newTypeName) {
        String newCode = astRewriter.setMethodReturnType(
                getCompilationUnit(),
                getCurrentCode(),
                method,
                newTypeName
        );
        triggerUpdate(newCode);
    }

    public void addParameterToMethod(MethodDeclaration method, String typeName, String paramName) {
        String newCode = astRewriter.addParameterToMethod(
                getCompilationUnit(),
                getCurrentCode(),
                method,
                typeName,
                paramName
        );
        triggerUpdate(newCode);
    }

    public void deleteParameterFromMethod(MethodDeclaration method, int index) {
        String newCode = astRewriter.deleteParameterFromMethod(
                getCompilationUnit(),
                getCurrentCode(),
                method,
                index
        );
        triggerUpdate(newCode);
    }

    public void setReturnExpression(ReturnStatement returnStmt, AddableExpression type) {
        blockFactory.setMarkNewIdentifiersAsUnedited(true);
        String newCode = astRewriter.setReturnExpression(
                getCompilationUnit(),
                getCurrentCode(),
                returnStmt,
                type
        );
        triggerUpdate(newCode);
    }



    /**
     * Adds an element to either an ArrayInitializer or a MethodInvocation (List).
     */
    public void addElementToList(
            ASTNode listNode,
            AddableExpression type,
            int insertIndex) {

        blockFactory.setMarkNewIdentifiersAsUnedited(true);

        // SPECIAL CASE:
        // If the user managed to get a raw ClassInstanceCreation (empty ArrayList),
        // AstRewriter needs to wrap it. However, ListBlock is usually bound to
        // the MethodInvocation inside.

        String newCode = astRewriter.addElementToList(
                getCompilationUnit(),
                getCurrentCode(),
                listNode,
                type,
                insertIndex
        );
        triggerUpdate(newCode);
    }

    /**
     * Deletes an element from either an ArrayInitializer or a MethodInvocation (List).
     */
    public void deleteElementFromList(
            ASTNode listNode,
            int elementIndex) {

        // Updated to use the generic 'deleteElementFromList' in Rewriter
        String newCode = astRewriter.deleteElementFromList(
                getCompilationUnit(),
                getCurrentCode(),
                listNode,
                elementIndex
        );
        triggerUpdate(newCode);
    }

    public void updateComment(Comment commentNode, String newText) {
        String newCode = astRewriter.updateComment(
                getCurrentCode(),
                commentNode,
                newText
        );
        triggerUpdate(newCode);
    }

    public void deleteComment(Comment commentNode) {
        String newCode = astRewriter.deleteComment(
                getCurrentCode(),
                commentNode
        );
        triggerUpdate(newCode);
    }

    public void replaceExpression(Expression toReplace, com.botmaker.ui.AddableExpression type) {
        blockFactory.setMarkNewIdentifiersAsUnedited(true);
        String newCode = astRewriter.replaceExpression(
                getCompilationUnit(),
                getCurrentCode(),
                toReplace,
                type
        );
        triggerUpdate(newCode);
    }

    public void addStatement(BodyBlock targetBody, AddableBlock type, int index) {
        blockFactory.setMarkNewIdentifiersAsUnedited(true);
        String newCode = astRewriter.addStatement(
                getCompilationUnit(),
                getCurrentCode(),
                targetBody,
                type,
                index
        );
        triggerUpdate(newCode);
    }

    public void deleteElseFromIfStatement(IfStatement ifStmt) {
        String newCode = astRewriter.deleteElseFromIfStatement(
                getCompilationUnit(),
                getCurrentCode(),
                ifStmt
        );
        triggerUpdate(newCode);
    }

    public void convertElseToElseIf(IfStatement ifStmt) {
        String newCode = astRewriter.convertElseToElseIf(
                getCompilationUnit(),
                getCurrentCode(),
                ifStmt
        );
        triggerUpdate(newCode);
    }

    public void addElseToIfStatement(IfStatement ifStmt) {
        String newCode = astRewriter.addElseToIfStatement(
                getCompilationUnit(),
                getCurrentCode(),
                ifStmt
        );
        triggerUpdate(newCode);
    }

    public void replaceSimpleName(SimpleName toReplace, String newName) {
        String newCode = astRewriter.replaceSimpleName(
                getCompilationUnit(),
                getCurrentCode(),
                toReplace,
                newName
        );
        triggerUpdate(newCode);
    }

    public void deleteStatement(Statement toDelete) {
        String newCode = astRewriter.deleteNode(
                getCompilationUnit(),
                getCurrentCode(),
                toDelete
        );
        triggerUpdate(newCode);
    }

    public void replaceVariableType(VariableDeclarationStatement toReplace, String newTypeName) {
        String newCode = astRewriter.replaceVariableType(
                getCompilationUnit(),
                getCurrentCode(),
                toReplace,
                newTypeName
        );
        triggerUpdate(newCode);
    }

    // --- FIX START: Manual Mapping instead of .values() ---

    public void updateAssignmentOperator(org.eclipse.jdt.core.dom.ASTNode node, String newOperatorSymbol) {
        String newCode = null;

        if (node instanceof Assignment) {
            Assignment.Operator op = getAssignmentOperator(newOperatorSymbol);
            if (op != null) {
                newCode = astRewriter.replaceAssignmentOperator(getCompilationUnit(), getCurrentCode(), (Assignment) node, op);
            }
        } else if (node instanceof org.eclipse.jdt.core.dom.PrefixExpression) {
            org.eclipse.jdt.core.dom.PrefixExpression.Operator op = getPrefixOperator(newOperatorSymbol);
            if (op != null) {
                newCode = astRewriter.replacePrefixOperator(getCompilationUnit(), getCurrentCode(), (org.eclipse.jdt.core.dom.PrefixExpression) node, op);
            }
        } else if (node instanceof org.eclipse.jdt.core.dom.PostfixExpression) {
            org.eclipse.jdt.core.dom.PostfixExpression.Operator op = getPostfixOperator(newOperatorSymbol);
            if (op != null) {
                newCode = astRewriter.replacePostfixOperator(getCompilationUnit(), getCurrentCode(), (org.eclipse.jdt.core.dom.PostfixExpression) node, op);
            }
        }

        if (newCode != null) {
            triggerUpdate(newCode);
        }
    }

    private Assignment.Operator getAssignmentOperator(String symbol) {
        // Manual mapping because JDT Operators are not Enums
        if ("=".equals(symbol)) return Assignment.Operator.ASSIGN;
        if ("+=".equals(symbol)) return Assignment.Operator.PLUS_ASSIGN;
        if ("-=".equals(symbol)) return Assignment.Operator.MINUS_ASSIGN;
        if ("*=".equals(symbol)) return Assignment.Operator.TIMES_ASSIGN;
        if ("/=".equals(symbol)) return Assignment.Operator.DIVIDE_ASSIGN;
        if ("%=".equals(symbol)) return Assignment.Operator.REMAINDER_ASSIGN;
        // Add other assignment operators if necessary (e.g. &=, |=, etc.)
        return null;
    }

    private org.eclipse.jdt.core.dom.PrefixExpression.Operator getPrefixOperator(String symbol) {
        if ("++".equals(symbol)) return org.eclipse.jdt.core.dom.PrefixExpression.Operator.INCREMENT;
        if ("--".equals(symbol)) return org.eclipse.jdt.core.dom.PrefixExpression.Operator.DECREMENT;
        return null;
    }

    private org.eclipse.jdt.core.dom.PostfixExpression.Operator getPostfixOperator(String symbol) {
        if ("++".equals(symbol)) return org.eclipse.jdt.core.dom.PostfixExpression.Operator.INCREMENT;
        if ("--".equals(symbol)) return org.eclipse.jdt.core.dom.PostfixExpression.Operator.DECREMENT;
        return null;
    }
    // --- FIX END ---
}

=================================================================================
FILE: ./src/main/java/com/botmaker/parser/ImportManager.java
=================================================================================

package com.botmaker.parser;

import org.eclipse.jdt.core.dom.*;
import org.eclipse.jdt.core.dom.rewrite.ASTRewrite;
import org.eclipse.jdt.core.dom.rewrite.ListRewrite;

import java.util.HashSet;
import java.util.List;
import java.util.Set;

public class ImportManager {

    /**
     * Ensures that the specific class is imported in the CompilationUnit.
     * @param cu The compilation unit.
     * @param rewriter The ASTRewrite instance.
     * @param qualifiedClassName The full class name (e.g., "java.util.ArrayList").
     */
    public static void addImport(CompilationUnit cu, ASTRewrite rewriter, String qualifiedClassName) {
        if (cu == null || qualifiedClassName == null) return;

        // Check existing imports
        List<ImportDeclaration> imports = cu.imports();
        Set<String> existingImports = new HashSet<>();

        for (ImportDeclaration imp : imports) {
            if (imp.isOnDemand()) {
                // e.g., java.util.*
                String packageName = imp.getName().getFullyQualifiedName();
                String targetPackage = qualifiedClassName.substring(0, qualifiedClassName.lastIndexOf('.'));
                if (packageName.equals(targetPackage)) {
                    return; // Covered by wildcard
                }
            } else {
                existingImports.add(imp.getName().getFullyQualifiedName());
            }
        }

        if (existingImports.contains(qualifiedClassName)) {
            return; // Already imported
        }

        // Create new import
        AST ast = cu.getAST();
        ImportDeclaration newImport = ast.newImportDeclaration();
        newImport.setName(ast.newName(qualifiedClassName));

        // Insert into AST
        ListRewrite listRewrite = rewriter.getListRewrite(cu, CompilationUnit.IMPORTS_PROPERTY);
        listRewrite.insertLast(newImport, null);
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/parser/NodeCreator.java
=================================================================================

package com.botmaker.parser;

import com.botmaker.ui.AddableBlock;
import com.botmaker.ui.AddableExpression;
import com.botmaker.util.DefaultNames;
import com.botmaker.util.TypeManager;
import org.eclipse.jdt.core.dom.*;
import org.eclipse.jdt.core.dom.rewrite.ASTRewrite;

import java.util.List;

import static com.botmaker.util.TypeManager.toWrapperType;

/**
 * Responsible solely for creating new AST Nodes (Statements and Expressions).
 */
public class NodeCreator {

    public Expression createDefaultExpression(AST ast, AddableExpression type, CompilationUnit cu, ASTRewrite rewriter) {
        switch (type) {
            case TEXT:
                StringLiteral newString = ast.newStringLiteral();
                newString.setLiteralValue("text");
                return newString;
            case FUNCTION_CALL:
                MethodInvocation call = ast.newMethodInvocation();
                call.setName(ast.newSimpleName("selectMethod"));
                return call;
            case NUMBER:
                return ast.newNumberLiteral("0");
            case TRUE:
                return ast.newBooleanLiteral(true);
            case FALSE:
                return ast.newBooleanLiteral(false);
            case VARIABLE:
                return ast.newSimpleName(DefaultNames.DEFAULT_VARIABLE);
            case LIST:
                ImportManager.addImport(cu, rewriter, "java.util.Arrays");
                MethodInvocation asList = ast.newMethodInvocation();
                asList.setExpression(ast.newSimpleName("Arrays"));
                asList.setName(ast.newSimpleName("asList"));
                return asList;

            case ADD:
            case SUBTRACT:
            case MULTIPLY:
            case DIVIDE:
            case MODULO:
                InfixExpression infixExpr = ast.newInfixExpression();
                infixExpr.setLeftOperand(ast.newSimpleName(DefaultNames.DEFAULT_VARIABLE));
                infixExpr.setRightOperand(ast.newNumberLiteral("0"));
                switch (type) {
                    case ADD: infixExpr.setOperator(InfixExpression.Operator.PLUS); break;
                    case SUBTRACT: infixExpr.setOperator(InfixExpression.Operator.MINUS); break;
                    case MULTIPLY: infixExpr.setOperator(InfixExpression.Operator.TIMES); break;
                    case DIVIDE: infixExpr.setOperator(InfixExpression.Operator.DIVIDE); break;
                    case MODULO: infixExpr.setOperator(InfixExpression.Operator.REMAINDER); break;
                }
                return infixExpr;
            default:
                return null;
        }
    }

    public Statement createDefaultStatement(AST ast, AddableBlock type, CompilationUnit cu, ASTRewrite rewriter) {
        switch (type) {
            case PRINT:
                MethodInvocation println = ast.newMethodInvocation();
                println.setExpression(ast.newQualifiedName(ast.newSimpleName("System"), ast.newSimpleName("out")));
                println.setName(ast.newSimpleName("println"));
                StringLiteral emptyString = ast.newStringLiteral();
                emptyString.setLiteralValue("");
                println.arguments().add(emptyString);
                return ast.newExpressionStatement(println);

            case DECLARE_INT:
                return createVariableDeclaration(ast, DefaultNames.DEFAULT_INT, "0", PrimitiveType.INT);
            case DECLARE_DOUBLE:
                return createVariableDeclaration(ast, DefaultNames.DEFAULT_DOUBLE, "0.0", PrimitiveType.DOUBLE);
            case DECLARE_BOOLEAN:
                return createVariableDeclaration(ast, DefaultNames.DEFAULT_BOOLEAN, false, PrimitiveType.BOOLEAN);
            case DECLARE_STRING:
                return createStringDeclaration(ast);
            case DECLARE_ARRAY:
                if (cu != null && rewriter != null) {
                    ImportManager.addImport(cu, rewriter, "java.util.ArrayList");
                    ImportManager.addImport(cu, rewriter, "java.util.Arrays");
                }
                VariableDeclarationFragment frag = ast.newVariableDeclarationFragment();
                frag.setName(ast.newSimpleName("myList"));
                frag.setInitializer(createRecursiveListInitializer(ast, "ArrayList<Integer>", cu, rewriter, null));
                VariableDeclarationStatement listDecl = ast.newVariableDeclarationStatement(frag);
                listDecl.setType(TypeManager.createTypeNode(ast, "ArrayList<Integer>"));
                return listDecl;
            case IF:
                IfStatement ifStatement = ast.newIfStatement();
                ifStatement.setExpression(ast.newBooleanLiteral(true));
                ifStatement.setThenStatement(ast.newBlock());
                return ifStatement;

            case WHILE:
                WhileStatement whileStatement = ast.newWhileStatement();
                whileStatement.setExpression(ast.newBooleanLiteral(true));
                whileStatement.setBody(ast.newBlock());
                return whileStatement;

            case FOR:
                EnhancedForStatement enhancedFor = ast.newEnhancedForStatement();
                SingleVariableDeclaration parameter = ast.newSingleVariableDeclaration();
                parameter.setType(TypeManager.createTypeNode(ast, "String"));
                parameter.setName(ast.newSimpleName("item"));
                enhancedFor.setParameter(parameter);
                enhancedFor.setExpression(ast.newSimpleName("array"));
                enhancedFor.setBody(ast.newBlock());
                return enhancedFor;

            case DO_WHILE:
                DoStatement doStatement = ast.newDoStatement();
                doStatement.setExpression(ast.newBooleanLiteral(true));
                doStatement.setBody(ast.newBlock());
                return doStatement;

            case BREAK: return ast.newBreakStatement();
            case CONTINUE: return ast.newContinueStatement();
            case RETURN: return ast.newReturnStatement();

            case COMMENT: return ast.newEmptyStatement();

            case ASSIGNMENT:
                Assignment assignment = ast.newAssignment();
                assignment.setLeftHandSide(ast.newSimpleName(DefaultNames.DEFAULT_VARIABLE));
                assignment.setOperator(Assignment.Operator.ASSIGN);
                assignment.setRightHandSide(ast.newNumberLiteral("0"));
                return ast.newExpressionStatement(assignment);

            case READ_LINE: return createScannerCall(ast, "input", "nextLine", "String");
            case READ_INT: return createScannerCall(ast, "num", "nextInt", PrimitiveType.INT);
            case READ_DOUBLE: return createScannerCall(ast, "num", "nextDouble", PrimitiveType.DOUBLE);

            case SWITCH:
                SwitchStatement switchStmt = ast.newSwitchStatement();
                switchStmt.setExpression(ast.newSimpleName(DefaultNames.DEFAULT_VARIABLE));
                SwitchCase defaultCase = ast.newSwitchCase();
                switchStmt.statements().add(defaultCase);
                switchStmt.statements().add(ast.newBreakStatement());
                return switchStmt;

            case CASE:
                SwitchCase switchCase = ast.newSwitchCase();
                try { switchCase.expressions().add(ast.newNumberLiteral("0")); } catch (Exception e) {}
                return switchCase;

            case WAIT:
                return createWaitStatement(ast);

            default:
                return null;
        }
    }

    // Helpers for creation logic
    private Statement createVariableDeclaration(AST ast, String name, String val, PrimitiveType.Code type) {
        VariableDeclarationFragment fragment = ast.newVariableDeclarationFragment();
        fragment.setName(ast.newSimpleName(name));
        fragment.setInitializer(ast.newNumberLiteral(val));
        VariableDeclarationStatement varDecl = ast.newVariableDeclarationStatement(fragment);
        varDecl.setType(ast.newPrimitiveType(type));
        return varDecl;
    }

    private Statement createVariableDeclaration(AST ast, String name, boolean val, PrimitiveType.Code type) {
        VariableDeclarationFragment fragment = ast.newVariableDeclarationFragment();
        fragment.setName(ast.newSimpleName(name));
        fragment.setInitializer(ast.newBooleanLiteral(val));
        VariableDeclarationStatement varDecl = ast.newVariableDeclarationStatement(fragment);
        varDecl.setType(ast.newPrimitiveType(type));
        return varDecl;
    }

    private Statement createStringDeclaration(AST ast) {
        VariableDeclarationFragment fragment = ast.newVariableDeclarationFragment();
        fragment.setName(ast.newSimpleName(DefaultNames.DEFAULT_STRING));
        fragment.setInitializer(ast.newStringLiteral());
        VariableDeclarationStatement varDecl = ast.newVariableDeclarationStatement(fragment);
        varDecl.setType(TypeManager.createTypeNode(ast, "String"));
        return varDecl;
    }

    private Statement createScannerCall(AST ast, String varName, String methodName, Object typeObj) {
        VariableDeclarationFragment fragment = ast.newVariableDeclarationFragment();
        fragment.setName(ast.newSimpleName(varName));
        MethodInvocation scannerCall = ast.newMethodInvocation();
        scannerCall.setExpression(ast.newSimpleName("scanner"));
        scannerCall.setName(ast.newSimpleName(methodName));
        fragment.setInitializer(scannerCall);
        VariableDeclarationStatement varDecl = ast.newVariableDeclarationStatement(fragment);
        if(typeObj instanceof String) varDecl.setType(TypeManager.createTypeNode(ast, (String)typeObj));
        else varDecl.setType(ast.newPrimitiveType((PrimitiveType.Code)typeObj));
        return varDecl;
    }

    private Statement createWaitStatement(AST ast) {
        TryStatement tryStmt = ast.newTryStatement();
        Block tryBody = ast.newBlock();
        MethodInvocation sleepCall = ast.newMethodInvocation();
        sleepCall.setExpression(ast.newSimpleName("Thread"));
        sleepCall.setName(ast.newSimpleName("sleep"));
        sleepCall.arguments().add(ast.newNumberLiteral("1000"));
        tryBody.statements().add(ast.newExpressionStatement(sleepCall));
        tryStmt.setBody(tryBody);
        CatchClause catchClause = ast.newCatchClause();
        SingleVariableDeclaration exceptionDecl = ast.newSingleVariableDeclaration();
        exceptionDecl.setType(ast.newSimpleType(ast.newSimpleName("InterruptedException")));
        exceptionDecl.setName(ast.newSimpleName("e"));
        catchClause.setException(exceptionDecl);
        Block catchBody = ast.newBlock();
        MethodInvocation printStackTrace = ast.newMethodInvocation();
        printStackTrace.setExpression(ast.newSimpleName("e"));
        printStackTrace.setName(ast.newSimpleName("printStackTrace"));
        catchBody.statements().add(ast.newExpressionStatement(printStackTrace));
        catchClause.setBody(catchBody);
        tryStmt.catchClauses().add(catchClause);
        return tryStmt;
    }

    public Expression createRecursiveListInitializer(AST ast, String typeName, CompilationUnit cu, ASTRewrite rewriter, List<Expression> leavesToPreserve) {
        ImportManager.addImport(cu, rewriter, "java.util.ArrayList");
        ImportManager.addImport(cu, rewriter, "java.util.Arrays");

        ClassInstanceCreation creation = ast.newClassInstanceCreation();
        String innerTypeStr = extractArrayListElementType(typeName);
        String wrapperInnerType = toWrapperType(innerTypeStr);
        ParameterizedType paramType = ast.newParameterizedType(ast.newSimpleType(ast.newName("ArrayList")));

        if (!innerTypeStr.equals("Object")) {
            paramType.typeArguments().add(TypeManager.createTypeNode(ast, wrapperInnerType));
        }
        creation.setType(paramType);

        MethodInvocation asList = ast.newMethodInvocation();
        asList.setExpression(ast.newSimpleName("Arrays"));
        asList.setName(ast.newSimpleName("asList"));

        if (innerTypeStr.startsWith("ArrayList<")) {
            Expression innerList = createRecursiveListInitializer(ast, innerTypeStr, cu, rewriter, leavesToPreserve);
            asList.arguments().add(innerList);
        } else {
            if (leavesToPreserve != null && !leavesToPreserve.isEmpty()) {
                for (Expression leaf : leavesToPreserve) {
                    asList.arguments().add((Expression) ASTNode.copySubtree(ast, leaf));
                }
            } else {
                asList.arguments().add(createDefaultInitializer(ast, innerTypeStr));
            }
        }
        creation.arguments().add(asList);
        return creation;
    }

    public Expression createDefaultInitializer(AST ast, String typeName) {
        switch (typeName) {
            case "int": case "long": case "short": case "byte": return ast.newNumberLiteral("0");
            case "double": case "float": return ast.newNumberLiteral("0.0");
            case "boolean": return ast.newBooleanLiteral(false);
            case "char":
                CharacterLiteral literal = ast.newCharacterLiteral();
                literal.setCharValue('a');
                return literal;
            case "String":
                StringLiteral str = ast.newStringLiteral();
                str.setLiteralValue("");
                return str;
            default: return ast.newNullLiteral();
        }
    }

    private String extractArrayListElementType(String arrayListType) {
        if (arrayListType.contains("<") && arrayListType.contains(">")) {
            int start = arrayListType.indexOf("<") + 1;
            int end = arrayListType.lastIndexOf(">");
            return arrayListType.substring(start, end);
        }
        return "Object";
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/project/ProjectConfig.java
=================================================================================

package com.botmaker.project;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.List;

/**
 * Configuration for BotMaker projects, stored in projects/.botmaker-config.json
 */
public class ProjectConfig {

    private static final Path CONFIG_FILE = Paths.get("projects/.botmaker-config.json");
    private static final Gson GSON = new GsonBuilder()
            .setPrettyPrinting()
            .create();

    private String lastOpenedProject;
    private List<ProjectEntry> recentProjects;

    public ProjectConfig() {
        this.recentProjects = new ArrayList<>();
    }

    public String getLastOpenedProject() {
        return lastOpenedProject;
    }

    public void setLastOpenedProject(String projectName) {
        this.lastOpenedProject = projectName;
    }

    public List<ProjectEntry> getRecentProjects() {
        return recentProjects;
    }

    public void addRecentProject(String projectName) {
        // Remove if already exists
        recentProjects.removeIf(p -> p.getName().equals(projectName));

        // Add at the beginning
        ProjectEntry entry = new ProjectEntry(projectName);
        recentProjects.add(0, entry);

        // Keep only last 10 projects
        if (recentProjects.size() > 10) {
            recentProjects = recentProjects.subList(0, 10);
        }
    }

    /**
     * Loads the configuration from disk
     */
    public static ProjectConfig load() {
        try {
            if (Files.exists(CONFIG_FILE)) {
                String json = Files.readString(CONFIG_FILE);
                return GSON.fromJson(json, ProjectConfig.class);
            }
        } catch (Exception e) {
            System.err.println("Failed to load project config: " + e.getMessage());
        }

        // Return default config if file doesn't exist or can't be read
        return new ProjectConfig();
    }

    /**
     * Saves the configuration to disk
     */
    public void save() {
        try {
            // Ensure projects directory exists
            Files.createDirectories(CONFIG_FILE.getParent());

            // Write JSON
            String json = GSON.toJson(this);
            Files.writeString(CONFIG_FILE, json);
        } catch (IOException e) {
            System.err.println("Failed to save project config: " + e.getMessage());
        }
    }

    /**
     * Updates the last opened project and saves
     */
    public static void updateLastOpened(String projectName) {
        ProjectConfig config = load();
        config.setLastOpenedProject(projectName);
        config.addRecentProject(projectName);
        config.save();
    }

    /**
     * Gets the last opened project name, or null if none
     */
    public static String getLastOpened() {
        ProjectConfig config = load();
        return config.getLastOpenedProject();
    }

    /**
     * Represents a recent project entry
     */
    public static class ProjectEntry {
        private String name;
        private String lastOpened; // ISO-8601 timestamp string

        public ProjectEntry() {
            // For Gson
        }

        public ProjectEntry(String name) {
            this.name = name;
            this.lastOpened = LocalDateTime.now().format(DateTimeFormatter.ISO_LOCAL_DATE_TIME);
        }

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }

        public String getLastOpened() {
            return lastOpened;
        }

        public void setLastOpened(String lastOpened) {
            this.lastOpened = lastOpened;
        }

        /**
         * Gets the last opened time as LocalDateTime
         */
        public LocalDateTime getLastOpenedDateTime() {
            try {
                return LocalDateTime.parse(lastOpened, DateTimeFormatter.ISO_LOCAL_DATE_TIME);
            } catch (Exception e) {
                return LocalDateTime.now();
            }
        }
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/project/ProjectCreator.java
=================================================================================

package com.botmaker.project;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

/**
 * Handles creation of new Gradle projects with proper structure
 */
public class ProjectCreator {

    private static final Path PROJECTS_ROOT = Paths.get("projects");

    /**
     * Creates a new Gradle project with standard structure
     *
     * @param projectName The name of the project to create
     * @throws IOException if project creation fails
     * @throws IllegalArgumentException if project name is invalid or already exists
     */
    public void createProject(String projectName) throws IOException {
        // Validate project name
        validateProjectName(projectName);

        // Check if project already exists
        if (projectExists(projectName)) {
            throw new IllegalArgumentException("Project '" + projectName + "' already exists");
        }

        // Create project structure
        Path projectPath = PROJECTS_ROOT.resolve(projectName);
        createProjectStructure(projectPath, projectName);

        System.out.println("Successfully created project: " + projectName);
    }

    /**
     * Validates the project name
     */
    private void validateProjectName(String projectName) {
        if (projectName == null || projectName.trim().isEmpty()) {
            throw new IllegalArgumentException("Project name cannot be empty");
        }

        // Check for valid Java class name (starts with letter, contains only letters/digits)
        if (!projectName.matches("^[A-Z][a-zA-Z0-9]*$")) {
            throw new IllegalArgumentException(
                    "Project name must start with an uppercase letter and contain only letters and numbers"
            );
        }

        // Check length
        if (projectName.length() < 2 || projectName.length() > 50) {
            throw new IllegalArgumentException("Project name must be between 2 and 50 characters");
        }
    }

    /**
     * Checks if a project already exists
     */
    public boolean projectExists(String projectName) {
        Path projectPath = PROJECTS_ROOT.resolve(projectName);
        return Files.exists(projectPath);
    }

    /**
     * Creates the complete project structure
     */
    private void createProjectStructure(Path projectPath, String projectName) throws IOException {
        // Create directories
        Files.createDirectories(projectPath);

        String packageName = projectName.toLowerCase();
        Path srcPath = projectPath.resolve("src/main/java/com/" + packageName);
        Files.createDirectories(srcPath);

        Path gradlePath = projectPath.resolve("gradle/wrapper");
        Files.createDirectories(gradlePath);

        // Create build.gradle
        createBuildGradle(projectPath, projectName);

        // Create settings.gradle
        createSettingsGradle(projectPath, projectName);

        // Create gradle-wrapper.properties
        createGradleWrapperProperties(gradlePath);

        // Create gradlew scripts
        createGradlewScripts(projectPath);

        // Create main Java file
        createMainJavaFile(srcPath, projectName, packageName);
    }

    /**
     * Creates build.gradle file
     */
    private void createBuildGradle(Path projectPath, String projectName) throws IOException {
        String packageName = projectName.toLowerCase();
        String content = String.format("""
            plugins {
                id 'java'
                id 'application'
            }
            
            group = 'com.%s'
            version = '0.0.1-SNAPSHOT'
            
            repositories {
                mavenCentral()
            }
            
            application {
                mainClass = 'com.%s.%s'
            }
            
            java {
                sourceCompatibility = JavaVersion.VERSION_17
                targetCompatibility = JavaVersion.VERSION_17
            }
            """, packageName, packageName, projectName);

        Files.writeString(projectPath.resolve("build.gradle"), content);
    }

    /**
     * Creates settings.gradle file
     */
    private void createSettingsGradle(Path projectPath, String projectName) throws IOException {
        String content = String.format("""
            
            pluginManagement {
                repositories {
                    gradlePluginPortal()
                    mavenCentral()
                }
            }
            
            
            
            rootProject.name = '%s'
            
            """, projectName);

        Files.writeString(projectPath.resolve("settings.gradle"), content);
    }

    /**
     * Creates gradle-wrapper.properties file
     */
    private void createGradleWrapperProperties(Path gradlePath) throws IOException {
        String content = """
            distributionBase=GRADLE_USER_HOME
            distributionPath=wrapper/dists
            distributionUrl=https\\://services.gradle.org/distributions/gradle-9.1.0-bin.zip
            networkTimeout=10000
            validateDistributionUrl=true
            zipStoreBase=GRADLE_USER_HOME
            zipStorePath=wrapper/dists
            """;

        Files.writeString(gradlePath.resolve("gradle-wrapper.properties"), content);
    }

    /**
     * Creates gradlew scripts (Unix and Windows)
     */
    private void createGradlewScripts(Path projectPath) throws IOException {
        // Create Unix gradlew script
        String gradlewUnix = """
            #!/bin/sh
            
            #
            # Copyright © 2015 the original authors.
            #
            # Licensed under the Apache License, Version 2.0 (the "License");
            # you may not use this file except in compliance with the License.
            # You may obtain a copy of the License at
            #
            #      https://www.apache.org/licenses/LICENSE-2.0
            #
            # Unless required by applicable law or agreed to in writing, software
            # distributed under the License is distributed on an "AS IS" BASIS,
            # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
            # See the License for the specific language governing permissions and
            # limitations under the License.
            #
            
            ##############################################################################
            #
            #   Gradle start up script for POSIX generated by Gradle.
            #
            ##############################################################################
            
            # Attempt to set APP_HOME
            app_path=$0
            
            APP_HOME=${app_path%"${app_path##*/}"}
            APP_BASE_NAME=${0##*/}
            APP_HOME=$( cd -P "${APP_HOME:-./}" > /dev/null && printf '%s\\n' "$PWD" ) || exit
            
            DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'
            
            JAVACMD=java
            if [ -n "$JAVA_HOME" ] ; then
                if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
                    JAVACMD=$JAVA_HOME/jre/sh/java
                else
                    JAVACMD=$JAVA_HOME/bin/java
                fi
            fi
            
            exec "$JAVACMD" "$@"
            """;

        Path gradlewPath = projectPath.resolve("gradlew");
        Files.writeString(gradlewPath, gradlewUnix);

        // Make it executable on Unix systems
        try {
            gradlewPath.toFile().setExecutable(true);
        } catch (Exception e) {
            System.err.println("Warning: Could not set gradlew as executable: " + e.getMessage());
        }

        // Create Windows gradlew.bat script
        String gradlewBat = """
            @rem
            @rem Copyright 2015 the original author or authors.
            @rem
            @rem Licensed under the Apache License, Version 2.0 (the "License");
            @rem you may not use this file except in compliance with the License.
            @rem You may obtain a copy of the License at
            @rem
            @rem      https://www.apache.org/licenses/LICENSE-2.0
            @rem
            @rem Unless required by applicable law or agreed to in writing, software
            @rem distributed under the License is distributed on an "AS IS" BASIS,
            @rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
            @rem See the License for the specific language governing permissions and
            @rem limitations under the License.
            @rem
            
            @if "%DEBUG%"=="" @echo off
            
            set DIRNAME=%~dp0
            if "%DIRNAME%"=="" set DIRNAME=.
            set APP_BASE_NAME=%~n0
            
            set DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"
            
            set JAVA_EXE=java.exe
            if defined JAVA_HOME goto findJavaFromJavaHome
            
            %JAVA_EXE% -version >NUL 2>&1
            if %ERRORLEVEL% equ 0 goto execute
            
            :findJavaFromJavaHome
            set JAVA_HOME=%JAVA_HOME:"=%
            set JAVA_EXE=%JAVA_HOME%/bin/java.exe
            
            :execute
            "%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -jar "%DIRNAME%\\gradle\\wrapper\\gradle-wrapper.jar" %*
            
            :end
            if %ERRORLEVEL% equ 0 goto mainEnd
            
            :fail
            exit /b %ERRORLEVEL%
            
            :mainEnd
            """;

        Files.writeString(projectPath.resolve("gradlew.bat"), gradlewBat);
    }

    /**
     * Creates the main Java source file
     */
    private void createMainJavaFile(Path srcPath, String projectName, String packageName) throws IOException {
        String content = String.format("""
            package com.%s;
            
            public class %s {
                public static void main(String[] args) {
                    System.out.println("Hello from %s!");
                }
            }
            """, packageName, projectName, projectName);

        Files.writeString(srcPath.resolve(projectName + ".java"), content);
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/project/ProjectFile.java
=================================================================================

package com.botmaker.project;

import org.eclipse.jdt.core.dom.CompilationUnit;
import java.nio.file.Path;

public class ProjectFile {
    private final Path path;
    private String content;
    private CompilationUnit ast;
    private final String className; // e.g., "Movement"

    public ProjectFile(Path path, String content) {
        this.path = path;
        this.content = content;
        String filename = path.getFileName().toString();
        this.className = filename.substring(0, filename.lastIndexOf('.'));
    }

    public Path getPath() { return path; }

    public String getContent() { return content; }
    public void setContent(String content) { this.content = content; }

    public CompilationUnit getAst() { return ast; }
    public void setAst(CompilationUnit ast) { this.ast = ast; }

    public String getClassName() { return className; }

    public String getUri() {
        return path.toUri().toString();
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/project/ProjectInfo.java
=================================================================================

package com.botmaker.project;

import java.nio.file.Path;
import java.time.LocalDateTime;

/**
 * Information about a project
 */
public class ProjectInfo {
    private final String name;
    private final Path projectPath;
    private final LocalDateTime lastModified;

    public ProjectInfo(String name, Path projectPath, LocalDateTime lastModified) {
        this.name = name;
        this.projectPath = projectPath;
        this.lastModified = lastModified;
    }

    public String getName() {
        return name;
    }

    public Path getProjectPath() {
        return projectPath;
    }

    public LocalDateTime getLastModified() {
        return lastModified;
    }

    @Override
    public String toString() {
        return name;
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/project/ProjectManager.java
=================================================================================

package com.botmaker.project;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.attribute.FileTime;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Stream;

/**
 * Manages project discovery and listing
 */
public class ProjectManager {

    private static final Path PROJECTS_ROOT = Paths.get("projects");

    /**
     * Lists all available projects
     */
    public List<ProjectInfo> listProjects() {
        List<ProjectInfo> projects = new ArrayList<>();

        if (!Files.exists(PROJECTS_ROOT)) {
            return projects;
        }

        try (Stream<Path> paths = Files.list(PROJECTS_ROOT)) {
            paths.filter(Files::isDirectory)
                    .filter(this::isValidProject)
                    .forEach(projectPath -> {
                        try {
                            String projectName = projectPath.getFileName().toString();
                            FileTime lastModified = Files.getLastModifiedTime(projectPath);
                            LocalDateTime modifiedDate = LocalDateTime.ofInstant(
                                    lastModified.toInstant(),
                                    ZoneId.systemDefault()
                            );
                            projects.add(new ProjectInfo(projectName, projectPath, modifiedDate));
                        } catch (IOException e) {
                            System.err.println("Error reading project: " + projectPath);
                        }
                    });
        } catch (IOException e) {
            System.err.println("Error listing projects: " + e.getMessage());
        }

        return projects;
    }

    /**
     * Checks if a directory is a valid project
     * (has src/main/java structure and build.gradle)
     */
    private boolean isValidProject(Path projectPath) {
        Path srcPath = projectPath.resolve("src/main/java");
        Path buildGradle = projectPath.resolve("build.gradle");
        boolean isValid = Files.exists(srcPath) && Files.exists(buildGradle);

        // Debug output
        System.out.println("Checking project: " + projectPath);
        System.out.println("  src/main/java exists: " + Files.exists(srcPath));
        System.out.println("  build.gradle exists: " + Files.exists(buildGradle));
        System.out.println("  Valid: " + isValid);

        return isValid;
    }

    /**
     * Gets the source file path for a project
     */
    public Path getSourceFilePath(String projectName) {
        String packageName = projectName.toLowerCase();
        return PROJECTS_ROOT
                .resolve(projectName)
                .resolve("src/main/java/com")
                .resolve(packageName)
                .resolve(projectName + ".java");
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/runtime/CodeExecutionService.java
=================================================================================

package com.botmaker.runtime;

import com.botmaker.config.ApplicationConfig;
import com.botmaker.project.ProjectFile;
import com.botmaker.state.ApplicationState;
import com.botmaker.validation.DiagnosticsManager;
import javafx.application.Platform;

import java.io.IOException;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.function.Consumer;

public class CodeExecutionService {

    private final Consumer<String> appendOutputConsumer;
    private final Runnable clearOutputConsumer;
    private final Consumer<String> setOutputConsumer;
    private final Consumer<String> statusConsumer;
    private final DiagnosticsManager diagnosticsManager;
    private final ApplicationConfig config;
    private final ApplicationState state;

    private volatile Process currentRunningProcess;
    private final AtomicBoolean isRunning = new AtomicBoolean(false);

    private static final int MAX_UI_BUFFER_SIZE = 4096;
    private static final int UI_UPDATE_RATE_MS = 100;

    public CodeExecutionService(
            Consumer<String> appendOutputConsumer,
            Runnable clearOutputConsumer,
            Consumer<String> setOutputConsumer,
            Consumer<String> statusConsumer,
            DiagnosticsManager diagnosticsManager,
            ApplicationConfig config,
            ApplicationState state) {
        this.appendOutputConsumer = appendOutputConsumer;
        this.clearOutputConsumer = clearOutputConsumer;
        this.setOutputConsumer = setOutputConsumer;
        this.statusConsumer = statusConsumer;
        this.diagnosticsManager = diagnosticsManager;
        this.config = config;
        this.state = state;
    }

    public void runCode(String currentEditorCode) {
        if (diagnosticsManager.hasErrors()) {
            Platform.runLater(() -> statusConsumer.accept("Run aborted due to errors."));
            return;
        }

        if (isRunning.get()) {
            Platform.runLater(() -> statusConsumer.accept("Program is already running. Stop it first."));
            return;
        }

        try {
            Path compiledOutputPath = config.getCompiledOutputPath();

            // 1. Compile (Blocking)
            if (!compileAndWait(currentEditorCode, compiledOutputPath)) {
                Platform.runLater(() -> statusConsumer.accept("Run aborted due to compilation failure."));
                return;
            }

            // 2. Setup Execution
            Platform.runLater(() -> {
                statusConsumer.accept("Running... (Press Stop to terminate)");
                clearOutputConsumer.run();
            });

            isRunning.set(true);

            String classPath = compiledOutputPath.toString();
            String className = config.getMainClassName();
            String javaExecutable = config.getJavaExecutable();

            ProcessBuilder pb = new ProcessBuilder(javaExecutable, "-cp", classPath, className);
            currentRunningProcess = pb.start();

            // 3. Start IO Readers and keep references to them
            Thread outReader = startLeakyBucketReader(currentRunningProcess.getInputStream());
            Thread errReader = startLeakyBucketReader(currentRunningProcess.getErrorStream());

            // 4. Wait for process to exit
            int exitCode = currentRunningProcess.waitFor();

            // 5. CRITICAL FIX: Wait for readers to drain the stream before stopping UI updates
            try {
                outReader.join(1000); // Wait up to 1s for streams to flush
                errReader.join(1000);
            } catch (InterruptedException ignored) {}

            Platform.runLater(() -> {
                if (exitCode == 0) statusConsumer.accept("Program completed successfully.");
                else if (exitCode == 143 || exitCode == 130 || exitCode == 1 || exitCode == -1) statusConsumer.accept("Program stopped.");
                else statusConsumer.accept("Program exited with code: " + exitCode);
            });

        } catch (InterruptedException e) {
            Platform.runLater(() -> statusConsumer.accept("Program stopped by user."));
        } catch (Exception e) {
            e.printStackTrace();
            Platform.runLater(() -> statusConsumer.accept("Error: " + e.getMessage()));
        } finally {
            isRunning.set(false); // NOW safe to stop UI updates
            currentRunningProcess = null;
        }
    }

    public void compileCode(String code) {
        new Thread(() -> {
            try {
                Platform.runLater(() -> setOutputConsumer.accept("Saving and compiling..."));
                Path compiledOutputPath = config.getCompiledOutputPath();
                if (compileAndWait(code, compiledOutputPath)) {
                    Platform.runLater(() -> setOutputConsumer.accept("Compilation successful."));
                }
            } catch (IOException | InterruptedException e) {
                Platform.runLater(() -> setOutputConsumer.accept("Compilation Error: " + e.getMessage()));
            }
        }).start();
    }

    public boolean compileAndWait(String currentActiveCode, Path compiledOutputPath) throws IOException, InterruptedException {
        // Sync memory
        state.setCurrentCode(currentActiveCode);

        // Save ALL files to disk
        for (ProjectFile file : state.getAllFiles()) {
            Path path = file.getPath();
            if (path != null) {
                Files.createDirectories(path.getParent());
                Files.writeString(path, file.getContent());
            }
        }

        Files.createDirectories(compiledOutputPath);

        String javacExecutable = Paths.get(System.getProperty("java.home"), "bin", "javac").toString();

        // Calculate source root (3 levels up from Main file: com/pkg/Main.java -> src/main/java)
        Path sourcePathRoot = config.getSourceFilePath().getParent().getParent().getParent();

        ProcessBuilder pb = new ProcessBuilder(
                javacExecutable,
                "-g",
                "-d", compiledOutputPath.toString(),
                "-sourcepath", sourcePathRoot.toString(),
                config.getSourceFilePath().toString()
        );

        Process process = pb.start();

        String errors = new String(process.getErrorStream().readAllBytes());
        int exitCode = process.waitFor();

        if (exitCode != 0) {
            Platform.runLater(() -> setOutputConsumer.accept("Compilation Failed:\n" + errors));
            return false;
        }
        return true;
    }

    public void stopRunningProgram() {
        if (currentRunningProcess != null && currentRunningProcess.isAlive()) {
            currentRunningProcess.destroyForcibly();
        }
    }

    public boolean isRunning() { return isRunning.get(); }

    // CHANGED: Returns the Thread so we can join() it
    private Thread startLeakyBucketReader(InputStream inputStream) {
        final StringBuilder buffer = new StringBuilder();
        final ScheduledExecutorService uiUpdater = Executors.newSingleThreadScheduledExecutor();

        // UI Pusher Loop
        uiUpdater.scheduleAtFixedRate(() -> {
            // Only stop if process is dead AND buffer is empty
            if (!isRunning.get() && buffer.length() == 0) {
                uiUpdater.shutdown();
                return;
            }

            String textToSend = "";
            synchronized (buffer) {
                if (buffer.length() > 0) {
                    textToSend = buffer.toString();
                    buffer.setLength(0);
                }
            }

            if (!textToSend.isEmpty()) {
                String finalTx = textToSend;
                Platform.runLater(() -> appendOutputConsumer.accept(finalTx));
            }
        }, UI_UPDATE_RATE_MS, UI_UPDATE_RATE_MS, TimeUnit.MILLISECONDS);

        // Stream Reader Thread
        Thread readerThread = new Thread(() -> {
            byte[] readBuf = new byte[1024];
            int len;
            try {
                while ((len = inputStream.read(readBuf)) != -1) {
                    synchronized (buffer) {
                        if (buffer.length() < MAX_UI_BUFFER_SIZE) {
                            buffer.append(new String(readBuf, 0, len, StandardCharsets.UTF_8));
                        }
                    }
                }
            } catch (IOException ignored) {
            } finally {
                // Do not shut down UI updater here; let the scheduler decide based on buffer/isRunning state
            }
        }, "Leaky-Reader");

        readerThread.start();
        return readerThread;
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/services/CodeEditorService.java
=================================================================================

package com.botmaker.services;

import com.botmaker.blocks.MainBlock;
import com.botmaker.config.ApplicationConfig;
import com.botmaker.core.AbstractCodeBlock;
import com.botmaker.core.CodeBlock;
import com.botmaker.events.CoreApplicationEvents;
import com.botmaker.events.EventBus;
import com.botmaker.lsp.CompletionContext;
import com.botmaker.parser.AstRewriter;
import com.botmaker.parser.BlockFactory;
import com.botmaker.parser.CodeEditor;
import com.botmaker.project.ProjectFile;
import com.botmaker.state.ApplicationState;
import com.botmaker.state.HistoryManager;
import com.botmaker.ui.BlockDragAndDropManager;
import com.botmaker.validation.DiagnosticsManager;
import javafx.application.Platform;

import java.nio.file.Files;
import java.nio.file.Path;
import java.util.stream.Stream;

public class CodeEditorService {

    private final ApplicationConfig config;
    private final ApplicationState state;
    private final EventBus eventBus;
    private final BlockFactory blockFactory;
    private final AstRewriter astRewriter;
    private final CodeEditor codeEditor;
    private final BlockDragAndDropManager dragAndDropManager;
    private final LanguageServerService languageServerService;
    private final DiagnosticsManager diagnosticsManager;
    private final HistoryManager historyManager;
    private boolean isRestoringHistory = false;

    public CodeEditorService(
            ApplicationConfig config,
            ApplicationState state,
            EventBus eventBus,
            BlockFactory blockFactory,
            AstRewriter astRewriter,
            BlockDragAndDropManager dragAndDropManager,
            LanguageServerService languageServerService,
            DiagnosticsManager diagnosticsManager) {

        this.config = config;
        this.state = state;
        this.eventBus = eventBus;
        this.blockFactory = blockFactory;
        this.astRewriter = astRewriter;
        this.dragAndDropManager = dragAndDropManager;
        this.languageServerService = languageServerService;
        this.diagnosticsManager = diagnosticsManager;
        this.historyManager = new HistoryManager();
        this.codeEditor = new CodeEditor(state, eventBus, astRewriter, blockFactory);

        setupEventHandlers();
    }

    private void setupEventHandlers() {
        eventBus.subscribe(
                CoreApplicationEvents.UIRefreshRequestedEvent.class,
                event -> Platform.runLater(() -> refreshUI(event.getCode())),
                false
        );

        // NEW: Listen for toggles to update state
        eventBus.subscribe(
                CoreApplicationEvents.BreakpointToggledEvent.class,
                this::handleBreakpointToggle,
                false
        );

        // 1. Record History on Code Updates
        eventBus.subscribe(CoreApplicationEvents.CodeUpdatedEvent.class, this::handleCodeUpdateForHistory, false);

        // 2. Handle Requests
        eventBus.subscribe(CoreApplicationEvents.UndoRequestedEvent.class, e -> undo(), false);
        eventBus.subscribe(CoreApplicationEvents.RedoRequestedEvent.class, e -> redo(), false);

    }

    // Called when block drag-drop or text edit happens
    private void handleCodeUpdateForHistory(CoreApplicationEvents.CodeUpdatedEvent event) {
        // If this update is triggered BY the undo button, don't record it again!
        if (isRestoringHistory) return;

        // Save the PREVIOUS code state before the update happened
        String previousCode = event.getPreviousCode();
        if (previousCode != null && !previousCode.isEmpty()) {
            historyManager.pushState(previousCode);
            broadcastHistoryState();
        }
    }

    private void undo() {
        if (!historyManager.canUndo()) return;
        applyHistoryState(historyManager.undo(state.getCurrentCode()));
    }

    private void redo() {
        if (!historyManager.canRedo()) return;
        applyHistoryState(historyManager.redo(state.getCurrentCode()));
    }

    private void applyHistoryState(String code) {
        isRestoringHistory = true; // Lock recording
        try {
            // This triggers the standard refresh flow (UI update, LSP sync, etc.)
            // We fake a CodeUpdatedEvent so the LanguageServerService picks it up
            eventBus.publish(new CoreApplicationEvents.CodeUpdatedEvent(code, state.getCurrentCode()));
            broadcastHistoryState();
        } finally {
            isRestoringHistory = false; // Unlock
        }
    }

    private void broadcastHistoryState() {
        eventBus.publish(new CoreApplicationEvents.HistoryStateChangedEvent(
                historyManager.canUndo(),
                historyManager.canRedo()
        ));
    }

    private void handleBreakpointToggle(CoreApplicationEvents.BreakpointToggledEvent event) {
        if (event.isEnabled()) {
            state.addBreakpoint(event.getBlock().getId());
        } else {
            state.removeBreakpoint(event.getBlock().getId());
        }
    }

    public void loadInitialCode() {
        try {
            Path mainFile = config.getSourceFilePath();
            Path sourceDir = mainFile.getParent();

            // Load all java files in the directory
            try (Stream<Path> files = Files.list(sourceDir)) {
                files.filter(p -> p.toString().endsWith(".java")).forEach(path -> {
                    try {
                        String content = Files.readString(path);
                        ProjectFile pf = new ProjectFile(path, content);
                        state.addFile(pf);
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                });
            }

            // Set Active File to Main
            switchToFile(mainFile);

        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public void switchToFile(Path path) {
        ProjectFile file = state.getAllFiles().stream()
                .filter(f -> f.getPath().equals(path))
                .findFirst().orElse(null);

        if (file == null) return;

        // 1. Refresh UI
        state.setActiveFile(path);

        // Clear history when switching (optional, or keep separate history per file)
        // historyManager.clear();

        refreshUI(file.getContent());
    }


    public void createFile(String className) {
        try {
            String packageName = config.getMainClassName().substring(0, config.getMainClassName().lastIndexOf('.'));
            Path dir = config.getSourceFilePath().getParent();
            Path newPath = dir.resolve(className + ".java");

            String template = "package " + packageName + ";\n\n" +
                    "public class " + className + " {\n" +
                    "    // Add functions here\n" +
                    "    public static void action() {\n" +
                    "        System.out.println(\"Action from " + className + "\");\n" +
                    "    }\n" +
                    "}";

            Files.writeString(newPath, template);

            ProjectFile pf = new ProjectFile(newPath, template);
            state.addFile(pf);

            // Notify LSP
            languageServerService.openFile(newPath, template);

            switchToFile(newPath);

        } catch (Exception e) {
            e.printStackTrace();
        }
    }



    private void refreshUI(String javaCode) {
        state.setCurrentCode(javaCode);
        state.clearNodeToBlockMap();

        if (diagnosticsManager != null) {
            diagnosticsManager.updateSource(state.getMutableNodeToBlockMap(), javaCode);
        }

        AbstractCodeBlock rootBlock = blockFactory.convert(
                javaCode,
                state.getMutableNodeToBlockMap(),
                dragAndDropManager
        );

        // NEW: Restore breakpoints on newly created blocks
        for (CodeBlock block : state.getNodeToBlockMap().values()) {
            if (state.hasBreakpoint(block.getId())) {
                block.setBreakpoint(true);
            }
        }

        state.setCompilationUnit(blockFactory.getCompilationUnit());

        eventBus.publish(new CoreApplicationEvents.UIBlocksUpdatedEvent(rootBlock));
        eventBus.publish(new CoreApplicationEvents.StatusMessageEvent("Loaded: " + state.getActiveFile().getClassName()));
    }

    public CompletionContext createCompletionContext() {
        return new CompletionContext(
                codeEditor,
                languageServerService.getServer(),
                state.getDocUri(),
                state.getCurrentCode(),
                state.getDocVersion(),
                dragAndDropManager,
                state // Pass the state instance
        );
    }

    public CodeEditor getCodeEditor() { return codeEditor; }
    public BlockFactory getBlockFactory() { return blockFactory; }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/services/DebuggingService.java
=================================================================================

package com.botmaker.services;

import com.botmaker.config.ApplicationConfig;
import com.botmaker.config.Constants;
import com.botmaker.core.CodeBlock;
import com.botmaker.core.StatementBlock;
import com.botmaker.events.CoreApplicationEvents;
import com.botmaker.events.EventBus;
import com.botmaker.parser.BlockFactory;
import com.botmaker.runtime.CodeExecutionService;
import com.botmaker.state.ApplicationState;
import com.sun.jdi.*;
import com.sun.jdi.connect.AttachingConnector;
import com.sun.jdi.connect.Connector;
import com.sun.jdi.event.*;
import com.sun.jdi.request.BreakpointRequest;
import com.sun.jdi.request.ClassPrepareRequest;
import com.sun.jdi.request.EventRequestManager;
import com.sun.jdi.request.StepRequest;
import javafx.application.Platform;
import org.eclipse.jdt.core.dom.CompilationUnit;

import java.io.IOException;
import java.io.InputStream;
import java.net.ServerSocket;
import java.util.*;
import java.util.concurrent.CountDownLatch;

/**
 * Handles the entire debugging lifecycle:
 * 1. Mapping AST nodes to line numbers.
 * 2. Launching the JVM in debug mode.
 * 3. Attaching via JDI (Java Debug Interface).
 * 4. Managing Breakpoints, Stepping, and Resuming.
 */
public class DebuggingService {

    // Console Coloring for internal logs
    private static final String ANSI_RESET = "\u001B[0m";
    private static final String ANSI_BLUE = "\u001B[34m";
    private static final String ANSI_GREEN = "\u001B[32m";
    private static final String ANSI_RED = "\u001B[31m";

    private final ApplicationState state;
    private final EventBus eventBus;
    private final CodeExecutionService codeExecutionService;
    private final BlockFactory factory;
    private final ApplicationConfig config;

    // Debug Session State
    private volatile Process currentProcess;
    private VirtualMachine vm;
    private ThreadReference currentDebugThread;
    private Map<Integer, CodeBlock> lineToBlockMap;

    public DebuggingService(
            ApplicationState state,
            EventBus eventBus,
            CodeExecutionService codeExecutionService,
            BlockFactory factory,
            ApplicationConfig config) {
        this.state = state;
        this.eventBus = eventBus;
        this.codeExecutionService = codeExecutionService;
        this.factory = factory;
        this.config = config;

        setupEventHandlers();
    }

    private void setupEventHandlers() {
        eventBus.subscribe(CoreApplicationEvents.DebugStartRequestedEvent.class, e -> startDebugging(), false);
        eventBus.subscribe(CoreApplicationEvents.DebugStepOverRequestedEvent.class, e -> stepOver(), false);
        eventBus.subscribe(CoreApplicationEvents.DebugContinueRequestedEvent.class, e -> continueExecution(), false);
        eventBus.subscribe(CoreApplicationEvents.DebugStopRequestedEvent.class, e -> stopDebugging(), false);
    }

    /**
     * Kicks off the debugging session on a separate thread.
     */
    public void startDebugging() {
        new Thread(() -> {
            try {
                String code = state.getCurrentCode();

                // 1. Compile
                // FIXED: Removed config.getSourceFilePath() argument to match new signature
                if (!codeExecutionService.compileAndWait(code, config.getCompiledOutputPath())) {
                    eventBus.publish(new CoreApplicationEvents.StatusMessageEvent("Debug aborted due to compilation failure."));
                    return;
                }

                // 2. Map Breakpoints (AST -> Line Numbers)
                CompilationUnit cu = factory.getCompilationUnit();
                // Note: getNodeToBlockMap only refers to the ACTIVE file.
                // Multi-file debugging requires mapping logic expansion, but this works for the active file.
                if (cu == null || state.getNodeToBlockMap().isEmpty()) {
                    eventBus.publish(new CoreApplicationEvents.StatusMessageEvent("Error: Could not parse code to get breakpoints."));
                    return;
                }

                this.lineToBlockMap = new HashMap<>();
                List<Integer> activeBreakpointLines = new ArrayList<>();

                for (CodeBlock block : state.getNodeToBlockMap().values()) {
                    int line = block.getBreakpointLine(cu);
                    if (line > 0) {
                        // Only map StatementBlocks (executable lines)
                        if (!lineToBlockMap.containsKey(line) || block instanceof StatementBlock) {
                            lineToBlockMap.put(line, block);
                        }
                        if (block.isBreakpoint()) {
                            activeBreakpointLines.add(line);
                        }
                    }
                }

                // If no breakpoints, add one at start so it doesn't just run to finish immediately
                if (activeBreakpointLines.isEmpty() && !lineToBlockMap.isEmpty()) {
                    lineToBlockMap.keySet().stream().min(Integer::compareTo).ifPresent(firstLine -> {
                        activeBreakpointLines.add(firstLine);
                        eventBus.publish(new CoreApplicationEvents.StatusMessageEvent("No breakpoints set. Pausing at start (Line " + firstLine + ")."));
                    });
                }

                // 3. Find Free Port
                int freePort;
                try (ServerSocket socket = new ServerSocket(0)) {
                    freePort = socket.getLocalPort();
                }

                // 4. Launch Target Process
                eventBus.publish(new CoreApplicationEvents.StatusMessageEvent("Starting debugger on port " + freePort + "..."));
                eventBus.publish(new CoreApplicationEvents.DebugSessionStartedEvent());
                Platform.runLater(() -> eventBus.publish(new CoreApplicationEvents.OutputClearedEvent()));

                String classPath = config.getCompiledOutputPath().toString();
                // We debug the Main class defined in config
                String className = config.getMainClassName();
                String javaExecutable = config.getJavaExecutable();

                // Suspend=y waits for us to attach before running main()
                String debugAgent = String.format("-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=%d", freePort);

                ProcessBuilder pb = new ProcessBuilder(javaExecutable, debugAgent, "-cp", classPath, className);
                this.currentProcess = pb.start();

                // Redirect output to UI
                redirectStream(currentProcess.getInputStream());
                redirectStream(currentProcess.getErrorStream());

                // 5. Attach JDI
                attachJdi(className, freePort, activeBreakpointLines);

            } catch (Exception e) {
                eventBus.publish(new CoreApplicationEvents.StatusMessageEvent("Debugger Error: " + e.getMessage()));
                e.printStackTrace();
                stopDebugging(); // Cleanup if fail
            }
        }).start();
    }

    /**
     * Connects the JDI VirtualMachine to the running process.
     */
    private void attachJdi(String mainClassName, int port, List<Integer> breakpointLines) throws Exception {
        VirtualMachineManager vmMgr = Bootstrap.virtualMachineManager();
        AttachingConnector connector = vmMgr.attachingConnectors().stream()
                .filter(c -> c.transport().name().equals("dt_socket"))
                .findFirst()
                .orElseThrow(() -> new RuntimeException("Socket attaching connector not found"));

        Map<String, Connector.Argument> arguments = connector.defaultArguments();
        arguments.get("port").setValue(String.valueOf(port));
        arguments.get("hostname").setValue("localhost");

        // Retry logic for connection
        int maxRetries = Constants.DEBUGGER_MAX_CONNECT_RETRIES;
        for (int i = 0; i < maxRetries; i++) {
            try {
                vm = connector.attach(arguments);
                System.out.println(ANSI_BLUE + "Attached to VM: " + vm.name() + ANSI_RESET);
                break;
            } catch (IOException e) {
                if (i == maxRetries - 1) throw e;
                Thread.sleep(Constants.DEBUGGER_RETRY_DELAY_MS);
            }
        }

        EventRequestManager erm = vm.eventRequestManager();

        // Handle Breakpoints
        List<ReferenceType> classes = vm.classesByName(mainClassName);
        if (!classes.isEmpty()) {
            applyBreakpointsToClass(classes.get(0), breakpointLines);
        } else {
            ClassPrepareRequest classPrepareRequest = erm.createClassPrepareRequest();
            classPrepareRequest.addClassFilter(mainClassName);
            classPrepareRequest.enable();
        }

        // Start Event Loop
        CountDownLatch listenerReadyLatch = new CountDownLatch(1);
        new Thread(() -> jdiEventLoop(listenerReadyLatch, mainClassName, breakpointLines)).start();

        listenerReadyLatch.await();
        vm.resume();
    }

    private void jdiEventLoop(CountDownLatch listenerReadyLatch, String mainClassName, List<Integer> breakpointLines) {
        EventQueue eventQueue = vm.eventQueue();
        listenerReadyLatch.countDown();

        while (true) {
            try {
                EventSet eventSet = eventQueue.remove();
                boolean shouldResume = true;

                for (Event event : eventSet) {
                    if (event instanceof VMDisconnectEvent) {
                        handleDisconnect();
                        return;
                    }

                    if (event instanceof ClassPrepareEvent) {
                        ClassPrepareEvent cpe = (ClassPrepareEvent) event;
                        if (cpe.referenceType().name().equals(mainClassName)) {
                            applyBreakpointsToClass(cpe.referenceType(), breakpointLines);
                        }
                    }
                    else if (event instanceof LocatableEvent) {
                        handleLocatableEvent((LocatableEvent) event);
                        shouldResume = false;
                    }
                }

                if (shouldResume) {
                    eventSet.resume();
                }
            } catch (InterruptedException | VMDisconnectedException e) {
                handleDisconnect();
                return;
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }

    private void applyBreakpointsToClass(ReferenceType refType, List<Integer> lines) {
        if (lines == null || lines.isEmpty()) return;
        try {
            EventRequestManager erm = vm.eventRequestManager();
            for (int lineNumber : lines) {
                List<Location> locations = refType.locationsOfLine(lineNumber);
                if (!locations.isEmpty()) {
                    BreakpointRequest bpReq = erm.createBreakpointRequest(locations.get(0));
                    bpReq.enable();
                }
            }
        } catch (AbsentInformationException e) {
            System.err.println("No debug info available (compiled without -g?).");
        }
    }

    private void handleLocatableEvent(LocatableEvent event) {
        this.currentDebugThread = event.thread();

        if (event instanceof StepEvent) {
            vm.eventRequestManager().deleteEventRequest(event.request());
        }

        int lineNumber = event.location().lineNumber();
        CodeBlock block = lineToBlockMap.get(lineNumber);
        CodeBlock target = (block != null) ? block.getHighlightTarget() : null;

        eventBus.publish(new CoreApplicationEvents.DebugSessionPausedEvent(lineNumber, target));
        eventBus.publish(new CoreApplicationEvents.BlockHighlightEvent(target));
        eventBus.publish(new CoreApplicationEvents.StatusMessageEvent("Paused at line: " + lineNumber));
    }

    private void handleDisconnect() {
        this.currentDebugThread = null;
        this.vm = null;
        this.currentProcess = null;

        eventBus.publish(new CoreApplicationEvents.DebugSessionFinishedEvent());
        eventBus.publish(new CoreApplicationEvents.StatusMessageEvent("Debug session finished."));
        eventBus.publish(new CoreApplicationEvents.BlockHighlightEvent(null));
    }

    public void stepOver() {
        if (vm == null || currentDebugThread == null) return;
        try {
            eventBus.publish(new CoreApplicationEvents.DebugSessionResumedEvent());
            EventRequestManager erm = vm.eventRequestManager();

            erm.stepRequests().stream()
                    .filter(r -> r.thread().equals(currentDebugThread))
                    .forEach(erm::deleteEventRequest);

            StepRequest request = erm.createStepRequest(currentDebugThread, StepRequest.STEP_LINE, StepRequest.STEP_OVER);
            request.addCountFilter(1);
            request.enable();

            vm.resume();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public void continueExecution() {
        if (vm != null) {
            eventBus.publish(new CoreApplicationEvents.DebugSessionResumedEvent());
            vm.resume();
        }
    }

    public void stopDebugging() {
        if (vm != null) {
            try {
                vm.dispose();
            } catch (VMDisconnectedException ignored) {
            } catch (Exception e) { e.printStackTrace(); }
        }

        if (currentProcess != null && currentProcess.isAlive()) {
            try {
                currentProcess.destroyForcibly();
                eventBus.publish(new CoreApplicationEvents.StatusMessageEvent("Debug process terminated."));
            } catch (Exception e) { e.printStackTrace(); }
        }

        handleDisconnect();
    }

    private void redirectStream(InputStream stream) {
        new Thread(() -> {
            try (Scanner s = new Scanner(stream)) {
                while (s.hasNextLine()) {
                    String line = s.nextLine();
                    Platform.runLater(() -> eventBus.publish(new CoreApplicationEvents.OutputAppendedEvent(line + "\n")));
                }
            }
        }).start();
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/services/ExecutionService.java
=================================================================================

package com.botmaker.services;

import com.botmaker.config.ApplicationConfig;
import com.botmaker.events.CoreApplicationEvents;
import com.botmaker.events.EventBus;
import com.botmaker.runtime.CodeExecutionService;
import com.botmaker.state.ApplicationState;

/**
 * Service wrapper for code execution (compilation and running).
 * Bridges between the event system and the existing CodeExecutionService.
 */
public class ExecutionService {

    private final ApplicationConfig config;
    private final ApplicationState state;
    private final EventBus eventBus;
    private final CodeExecutionService codeExecutionService;
    private final com.botmaker.validation.DiagnosticsManager diagnosticsManager;

    public ExecutionService(
            ApplicationConfig config,
            ApplicationState state,
            EventBus eventBus,
            CodeExecutionService codeExecutionService,
            com.botmaker.validation.DiagnosticsManager diagnosticsManager) {

        this.config = config;
        this.state = state;
        this.eventBus = eventBus;
        this.codeExecutionService = codeExecutionService;
        this.diagnosticsManager = diagnosticsManager;

        setupEventHandlers();
    }

    private void setupEventHandlers() {
        // Subscribe to compilation requests
        eventBus.subscribe(
                CoreApplicationEvents.CompilationRequestedEvent.class,
                event -> compile(),
                false
        );

        // Subscribe to execution requests
        eventBus.subscribe(
                CoreApplicationEvents.ExecutionRequestedEvent.class,
                event -> run(),
                false
        );

        // NEW: Subscribe to stop run requests
        eventBus.subscribe(
                CoreApplicationEvents.StopRunRequestedEvent.class,
                event -> stopRun(),
                false
        );
    }

    /**
     * Compiles the current code
     */
    public void compile() {
        codeExecutionService.compileCode(state.getCurrentCode());
    }

    /**
     * Runs the current code
     */
    public void run() {
        // 1. UI Updates to RUNNING state
        eventBus.publish(new CoreApplicationEvents.ProgramStartedEvent());

        // 2. Thread Starts
        new Thread(() -> {
            // 3. Blocks here while program runs
            codeExecutionService.runCode(state.getCurrentCode());

            // 4. Program finishes/dies, then UI Updates to IDLE state
            eventBus.publish(new CoreApplicationEvents.ProgramStoppedEvent());
        }).start();
    }

    /**
     * NEW: Stops the currently running program
     */
    public void stopRun() {
        codeExecutionService.stopRunningProgram();
        eventBus.publish(new CoreApplicationEvents.ProgramStoppedEvent());
    }

    /**
     * Get the underlying code execution service
     */
    public CodeExecutionService getCodeExecutionService() {
        return codeExecutionService;
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/services/LanguageServerService.java
=================================================================================

package com.botmaker.services;

import com.botmaker.config.ApplicationConfig;
import com.botmaker.config.Constants;
import com.botmaker.events.CoreApplicationEvents;
import com.botmaker.events.EventBus;
import com.botmaker.lsp.JdtLanguageServerLauncher;
import com.botmaker.state.ApplicationState;
import javafx.application.Platform;
import org.eclipse.lsp4j.*;
import org.eclipse.lsp4j.services.LanguageServer;

import java.nio.file.Files;
import java.nio.file.Path;
import java.util.List;

public class LanguageServerService {

    private final ApplicationConfig config;
    private final ApplicationState state;
    private final EventBus eventBus;
    private final com.botmaker.validation.DiagnosticsManager diagnosticsManager;

    private LanguageServer server;
    private JdtLanguageServerLauncher launcher;

    // New flag
    private boolean shouldClearCache = false;

    public LanguageServerService(
            ApplicationConfig config,
            ApplicationState state,
            EventBus eventBus,
            com.botmaker.validation.DiagnosticsManager diagnosticsManager) {
        this.config = config;
        this.state = state;
        this.eventBus = eventBus;
        this.diagnosticsManager = diagnosticsManager;

        setupEventHandlers();
    }

    public void setShouldClearCache(boolean shouldClear) {
        this.shouldClearCache = shouldClear;
    }

    private void setupEventHandlers() {
        eventBus.subscribe(
                CoreApplicationEvents.CodeUpdatedEvent.class,
                this::handleCodeUpdate,
                false
        );
    }

    public void initialize() throws Exception {
        // NEW: Check if we need to clear cache
        if (shouldClearCache) {
            JdtLanguageServerLauncher.cleanupWorkspace(config.getWorkspaceDataPath());
        }

        launcher = new JdtLanguageServerLauncher(
                config.getJdtServerPath(),
                config.getProjectPath(),
                config.getWorkspaceDataPath(),
                (PublishDiagnosticsParams params) -> {
                    Platform.runLater(() -> {
                        List<Diagnostic> diagnostics = params.getDiagnostics();
                        eventBus.publish(new CoreApplicationEvents.DiagnosticsUpdatedEvent(diagnostics));
                    });
                }
        );

        // ... rest of the file stays the same ...
        server = launcher.getServer();

        Path docPath = config.getSourceFilePath().toAbsolutePath().normalize();

        // Ensure the file exists
        if (!Files.exists(docPath)) {
            Files.createDirectories(docPath.getParent());

            // Extract project name and package from main class name
            String mainClassName = config.getMainClassName();
            String[] parts = mainClassName.split("\\.");
            String packageName = parts.length > 1 ? String.join(".", java.util.Arrays.copyOf(parts, parts.length - 1)) : "com.demo";
            String className = parts[parts.length - 1];

            // Create a default file with correct package and class name
            String defaultCode = String.format("""
            package %s;
            public class %s {
                public static void main(String[] args) {
                    System.out.println("Hello from %s!");
                }
            }
            """, packageName, className, className);
            Files.writeString(docPath, defaultCode);
        }

        String docUri = docPath.toUri().toString();
        String currentCode = Files.readString(docPath);

        state.setDocUri(docUri);
        state.setCurrentCode(currentCode);
        state.setDocVersion(1);

        server.getTextDocumentService().didOpen(new DidOpenTextDocumentParams(
                new TextDocumentItem(docUri, "java", (int) state.getDocVersion(), currentCode)
        ));
    }

    // ... shutdown/handlers stay same ...
    private void handleCodeUpdate(CoreApplicationEvents.CodeUpdatedEvent event) {
        try {
            // Write to file
            Path docPath = Path.of(new java.net.URI(state.getDocUri()));
            Files.writeString(docPath, event.getNewCode());

            // Update state
            state.incrementDocVersion();
            state.setCurrentCode(event.getNewCode());

            // Notify LSP server
            server.getTextDocumentService().didChange(new DidChangeTextDocumentParams(
                    new VersionedTextDocumentIdentifier(state.getDocUri(), (int) state.getDocVersion()),
                    List.of(new TextDocumentContentChangeEvent(event.getNewCode()))
            ));

            eventBus.publish(new CoreApplicationEvents.UIRefreshRequestedEvent(event.getNewCode()));

        } catch (Exception e) {
            e.printStackTrace();
            eventBus.publish(new CoreApplicationEvents.StatusMessageEvent(
                    "Error saving file: " + e.getMessage()
            ));
        }
    }

    public void openFile(Path path, String content) {
        if (server == null) return;
        String uri = path.toUri().toString();
        server.getTextDocumentService().didOpen(new DidOpenTextDocumentParams(
                new TextDocumentItem(uri, "java", 1, content)
        ));
    }

    public void shutdown() {
        if (launcher != null) {
            try {
                System.out.println("Requesting server shutdown...");
                if (server != null) {
                    server.shutdown().get(Constants.DEBUGGER_SHUTDOWN_TIMEOUT_SECONDS, java.util.concurrent.TimeUnit.SECONDS);
                    server.exit();
                }
                Thread.sleep(Constants.SHORT_SLEEP_MS);
            } catch (java.util.concurrent.TimeoutException e) {
                System.err.println("Server shutdown timed out, forcing stop...");
            } catch (Exception e) {
                System.err.println("Error during server shutdown: " + e.getMessage());
            } finally {
                launcher.stop();
            }
        }
    }

    public LanguageServer getServer() {
        return server;
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/state/ApplicationState.java
=================================================================================

package com.botmaker.state;

import com.botmaker.core.CodeBlock;
import com.botmaker.project.ProjectFile;
import org.eclipse.jdt.core.dom.ASTNode;
import org.eclipse.jdt.core.dom.CompilationUnit;

import java.nio.file.Path;
import java.util.*;

public class ApplicationState {

    // Multi-file state
    private final Map<Path, ProjectFile> openFiles = new HashMap<>();
    private ProjectFile activeFile;

    // AST and block mappings (For the ACTIVE file)
    private Map<ASTNode, CodeBlock> nodeToBlockMap = new HashMap<>();

    // UI state
    private CodeBlock highlightedBlock;
    private boolean isDebugging;
    private final Set<String> breakpointIds = new HashSet<>();
    private long docVersion = 1;

    // --- File Management ---

    public void addFile(ProjectFile file) {
        openFiles.put(file.getPath(), file);
    }

    public void setActiveFile(Path path) {
        this.activeFile = openFiles.get(path);
        // Reset or sync doc version when switching if necessary,
        // though usually we track version per file.
        // For now, we keep a global version counter for LSP sync simplicity.
    }

    public ProjectFile getActiveFile() {
        return activeFile;
    }

    public Collection<ProjectFile> getAllFiles() {
        return Collections.unmodifiableCollection(openFiles.values());
    }

    // --- Helpers (Delegate to Active File) ---

    public String getCurrentCode() {
        return activeFile != null ? activeFile.getContent() : "";
    }

    public void setCurrentCode(String code) {
        if (activeFile != null) activeFile.setContent(code);
    }

    public String getDocUri() {
        return activeFile != null ? activeFile.getUri() : "";
    }

    /**
     * Set Doc URI.
     * Note: In multi-file mode, the URI is derived from the ProjectFile path.
     * This method exists for backward compatibility with LanguageServerService.
     */
    public void setDocUri(String docUri) {
        // No-op: The URI is determined by the active file's path.
        // We accept the call to satisfy the compiler, but rely on setActiveFile() being called previously.
    }

    public Optional<CompilationUnit> getCompilationUnit() {
        return activeFile != null ? Optional.ofNullable(activeFile.getAst()) : Optional.empty();
    }

    public void setCompilationUnit(CompilationUnit cu) {
        if (activeFile != null) activeFile.setAst(cu);
    }

    // --- Versioning ---

    public long getDocVersion() {
        return docVersion;
    }

    public void setDocVersion(long version) {
        this.docVersion = version;
    }

    public void incrementDocVersion() {
        this.docVersion++;
    }

    // --- Mappings & UI State ---

    public Map<ASTNode, CodeBlock> getNodeToBlockMap() {
        return Collections.unmodifiableMap(nodeToBlockMap);
    }

    public Map<ASTNode, CodeBlock> getMutableNodeToBlockMap() {
        return nodeToBlockMap;
    }

    public void setNodeToBlockMap(Map<ASTNode, CodeBlock> nodeToBlockMap) {
        this.nodeToBlockMap = nodeToBlockMap != null ?
                new HashMap<>(nodeToBlockMap) : new HashMap<>();
    }

    public void clearNodeToBlockMap() {
        this.nodeToBlockMap.clear();
    }

    public Optional<CodeBlock> getBlockForNode(ASTNode node) {
        return Optional.ofNullable(nodeToBlockMap.get(node));
    }

    public Optional<CodeBlock> getHighlightedBlock() {
        return Optional.ofNullable(highlightedBlock);
    }

    public void setHighlightedBlock(CodeBlock block) {
        if (this.highlightedBlock != null) {
            this.highlightedBlock.unhighlight();
        }
        this.highlightedBlock = block;
        if (this.highlightedBlock != null) {
            this.highlightedBlock.highlight();
        }
    }

    public void clearHighlight() {
        setHighlightedBlock(null);
    }

    // --- Debugging ---

    public boolean isDebugging() {
        return isDebugging;
    }

    public void setDebugging(boolean debugging) {
        this.isDebugging = debugging;
    }

    public Set<String> getBreakpointIds() {
        return Collections.unmodifiableSet(breakpointIds);
    }

    public void addBreakpoint(String blockId) {
        breakpointIds.add(blockId);
    }

    public void removeBreakpoint(String blockId) {
        breakpointIds.remove(blockId);
    }

    public boolean hasBreakpoint(String blockId) {
        return breakpointIds.contains(blockId);
    }

    /**
     * Snapshot for debugging/logging
     */
    public StateSnapshot createSnapshot() {
        return new StateSnapshot(
                getCurrentCode(),
                getDocUri(),
                docVersion,
                nodeToBlockMap.size(),
                highlightedBlock != null,
                isDebugging
        );
    }

    public static class StateSnapshot {
        public final String currentCode;
        public final String docUri;
        public final long docVersion;
        public final int blockCount;
        public final boolean hasHighlight;
        public final boolean isDebugging;

        private StateSnapshot(String currentCode, String docUri, long docVersion,
                              int blockCount, boolean hasHighlight, boolean isDebugging) {
            this.currentCode = currentCode;
            this.docUri = docUri;
            this.docVersion = docVersion;
            this.blockCount = blockCount;
            this.hasHighlight = hasHighlight;
            this.isDebugging = isDebugging;
        }

        @Override
        public String toString() {
            return String.format(
                    "StateSnapshot{docVersion=%d, codeLength=%d, blockCount=%d, hasHighlight=%s, isDebugging=%s}",
                    docVersion, currentCode != null ? currentCode.length() : 0, blockCount, hasHighlight, isDebugging
            );
        }
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/state/HistoryManager.java
=================================================================================

package com.botmaker.state;

import java.util.Stack;

public class HistoryManager {

    private final Stack<String> undoStack = new Stack<>();
    private final Stack<String> redoStack = new Stack<>();
    private static final int MAX_HISTORY_SIZE = 50; // Limit memory usage

    /**
     * Saves a snapshot of the code.
     * Call this BEFORE applying a new change.
     */
    public void pushState(String code) {
        // Avoid saving duplicates (e.g. if multiple events fire for same code)
        if (!undoStack.isEmpty() && undoStack.peek().equals(code)) {
            return;
        }

        undoStack.push(code);

        // Enforce size limit
        if (undoStack.size() > MAX_HISTORY_SIZE) {
            undoStack.remove(0);
        }

        // New change clears the redo future
        redoStack.clear();
    }

    public boolean canUndo() { return !undoStack.isEmpty(); }
    public boolean canRedo() { return !redoStack.isEmpty(); }

    public String undo(String currentCode) {
        if (!canUndo()) return currentCode;

        // Save current state to Redo stack
        redoStack.push(currentCode);

        // Return previous state
        return undoStack.pop();
    }

    public String redo(String currentCode) {
        if (!canRedo()) return currentCode;

        // Save current state to Undo stack
        undoStack.push(currentCode);

        // Return future state
        return redoStack.pop();
    }

    public void clear() {
        undoStack.clear();
        redoStack.clear();
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/ui/AddableBlock.java
=================================================================================

package com.botmaker.ui;

import com.botmaker.blocks.*;
import com.botmaker.core.StatementBlock;

public enum AddableBlock {
    // --- OUTPUT ---
    PRINT("Print", PrintBlock.class, BlockCategory.OUTPUT),

    // --- FLOW CONTROL ---
    IF("If Statement", IfBlock.class, BlockCategory.FLOW),
    WHILE("While Loop", WhileBlock.class, BlockCategory.LOOPS),
    FOR("For Each Loop", ForBlock.class, BlockCategory.LOOPS),
    DO_WHILE("Do While", DoWhileBlock.class, BlockCategory.LOOPS),
    SWITCH("Switch", SwitchBlock.class, BlockCategory.FLOW),
    CASE("Case", SwitchBlock.SwitchCaseBlock.class, BlockCategory.FLOW),
    FUNCTION_CALL("Call Function", MethodInvocationBlock.class, BlockCategory.FLOW),
    // --- CONTROL COMMANDS ---
    BREAK("Break", BreakBlock.class, BlockCategory.CONTROL),
    CONTINUE("Continue", ContinueBlock.class, BlockCategory.CONTROL),
    RETURN("Return", ReturnBlock.class, BlockCategory.CONTROL),
    WAIT("Wait (ms)", WaitBlock.class, BlockCategory.CONTROL),

    // --- VARIABLES ---
    DECLARE_INT("Int Variable", VariableDeclarationBlock.class, BlockCategory.VARIABLES),
    DECLARE_DOUBLE("Double Variable", VariableDeclarationBlock.class, BlockCategory.VARIABLES),
    DECLARE_BOOLEAN("Bool Variable", VariableDeclarationBlock.class, BlockCategory.VARIABLES),
    DECLARE_STRING("String Variable", VariableDeclarationBlock.class, BlockCategory.VARIABLES),

    // NEW: Generic Array Declaration
    DECLARE_ARRAY("Create List", VariableDeclarationBlock.class, BlockCategory.VARIABLES),

    ASSIGNMENT("Set Variable", AssignmentBlock.class, BlockCategory.VARIABLES),

    // --- INPUT ---
    READ_LINE("Read Text", ReadInputBlock.class, BlockCategory.INPUT),
    READ_INT("Read Int", ReadInputBlock.class, BlockCategory.INPUT),
    READ_DOUBLE("Read Double", ReadInputBlock.class, BlockCategory.INPUT),

    // --- UTILITY ---
    COMMENT("Comment", CommentBlock.class, BlockCategory.UTILITY);


    private final String displayName;
    private final Class<? extends StatementBlock> blockClass;
    private final BlockCategory category;

    AddableBlock(String displayName, Class<? extends StatementBlock> blockClass, BlockCategory category) {
        this.displayName = displayName;
        this.blockClass = blockClass;
        this.category = category;
    }

    public String getDisplayName() { return displayName; }
    public Class<? extends StatementBlock> getBlockClass() { return blockClass; }
    public BlockCategory getCategory() { return category; }

    public enum BlockCategory {
        OUTPUT("Output"),
        INPUT("Input"),
        VARIABLES("Variables"),
        FLOW("Logic"),
        LOOPS("Loops"),
        CONTROL("Control"),
        UTILITY("Utility");

        private final String label;
        BlockCategory(String label) { this.label = label; }
        public String getLabel() { return label; }
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/ui/AddableExpression.java
=================================================================================

package com.botmaker.ui;

import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

public enum AddableExpression {
    // Literals
    TEXT("Text", "String"),
    NUMBER("Number", "number"),
    TRUE("True", "boolean"),
    FALSE("False", "boolean"),
    VARIABLE("Variable", "any"),

    // NEW: Function Call
    FUNCTION_CALL("Function Call", "any"), // Can return anything

    // Nested
    LIST("Sub-List", "list"),

    // Math Operations
    ADD("Addition (+)", "+", "number"),
    SUBTRACT("Subtraction (-)", "-", "number"),
    MULTIPLY("Multiplication (*)", "*", "number"),
    DIVIDE("Division (/)", "/", "number"),
    MODULO("Modulo (%)", "%", "number");

    private final String displayName;
    private final String operator;
    private final String returnType;

    AddableExpression(String displayName, String returnType) {
        this(displayName, null, returnType);
    }

    AddableExpression(String displayName, String operator, String returnType) {
        this.displayName = displayName;
        this.operator = operator;
        this.returnType = returnType;
    }

    public String getDisplayName() { return displayName; }
    public String getOperator() { return operator; }

    public static List<AddableExpression> getForType(String targetType) {
        if (targetType == null || targetType.equals("any")) {
            return Arrays.asList(values());
        }
        return Arrays.stream(values())
                .filter(e -> {
                    if (e.returnType.equals("any")) return true;
                    return e.returnType.equals(targetType);
                })
                .collect(Collectors.toList());
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/ui/BlockDragAndDropManager.java
=================================================================================

package com.botmaker.ui;

import com.botmaker.core.BodyBlock;
import com.botmaker.core.StatementBlock;
import javafx.scene.Node;
import javafx.scene.input.ClipboardContent;
import javafx.scene.input.DataFormat;
import javafx.scene.input.Dragboard;
import javafx.scene.input.TransferMode;
import javafx.scene.layout.Region;

import java.util.function.Consumer;

public class BlockDragAndDropManager {

    public static final DataFormat ADDABLE_BLOCK_FORMAT = new DataFormat("application/x-java-addable-block");
    public static final DataFormat EXISTING_BLOCK_FORMAT = new DataFormat("application/x-java-existing-block");

    // Callbacks
    private Consumer<DropInfo> onDrop;
    private Consumer<MoveBlockInfo> onBlockMove;

    public BlockDragAndDropManager(Consumer<DropInfo> onDrop) {
        this.onDrop = onDrop;
    }

    public void setCallback(Consumer<DropInfo> onDrop) {
        this.onDrop = onDrop;
    }

    public void setMoveCallback(Consumer<MoveBlockInfo> onBlockMove) {
        this.onBlockMove = onBlockMove;
    }

    /**
     * Makes a UI node draggable, associating it with a specific type of AddableBlock.
     * @param node The node to make draggable (e.g., a Label in the palette).
     * @param blockType The type of block this node represents.
     */
    public void makeDraggable(Node node, AddableBlock blockType) {
        node.setOnDragDetected(event -> {
            Dragboard db = node.startDragAndDrop(TransferMode.COPY);
            ClipboardContent content = new ClipboardContent();
            content.put(ADDABLE_BLOCK_FORMAT, blockType.name());
            db.setContent(content);
            System.out.println("Drag detected for: " + blockType.name());
            event.consume();
        });
    }

    /**
     * Makes an existing block's UI node draggable for repositioning.
     * @param node The UI node of the block to make draggable.
     * @param block The StatementBlock instance being dragged.
     * @param sourceBody The BodyBlock containing this block.
     */
    public void makeBlockMovable(Node node, StatementBlock block, BodyBlock sourceBody) {
        node.setOnDragDetected(event -> {
            // Only start drag if not clicking on interactive elements
            if (event.getTarget() instanceof javafx.scene.control.Control) {
                return;
            }

            Dragboard db = node.startDragAndDrop(TransferMode.MOVE);
            ClipboardContent content = new ClipboardContent();
            content.put(EXISTING_BLOCK_FORMAT, block.getId());
            db.setContent(content);

            // Visual feedback - make the block semi-transparent while dragging
            node.setOpacity(0.5);

            System.out.println("Dragging existing block: " + block.getDetails());
            event.consume();
        });

        // Reset opacity and release focus when drag is done
        node.setOnDragDone(event -> {
            node.setOpacity(1.0);
            // DON'T consume - let the event propagate to restore normal mouse behavior
            // event.consume();

            // Multiple approaches to ensure drag is fully released
            javafx.application.Platform.runLater(() -> {
                // 1. Find and focus ScrollPane
                javafx.scene.Node current = node;
                javafx.scene.control.ScrollPane scrollPane = null;
                while (current != null) {
                    if (current instanceof javafx.scene.control.ScrollPane) {
                        scrollPane = (javafx.scene.control.ScrollPane) current;
                        break;
                    }
                    current = current.getParent();
                }

                if (scrollPane != null) {
                    // Make sure ScrollPane can receive focus
                    scrollPane.setFocusTraversable(true);
                    scrollPane.requestFocus();

                    // Also try to release any event filters
                    final javafx.scene.control.ScrollPane sp = scrollPane;
                    javafx.application.Platform.runLater(() -> {
                        sp.requestFocus();
                    });
                }
            });
        });
    }

    /**
     * Creates a thin, transparent region to act as a separator and drop target.
     */
    public Region createSeparator() {
        Region separator = new Region();
        separator.setMinHeight(8);
        separator.setStyle("-fx-background-color: transparent;");
        return separator;
    }

    /**
     * Adds all necessary drag-and-drop event handlers to a separator region.
     * Handles both adding new blocks and moving existing blocks.
     * @param separator The region to add handlers to.
     * @param targetBody The body where blocks will be inserted.
     * @param insertionIndex The index in the list where a drop should occur.
     * @param adjacentBlock The block next to the separator, for context (can be null).
     */
    public void addSeparatorDragHandlers(Region separator, BodyBlock targetBody, int insertionIndex, StatementBlock adjacentBlock) {
        String defaultColor = "transparent";
        String hoverColor = "#007bff"; // A distinct blue
        String moveHoverColor = "#28a745"; // Green for moving blocks

        separator.setOnDragEntered(event -> {
            Dragboard db = event.getDragboard();
            if (db.hasContent(ADDABLE_BLOCK_FORMAT)) {
                separator.setStyle("-fx-background-color: " + hoverColor + ";");
                String logMessage = "Hovering insertion point at index: " + insertionIndex;
                if (adjacentBlock != null) {
                    logMessage += " (next to: " + adjacentBlock.getDetails() + ")";
                }
                System.out.println(logMessage);
            } else if (db.hasContent(EXISTING_BLOCK_FORMAT)) {
                separator.setStyle("-fx-background-color: " + moveHoverColor + ";");
                System.out.println("Hovering to move block at index: " + insertionIndex);
            }
            event.consume();
        });

        separator.setOnDragExited(event -> {
            separator.setStyle("-fx-background-color: " + defaultColor);
            event.consume();
        });

        separator.setOnDragOver(event -> {
            Dragboard db = event.getDragboard();
            if (db.hasContent(ADDABLE_BLOCK_FORMAT) || db.hasContent(EXISTING_BLOCK_FORMAT)) {
                event.acceptTransferModes(TransferMode.COPY_OR_MOVE);
            }
            event.consume();
        });

        separator.setOnDragDropped(event -> {
            Dragboard db = event.getDragboard();
            boolean success = false;

            if (db.hasContent(ADDABLE_BLOCK_FORMAT)) {
                // Adding a new block
                String blockTypeName = (String) db.getContent(ADDABLE_BLOCK_FORMAT);
                AddableBlock type = AddableBlock.valueOf(blockTypeName);

                if (onDrop != null) {
                    onDrop.accept(new DropInfo(type, targetBody, insertionIndex));
                    success = true;
                } else {
                    System.err.println("WARNING: onDrop callback not set yet!");
                }
            } else if (db.hasContent(EXISTING_BLOCK_FORMAT)) {
                // Moving an existing block
                String blockId = (String) db.getContent(EXISTING_BLOCK_FORMAT);

                if (onBlockMove != null) {
                    onBlockMove.accept(new MoveBlockInfo(blockId, targetBody, insertionIndex));
                    success = true;
                } else {
                    System.err.println("WARNING: onBlockMove callback not set yet!");
                }
            }

            event.setDropCompleted(success);
            event.consume();
        });
    }

    public void addEmptyBodyDropHandlers(Region target, BodyBlock targetBody) {
        target.setOnDragEntered(event -> {
            if (event.getDragboard().hasContent(ADDABLE_BLOCK_FORMAT) ||
                    event.getDragboard().hasContent(EXISTING_BLOCK_FORMAT)) {
                target.getStyleClass().add("empty-body-drop-hover");
                System.out.println("Added hover class to: " + target.getClass().getSimpleName());
            }
            event.consume();
        });

        target.setOnDragExited(event -> {
            target.getStyleClass().remove("empty-body-drop-hover");
            event.consume();
        });

        target.setOnDragOver(event -> {
            Dragboard db = event.getDragboard();
            if (db.hasContent(ADDABLE_BLOCK_FORMAT) || db.hasContent(EXISTING_BLOCK_FORMAT)) {
                event.acceptTransferModes(TransferMode.COPY_OR_MOVE);
            }
            event.consume();
        });

        target.setOnDragDropped(event -> {
            Dragboard db = event.getDragboard();
            boolean success = false;

            if (db.hasContent(ADDABLE_BLOCK_FORMAT)) {
                // Adding a new block
                String blockTypeName = (String) db.getContent(ADDABLE_BLOCK_FORMAT);
                AddableBlock type = AddableBlock.valueOf(blockTypeName);

                if (onDrop != null) {
                    onDrop.accept(new DropInfo(type, targetBody, 0)); // Always index 0 for empty body
                    success = true;
                } else {
                    System.err.println("WARNING: onDrop callback not set yet!");
                }
            } else if (db.hasContent(EXISTING_BLOCK_FORMAT)) {
                // Moving an existing block
                String blockId = (String) db.getContent(EXISTING_BLOCK_FORMAT);

                if (onBlockMove != null) {
                    onBlockMove.accept(new MoveBlockInfo(blockId, targetBody, 0));
                    success = true;
                } else {
                    System.err.println("WARNING: onBlockMove callback not set yet!");
                }
            }

            event.setDropCompleted(success);
            event.consume();
        });
    }

    public void addExpressionDropHandlers(Region target) {
        String defaultStyle = "-fx-background-color: #f0f0f0; -fx-border-color: #c0c0c0; -fx-border-style: dashed; -fx-min-width: 50; -fx-min-height: 25;";
        String hoverStyle = defaultStyle + "-fx-border-color: #007bff;"; // Highlight with blue

        target.setStyle(defaultStyle);

        target.setOnDragEntered(event -> {
            if (event.getDragboard().hasContent(ADDABLE_BLOCK_FORMAT)) {
                target.setStyle(hoverStyle);
                System.out.println("Hovering expression slot.");
            }
            event.consume();
        });

        target.setOnDragExited(event -> {
            target.setStyle(defaultStyle);
            event.consume();
        });

        target.setOnDragOver(event -> {
            if (event.getDragboard().hasContent(ADDABLE_BLOCK_FORMAT)) {
                event.acceptTransferModes(TransferMode.COPY);
            }
            event.consume();
        });

        target.setOnDragDropped(event -> {
            Dragboard db = event.getDragboard();
            boolean success = false;
            if (db.hasContent(ADDABLE_BLOCK_FORMAT)) {
                String blockTypeName = (String) db.getContent(ADDABLE_BLOCK_FORMAT);
                System.out.println("Cannot drop a Statement block ('" + blockTypeName + "') into an Expression slot.");
                success = true;
            }
            event.setDropCompleted(success);
            event.consume();
        });
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/ui/BlockEvent.java
=================================================================================

package com.botmaker.ui;

import com.botmaker.core.CodeBlock;
import javafx.event.Event;
import javafx.event.EventType;

public class BlockEvent extends Event {
    public static final EventType<BlockEvent> ANY = new EventType<>(Event.ANY, "BLOCK_EVENT");

    public BlockEvent(EventType<? extends Event> eventType) {
        super(eventType);
    }

    public static class BreakpointToggleEvent extends BlockEvent {
        public static final EventType<BreakpointToggleEvent> TOGGLE_BREAKPOINT = new EventType<>(ANY, "TOGGLE_BREAKPOINT");

        private final CodeBlock block;
        private final boolean isEnabled;

        public BreakpointToggleEvent(CodeBlock block, boolean isEnabled) {
            super(TOGGLE_BREAKPOINT);
            this.block = block;
            this.isEnabled = isEnabled;
        }

        public CodeBlock getBlock() { return block; }
        public boolean isEnabled() { return isEnabled; }
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/ui/DropInfo.java
=================================================================================

package com.botmaker.ui;

import com.botmaker.core.BodyBlock;

public record DropInfo(AddableBlock type, BodyBlock targetBody, int insertionIndex) {
}


=================================================================================
FILE: ./src/main/java/com/botmaker/ui/EventLogManager.java
=================================================================================

package com.botmaker.ui;

import com.botmaker.events.ApplicationEvent;
import com.botmaker.events.CoreApplicationEvents;
import com.botmaker.events.EventBus;
import javafx.application.Platform;
import javafx.scene.control.ListView;
import javafx.scene.control.SelectionMode;

import java.time.Instant;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

/**
 * Manages the Event Log pane.
 * Buffers events to prevent UI flooding and filters out high-frequency noise.
 */
public class EventLogManager {

    private final ListView<String> eventListView;
    private final ConcurrentLinkedQueue<String> pendingLogs = new ConcurrentLinkedQueue<>();
    private final ScheduledExecutorService uiUpdater;
    private final DateTimeFormatter timeFormatter = DateTimeFormatter.ofPattern("HH:mm:ss.SSS")
            .withZone(ZoneId.systemDefault());

    private static final int MAX_LOG_ENTRIES = 1000;
    private static final int UPDATE_INTERVAL_MS = 250; // Update UI max 4 times per second

    public EventLogManager(EventBus eventBus) {
        this.eventListView = new ListView<>();
        this.eventListView.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE);
        this.eventListView.getStyleClass().add("event-log-list");

        // Use a monospaced font style via CSS or inline for now
        this.eventListView.setStyle("-fx-font-family: 'Consolas', 'Monospaced'; -fx-font-size: 11px;");

        // Subscribe to everything
        eventBus.subscribeAll(this::handleEvent);

        // Start the UI update thread
        this.uiUpdater = Executors.newSingleThreadScheduledExecutor(r -> {
            Thread t = new Thread(r, "EventLog-Updater");
            t.setDaemon(true);
            return t;
        });

        startUiLoop();
    }

    public ListView<String> getView() {
        return eventListView;
    }

    private void handleEvent(ApplicationEvent event) {
        // 1. FILTERING: Ignore extremely frequent events that have their own displays
        if (event instanceof CoreApplicationEvents.OutputAppendedEvent) return;

        // Optional: Filter CodeUpdatedEvent if it's too noisy (happens on every keypress)
        // if (event instanceof CoreApplicationEvents.CodeUpdatedEvent) return;

        // 2. FORMATTING
        String timestamp = timeFormatter.format(Instant.ofEpochMilli(event.getTimestamp()));
        String eventName = event.getClass().getSimpleName();
        String source = event.getSource();

        String details = "";

        // Extract interesting details for specific events
        if (event instanceof CoreApplicationEvents.StatusMessageEvent) {
            details = ": " + ((CoreApplicationEvents.StatusMessageEvent) event).getMessage();
        } else if (event instanceof CoreApplicationEvents.DebugSessionPausedEvent) {
            details = " @ Line " + ((CoreApplicationEvents.DebugSessionPausedEvent) event).getLineNumber();
        } else if (event instanceof CoreApplicationEvents.BreakpointToggledEvent) {
            var bp = (CoreApplicationEvents.BreakpointToggledEvent) event;
            details = " (" + (bp.isEnabled() ? "ON" : "OFF") + ") ID: " + bp.getBlock().getId();
        }

        String logEntry = String.format("[%s] %-25s | %s%s", timestamp, eventName, source, details);

        // 3. QUEUING
        pendingLogs.offer(logEntry);
    }

    private void startUiLoop() {
        uiUpdater.scheduleAtFixedRate(() -> {
            if (pendingLogs.isEmpty()) return;

            // Drain the queue into a temporary list
            List<String> batch = new ArrayList<>();
            String log;
            while ((log = pendingLogs.poll()) != null) {
                batch.add(log);
            }

            if (!batch.isEmpty()) {
                Platform.runLater(() -> {
                    eventListView.getItems().addAll(batch);

                    // Prune old entries
                    if (eventListView.getItems().size() > MAX_LOG_ENTRIES) {
                        eventListView.getItems().remove(0, eventListView.getItems().size() - MAX_LOG_ENTRIES);
                    }

                    // Auto-scroll to bottom
                    eventListView.scrollTo(eventListView.getItems().size() - 1);
                });
            }
        }, UPDATE_INTERVAL_MS, UPDATE_INTERVAL_MS, TimeUnit.MILLISECONDS);
    }

    public void shutdown() {
        uiUpdater.shutdownNow();
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/ui/FileExplorerManager.java
=================================================================================

package com.botmaker.ui;

import com.botmaker.config.ApplicationConfig;
import com.botmaker.services.CodeEditorService;
import com.botmaker.state.ApplicationState;
import javafx.scene.control.*;
import javafx.scene.layout.VBox;

import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Optional;
import java.util.stream.Stream;

public class FileExplorerManager {

    private final ApplicationConfig config;
    private final CodeEditorService codeEditorService;
    private final ApplicationState state;
    private final TreeView<Path> fileTree;

    public FileExplorerManager(ApplicationConfig config, CodeEditorService codeEditorService, ApplicationState state) {
        this.config = config;
        this.codeEditorService = codeEditorService;
        this.state = state;
        this.fileTree = new TreeView<>();
    }

    public VBox createView() {
        VBox container = new VBox();
        container.getStyleClass().add("file-explorer");

        Label header = new Label("Project Files");
        header.getStyleClass().add("sidebar-header");

        Button newFileBtn = new Button("New Function Library");
        newFileBtn.setMaxWidth(Double.MAX_VALUE);
        newFileBtn.setOnAction(e -> showCreateFileDialog());

        configureTree();
        refreshTree();

        container.getChildren().addAll(header, newFileBtn, fileTree);
        return container;
    }

    private void configureTree() {
        fileTree.setShowRoot(false);
        fileTree.setCellFactory(tv -> new TreeCell<>() {
            @Override
            protected void updateItem(Path item, boolean empty) {
                super.updateItem(item, empty);
                if (empty || item == null) {
                    setText(null);
                } else {
                    setText(item.getFileName().toString());
                    // Highlight active file
                    if (state.getActiveFile() != null && item.equals(state.getActiveFile().getPath())) {
                        setStyle("-fx-font-weight: bold; -fx-text-fill: #007bff;");
                    } else {
                        setStyle("");
                    }
                }
            }
        });

        fileTree.getSelectionModel().selectedItemProperty().addListener((obs, oldVal, newVal) -> {
            if (newVal != null && newVal.getValue() != null) {
                // Switch file
                Path selectedPath = newVal.getValue();
                // Avoid reloading if already active
                if (state.getActiveFile() == null || !state.getActiveFile().getPath().equals(selectedPath)) {
                    codeEditorService.switchToFile(selectedPath);
                    fileTree.refresh(); // Update bold styling
                }
            }
        });
    }

    public void refreshTree() {
        // Find src directory
        Path sourceDir = config.getSourceFilePath().getParent();

        TreeItem<Path> root = new TreeItem<>(sourceDir);

        try (Stream<Path> files = Files.list(sourceDir)) {
            files.filter(p -> p.toString().endsWith(".java"))
                    .forEach(path -> root.getChildren().add(new TreeItem<>(path)));
        } catch (Exception e) {
            e.printStackTrace();
        }

        fileTree.setRoot(root);
    }

    private void showCreateFileDialog() {
        TextInputDialog dialog = new TextInputDialog();
        dialog.setTitle("New Function Library");
        dialog.setHeaderText("Create a new library of functions");
        dialog.setContentText("Name (e.g. Movement):");

        Optional<String> result = dialog.showAndWait();
        result.ifPresent(name -> {
            String className = name.trim().replaceAll("[^a-zA-Z0-9]", "");
            if (!className.isEmpty()) {
                codeEditorService.createFile(className);
                refreshTree();
            }
        });
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/ui/MenuBarManager.java
=================================================================================

package com.botmaker.ui;

import com.botmaker.events.CoreApplicationEvents;
import com.botmaker.events.EventBus;
import javafx.scene.control.Menu;
import javafx.scene.control.MenuBar;
import javafx.scene.control.MenuItem;
import javafx.scene.control.SeparatorMenuItem;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyCodeCombination;
import javafx.scene.input.KeyCombination;
import javafx.stage.Stage;

import java.util.function.Consumer;

/**
 * Manages the application menu bar
 */
public class MenuBarManager {

    private final MenuBar menuBar;
    private final Stage primaryStage;
    private Consumer<Void> onSelectProject;
    private EventBus eventBus;
    private MenuItem undoItem;
    private MenuItem redoItem;
    public MenuBarManager(Stage primaryStage) {
        this.primaryStage = primaryStage;
        this.menuBar = new MenuBar();
        createMenus();
    }

    /**
     * Creates all menus
     */
    private void createMenus() {
        // File menu
        Menu fileMenu = createFileMenu();

        // Edit menu (placeholder for future)
        Menu editMenu = createEditMenu();

        // View menu (placeholder for future)
        Menu viewMenu = createViewMenu();

        // Help menu
        Menu helpMenu = createHelpMenu();

        menuBar.getMenus().addAll(fileMenu, editMenu, viewMenu, helpMenu);
    }

    /**
     * Creates the File menu
     */
    private Menu createFileMenu() {
        Menu fileMenu = new Menu("File");

        // Select Project
        MenuItem selectProjectItem = new MenuItem("Select Project...");
        selectProjectItem.setAccelerator(new KeyCodeCombination(
                KeyCode.O,
                KeyCombination.CONTROL_DOWN,
                KeyCombination.SHIFT_DOWN
        ));
        selectProjectItem.setOnAction(e -> {
            if (onSelectProject != null) {
                onSelectProject.accept(null);
            }
        });

        // Separator
        SeparatorMenuItem separator1 = new SeparatorMenuItem();

        // Exit
        MenuItem exitItem = new MenuItem("Exit");
        exitItem.setAccelerator(new KeyCodeCombination(
                KeyCode.Q,
                KeyCombination.CONTROL_DOWN
        ));

        // UPDATED: Force system exit
        exitItem.setOnAction(e -> {
            javafx.application.Platform.exit(); // Close JavaFX
            System.exit(0); // Kill JVM (stops LSP, Debugger, etc.)
        });

        fileMenu.getItems().addAll(
                selectProjectItem,
                separator1,
                exitItem
        );

        return fileMenu;
    }

    /**
     * Creates the Edit menu
     */
    private Menu createEditMenu() {
        Menu editMenu = new Menu("Edit");

        undoItem = new MenuItem("Undo");
        undoItem.setAccelerator(new KeyCodeCombination(KeyCode.Z, KeyCombination.CONTROL_DOWN));
        undoItem.setDisable(true);
        undoItem.setOnAction(e -> {
            if (eventBus != null) eventBus.publish(new CoreApplicationEvents.UndoRequestedEvent());
        });

        redoItem = new MenuItem("Redo");
        redoItem.setAccelerator(new KeyCodeCombination(KeyCode.Y, KeyCombination.CONTROL_DOWN));
        redoItem.setDisable(true);
        redoItem.setOnAction(e -> {
            if (eventBus != null) eventBus.publish(new CoreApplicationEvents.RedoRequestedEvent());
        });

        SeparatorMenuItem separator = new SeparatorMenuItem();

        MenuItem cutItem = new MenuItem("Cut");
        cutItem.setAccelerator(new KeyCodeCombination(KeyCode.X, KeyCombination.CONTROL_DOWN));
        cutItem.setDisable(true); // Not implemented yet

        MenuItem copyItem = new MenuItem("Copy");
        copyItem.setAccelerator(new KeyCodeCombination(KeyCode.C, KeyCombination.CONTROL_DOWN));
        copyItem.setDisable(true); // Not implemented yet

        MenuItem pasteItem = new MenuItem("Paste");
        pasteItem.setAccelerator(new KeyCodeCombination(KeyCode.V, KeyCombination.CONTROL_DOWN));
        pasteItem.setDisable(true); // Not implemented yet

        editMenu.getItems().addAll(
                undoItem,
                redoItem,
                separator,
                cutItem,
                copyItem,
                pasteItem
        );

        return editMenu;
    }

    /**
     * Creates the View menu
     */
    private Menu createViewMenu() {
        Menu viewMenu = new Menu("View");

        // Placeholder items for future implementation
        MenuItem zoomInItem = new MenuItem("Zoom In");
        zoomInItem.setAccelerator(new KeyCodeCombination(
                KeyCode.PLUS,
                KeyCombination.CONTROL_DOWN
        ));
        zoomInItem.setDisable(true); // Not implemented yet

        MenuItem zoomOutItem = new MenuItem("Zoom Out");
        zoomOutItem.setAccelerator(new KeyCodeCombination(
                KeyCode.MINUS,
                KeyCombination.CONTROL_DOWN
        ));
        zoomOutItem.setDisable(true); // Not implemented yet

        MenuItem resetZoomItem = new MenuItem("Reset Zoom");
        resetZoomItem.setAccelerator(new KeyCodeCombination(
                KeyCode.DIGIT0,
                KeyCombination.CONTROL_DOWN
        ));
        resetZoomItem.setDisable(true); // Not implemented yet

        viewMenu.getItems().addAll(
                zoomInItem,
                zoomOutItem,
                resetZoomItem
        );

        return viewMenu;
    }


    public void setEventBus(EventBus eventBus) {
        this.eventBus = eventBus;
        eventBus.subscribe(CoreApplicationEvents.HistoryStateChangedEvent.class, this::updateMenuState, true);
    }

    private void updateMenuState(CoreApplicationEvents.HistoryStateChangedEvent event) {
        if (undoItem != null) undoItem.setDisable(!event.canUndo());
        if (redoItem != null) redoItem.setDisable(!event.canRedo());
    }

    /**
     * Creates the Help menu
     */
    private Menu createHelpMenu() {
        Menu helpMenu = new Menu("Help");

        MenuItem aboutItem = new MenuItem("About BotMaker");
        aboutItem.setOnAction(e -> showAboutDialog());

        helpMenu.getItems().add(aboutItem);

        return helpMenu;
    }

    /**
     * Shows the about dialog
     */
    private void showAboutDialog() {
        javafx.scene.control.Alert alert = new javafx.scene.control.Alert(
                javafx.scene.control.Alert.AlertType.INFORMATION
        );
        alert.initOwner(primaryStage);
        alert.setTitle("About BotMaker");
        alert.setHeaderText("BotMaker Blocks");
        alert.setContentText(
                "Version: 1.0.0\n\n" +
                        "A visual block-based programming environment for Java.\n\n" +
                        "Build Java applications using drag-and-drop blocks!"
        );
        alert.showAndWait();
    }

    /**
     * Gets the menu bar
     */
    public MenuBar getMenuBar() {
        return menuBar;
    }

    /**
     * Sets the callback for when "Select Project" is clicked
     */
    public void setOnSelectProject(Consumer<Void> callback) {
        this.onSelectProject = callback;
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/ui/MoveBlockInfo.java
=================================================================================

package com.botmaker.ui;

import com.botmaker.core.BodyBlock;

/**
 * Information about moving an existing block to a new position.
 * @param blockId The ID of the block being moved
 * @param targetBody The BodyBlock where the block should be moved to
 * @param insertionIndex The index where the block should be inserted
 */
public record MoveBlockInfo(String blockId, BodyBlock targetBody, int insertionIndex) {
}

=================================================================================
FILE: ./src/main/java/com/botmaker/ui/PaletteManager.java
=================================================================================

package com.botmaker.ui;

import com.botmaker.ui.AddableBlock.BlockCategory;
import javafx.geometry.Insets;
import javafx.scene.control.Accordion;
import javafx.scene.control.Label;
import javafx.scene.control.TitledPane;
import javafx.scene.layout.VBox;

import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

public class PaletteManager {

    private final BlockDragAndDropManager dragAndDropManager;

    public PaletteManager(BlockDragAndDropManager dragAndDropManager) {
        this.dragAndDropManager = dragAndDropManager;
    }

    public Accordion createCategorizedPalette() {
        Accordion accordion = new Accordion();
        Map<BlockCategory, List<AddableBlock>> grouped = Arrays.stream(AddableBlock.values())
                .collect(Collectors.groupingBy(AddableBlock::getCategory));

        BlockCategory[] order = {
                BlockCategory.OUTPUT, BlockCategory.INPUT, BlockCategory.VARIABLES,
                BlockCategory.FLOW, BlockCategory.LOOPS, BlockCategory.CONTROL, BlockCategory.UTILITY
        };

        for (BlockCategory category : order) {
            List<AddableBlock> blocks = grouped.get(category);
            if (blocks == null) continue;

            VBox content = new VBox(8);
            content.setPadding(new Insets(10));

            for (AddableBlock blockType : blocks) {
                Label blockLabel = new Label(blockType.getDisplayName());
                blockLabel.setMaxWidth(Double.MAX_VALUE);
                blockLabel.getStyleClass().addAll("palette-item", "palette-" + category.name().toLowerCase());

                // --- FIX: Force Black Text Color ---
                blockLabel.setStyle("-fx-text-fill: black; -fx-font-weight: bold;");

                dragAndDropManager.makeDraggable(blockLabel, blockType);
                content.getChildren().add(blockLabel);
            }

            TitledPane pane = new TitledPane(category.getLabel(), content);
            pane.getStyleClass().add("palette-pane");
            accordion.getPanes().add(pane);
        }
        if (!accordion.getPanes().isEmpty()) accordion.setExpandedPane(accordion.getPanes().get(0));
        return accordion;
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/ui/ProjectSelectionScreen.java
=================================================================================

package com.botmaker.ui;

import com.botmaker.project.ProjectCreator;
import com.botmaker.project.ProjectInfo;
import com.botmaker.project.ProjectManager;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.Scene;
import javafx.scene.control.*;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.HBox;
import javafx.scene.layout.VBox;
import javafx.stage.Stage;

import java.time.format.DateTimeFormatter;
import java.util.List;
import java.util.Optional;
import java.util.function.BiConsumer;
import java.util.function.Consumer;

/**
 * Project selection screen shown on startup with project creation capability
 */
public class ProjectSelectionScreen {

    private final ProjectManager projectManager;
    private final ProjectCreator projectCreator;

    // Changed to BiConsumer to pass (ProjectName, ShouldClearCache)
    private final BiConsumer<String, Boolean> onProjectSelected;

    private final Stage stage;
    private ListView<ProjectInfo> projectListView;

    // New Checkbox
    private CheckBox clearCacheCheckbox;

    public ProjectSelectionScreen(Stage stage, BiConsumer<String, Boolean> onProjectSelected) {
        this.stage = stage;
        this.projectManager = new ProjectManager();
        this.projectCreator = new ProjectCreator();
        this.onProjectSelected = onProjectSelected;
    }

    public Scene createScene() {
        BorderPane root = new BorderPane();
        root.setPadding(new Insets(20));

        // Header
        Label titleLabel = new Label("Select a Project");
        titleLabel.setStyle("-fx-font-size: 24px; -fx-font-weight: bold;");
        VBox header = new VBox(10, titleLabel);
        header.setAlignment(Pos.CENTER);
        header.setPadding(new Insets(0, 0, 20, 0));

        // Project list
        projectListView = new ListView<>();
        projectListView.setPrefHeight(400);

        projectListView.setCellFactory(lv -> new ListCell<>() {
            @Override
            protected void updateItem(ProjectInfo project, boolean empty) {
                super.updateItem(project, empty);
                if (empty || project == null) {
                    setText(null);
                    setGraphic(null);
                } else {
                    VBox box = new VBox(5);
                    Label nameLabel = new Label(project.getName());
                    nameLabel.setStyle("-fx-font-size: 16px; -fx-font-weight: bold;");

                    Label pathLabel = new Label(project.getProjectPath().toString());
                    pathLabel.setStyle("-fx-font-size: 11px; -fx-text-fill: gray;");

                    Label dateLabel = new Label("Last modified: " +
                            project.getLastModified().format(DateTimeFormatter.ofPattern("MMM dd, yyyy HH:mm")));
                    dateLabel.setStyle("-fx-font-size: 11px; -fx-text-fill: gray;");

                    box.getChildren().addAll(nameLabel, pathLabel, dateLabel);
                    setGraphic(box);
                }
            }
        });

        refreshProjectList();

        if (!projectListView.getItems().isEmpty()) {
            projectListView.getSelectionModel().select(0);
        }

        // Controls Area
        Button openButton = new Button("Open Project");
        openButton.setPrefWidth(150);
        openButton.setDefaultButton(true);
        openButton.setOnAction(e -> openSelectedProject());

        Button createButton = new Button("Create New Project");
        createButton.setPrefWidth(150);
        createButton.setOnAction(e -> showCreateProjectDialog());

        // CLEAR CACHE CHECKBOX
        clearCacheCheckbox = new CheckBox("Clear Language Server Cache (Fix startup freeze)");
        clearCacheCheckbox.setStyle("-fx-text-fill: #666; -fx-font-size: 11px;");
        clearCacheCheckbox.setTooltip(new Tooltip("Check this if the application hangs on loading."));

        projectListView.setOnMouseClicked(e -> {
            if (e.getClickCount() == 2) {
                openSelectedProject();
            }
        });

        HBox buttonBox = new HBox(10, openButton, createButton);
        buttonBox.setAlignment(Pos.CENTER);

        VBox footer = new VBox(15, clearCacheCheckbox, buttonBox);
        footer.setAlignment(Pos.CENTER);
        footer.setPadding(new Insets(20, 0, 0, 0));

        VBox center = new VBox(10, projectListView, footer);
        root.setTop(header);
        root.setCenter(center);

        Scene scene = new Scene(root, 600, 550); // Increased height slightly
        scene.getStylesheets().add(getClass().getResource("/com/botmaker/styles.css").toExternalForm());

        return scene;
    }

    private void openSelectedProject() {
        ProjectInfo selected = projectListView.getSelectionModel().getSelectedItem();
        if (selected != null) {
            onProjectSelected.accept(selected.getName(), clearCacheCheckbox.isSelected());
        }
    }

    // ... rest of file (refreshProjectList, showCreateProjectDialog, etc) remains the same ...

    private void refreshProjectList() {
        List<ProjectInfo> projects = projectManager.listProjects();
        projectListView.getItems().clear();
        projectListView.getItems().addAll(projects);
    }

    private void showCreateProjectDialog() {
        Dialog<String> dialog = new Dialog<>();
        dialog.setTitle("Create New Project");
        dialog.setHeaderText("Enter project name");

        ButtonType createButtonType = new ButtonType("Create", ButtonBar.ButtonData.OK_DONE);
        dialog.getDialogPane().getButtonTypes().addAll(createButtonType, ButtonType.CANCEL);

        VBox content = new VBox(10);
        content.setPadding(new Insets(20));

        TextField projectNameField = new TextField();
        projectNameField.setPromptText("ProjectName");

        Label instructionLabel = new Label("Project name must:");
        instructionLabel.setStyle("-fx-font-size: 11px; -fx-text-fill: gray;");

        Label rule1 = new Label("• Start with an uppercase letter");
        rule1.setStyle("-fx-font-size: 10px; -fx-text-fill: gray;");

        Label rule2 = new Label("• Contain only letters and numbers");
        rule2.setStyle("-fx-font-size: 10px; -fx-text-fill: gray;");

        Label rule3 = new Label("• Be between 2-50 characters");
        rule3.setStyle("-fx-font-size: 10px; -fx-text-fill: gray;");

        Label exampleLabel = new Label("Example: MyFirstProject");
        exampleLabel.setStyle("-fx-font-size: 10px; -fx-font-style: italic; -fx-text-fill: gray;");

        content.getChildren().addAll(
                new Label("Project Name:"),
                projectNameField,
                instructionLabel,
                rule1,
                rule2,
                rule3,
                exampleLabel
        );

        dialog.getDialogPane().setContent(content);

        Button createButton = (Button) dialog.getDialogPane().lookupButton(createButtonType);
        createButton.setDisable(true);

        projectNameField.textProperty().addListener((observable, oldValue, newValue) -> {
            boolean isValid = isValidProjectName(newValue);
            createButton.setDisable(!isValid);
            if (newValue.isEmpty()) projectNameField.setStyle("");
            else if (isValid) projectNameField.setStyle("-fx-border-color: green; -fx-border-width: 2px;");
            else projectNameField.setStyle("-fx-border-color: red; -fx-border-width: 2px;");
        });

        javafx.application.Platform.runLater(projectNameField::requestFocus);

        dialog.setResultConverter(dialogButton -> {
            if (dialogButton == createButtonType) return projectNameField.getText();
            return null;
        });

        Optional<String> result = dialog.showAndWait();
        result.ifPresent(this::createProject);
    }

    private boolean isValidProjectName(String name) {
        if (name == null || name.trim().isEmpty()) return false;
        if (!name.matches("^[A-Z][a-zA-Z0-9]*$")) return false;
        if (name.length() < 2 || name.length() > 50) return false;
        if (projectCreator.projectExists(name)) return false;
        return true;
    }

    private void createProject(String projectName) {
        try {
            projectCreator.createProject(projectName);
            refreshProjectList();
            for (ProjectInfo project : projectListView.getItems()) {
                if (project.getName().equals(projectName)) {
                    projectListView.getSelectionModel().select(project);
                    break;
                }
            }
        } catch (Exception e) {
            Alert errorAlert = new Alert(Alert.AlertType.ERROR);
            errorAlert.setTitle("Error");
            errorAlert.setHeaderText("Failed to create project");
            errorAlert.setContentText(e.getMessage());
            errorAlert.showAndWait();
        }
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/ui/ToolbarManager.java
=================================================================================

package com.botmaker.ui;

import com.botmaker.events.CoreApplicationEvents;
import com.botmaker.events.EventBus;
import javafx.geometry.Insets;
import javafx.scene.control.Button;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Priority;
import javafx.scene.layout.Region;

public class ToolbarManager {

    private final EventBus eventBus;

    // Controls
    private Button undoButton, redoButton;
    private Button runButton, debugButton, unifiedStopButton;
    private Button stepOverButton, continueButton;

    private enum AppState { IDLE, RUNNING, DEBUGGING }
    private AppState currentAppState = AppState.IDLE;

    public ToolbarManager(EventBus eventBus) {
        this.eventBus = eventBus;
        setupEventHandlers();
    }

    private void setupEventHandlers() {
        eventBus.subscribe(CoreApplicationEvents.ProgramStartedEvent.class, e -> setAppState(AppState.RUNNING), true);
        eventBus.subscribe(CoreApplicationEvents.ProgramStoppedEvent.class, e -> setAppState(AppState.IDLE), true);
        eventBus.subscribe(CoreApplicationEvents.DebugSessionStartedEvent.class, e -> setAppState(AppState.DEBUGGING), true);
        eventBus.subscribe(CoreApplicationEvents.DebugSessionFinishedEvent.class, e -> setAppState(AppState.IDLE), true);
        eventBus.subscribe(CoreApplicationEvents.DebugSessionPausedEvent.class, e -> updateDebugControls(true), true);
        eventBus.subscribe(CoreApplicationEvents.DebugSessionResumedEvent.class, e -> updateDebugControls(false), true);
        eventBus.subscribe(CoreApplicationEvents.HistoryStateChangedEvent.class, event -> {
            if (undoButton != null) undoButton.setDisable(!event.canUndo());
            if (redoButton != null) redoButton.setDisable(!event.canRedo());
        }, true);
    }

    public HBox createToolBar() {
        undoButton = new Button("Undo");
        undoButton.setDisable(true);
        undoButton.setOnAction(e -> eventBus.publish(new CoreApplicationEvents.UndoRequestedEvent()));

        redoButton = new Button("Redo");
        redoButton.setDisable(true);
        redoButton.setOnAction(e -> eventBus.publish(new CoreApplicationEvents.RedoRequestedEvent()));

        Region spacer1 = new Region();
        HBox.setHgrow(spacer1, Priority.ALWAYS);

        Button compileButton = new Button("Compile");
        compileButton.getStyleClass().add("toolbar-btn");
        compileButton.setOnAction(e -> eventBus.publish(new CoreApplicationEvents.CompilationRequestedEvent()));

        runButton = new Button("Run ▶");
        runButton.getStyleClass().addAll("toolbar-btn", "btn-run");
        runButton.setOnAction(e -> eventBus.publish(new CoreApplicationEvents.ExecutionRequestedEvent()));

        debugButton = new Button("Debug 🐞");
        debugButton.getStyleClass().addAll("toolbar-btn", "btn-debug");
        debugButton.setOnAction(e -> eventBus.publish(new CoreApplicationEvents.DebugStartRequestedEvent()));

        unifiedStopButton = new Button("Stop ⏹");
        unifiedStopButton.getStyleClass().addAll("toolbar-btn", "btn-stop");
        unifiedStopButton.setDisable(true);
        unifiedStopButton.setOnAction(e -> {
            if (currentAppState == AppState.RUNNING) eventBus.publish(new CoreApplicationEvents.StopRunRequestedEvent());
            else if (currentAppState == AppState.DEBUGGING) eventBus.publish(new CoreApplicationEvents.DebugStopRequestedEvent());
        });

        Region spacer2 = new Region();
        HBox.setHgrow(spacer2, Priority.ALWAYS);

        stepOverButton = new Button("Step ⤵");
        stepOverButton.setDisable(true);
        stepOverButton.setOnAction(e -> eventBus.publish(new CoreApplicationEvents.DebugStepOverRequestedEvent()));

        continueButton = new Button("Continue ⏩");
        continueButton.setDisable(true);
        continueButton.setOnAction(e -> eventBus.publish(new CoreApplicationEvents.DebugContinueRequestedEvent()));

        HBox toolbar = new HBox(10, undoButton, redoButton, spacer1, compileButton, runButton, debugButton, unifiedStopButton, spacer2, stepOverButton, continueButton);
        toolbar.setPadding(new Insets(10));
        toolbar.getStyleClass().add("main-toolbar");
        return toolbar;
    }

    private void setAppState(AppState state) {
        this.currentAppState = state;
        updateToolbarState();
    }

    private void updateToolbarState() {
        boolean isBusy = (currentAppState != AppState.IDLE);
        runButton.setDisable(isBusy);
        debugButton.setDisable(isBusy);
        unifiedStopButton.setDisable(!isBusy);

        if (currentAppState == AppState.DEBUGGING) {
            unifiedStopButton.setText("Stop Debugging ⏹");
            unifiedStopButton.setStyle("-fx-background-color: #E74C3C; -fx-text-fill: white;");
        } else if (currentAppState == AppState.RUNNING) {
            unifiedStopButton.setText("Stop Run ⏹");
            unifiedStopButton.setStyle("-fx-background-color: #E74C3C; -fx-text-fill: white;");
            stepOverButton.setDisable(true);
            continueButton.setDisable(true);
        } else {
            unifiedStopButton.setText("Stop ⏹");
            unifiedStopButton.setStyle("");
            stepOverButton.setDisable(true);
            continueButton.setDisable(true);
        }
    }

    private void updateDebugControls(boolean isPaused) {
        if (currentAppState == AppState.DEBUGGING) {
            stepOverButton.setDisable(!isPaused);
            continueButton.setDisable(!isPaused);
        }
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/ui/UIManager.java
=================================================================================

package com.botmaker.ui;

import com.botmaker.config.ApplicationConfig;
import com.botmaker.core.CodeBlock;
import com.botmaker.events.CoreApplicationEvents;
import com.botmaker.events.EventBus;
import com.botmaker.lsp.CompletionContext;
import com.botmaker.services.CodeEditorService;
import com.botmaker.state.ApplicationState;
import com.botmaker.validation.DiagnosticsManager;
import com.botmaker.validation.ErrorTranslator;
import javafx.geometry.Orientation;
import javafx.scene.Node;
import javafx.scene.Scene;
import javafx.scene.control.*;
import javafx.scene.layout.*;
import javafx.stage.Stage;
import org.eclipse.lsp4j.Diagnostic;
import org.eclipse.lsp4j.DiagnosticSeverity;

import java.util.List;
import java.util.function.Consumer;

public class UIManager {

    private final EventBus eventBus;
    private final CodeEditorService codeEditorService;
    private final DiagnosticsManager diagnosticsManager;
    private final Stage primaryStage;

    // UI Managers
    private final PaletteManager paletteManager;
    private final ToolbarManager toolbarManager;
    private final EventLogManager eventLogManager;
    private final MenuBarManager menuBarManager;
    private final FileExplorerManager fileExplorerManager; // New Manager

    private VBox blocksContainer;
    private Label statusLabel;
    private TextArea outputArea;
    private ListView<Diagnostic> errorListView;
    private TabPane bottomTabPane;
    private Consumer<Void> onSelectProject;

    public UIManager(BlockDragAndDropManager dragAndDropManager,
                     EventBus eventBus,
                     CodeEditorService codeEditorService,
                     DiagnosticsManager diagnosticsManager,
                     Stage primaryStage,
                     ApplicationConfig config,   // Added
                     ApplicationState state) {   // Added
        this.eventBus = eventBus;
        this.codeEditorService = codeEditorService;
        this.diagnosticsManager = diagnosticsManager;
        this.primaryStage = primaryStage;

        // Delegate Managers
        this.paletteManager = new PaletteManager(dragAndDropManager);
        this.toolbarManager = new ToolbarManager(eventBus);
        this.eventLogManager = new EventLogManager(eventBus);
        this.menuBarManager = new MenuBarManager(primaryStage);
        this.menuBarManager.setEventBus(eventBus);

        // Initialize File Explorer
        this.fileExplorerManager = new FileExplorerManager(config, codeEditorService, state);

        setupEventHandlers();
    }

    private void setupEventHandlers() {
        eventBus.subscribe(CoreApplicationEvents.UIBlocksUpdatedEvent.class, this::handleBlocksUpdate, true);
        eventBus.subscribe(CoreApplicationEvents.OutputAppendedEvent.class, event -> {
            if (outputArea.getText().length() > 10_000) {
                String current = outputArea.getText();
                outputArea.setText("[...Trimmed...]\n" + current.substring(current.length() - 5000) + event.getText());
                outputArea.positionCaret(outputArea.getLength());
            } else {
                outputArea.appendText(event.getText());
            }
        }, true);
        eventBus.subscribe(CoreApplicationEvents.OutputClearedEvent.class, event -> outputArea.clear(), true);
        eventBus.subscribe(CoreApplicationEvents.OutputSetEvent.class, event -> outputArea.setText(event.getText()), true);
        eventBus.subscribe(CoreApplicationEvents.StatusMessageEvent.class, event -> statusLabel.setText(event.getMessage()), true);
        eventBus.subscribe(CoreApplicationEvents.DiagnosticsUpdatedEvent.class, event -> {
            diagnosticsManager.processDiagnostics(event.getDiagnostics());
            updateErrors(diagnosticsManager.getDiagnostics());
            statusLabel.setText(diagnosticsManager.getErrorSummary());
        }, true);
        eventBus.subscribe(CoreApplicationEvents.ProgramStartedEvent.class, e -> selectBottomTab(0), true);
        eventBus.subscribe(CoreApplicationEvents.DebugSessionStartedEvent.class, e -> selectBottomTab(0), true);
    }

    private void handleBlocksUpdate(CoreApplicationEvents.UIBlocksUpdatedEvent event) {
        blocksContainer.getChildren().clear();
        if (event.getRootBlock() != null) {
            CompletionContext context = codeEditorService.createCompletionContext();
            Node rootNode = event.getRootBlock().getUINode(context);
            rootNode.addEventHandler(BlockEvent.BreakpointToggleEvent.TOGGLE_BREAKPOINT, e ->
                    eventBus.publish(new CoreApplicationEvents.BreakpointToggledEvent(e.getBlock(), e.isEnabled())));
            blocksContainer.getChildren().add(rootNode);
        }
    }

    public Scene createScene() {
        menuBarManager.setOnSelectProject(v -> { if (onSelectProject != null) onSelectProject.accept(null); });

        // 1. Center Code Area
        blocksContainer = new VBox(10);
        blocksContainer.getStyleClass().add("blocks-canvas");
        ScrollPane scrollPane = new ScrollPane(blocksContainer);
        scrollPane.setFitToWidth(true);
        scrollPane.getStyleClass().add("code-scroll-pane");

        // 2. Left Sidebar (Files + Palette)
        VBox paletteContent = new VBox(paletteManager.createCategorizedPalette());
        paletteContent.getStyleClass().add("palette-sidebar");

        VBox fileExplorerContent = fileExplorerManager.createView();

        TabPane sidebarTabs = new TabPane();
        sidebarTabs.setTabClosingPolicy(TabPane.TabClosingPolicy.UNAVAILABLE);

        Tab filesTab = new Tab("Files", fileExplorerContent);
        Tab blocksTab = new Tab("Blocks", paletteContent);

        sidebarTabs.getTabs().addAll(filesTab, blocksTab);
        sidebarTabs.setPrefWidth(260); // Slightly wider to accommodate file names
        sidebarTabs.getStyleClass().add("sidebar-tabs");

        // 3. Status Bar
        statusLabel = new Label("Ready");
        statusLabel.setId("status-label");

        // 4. Bottom Panel (Output, Errors, Logs)
        outputArea = new TextArea();
        outputArea.setEditable(false);
        outputArea.getStyleClass().add("console-area");

        errorListView = new ListView<>();
        configureErrorList(errorListView);

        bottomTabPane = new TabPane();
        Tab terminalTab = new Tab("Terminal", outputArea); terminalTab.setClosable(false);
        Tab errorsTab = new Tab("Errors", errorListView); errorsTab.setClosable(false);
        Tab eventsTab = new Tab("Event Log", eventLogManager.getView()); eventsTab.setClosable(false);
        bottomTabPane.getTabs().addAll(terminalTab, errorsTab, eventsTab);

        // 5. Layout Assembly
        SplitPane verticalSplit = new SplitPane();
        verticalSplit.setOrientation(Orientation.VERTICAL);
        verticalSplit.getItems().addAll(scrollPane, bottomTabPane);
        verticalSplit.setDividerPositions(0.75);
        VBox.setVgrow(verticalSplit, Priority.ALWAYS);

        BorderPane mainLayout = new BorderPane();
        mainLayout.setTop(toolbarManager.createToolBar());
        mainLayout.setLeft(sidebarTabs); // Changed from paletteContainer to sidebarTabs
        mainLayout.setCenter(verticalSplit);
        mainLayout.setBottom(statusLabel);

        VBox root = new VBox(menuBarManager.getMenuBar(), mainLayout);
        VBox.setVgrow(mainLayout, Priority.ALWAYS);
        root.getStyleClass().add("light-theme");

        primaryStage.setOnHidden(e -> eventLogManager.shutdown());

        Scene scene = new Scene(root, 1000, 700);
        scene.getStylesheets().add(getClass().getResource("/com/botmaker/styles.css").toExternalForm());
        return scene;
    }

    private void configureErrorList(ListView<Diagnostic> lv) {
        lv.setPlaceholder(new Label("No errors."));
        lv.setCellFactory(list -> new ListCell<>() {
            @Override
            protected void updateItem(Diagnostic diagnostic, boolean empty) {
                super.updateItem(diagnostic, empty);
                getStyleClass().removeAll("error-cell", "warning-cell");
                if (empty || diagnostic == null) {
                    setText(null);
                    setOnMouseClicked(null);
                } else {
                    String message = ErrorTranslator.getShortSummary(diagnostic);
                    int line = diagnostic.getRange().getStart().getLine() + 1;
                    setText(String.format("Line %d: %s", line, message));
                    if (diagnostic.getSeverity() == DiagnosticSeverity.Error) getStyleClass().add("error-cell");
                    else if (diagnostic.getSeverity() == DiagnosticSeverity.Warning) getStyleClass().add("warning-cell");
                    setOnMouseClicked(event -> {
                        if (event.getClickCount() >= 1) {
                            diagnosticsManager.findBlockForDiagnostic(diagnostic).ifPresent(block -> {
                                Node uiNode = block.getUINode();
                                if (uiNode != null) uiNode.requestFocus();
                            });
                        }
                    });
                }
            }
        });
    }

    private void updateErrors(List<Diagnostic> diagnostics) {
        if (diagnostics == null) errorListView.getItems().clear();
        else errorListView.getItems().setAll(diagnostics);
        if (diagnostics != null && !diagnostics.isEmpty()) selectBottomTab(1);
    }

    private void selectBottomTab(int index) {
        if (bottomTabPane != null && index < bottomTabPane.getTabs().size()) {
            bottomTabPane.getSelectionModel().select(index);
        }
    }

    public void setOnSelectProject(Consumer<Void> callback) { this.onSelectProject = callback; }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/util/BlockLookupHelper.java
=================================================================================

package com.botmaker.util;

import com.botmaker.core.BodyBlock;
import com.botmaker.core.BlockWithChildren;
import com.botmaker.core.CodeBlock;
import com.botmaker.core.StatementBlock;

import java.util.Map;

/**
 * Helper class for looking up blocks in the block tree.
 */
public class BlockLookupHelper {

    /**
     * Finds a block by its ID in the node-to-block map.
     * @param blockId The ID of the block to find
     * @param nodeToBlockMap The map of AST nodes to CodeBlocks
     * @return The StatementBlock if found, null otherwise
     */
    public static StatementBlock findBlockById(String blockId, Map<?, CodeBlock> nodeToBlockMap) {
        if (blockId == null || nodeToBlockMap == null) {
            return null;
        }

        // Search through all blocks in the map
        for (CodeBlock block : nodeToBlockMap.values()) {
            if (block.getId().equals(blockId) && block instanceof StatementBlock) {
                return (StatementBlock) block;
            }
        }

        return null;
    }

    /**
     * Finds the BodyBlock that contains the given statement block.
     * @param targetBlock The statement block to find the parent for
     * @param nodeToBlockMap The map of AST nodes to CodeBlocks
     * @return The BodyBlock containing the statement, null if not found
     */
    public static BodyBlock findParentBody(StatementBlock targetBlock, Map<?, CodeBlock> nodeToBlockMap) {
        if (targetBlock == null || nodeToBlockMap == null) {
            return null;
        }

        // Search through all blocks to find which BodyBlock contains the target
        for (CodeBlock block : nodeToBlockMap.values()) {
            if (block instanceof BodyBlock) {
                BodyBlock bodyBlock = (BodyBlock) block;
                if (bodyBlock.getStatements().contains(targetBlock)) {
                    return bodyBlock;
                }
            }

            // Also check nested structures
            if (block instanceof BlockWithChildren) {
                BodyBlock found = findParentBodyInChildren(targetBlock, (BlockWithChildren) block);
                if (found != null) {
                    return found;
                }
            }
        }

        return null;
    }

    /**
     * Recursively searches for the parent body in a block's children.
     */
    private static BodyBlock findParentBodyInChildren(StatementBlock targetBlock, BlockWithChildren parent) {
        for (CodeBlock child : parent.getChildren()) {
            if (child instanceof BodyBlock) {
                BodyBlock bodyBlock = (BodyBlock) child;
                if (bodyBlock.getStatements().contains(targetBlock)) {
                    return bodyBlock;
                }
            }

            if (child instanceof BlockWithChildren) {
                BodyBlock found = findParentBodyInChildren(targetBlock, (BlockWithChildren) child);
                if (found != null) {
                    return found;
                }
            }
        }

        return null;
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/util/DefaultNames.java
=================================================================================

package com.botmaker.util;

/**
 * Provides sensible default names for auto-generated elements
 */
public class DefaultNames {

    // Variable names by type
    public static final String DEFAULT_INT = "number";
    public static final String DEFAULT_DOUBLE = "decimal";
    public static final String DEFAULT_BOOLEAN = "flag";
    public static final String DEFAULT_STRING = "text";
    public static final String DEFAULT_VARIABLE = "variable";

    // Method to get default name by type
    public static String forType(String typeName) {
        if (typeName == null) return DEFAULT_VARIABLE;

        switch (typeName.toLowerCase()) {
            case "int":
            case "long":
            case "short":
            case "byte":
                return DEFAULT_INT;
            case "double":
            case "float":
                return DEFAULT_DOUBLE;
            case "boolean":
                return DEFAULT_BOOLEAN;
            case "string":
                return DEFAULT_STRING;
            default:
                return DEFAULT_VARIABLE;
        }
    }

    private DefaultNames() {} // Prevent instantiation
}

=================================================================================
FILE: ./src/main/java/com/botmaker/util/TypeManager.java
=================================================================================

package com.botmaker.util;

import org.eclipse.jdt.core.dom.*;

import java.util.List;
import java.util.Set;

public class TypeManager {

    // --- Constants for UI Categories ---
    public static final String UI_TYPE_ANY = "any";
    public static final String UI_TYPE_NUMBER = "number";
    public static final String UI_TYPE_BOOLEAN = "boolean";
    public static final String UI_TYPE_STRING = "String";
    public static final String UI_TYPE_TEXT = "Text"; // Alias for String
    public static final String UI_TYPE_LIST = "list";

    // --- Mapping Tables ---

    // Fundamental types for dropdown menus
    private static final List<String> FUNDAMENTAL_TYPES = List.of(
            "int", "double", "boolean", "String", "long", "float", "char"
    );

    // Hidden variables that shouldn't appear in autocomplete
    private static final Set<String> HIDDEN_VARIABLES = Set.of(
            "args", "this", "super", "scanner", "class"
    );

    // Groupings for Type Checking
    private static final Set<String> NUMBER_TYPES = Set.of(
            "int", "double", "float", "long", "short", "byte",
            "java.lang.Integer", "java.lang.Double", "java.lang.Float",
            "java.lang.Long", "java.lang.Short", "java.lang.Byte",
            "Integer", "Double", "Float", "Long", "Short", "Byte" // Simple names
    );

    private static final Set<String> BOOLEAN_TYPES = Set.of(
            "boolean", "java.lang.Boolean", "Boolean"
    );

    private static final Set<String> STRING_TYPES = Set.of(
            "String", "java.lang.String", "char", "java.lang.Character", "Character"
    );

    public static List<String> getFundamentalTypeNames() {
        return FUNDAMENTAL_TYPES;
    }

    // --- Validation Logic ---

    public static boolean isUserVariable(String variableName) {
        if (variableName == null || variableName.isEmpty()) return false;
        String cleanName = variableName.split(" ")[0].split(":")[0].trim();
        if (HIDDEN_VARIABLES.contains(cleanName)) return false;
        if (cleanName.startsWith("_")) return false;
        return true;
    }

    // --- UI Type Determination ---

    /**
     * Determines the UI Category (number, boolean, String, list) from a Java type name.
     * Used to filter available expressions in blocks.
     */
    public static String determineUiType(String typeName) {
        if (typeName == null || typeName.isBlank()) return UI_TYPE_ANY;
        String clean = typeName.trim();

        // Check for ArrayList first
        if (isArrayList(clean)) return UI_TYPE_LIST;

        // Then check for arrays
        if (clean.endsWith("[]")) return UI_TYPE_LIST;

        if (NUMBER_TYPES.contains(clean)) return UI_TYPE_NUMBER;
        if (BOOLEAN_TYPES.contains(clean)) return UI_TYPE_BOOLEAN;
        if (STRING_TYPES.contains(clean)) return UI_TYPE_STRING;

        return UI_TYPE_ANY;
    }


    // --- Type Compatibility (ITypeBinding) ---

    public static boolean isCompatible(ITypeBinding binding, String targetUiType) {
        if (targetUiType == null || targetUiType.equals(UI_TYPE_ANY)) return true;
        if (binding == null) return true;

        if (binding.isArray()) {
            return targetUiType.equals(UI_TYPE_LIST) || targetUiType.endsWith("[]");
        }

        String qualifiedName = binding.getQualifiedName();
        String simpleName = binding.getName();

        switch (targetUiType) {
            case UI_TYPE_NUMBER:
                return NUMBER_TYPES.contains(simpleName) || NUMBER_TYPES.contains(qualifiedName);
            case UI_TYPE_BOOLEAN:
                return BOOLEAN_TYPES.contains(simpleName) || BOOLEAN_TYPES.contains(qualifiedName);
            case UI_TYPE_STRING:
            case UI_TYPE_TEXT:
                return STRING_TYPES.contains(simpleName) || STRING_TYPES.contains(qualifiedName);
            default:
                return targetUiType.equals(simpleName) || targetUiType.equals(qualifiedName);
        }
    }

    /**
     * Determines if a type string represents an ArrayList
     */
    public static boolean isArrayList(String typeName) {
        if (typeName == null) return false;
        return typeName.startsWith("ArrayList<") || typeName.equals("ArrayList");
    }



    // --- Type Compatibility (String) ---

    public static boolean isCompatible(String typeName, String targetUiType) {
        if (targetUiType == null || targetUiType.equals(UI_TYPE_ANY)) return true;
        if (typeName == null || typeName.isBlank()) return true;

        String cleanType = typeName.trim();

        if (cleanType.endsWith("[]")) {
            return targetUiType.equals(UI_TYPE_LIST) || targetUiType.endsWith("[]");
        }

        switch (targetUiType) {
            case UI_TYPE_NUMBER:
                return NUMBER_TYPES.contains(cleanType);
            case UI_TYPE_BOOLEAN:
                return BOOLEAN_TYPES.contains(cleanType);
            case UI_TYPE_STRING:
            case UI_TYPE_TEXT:
                return STRING_TYPES.contains(cleanType) || cleanType.endsWith("String");
            default:
                return cleanType.equals(targetUiType);
        }
    }

    // --- Display Utilities ---

    public static String getFriendlyTypeName(ITypeBinding typeBinding) {
        if (typeBinding == null) return "unknown";
        if (typeBinding.isArray()) return "list";
        String name = typeBinding.getName();
        if (NUMBER_TYPES.contains(name)) return "number";
        if (STRING_TYPES.contains(name)) return "text";
        if (BOOLEAN_TYPES.contains(name)) return "bool";
        return name;
    }

    // --- AST Node Creation ---

    /**
     * Converts primitive type names to their wrapper classes.
     * Required for ArrayList and other generics which don't support primitives.
     *
     * @param typeName The type name to convert (e.g., "int", "boolean")
     * @return The wrapper class name (e.g., "Integer", "Boolean")
     */
    public static String toWrapperType(String typeName) {
        if (typeName == null) return typeName;

        switch (typeName) {
            case "int": return "Integer";
            case "double": return "Double";
            case "boolean": return "Boolean";
            case "char": return "Character";
            case "long": return "Long";
            case "float": return "Float";
            case "short": return "Short";
            case "byte": return "Byte";
            default: return typeName; // Already a reference type
        }
    }

    /**
     * Checks if a type name is a primitive type.
     *
     * @param typeName The type name to check
     * @return true if the type is a Java primitive
     */
    public static boolean isPrimitive(String typeName) {
        if (typeName == null) return false;

        return typeName.equals("int") ||
                typeName.equals("double") ||
                typeName.equals("boolean") ||
                typeName.equals("char") ||
                typeName.equals("long") ||
                typeName.equals("float") ||
                typeName.equals("short") ||
                typeName.equals("byte");
    }

    /**
     * Converts wrapper class names back to primitives.
     * Opposite of toWrapperType().
     *
     * @param typeName The wrapper class name (e.g., "Integer")
     * @return The primitive type name (e.g., "int")
     */
    public static String toPrimitiveType(String typeName) {
        if (typeName == null) return typeName;

        switch (typeName) {
            case "Integer": return "int";
            case "Double": return "double";
            case "Boolean": return "boolean";
            case "Character": return "char";
            case "Long": return "long";
            case "Float": return "float";
            case "Short": return "short";
            case "Byte": return "byte";
            default: return typeName; // Not a wrapper
        }
    }

    public static int getListNestingLevel(String typeName) {
        if (typeName == null) return 0;
        int level = 0;
        String temp = typeName;
        while (temp.startsWith("ArrayList<") || temp.startsWith("List<")) {
            level++;
            int start = temp.indexOf("<") + 1;
            int end = temp.lastIndexOf(">");
            if (start < end) {
                temp = temp.substring(start, end);
            } else {
                break;
            }
        }
        return level;
    }

    public static String getLeafType(String typeName) {
        if (typeName == null) return "Object";
        String temp = typeName;
        while (temp.startsWith("ArrayList<") || temp.startsWith("List<")) {
            int start = temp.indexOf("<") + 1;
            int end = temp.lastIndexOf(">");
            if (start < end) {
                temp = temp.substring(start, end);
            } else {
                break;
            }
        }
        return temp;
    }

    public static Type createTypeNode(AST ast, String typeName) {
        // Handle ArrayList<Type>
        if (typeName.startsWith("ArrayList<") && typeName.endsWith(">")) {
            // Extract element type
            int start = typeName.indexOf("<") + 1;
            int end = typeName.lastIndexOf(">");
            String elementTypeName = typeName.substring(start, end);

            // Create parameterized type: ArrayList<ElementType>
            ParameterizedType paramType = ast.newParameterizedType(
                    ast.newSimpleType(ast.newName("ArrayList"))
            );

            // Handle nested ArrayList recursively
            Type elementType = createTypeNode(ast, elementTypeName);
            paramType.typeArguments().add(elementType);

            return paramType;
        }

        // Handle arrays
        int dimensions = 0;
        String baseName = typeName;

        while (baseName.endsWith("[]")) {
            dimensions++;
            baseName = baseName.substring(0, baseName.length() - 2);
        }

        Type baseType;
        switch (baseName) {
            case "int": baseType = ast.newPrimitiveType(PrimitiveType.INT); break;
            case "double": baseType = ast.newPrimitiveType(PrimitiveType.DOUBLE); break;
            case "boolean": baseType = ast.newPrimitiveType(PrimitiveType.BOOLEAN); break;
            case "char": baseType = ast.newPrimitiveType(PrimitiveType.CHAR); break;
            case "long": baseType = ast.newPrimitiveType(PrimitiveType.LONG); break;
            case "float": baseType = ast.newPrimitiveType(PrimitiveType.FLOAT); break;
            case "short": baseType = ast.newPrimitiveType(PrimitiveType.SHORT); break;
            case "byte": baseType = ast.newPrimitiveType(PrimitiveType.BYTE); break;
            default: baseType = ast.newSimpleType(ast.newName(baseName)); break;
        }

        if (dimensions > 0) {
            return ast.newArrayType(baseType, dimensions);
        } else {
            return baseType;
        }
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/validation/DiagnosticsManager.java
=================================================================================

package com.botmaker.validation;

import com.botmaker.core.CodeBlock;
import javafx.application.Platform;
import org.eclipse.jdt.core.dom.ASTNode;
import org.eclipse.lsp4j.Diagnostic;
import org.eclipse.lsp4j.DiagnosticSeverity;
import org.eclipse.lsp4j.PublishDiagnosticsParams;

import java.util.*;

public class DiagnosticsManager {

    private Map<ASTNode, CodeBlock> nodeToBlockMap;
    private String sourceCode;
    private final Set<CodeBlock> blocksWithErrors = new HashSet<>();
    private List<Diagnostic> lastDiagnostics = new ArrayList<>();

    // NEW: Track line numbers to blocks for fallback matching
    private Map<Integer, Set<CodeBlock>> lineToBlocksMap = new HashMap<>();

    public List<Diagnostic> getDiagnostics() {
        return lastDiagnostics;
    }

    public boolean hasErrors() {
        if (lastDiagnostics == null || lastDiagnostics.isEmpty()) {
            return false;
        }
        return lastDiagnostics.stream().anyMatch(d -> {
            DiagnosticSeverity severity = d.getSeverity();
            return severity == null || severity == DiagnosticSeverity.Error;
        });
    }

    public void updateSource(Map<ASTNode, CodeBlock> nodeToBlockMap, String sourceCode) {
        this.nodeToBlockMap = nodeToBlockMap;
        this.sourceCode = sourceCode;

        // Build line-to-block mapping for fallback
        buildLineToBlockMap();
    }

    /**
     * Builds a map from line numbers to blocks for fallback matching
     * when AST node matching fails.
     */
    private void buildLineToBlockMap() {
        lineToBlocksMap.clear();

        if (nodeToBlockMap == null || sourceCode == null) {
            return;
        }

        for (Map.Entry<ASTNode, CodeBlock> entry : nodeToBlockMap.entrySet()) {
            ASTNode node = entry.getKey();
            CodeBlock block = entry.getValue();

            // Calculate which lines this node spans
            int startLine = getLineNumber(node.getStartPosition());
            int endLine = getLineNumber(node.getStartPosition() + node.getLength());

            // Add block to all lines it spans
            for (int line = startLine; line <= endLine; line++) {
                lineToBlocksMap.computeIfAbsent(line, k -> new HashSet<>()).add(block);
            }
        }
    }

    public void processDiagnostics(List<Diagnostic> diagnostics) {
        this.lastDiagnostics = diagnostics;

        // Clear previous errors
        for (CodeBlock block : blocksWithErrors) {
            block.clearError();
        }
        blocksWithErrors.clear();

        if (nodeToBlockMap == null) return;

        // Process new diagnostics
        for (Diagnostic diagnostic : diagnostics) {
            // Only show errors, not warnings (unless you want warnings too)
            if (diagnostic.getSeverity() != DiagnosticSeverity.Error) {
                continue;
            }

            Optional<CodeBlock> blockOpt = findBlockForDiagnostic(diagnostic);

            if (blockOpt.isPresent()) {
                CodeBlock block = blockOpt.get();

                // Use translated error message
                String userFriendlyMessage = ErrorTranslator.getShortSummary(diagnostic);
                String suggestion = ErrorTranslator.getSuggestion(diagnostic);

                block.setError(userFriendlyMessage + "\n" + suggestion);
                blocksWithErrors.add(block);
            } else {
                // Log unmapped diagnostics for debugging
                System.err.println("Warning: Could not map diagnostic to block: " +
                        diagnostic.getMessage() + " at line " +
                        (diagnostic.getRange().getStart().getLine() + 1));
            }
        }
    }

    /**
     * Finds the code block responsible for a diagnostic.
     * Uses multiple strategies for better matching.
     */
    public Optional<CodeBlock> findBlockForDiagnostic(Diagnostic diagnostic) {
        // Strategy 1: Precise AST node matching (best)
        Optional<CodeBlock> block = findBlockByASTNode(diagnostic);
        if (block.isPresent()) {
            return block;
        }

        // Strategy 2: Line-based fallback (good for edge cases)
        block = findBlockByLine(diagnostic);
        if (block.isPresent()) {
            return block;
        }

        // Strategy 3: Parent node search (for nested expressions)
        return findBlockByParentNode(diagnostic);
    }

    /**
     * Strategy 1: Find block by matching AST node ranges
     */
    private Optional<CodeBlock> findBlockByASTNode(Diagnostic diagnostic) {
        int startOffset = getOffsetFromPosition(diagnostic.getRange().getStart());
        int endOffset = getOffsetFromPosition(diagnostic.getRange().getEnd());

        // Find the most specific (smallest) block that contains the diagnostic range
        ASTNode bestNode = null;
        int bestLength = Integer.MAX_VALUE;

        for (ASTNode node : nodeToBlockMap.keySet()) {
            int nodeStart = node.getStartPosition();
            int nodeEnd = nodeStart + node.getLength();

            // Check if node contains the diagnostic range
            if (nodeStart <= startOffset && nodeEnd >= endOffset) {
                int nodeLength = node.getLength();

                // Prefer the smallest containing node
                if (nodeLength < bestLength) {
                    bestNode = node;
                    bestLength = nodeLength;
                }
            }
        }

        return Optional.ofNullable(bestNode).map(nodeToBlockMap::get);
    }

    /**
     * Strategy 2: Find block by line number (fallback)
     */
    private Optional<CodeBlock> findBlockByLine(Diagnostic diagnostic) {
        int line = diagnostic.getRange().getStart().getLine();

        Set<CodeBlock> blocksOnLine = lineToBlocksMap.get(line);
        if (blocksOnLine == null || blocksOnLine.isEmpty()) {
            return Optional.empty();
        }

        // If multiple blocks on same line, prefer the first one
        // (Could be improved with more sophisticated heuristics)
        return blocksOnLine.stream().findFirst();
    }

    /**
     * Strategy 3: Find block by searching parent nodes
     */
    private Optional<CodeBlock> findBlockByParentNode(Diagnostic diagnostic) {
        int startOffset = getOffsetFromPosition(diagnostic.getRange().getStart());

        // Find any node that contains the start position
        for (ASTNode node : nodeToBlockMap.keySet()) {
            int nodeStart = node.getStartPosition();
            int nodeEnd = nodeStart + node.getLength();

            if (nodeStart <= startOffset && nodeEnd >= startOffset) {
                return Optional.of(nodeToBlockMap.get(node));
            }
        }

        return Optional.empty();
    }

    /**
     * Converts LSP position to source code offset
     */
    private int getOffsetFromPosition(org.eclipse.lsp4j.Position pos) {
        int line = pos.getLine();
        int character = pos.getCharacter();
        int offset = 0;
        int currentLine = 0;

        if (sourceCode == null) return 0;

        while (currentLine < line && offset < sourceCode.length()) {
            if (sourceCode.charAt(offset) == '\n') {
                currentLine++;
            }
            offset++;
        }

        return offset + character;
    }

    /**
     * Gets line number from character offset
     */
    private int getLineNumber(int offset) {
        if (sourceCode == null || offset < 0) return 0;

        int line = 0;
        for (int i = 0; i < Math.min(offset, sourceCode.length()); i++) {
            if (sourceCode.charAt(i) == '\n') {
                line++;
            }
        }
        return line;
    }

    /**
     * Get all blocks that have errors (useful for UI highlighting)
     */
    public Set<CodeBlock> getBlocksWithErrors() {
        return Collections.unmodifiableSet(blocksWithErrors);
    }

    /**
     * Check if a specific block has errors
     */
    public boolean hasError(CodeBlock block) {
        return blocksWithErrors.contains(block);
    }

    /**
     * Get diagnostics for a specific block
     */
    public List<Diagnostic> getDiagnosticsForBlock(CodeBlock block) {
        if (lastDiagnostics == null || nodeToBlockMap == null) {
            return Collections.emptyList();
        }

        List<Diagnostic> blockDiagnostics = new ArrayList<>();

        for (Diagnostic diagnostic : lastDiagnostics) {
            Optional<CodeBlock> diagBlock = findBlockForDiagnostic(diagnostic);
            if (diagBlock.isPresent() && diagBlock.get() == block) {
                blockDiagnostics.add(diagnostic);
            }
        }

        return blockDiagnostics;
    }

    /**
     * Get a summary of all errors (useful for status bar)
     */
    public String getErrorSummary() {
        if (!hasErrors()) {
            return "✅ No errors";
        }

        long errorCount = lastDiagnostics.stream()
                .filter(d -> d.getSeverity() == DiagnosticSeverity.Error)
                .count();

        long warningCount = lastDiagnostics.stream()
                .filter(d -> d.getSeverity() == DiagnosticSeverity.Warning)
                .count();

        StringBuilder summary = new StringBuilder();
        if (errorCount > 0) {
            summary.append(String.format("❌ %d error%s", errorCount, errorCount == 1 ? "" : "s"));
        }
        if (warningCount > 0) {
            if (summary.length() > 0) summary.append(", ");
            summary.append(String.format("⚠️ %d warning%s", warningCount, warningCount == 1 ? "" : "s"));
        }

        return summary.toString();
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/validation/ErrorTranslator.java
=================================================================================

package com.botmaker.validation;

import org.eclipse.lsp4j.Diagnostic;
import org.eclipse.lsp4j.DiagnosticSeverity;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class ErrorTranslator {

    private static final Map<Integer, ErrorInfo> ERROR_MAPPINGS = new HashMap<>();
    private static final Pattern ERROR_CODE_PATTERN = Pattern.compile("\\b(\\d{7,})\\b");

    static class ErrorInfo {
        String userMessage;
        String suggestion;
        DiagnosticSeverity severity;

        ErrorInfo(String userMessage, String suggestion, DiagnosticSeverity severity) {
            this.userMessage = userMessage;
            this.suggestion = suggestion;
            this.severity = severity;
        }

        ErrorInfo(String userMessage, String suggestion) {
            this(userMessage, suggestion, DiagnosticSeverity.Error);
        }
    }

    static {
        // PRIORITY 1: Critical Errors (Must Handle)

        // 16777233 - TypeMismatch
        ERROR_MAPPINGS.put(16777233, new ErrorInfo(
                "Wrong type used: You're trying to use a {0} where a {1} is expected",
                "Check that you're using the right type of value (number, text, true/false, etc.)"
        ));

        // 570425394 - UndefinedName (Variable doesn't exist)
        ERROR_MAPPINGS.put(570425394, new ErrorInfo(
                "Variable or name '{0}' doesn't exist",
                "Did you forget to create this variable? Check for typos in the name."
        ));

        // 536870963 - UninitializedLocalVariable
        ERROR_MAPPINGS.put(536870963, new ErrorInfo(
                "Variable '{0}' is used before being given a value",
                "Set a value to this variable before using it."
        ));

        // 536870967 - RedefinedLocal (Duplicate variable)
        ERROR_MAPPINGS.put(536870967, new ErrorInfo(
                "A variable named '{0}' already exists",
                "Choose a different name or remove the duplicate variable."
        ));

        // 67108979 - ParameterMismatch
        ERROR_MAPPINGS.put(67108979, new ErrorInfo(
                "Wrong number of parameters: Expected {0} but got {1}",
                "Check how many inputs this function needs."
        ));

        // 603979884 - ShouldReturnValue
        ERROR_MAPPINGS.put(603979884, new ErrorInfo(
                "This function must return a value",
                "Add a return statement with a value at the end of the function."
        ));

        // PRIORITY 2: Type System Errors

        // 16777218 - UndefinedType
        ERROR_MAPPINGS.put(16777218, new ErrorInfo(
                "Type '{0}' cannot be found",
                "This type doesn't exist. Check for typos or missing imports."
        ));

        // 67108964 - UndefinedMethod
        ERROR_MAPPINGS.put(67108964, new ErrorInfo(
                "Method '{0}' doesn't exist",
                "Check the spelling of the method name or if it's available."
        ));

        // 33554502 - UndefinedField
        ERROR_MAPPINGS.put(33554502, new ErrorInfo(
                "Field '{0}' doesn't exist",
                "This field is not defined. Check the name and spelling."
        ));

        // PRIORITY 3: Syntax Errors (If user can edit code)

        // 1610612960 - MissingSemiColon
        ERROR_MAPPINGS.put(1610612960, new ErrorInfo(
                "Missing semicolon (;) at the end of the line",
                "Add a semicolon (;) at the end of this statement."
        ));

        // 1610612995 - UnterminatedString
        ERROR_MAPPINGS.put(1610612995, new ErrorInfo(
                "Text is missing a closing quote",
                "Add a closing quote (\") at the end of the text."
        ));

        // 1610612941 - ParsingErrorNoSuggestion
        ERROR_MAPPINGS.put(1610612941, new ErrorInfo(
                "Syntax error: The code structure is incorrect",
                "Check for missing brackets, parentheses, or other syntax issues."
        ));

        // 1610612956 - UnmatchedBracket
        ERROR_MAPPINGS.put(1610612956, new ErrorInfo(
                "Unmatched bracket - missing opening or closing bracket",
                "Check that all { } brackets are properly paired."
        ));

        // PRIORITY 4: Flow Control

        // 536870908 - InvalidBreak
        ERROR_MAPPINGS.put(536870908, new ErrorInfo(
                "'break' can only be used inside a loop or switch",
                "Move this break statement inside a loop block."
        ));

        // 536870909 - InvalidContinue
        ERROR_MAPPINGS.put(536870909, new ErrorInfo(
                "'continue' can only be used inside a loop",
                "Move this continue statement inside a loop block."
        ));

        // 536870161 - CodeCannotBeReached
        ERROR_MAPPINGS.put(536870161, new ErrorInfo(
                "This code will never run (unreachable code)",
                "Remove this code or fix the logic that prevents it from running.",
                DiagnosticSeverity.Warning
        ));

        // PRIORITY 5: Warnings

        // 536870973 - LocalVariableIsNeverUsed
        ERROR_MAPPINGS.put(536870973, new ErrorInfo(
                "Variable '{0}' is created but never used",
                "Remove this variable or use it somewhere in your code.",
                DiagnosticSeverity.Warning
        ));

        // 536870974 - ArgumentIsNeverUsed
        ERROR_MAPPINGS.put(536870974, new ErrorInfo(
                "Parameter '{0}' is never used",
                "Remove this parameter or use it in the function.",
                DiagnosticSeverity.Warning
        ));

        // 536871185 - AssignmentHasNoEffect
        ERROR_MAPPINGS.put(536871185, new ErrorInfo(
                "This assignment does nothing",
                "You're assigning a variable to itself. Remove this line or fix the logic.",
                DiagnosticSeverity.Warning
        ));
    }

    /**
     * Extracts the JDT error code from a diagnostic message
     */
    private static Integer extractErrorCode(String message) {
        Matcher matcher = ERROR_CODE_PATTERN.matcher(message);
        if (matcher.find()) {
            try {
                return Integer.parseInt(matcher.group(1));
            } catch (NumberFormatException e) {
                return null;
            }
        }
        return null;
    }

    /**
     * Translates diagnostics to user-friendly messages
     */
    public static String translate(List<Diagnostic> diagnostics) {
        if (diagnostics == null || diagnostics.isEmpty()) {
            return "✅ No errors found. Your code looks good!";
        }

        StringBuilder result = new StringBuilder();
        int errorCount = 0;
        int warningCount = 0;

        for (Diagnostic diagnostic : diagnostics) {
            if (diagnostic.getSeverity() == DiagnosticSeverity.Error) {
                errorCount++;
            } else if (diagnostic.getSeverity() == DiagnosticSeverity.Warning) {
                warningCount++;
            }
        }

        if (errorCount > 0) {
            result.append(String.format("❌ Found %d error%s:\n\n", errorCount, errorCount == 1 ? "" : "s"));
        }
        if (warningCount > 0) {
            result.append(String.format("⚠️  Found %d warning%s:\n\n", warningCount, warningCount == 1 ? "" : "s"));
        }

        for (Diagnostic diagnostic : diagnostics) {
            String icon = diagnostic.getSeverity() == DiagnosticSeverity.Error ? "❌" : "⚠️";
            int lineNumber = diagnostic.getRange().getStart().getLine() + 1;

            String translated = translateSingleDiagnostic(diagnostic);
            result.append(String.format("%s Line %d: %s\n\n", icon, lineNumber, translated));
        }

        return result.toString().trim();
    }

    /**
     * Translates a single diagnostic to a user-friendly message
     */
    public static String translateSingleDiagnostic(Diagnostic diagnostic) {
        String originalMessage = diagnostic.getMessage();

        // Try to extract error code
        Integer errorCode = extractErrorCode(originalMessage);

        if (errorCode != null && ERROR_MAPPINGS.containsKey(errorCode)) {
            ErrorInfo info = ERROR_MAPPINGS.get(errorCode);

            // Try to extract variable/type names from the original message
            String enrichedMessage = enrichMessage(info.userMessage, originalMessage);

            return String.format("%s\n   💡 %s", enrichedMessage, info.suggestion);
        }

        // Fallback: Try pattern matching for common error messages (backward compatibility)
        return translateByPattern(originalMessage);
    }

    /**
     * Enriches the user message with context from the original error message
     */
    private static String enrichMessage(String template, String originalMessage) {
        // Extract quoted strings (variable names, type names, etc.)
        Pattern quotedPattern = Pattern.compile("'([^']+)'|\"([^\"]+)\"");
        Matcher matcher = quotedPattern.matcher(originalMessage);

        int index = 0;
        String result = template;
        while (matcher.find() && result.contains("{" + index + "}")) {
            String value = matcher.group(1) != null ? matcher.group(1) : matcher.group(2);
            result = result.replace("{" + index + "}", "'" + value + "'");
            index++;
        }

        // Remove unreplaced placeholders
        result = result.replaceAll("\\{\\d+\\}", "the value");

        return result;
    }

    /**
     * Fallback pattern-based translation (for backward compatibility)
     */
    private static String translateByPattern(String message) {
        if (message.contains("cannot be resolved to a type")) {
            return "A type or class could not be found.\n   💡 Check for typos or if the type exists.";
        }
        if (message.contains("cannot be resolved")) {
            return "A variable, method, or name could not be found.\n   💡 Check for typos or if it was declared.";
        }
        if (message.contains("Syntax error, insert")) {
            try {
                String suggestion = message.split("insert \"")[1].split("\" to")[0];
                return String.format("Syntax error: Something is missing.\n   💡 Try adding '%s'", suggestion);
            } catch (Exception e) {
                return "Syntax error: Something is missing in the code structure.\n   💡 Check for missing semicolons, brackets, or parentheses.";
            }
        }
        if (message.contains("incompatible types") || message.contains("Type mismatch")) {
            return "Wrong type used: You're using a value of the wrong type.\n   💡 Make sure you're using the right kind of value (number, text, etc.)";
        }
        if (message.contains("might not have been initialized")) {
            return "Variable used before being set.\n   💡 Give this variable a value before using it.";
        }
        if (message.contains("is not a statement")) {
            return "This line is not a valid statement.\n   💡 It might be an incomplete expression or command.";
        }
        if (message.contains("Duplicate local variable")) {
            return "A variable with this name already exists.\n   💡 Choose a different name for this variable.";
        }

        // Return original message if no translation found
        return message;
    }

    /**
     * Get a short summary for UI display (e.g., tooltip)
     */
    public static String getShortSummary(Diagnostic diagnostic) {
        String originalMessage = diagnostic.getMessage();
        Integer errorCode = extractErrorCode(originalMessage);

        if (errorCode != null && ERROR_MAPPINGS.containsKey(errorCode)) {
            ErrorInfo info = ERROR_MAPPINGS.get(errorCode);
            return enrichMessage(info.userMessage, originalMessage);
        }

        // Fallback: Return first line of original message
        return originalMessage.split("\n")[0];
    }

    /**
     * Get just the suggestion part
     */
    public static String getSuggestion(Diagnostic diagnostic) {
        String originalMessage = diagnostic.getMessage();
        Integer errorCode = extractErrorCode(originalMessage);

        if (errorCode != null && ERROR_MAPPINGS.containsKey(errorCode)) {
            return ERROR_MAPPINGS.get(errorCode).suggestion;
        }

        return "Check your code for issues.";
    }
}


