=================================================================================
FILE: ./src/main/java/com/botmaker/blocks/AssignmentBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractStatementBlock;
import com.botmaker.core.ExpressionBlock;
import com.botmaker.lsp.CompletionContext;
import javafx.geometry.Pos;
import javafx.scene.Node;
import javafx.scene.control.Button;
import javafx.scene.control.ComboBox;
import javafx.scene.control.ContextMenu;
import javafx.scene.control.MenuItem;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Pane;
import javafx.scene.layout.Priority;
import org.eclipse.jdt.core.dom.Assignment;
import org.eclipse.jdt.core.dom.ExpressionStatement;
import org.eclipse.jdt.core.dom.PostfixExpression;
import org.eclipse.jdt.core.dom.PrefixExpression;

public class AssignmentBlock extends AbstractStatementBlock {

    private ExpressionBlock leftHandSide;
    private ExpressionBlock rightHandSide;
    private String operator;

    private static final String[] OPERATOR_NAMES = {
            "set to", "add", "subtract", "multiply by", "divide by", "increment", "decrement"
    };

    private static final String[] OPERATOR_SYMBOLS = {
            "=", "+=", "-=", "*=", "/=", "++", "--"
    };

    public AssignmentBlock(String id, ExpressionStatement astNode) {
        super(id, astNode);

        if (astNode.getExpression() instanceof Assignment) {
            Assignment assignment = (Assignment) astNode.getExpression();
            this.operator = assignment.getOperator().toString();
        } else if (astNode.getExpression() instanceof PostfixExpression) {
            PostfixExpression postfix = (PostfixExpression) astNode.getExpression();
            this.operator = postfix.getOperator().toString();
        } else if (astNode.getExpression() instanceof PrefixExpression) {
            PrefixExpression prefix = (PrefixExpression) astNode.getExpression();
            this.operator = prefix.getOperator().toString();
        } else {
            this.operator = "=";
        }
    }

    public ExpressionBlock getLeftHandSide() {
        return leftHandSide;
    }

    public void setLeftHandSide(ExpressionBlock leftHandSide) {
        this.leftHandSide = leftHandSide;
    }

    public ExpressionBlock getRightHandSide() {
        return rightHandSide;
    }

    public void setRightHandSide(ExpressionBlock rightHandSide) {
        this.rightHandSide = rightHandSide;
    }

    public String getOperator() {
        return operator;
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        HBox container = new HBox(5);
        container.setAlignment(Pos.CENTER_LEFT);
        container.getStyleClass().add("assignment-block");

        // Left hand side
        if (leftHandSide != null) {
            container.getChildren().add(leftHandSide.getUINode(context));
        }

        // Operator selector
        ComboBox<String> operatorSelector = new ComboBox<>();
        operatorSelector.getItems().addAll(OPERATOR_NAMES);
        operatorSelector.getStyleClass().add("operator-selector");
        operatorSelector.setEditable(false);

        String currentName = getOperatorDisplayName(operator);
        operatorSelector.setValue(currentName);

        operatorSelector.setOnAction(e -> {
            String selectedName = operatorSelector.getValue();
            String newOperator = getOperatorSymbol(selectedName);

            // Only update if it actually changed
            if (newOperator != null && !newOperator.equals(this.operator)) {
                this.operator = newOperator;

                // THE FIX: Actually write to file
                context.codeEditor().updateAssignmentOperator(this.astNode, newOperator);
            }
        });

        container.getChildren().add(operatorSelector);

        // Right hand side (only for non-increment/decrement)
        if (!operator.equals("++") && !operator.equals("--")) {
            if (rightHandSide != null) {
                container.getChildren().add(rightHandSide.getUINode(context));
            }

            // + Button for changing right side expression
            Button addButton = new Button("+");
            addButton.getStyleClass().add("expression-add-button");
            addButton.setOnAction(e -> showExpressionMenu(addButton, context));
            container.getChildren().add(addButton);
        }

        // Spacer and delete button
        Pane spacer = new Pane();
        HBox.setHgrow(spacer, Priority.ALWAYS);

        Button deleteButton = new Button("X");
        deleteButton.setOnAction(e -> {
            context.codeEditor().deleteStatement((org.eclipse.jdt.core.dom.Statement) this.astNode);
        });

        container.getChildren().addAll(spacer, deleteButton);

        return container;
    }

    private void showExpressionMenu(Button button, CompletionContext context) {
        ContextMenu menu = new ContextMenu();

        for (com.botmaker.ui.AddableExpression type : com.botmaker.ui.AddableExpression.values()) {
            MenuItem menuItem = new MenuItem(type.getDisplayName());
            menuItem.setOnAction(e -> {
                if (rightHandSide != null) {
                    org.eclipse.jdt.core.dom.Expression toReplace = (org.eclipse.jdt.core.dom.Expression) rightHandSide.getAstNode();
                    context.codeEditor().replaceExpression(toReplace, type);
                }
            });
            menu.getItems().add(menuItem);
        }

        menu.show(button, javafx.geometry.Side.BOTTOM, 0, 0);
    }

    private String getOperatorDisplayName(String symbol) {
        for (int i = 0; i < OPERATOR_SYMBOLS.length; i++) {
            if (OPERATOR_SYMBOLS[i].equals(symbol)) {
                return OPERATOR_NAMES[i];
            }
        }
        return "set to";
    }

    private String getOperatorSymbol(String displayName) {
        for (int i = 0; i < OPERATOR_NAMES.length; i++) {
            if (OPERATOR_NAMES[i].equals(displayName)) {
                return OPERATOR_SYMBOLS[i];
            }
        }
        return "=";
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/blocks/BinaryExpressionBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractExpressionBlock;
import com.botmaker.core.ExpressionBlock;
import com.botmaker.lsp.CompletionContext;
import javafx.geometry.Pos;
import javafx.scene.Node;
import javafx.scene.control.ComboBox;
import javafx.scene.control.Label;
import javafx.scene.layout.HBox;
import org.eclipse.jdt.core.dom.ITypeBinding;
import org.eclipse.jdt.core.dom.InfixExpression;

public class BinaryExpressionBlock extends AbstractExpressionBlock {

    private ExpressionBlock leftOperand;
    private ExpressionBlock rightOperand;
    private String operator;
    private final ITypeBinding returnType;

    // Math operator display names (user-friendly)
    private static final String[] MATH_OPERATOR_NAMES = {
            "plus",         // +
            "minus",        // -
            "times",        // *
            "divided by",   // /
            "modulo"        // %
    };

    // Corresponding Java operators
    private static final String[] MATH_OPERATOR_SYMBOLS = {
            "+", "-", "*", "/", "%"
    };

    public BinaryExpressionBlock(String id, InfixExpression astNode) {
        super(id, astNode);
        this.operator = astNode.getOperator().toString();
        this.returnType = astNode.resolveTypeBinding();
    }

    public ExpressionBlock getLeftOperand() {
        return leftOperand;
    }

    public void setLeftOperand(ExpressionBlock leftOperand) {
        this.leftOperand = leftOperand;
    }

    public ExpressionBlock getRightOperand() {
        return rightOperand;
    }

    public void setRightOperand(ExpressionBlock rightOperand) {
        this.rightOperand = rightOperand;
    }

    public String getOperator() {
        return operator;
    }

    public ITypeBinding getReturnType() {
        return returnType;
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        HBox container = new HBox(5);
        container.setAlignment(Pos.CENTER_LEFT);
        container.getStyleClass().add("binary-expression-block");

        HBox expressionBox = new HBox(5);
        expressionBox.setAlignment(Pos.CENTER_LEFT);

        // Left operand
        if (leftOperand != null) {
            expressionBox.getChildren().add(leftOperand.getUINode(context));
        }

        // Check if this is a math operator or comparison/logical operator
        if (isMathOperator(operator)) {
            // Operator selector for math operations
            ComboBox<String> operatorSelector = new ComboBox<>();
            operatorSelector.getItems().addAll(MATH_OPERATOR_NAMES);
            operatorSelector.getStyleClass().add("math-operator-selector");

            // Set current operator
            String currentName = getOperatorDisplayName(operator);
            operatorSelector.setValue(currentName);

            // Handle operator change
            operatorSelector.setOnAction(e -> {
                String selectedName = operatorSelector.getValue();
                String newOperator = getOperatorSymbol(selectedName);
                if (newOperator != null && !newOperator.equals(operator)) {
                    this.operator = newOperator;
                    System.out.println("Math operator changed to: " + newOperator);
                    // Note: Operator change will take effect on next code regeneration
                }
            });

            expressionBox.getChildren().add(operatorSelector);
        } else {
            // For non-math operators (comparisons, logical), just show the symbol
            Label operatorLabel = new Label(operator);
            operatorLabel.getStyleClass().add("operator-label");
            expressionBox.getChildren().add(operatorLabel);
        }

        // Right operand
        if (rightOperand != null) {
            expressionBox.getChildren().add(rightOperand.getUINode(context));
        }

        container.getChildren().add(expressionBox);

        // Type indicator (optional, can be removed if too cluttered)
        String typeName = "unknown";
        if (returnType != null) {
            typeName = returnType.getName();
        }
        Label typeLabel = new Label("→ " + typeName);
        typeLabel.setStyle("-fx-font-style: italic; -fx-text-fill: #999; -fx-font-size: 10px;");
        container.getChildren().add(typeLabel);

        return container;
    }

    /**
     * Check if operator is a math operator
     */
    private boolean isMathOperator(String op) {
        for (String mathOp : MATH_OPERATOR_SYMBOLS) {
            if (mathOp.equals(op)) {
                return true;
            }
        }
        return false;
    }

    /**
     * Convert operator symbol to display name
     */
    private String getOperatorDisplayName(String symbol) {
        for (int i = 0; i < MATH_OPERATOR_SYMBOLS.length; i++) {
            if (MATH_OPERATOR_SYMBOLS[i].equals(symbol)) {
                return MATH_OPERATOR_NAMES[i];
            }
        }
        return symbol; // Return as-is if not found
    }

    /**
     * Convert display name to operator symbol
     */
    private String getOperatorSymbol(String displayName) {
        for (int i = 0; i < MATH_OPERATOR_NAMES.length; i++) {
            if (MATH_OPERATOR_NAMES[i].equals(displayName)) {
                return MATH_OPERATOR_SYMBOLS[i];
            }
        }
        return "+"; // default
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/blocks/BooleanLiteralBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractExpressionBlock;
import com.botmaker.lsp.CompletionContext;
import javafx.scene.Node;
import javafx.scene.control.ComboBox;
import javafx.scene.layout.HBox;
import org.eclipse.jdt.core.dom.BooleanLiteral;

/**
 * Block for true/false values with dropdown selection
 * User-friendly for non-coders
 */
public class BooleanLiteralBlock extends AbstractExpressionBlock {

    private boolean value;

    public BooleanLiteralBlock(String id, BooleanLiteral astNode) {
        super(id, astNode);
        this.value = astNode.booleanValue();
    }

    public boolean getValue() {
        return value;
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        HBox container = new HBox();
        container.setAlignment(javafx.geometry.Pos.CENTER_LEFT);
        container.getStyleClass().add("boolean-literal-block");

        // Dropdown for true/false
        ComboBox<String> booleanSelector = new ComboBox<>();
        booleanSelector.getItems().addAll("true", "false");
        booleanSelector.setValue(value ? "true" : "false");
        booleanSelector.getStyleClass().add("boolean-selector");
        booleanSelector.setEditable(false);

        // Handle value change
        booleanSelector.setOnAction(e -> {
            String selected = booleanSelector.getValue();
            boolean newValue = "true".equals(selected);

            if (newValue != value) {
                this.value = newValue;
                // Update the AST
                context.codeEditor().replaceLiteralValue(
                        (org.eclipse.jdt.core.dom.Expression) this.astNode,
                        String.valueOf(newValue)
                );
            }
        });

        container.getChildren().add(booleanSelector);

        return container;
    }

    @Override
    public String getDetails() {
        return "Boolean: " + value;
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/blocks/BreakBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractStatementBlock;
import com.botmaker.lsp.CompletionContext;
import javafx.geometry.Pos;
import javafx.scene.Node;
import javafx.scene.control.Label;
import javafx.scene.layout.HBox;
import org.eclipse.jdt.core.dom.BreakStatement;

public class BreakBlock extends AbstractStatementBlock {

    public BreakBlock(String id, BreakStatement astNode) {
        super(id, astNode);
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        HBox container = new HBox(5);
        container.setAlignment(Pos.CENTER_LEFT);
        container.getStyleClass().add("break-block");

        Label breakLabel = new Label("break");
        breakLabel.getStyleClass().add("keyword-label");

        // Add spacer and delete button
        javafx.scene.layout.Pane spacer = new javafx.scene.layout.Pane();
        HBox.setHgrow(spacer, javafx.scene.layout.Priority.ALWAYS);

        javafx.scene.control.Button deleteButton = new javafx.scene.control.Button("X");
        deleteButton.setOnAction(e -> {
            context.codeEditor().deleteStatement((org.eclipse.jdt.core.dom.Statement) this.astNode);
        });

        container.getChildren().addAll(breakLabel, spacer, deleteButton);
        return container;
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/blocks/CommentBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractStatementBlock;
import com.botmaker.lsp.CompletionContext;
import javafx.geometry.Pos;
import javafx.scene.Node;
import javafx.scene.control.Button;
import javafx.scene.control.TextField;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Pane;
import javafx.scene.layout.Priority;
import org.eclipse.jdt.core.dom.Comment;

public class CommentBlock extends AbstractStatementBlock {

    private String commentText;

    public CommentBlock(String id, Comment astNode, String commentText) {
        super(id, astNode);
        this.commentText = commentText;
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        HBox container = new HBox(5);
        container.setAlignment(Pos.CENTER_LEFT);
        container.getStyleClass().add("comment-block");

        // Simple user-friendly label
        javafx.scene.control.Label commentLabel = new javafx.scene.control.Label("Comment:");
        commentLabel.getStyleClass().add("comment-indicator");

        // Text Field
        TextField commentField = new TextField(commentText != null ? commentText : "");
        commentField.setPromptText("Write your note here...");
        commentField.getStyleClass().add("comment-text-field");
        HBox.setHgrow(commentField, Priority.ALWAYS);

        // Save on Focus Lost
        commentField.focusedProperty().addListener((obs, oldVal, newVal) -> {
            if (!newVal) {
                if (!commentField.getText().equals(commentText)) {
                    this.commentText = commentField.getText();
                    rebuildCode(context);
                }
            }
        });

        // Save on Enter
        commentField.setOnAction(e -> {
            this.commentText = commentField.getText();
            rebuildCode(context);
            container.requestFocus();
        });

        Pane spacer = new Pane();
        HBox.setHgrow(spacer, Priority.ALWAYS);

        // Delete Button
        Button deleteButton = new Button("X");
        deleteButton.setOnAction(e -> {
            context.codeEditor().deleteComment((Comment) this.astNode);
        });

        container.getChildren().addAll(commentLabel, commentField, spacer, deleteButton);
        return container;
    }

    private void rebuildCode(CompletionContext context) {
        javafx.application.Platform.runLater(() -> {
            context.codeEditor().updateComment((Comment) this.astNode, this.commentText);
        });
    }

    @Override
    public String getDetails() {
        return "Comment: " + (commentText != null ? commentText : "");
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/blocks/ComparisonExpressionBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractExpressionBlock;
import com.botmaker.core.ExpressionBlock;
import com.botmaker.lsp.CompletionContext;
import javafx.geometry.Pos;
import javafx.scene.Node;
import javafx.scene.control.ComboBox;
import javafx.scene.layout.HBox;
import org.eclipse.jdt.core.dom.ITypeBinding;
import org.eclipse.jdt.core.dom.InfixExpression;

public class ComparisonExpressionBlock extends AbstractExpressionBlock {

    private ExpressionBlock leftOperand;
    private ExpressionBlock rightOperand;
    private String operator;
    private final ITypeBinding returnType;

    // Operator display names (user-friendly)
    private static final String[] OPERATOR_NAMES = {
            "less than",                    // <
            "less than or equal",           // <=
            "greater than",                 // >
            "greater than or equal",        // >=
            "equal to",                     // ==
            "not equal to"                  // !=
    };

    // Corresponding Java operators
    private static final String[] OPERATOR_SYMBOLS = {
            "<", "<=", ">", ">=", "==", "!="
    };

    public ComparisonExpressionBlock(String id, InfixExpression astNode) {
        super(id, astNode);
        this.operator = astNode.getOperator().toString();
        this.returnType = astNode.resolveTypeBinding();
    }

    public ExpressionBlock getLeftOperand() {
        return leftOperand;
    }

    public void setLeftOperand(ExpressionBlock leftOperand) {
        this.leftOperand = leftOperand;
    }

    public ExpressionBlock getRightOperand() {
        return rightOperand;
    }

    public void setRightOperand(ExpressionBlock rightOperand) {
        this.rightOperand = rightOperand;
    }

    public String getOperator() {
        return operator;
    }

    public ITypeBinding getReturnType() {
        return returnType;
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        HBox container = new HBox(5);
        container.setAlignment(Pos.CENTER_LEFT);
        container.getStyleClass().add("comparison-expression-block");

        // Left operand
        if (leftOperand != null) {
            container.getChildren().add(leftOperand.getUINode(context));
        }

        // Operator selector - shows user-friendly names
        ComboBox<String> operatorSelector = new ComboBox<>();
        operatorSelector.getItems().addAll(OPERATOR_NAMES);
        operatorSelector.getStyleClass().add("comparison-operator-selector");

        // Set current operator
        String currentName = getOperatorDisplayName(operator);
        operatorSelector.setValue(currentName);

        // Handle operator change
        operatorSelector.setOnAction(e -> {
            String selectedName = operatorSelector.getValue();
            String newOperator = getOperatorSymbol(selectedName);
            if (newOperator != null && !newOperator.equals(operator)) {
                this.operator = newOperator;
                // Trigger code regeneration with new operator
                System.out.println("Comparison operator changed to: " + newOperator);
            }
        });

        container.getChildren().add(operatorSelector);

        // Right operand
        if (rightOperand != null) {
            container.getChildren().add(rightOperand.getUINode(context));
        }

        return container;
    }

    /**
     * Convert operator symbol to display name
     */
    private String getOperatorDisplayName(String symbol) {
        for (int i = 0; i < OPERATOR_SYMBOLS.length; i++) {
            if (OPERATOR_SYMBOLS[i].equals(symbol)) {
                return OPERATOR_NAMES[i];
            }
        }
        return "equal to"; // default
    }

    /**
     * Convert display name to operator symbol
     */
    private String getOperatorSymbol(String displayName) {
        for (int i = 0; i < OPERATOR_NAMES.length; i++) {
            if (OPERATOR_NAMES[i].equals(displayName)) {
                return OPERATOR_SYMBOLS[i];
            }
        }
        return "=="; // default
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/blocks/ContinueBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractStatementBlock;
import com.botmaker.lsp.CompletionContext;
import javafx.geometry.Pos;
import javafx.scene.Node;
import javafx.scene.control.Label;
import javafx.scene.layout.HBox;
import org.eclipse.jdt.core.dom.ContinueStatement;

public class ContinueBlock extends AbstractStatementBlock {

    public ContinueBlock(String id, ContinueStatement astNode) {
        super(id, astNode);
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        HBox container = new HBox(5);
        container.setAlignment(Pos.CENTER_LEFT);
        container.getStyleClass().add("continue-block");

        Label continueLabel = new Label("continue");
        continueLabel.getStyleClass().add("keyword-label");

        // Add spacer and delete button
        javafx.scene.layout.Pane spacer = new javafx.scene.layout.Pane();
        HBox.setHgrow(spacer, javafx.scene.layout.Priority.ALWAYS);

        javafx.scene.control.Button deleteButton = new javafx.scene.control.Button("X");
        deleteButton.setOnAction(e -> {
            context.codeEditor().deleteStatement((org.eclipse.jdt.core.dom.Statement) this.astNode);
        });

        container.getChildren().addAll(continueLabel, spacer, deleteButton);
        return container;
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/blocks/DoWhileBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractStatementBlock;
import com.botmaker.core.BodyBlock;
import com.botmaker.core.BlockWithChildren;
import com.botmaker.core.CodeBlock;
import com.botmaker.core.ExpressionBlock;
import com.botmaker.lsp.CompletionContext;
import com.botmaker.ui.BlockDragAndDropManager;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.Node;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Pane;
import javafx.scene.layout.Priority;
import javafx.scene.layout.VBox;
import org.eclipse.jdt.core.dom.DoStatement;

import java.util.ArrayList;
import java.util.List;

public class DoWhileBlock extends AbstractStatementBlock implements BlockWithChildren {

    private ExpressionBlock condition;
    private BodyBlock body;
    private final BlockDragAndDropManager dragAndDropManager;

    public DoWhileBlock(String id, DoStatement astNode, BlockDragAndDropManager dragAndDropManager) {
        super(id, astNode);
        this.dragAndDropManager = dragAndDropManager;
    }

    public ExpressionBlock getCondition() {
        return condition;
    }

    public void setCondition(ExpressionBlock condition) {
        this.condition = condition;
    }

    public BodyBlock getBody() {
        return body;
    }

    public void setBody(BodyBlock body) {
        this.body = body;
    }

    @Override
    public List<CodeBlock> getChildren() {
        List<CodeBlock> children = new ArrayList<>();
        if (body != null) children.add(body);
        if (condition != null) children.add(condition);
        return children;
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        VBox mainContainer = new VBox(5);
        mainContainer.getStyleClass().add("do-while-block");

        // Do header with delete button
        HBox doHeaderRow = new HBox(5);
        doHeaderRow.setAlignment(Pos.CENTER_LEFT);

        Label doLabel = new Label("do");
        doLabel.getStyleClass().add("keyword-label");

        // Add spacer and delete button
        Pane spacer = new Pane();
        HBox.setHgrow(spacer, Priority.ALWAYS);

        Button deleteButton = new Button("X");
        deleteButton.setOnAction(e -> {
            context.codeEditor().deleteStatement((org.eclipse.jdt.core.dom.Statement) this.astNode);
        });

        doHeaderRow.getChildren().addAll(doLabel, spacer, deleteButton);
        mainContainer.getChildren().add(doHeaderRow);

        // Body
        if (body != null) {
            VBox bodyContainer = new VBox();
            bodyContainer.getStyleClass().add("do-while-body");
            bodyContainer.setPadding(new Insets(5, 0, 0, 20));
            bodyContainer.getChildren().add(body.getUINode(context));
            mainContainer.getChildren().add(bodyContainer);
        }

        // While condition
        HBox whileCondition = new HBox(5);
        whileCondition.setAlignment(Pos.CENTER_LEFT);
        whileCondition.getStyleClass().add("do-while-condition");

        Label whileLabel = new Label("while");
        whileLabel.getStyleClass().add("keyword-label");

        whileCondition.getChildren().add(whileLabel);
        if (condition != null) {
            whileCondition.getChildren().add(condition.getUINode(context));
        }

        mainContainer.getChildren().add(whileCondition);

        return mainContainer;
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/blocks/ForBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractStatementBlock;
import com.botmaker.core.BodyBlock;
import com.botmaker.core.BlockWithChildren;
import com.botmaker.core.CodeBlock;
import com.botmaker.core.ExpressionBlock;
import com.botmaker.lsp.CompletionContext;
import com.botmaker.ui.BlockDragAndDropManager;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.Node;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Pane;
import javafx.scene.layout.Priority;
import javafx.scene.layout.VBox;
import org.eclipse.jdt.core.dom.EnhancedForStatement;

import java.util.ArrayList;
import java.util.List;

/**
 * ForEach loop block: for(Type variable : collection) { }
 */
public class ForBlock extends AbstractStatementBlock implements BlockWithChildren {

    private ExpressionBlock variable;
    private ExpressionBlock collection;
    private BodyBlock body;
    private final BlockDragAndDropManager dragAndDropManager;

    public ForBlock(String id, EnhancedForStatement astNode, BlockDragAndDropManager dragAndDropManager) {
        super(id, astNode);
        this.dragAndDropManager = dragAndDropManager;
    }

    public ExpressionBlock getVariable() {
        return variable;
    }

    public void setVariable(ExpressionBlock variable) {
        this.variable = variable;
    }

    public ExpressionBlock getCollection() {
        return collection;
    }

    public void setCollection(ExpressionBlock collection) {
        this.collection = collection;
    }

    public BodyBlock getBody() {
        return body;
    }

    public void setBody(BodyBlock body) {
        this.body = body;
    }

    @Override
    public List<CodeBlock> getChildren() {
        List<CodeBlock> children = new ArrayList<>();
        if (variable != null) children.add(variable);
        if (collection != null) children.add(collection);
        if (body != null) children.add(body);
        return children;
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        VBox mainContainer = new VBox(5);
        mainContainer.getStyleClass().add("for-block");

        // Header row with delete button
        HBox headerRow = new HBox(5);
        headerRow.setAlignment(Pos.CENTER_LEFT);

        // For each parts
        HBox header = new HBox(5);
        header.setAlignment(Pos.CENTER_LEFT);
        header.getStyleClass().add("for-header");

        Label forLabel = new Label("for each");
        forLabel.getStyleClass().add("keyword-label");

        header.getChildren().add(forLabel);

        if (variable != null) {
            header.getChildren().add(variable.getUINode(context));
        }

        Label inLabel = new Label("in");
        header.getChildren().add(inLabel);

        if (collection != null) {
            header.getChildren().add(collection.getUINode(context));
        }

        // Add spacer and delete button
        Pane spacer = new Pane();
        HBox.setHgrow(spacer, Priority.ALWAYS);

        Button deleteButton = new Button("X");
        deleteButton.setOnAction(e -> {
            context.codeEditor().deleteStatement((org.eclipse.jdt.core.dom.Statement) this.astNode);
        });

        headerRow.getChildren().addAll(header, spacer, deleteButton);
        mainContainer.getChildren().add(headerRow);

        // Body
        if (body != null) {
            VBox bodyContainer = new VBox();
            bodyContainer.getStyleClass().add("for-body");
            bodyContainer.setPadding(new Insets(5, 0, 0, 20));
            bodyContainer.getChildren().add(body.getUINode(context));
            mainContainer.getChildren().add(bodyContainer);
        }

        return mainContainer;
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/blocks/IdentifierBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractExpressionBlock;
import com.botmaker.lsp.CompletionContext;
import com.botmaker.validation.TypeValidator;
import javafx.application.Platform;
import javafx.scene.Cursor;
import javafx.scene.Node;
import javafx.scene.control.ContextMenu;
import javafx.scene.control.MenuItem;
import javafx.scene.control.Tooltip;
import javafx.scene.layout.HBox;
import javafx.scene.text.Text;
import org.eclipse.jdt.core.dom.SimpleName;
import org.eclipse.lsp4j.*;

import java.util.List;
import java.util.stream.Collectors;

public class IdentifierBlock extends AbstractExpressionBlock {
    private final String identifier;
    private boolean isUnedited = false;
    private static final String UNEDITED_STYLE_CLASS = "unedited-identifier";

    public IdentifierBlock(String id, SimpleName astNode) {
        this(id, astNode, false);
    }

    public IdentifierBlock(String id, SimpleName astNode, boolean markAsUnedited) {
        super(id, astNode);
        this.identifier = astNode.getIdentifier();
        this.isUnedited = markAsUnedited;
    }

    public String getIdentifier() {
        return identifier;
    }

    public boolean isUnedited() {
        return isUnedited;
    }

    public void markAsEdited() {
        this.isUnedited = false;
        if (uiNode != null) {
            uiNode.getStyleClass().remove(UNEDITED_STYLE_CLASS);
        }
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        Text text = new Text(this.identifier);
        HBox container = new HBox(text);
        container.setAlignment(javafx.geometry.Pos.CENTER_LEFT);
        container.getStyleClass().add("identifier-block");

        if (isUnedited) {
            container.getStyleClass().add(UNEDITED_STYLE_CLASS);
        }

        container.setCursor(Cursor.HAND);

        String tooltipText = isUnedited
                ? "⚠️ Default variable name - Click to choose a variable"
                : "Click to see available variables";

        Tooltip tooltip = new Tooltip(tooltipText);
        Tooltip.install(container, tooltip);

        container.setOnMouseClicked(e -> {
            if (e.getClickCount() == 1) {
                requestSuggestions(container, context);
            }
        });

        if (isUnedited) {
            Platform.runLater(() -> autoPopulateWithSuggestion(container, context));
        }

        return container;
    }

    private void autoPopulateWithSuggestion(Node uiNode, CompletionContext context) {
        try {
            Position pos = getPositionFromOffset(context.sourceCode(), this.astNode.getStartPosition());
            CompletionParams params = new CompletionParams(new TextDocumentIdentifier(context.docUri()), pos);

            context.server().getTextDocumentService().completion(params).thenAccept(result -> {
                if (result == null || (result.isLeft() && result.getLeft().isEmpty()) ||
                        (result.isRight() && result.getRight().getItems().isEmpty())) {
                    return;
                }

                List<CompletionItem> items = result.isLeft() ? result.getLeft() : result.getRight().getItems();

                // Filter for user-friendly variables only
                CompletionItem firstVariable = items.stream()
                        .filter(item -> item.getKind() == CompletionItemKind.Variable)
                        .filter(item -> TypeValidator.isUserVariable(item.getLabel()))
                        .findFirst()
                        .orElse(null);

                if (firstVariable != null) {
                    Platform.runLater(() -> {
                        applySuggestion(firstVariable, context);
                        Tooltip newTooltip = new Tooltip("✓ Auto-selected variable - Click to change");
                        Tooltip.install(uiNode, newTooltip);
                    });
                }
            });
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private void requestSuggestions(Node uiNode, CompletionContext context) {
        try {
            Position pos = getPositionFromOffset(context.sourceCode(), this.astNode.getStartPosition());
            CompletionParams params = new CompletionParams(new TextDocumentIdentifier(context.docUri()), pos);

            context.server().getTextDocumentService().completion(params).thenAccept(result -> {
                if (result == null || (result.isLeft() && result.getLeft().isEmpty()) ||
                        (result.isRight() && result.getRight().getItems().isEmpty())) {
                    return;
                }

                List<CompletionItem> items = result.isLeft() ? result.getLeft() : result.getRight().getItems();

                Platform.runLater(() -> {
                    ContextMenu menu = new ContextMenu();

                    // Filter for user-friendly variables only
                    List<CompletionItem> userVariables = items.stream()
                            .filter(item -> item.getKind() == CompletionItemKind.Variable)
                            .filter(item -> TypeValidator.isUserVariable(item.getLabel()))
                            .collect(Collectors.toList());

                    if (userVariables.isEmpty()) {
                        MenuItem noVars = new MenuItem("(No variables available yet)");
                        noVars.setDisable(true);
                        menu.getItems().add(noVars);
                    } else {
                        for (CompletionItem item : userVariables) {
                            MenuItem mi = new MenuItem(item.getLabel());

                            // Add type information if available
                            if (item.getDetail() != null && !item.getDetail().isEmpty()) {
                                mi.setText(item.getLabel() + " (" + getSimpleTypeName(item.getDetail()) + ")");
                            }

                            mi.setOnAction(event -> {
                                applySuggestion(item, context);
                                markAsEdited();
                            });
                            menu.getItems().add(mi);
                        }
                    }

                    if (!menu.getItems().isEmpty()) {
                        menu.show(uiNode, javafx.geometry.Side.BOTTOM, 0, 0);
                    }
                });
            });
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * Simplify type names for user-friendliness
     */
    private String getSimpleTypeName(String detail) {
        if (detail.contains("int")) return "number";
        if (detail.contains("double") || detail.contains("float")) return "decimal";
        if (detail.contains("boolean")) return "true/false";
        if (detail.contains("String")) return "text";
        if (detail.contains("[]")) return "list";
        return detail.replaceAll(".*\\.", ""); // Remove package names
    }

    private void applySuggestion(CompletionItem item, CompletionContext context) {
        try {
            String insertText = item.getInsertText() != null ? item.getInsertText() : item.getLabel();
            context.codeEditor().replaceSimpleName((SimpleName) this.astNode, insertText);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private Position getPositionFromOffset(String code, int offset) {
        int line = 0;
        int lastNewline = -1;
        for (int i = 0; i < offset; i++) {
            if (code.charAt(i) == '\n') {
                line++;
                lastNewline = i;
            }
        }
        int character = offset - lastNewline - 1;
        return new Position(line, character);
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/blocks/IfBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractStatementBlock;
import com.botmaker.core.BodyBlock;
import com.botmaker.core.CodeBlock;
import com.botmaker.core.ExpressionBlock;
import com.botmaker.lsp.CompletionContext;
import javafx.geometry.Pos;
import javafx.scene.Node;
import javafx.scene.control.Button;
import javafx.scene.control.ContextMenu;
import javafx.scene.control.Label;
import javafx.scene.control.MenuItem;
import javafx.scene.layout.HBox;
import javafx.scene.layout.VBox;
import org.eclipse.jdt.core.dom.CompilationUnit;
import org.eclipse.jdt.core.dom.IfStatement;

public class IfBlock extends AbstractStatementBlock {

    private ExpressionBlock condition;
    private BodyBlock thenBody;
    private com.botmaker.core.StatementBlock elseStatement;

    public IfBlock(String id, IfStatement astNode) {
        super(id, astNode);
    }

    public ExpressionBlock getCondition() {
        return condition;
    }

    public void setCondition(ExpressionBlock condition) {
        this.condition = condition;
    }

    public BodyBlock getThenBody() {
        return thenBody;
    }

    public void setThenBody(BodyBlock thenBody) {
        this.thenBody = thenBody;
    }

    public com.botmaker.core.StatementBlock getElseStatement() {
        return elseStatement;
    }

    public void setElseStatement(com.botmaker.core.StatementBlock elseStatement) {
        this.elseStatement = elseStatement;
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        VBox container = new VBox(5);
        container.getStyleClass().add("if-block");

        // Header: If + condition + + button + delete button
        HBox header = new HBox(5);
        header.setAlignment(Pos.CENTER_LEFT);

        Label ifLabel = new Label("If");
        ifLabel.getStyleClass().add("keyword-label");
        header.getChildren().add(ifLabel);

        if (condition != null) {
            header.getChildren().add(condition.getUINode(context));
        } else {
            header.getChildren().add(createExpressionDropZone(context));
        }

        // + Button for changing condition
        Button addButton = new Button("+");
        addButton.getStyleClass().add("expression-add-button");
        addButton.setOnAction(e -> showExpressionMenu(addButton, context));
        header.getChildren().add(addButton);

        javafx.scene.layout.Pane spacer = new javafx.scene.layout.Pane();
        HBox.setHgrow(spacer, javafx.scene.layout.Priority.ALWAYS);

        javafx.scene.control.Button deleteButton = new javafx.scene.control.Button("X");
        deleteButton.setOnAction(e -> context.codeEditor().deleteStatement((org.eclipse.jdt.core.dom.Statement) this.astNode));

        header.getChildren().addAll(spacer, deleteButton);
        container.getChildren().add(header);

        // Then body
        if (thenBody != null) {
            Node thenBodyNode = thenBody.getUINode(context);
            thenBodyNode.getStyleClass().add("if-body");
            HBox.setHgrow(thenBodyNode, javafx.scene.layout.Priority.ALWAYS);
            container.getChildren().add(thenBodyNode);
        }

        // Else part
        if (elseStatement != null) {
            if (elseStatement instanceof com.botmaker.core.BodyBlock) {
                VBox elseContainer = new VBox(5);
                HBox elseHeader = new HBox(5);
                elseHeader.setAlignment(Pos.CENTER_LEFT);
                Label elseLabel = new Label("Else");
                elseLabel.getStyleClass().add("keyword-label");
                javafx.scene.control.Button addElseIfButton = new javafx.scene.control.Button("+ if");
                addElseIfButton.setOnAction(e -> context.codeEditor().convertElseToElseIf((IfStatement) this.astNode));
                javafx.scene.layout.Pane elseSpacer = new javafx.scene.layout.Pane();
                HBox.setHgrow(elseSpacer, javafx.scene.layout.Priority.ALWAYS);
                javafx.scene.control.Button deleteElseButton = new javafx.scene.control.Button("X");
                deleteElseButton.setOnAction(e -> context.codeEditor().deleteElseFromIfStatement((IfStatement) this.astNode));
                elseHeader.getChildren().addAll(elseLabel, addElseIfButton, elseSpacer, deleteElseButton);

                Node elseBodyNode = elseStatement.getUINode(context);
                elseBodyNode.getStyleClass().add("if-body");
                HBox.setHgrow(elseBodyNode, javafx.scene.layout.Priority.ALWAYS);
                elseContainer.getChildren().addAll(elseHeader, elseBodyNode);
                container.getChildren().add(elseContainer);
            } else {
                HBox elseIfContainer = new HBox(5);
                elseIfContainer.setAlignment(Pos.CENTER_LEFT);
                Label elseLabel = new Label("Else");
                elseLabel.getStyleClass().add("keyword-label");
                elseIfContainer.getChildren().add(elseLabel);
                Node elseNode = elseStatement.getUINode(context);
                HBox.setHgrow(elseNode, javafx.scene.layout.Priority.ALWAYS);
                elseIfContainer.getChildren().add(elseNode);
                container.getChildren().add(elseIfContainer);
            }
        } else {
            javafx.scene.control.Button addElseButton = new javafx.scene.control.Button("+");
            addElseButton.setOnAction(e -> context.codeEditor().addElseToIfStatement((IfStatement) this.astNode));
            container.getChildren().add(addElseButton);
        }

        return container;
    }

    private void showExpressionMenu(Button button, CompletionContext context) {
        ContextMenu menu = new ContextMenu();

        for (com.botmaker.ui.AddableExpression type : com.botmaker.ui.AddableExpression.values()) {
            MenuItem menuItem = new MenuItem(type.getDisplayName());
            menuItem.setOnAction(e -> {
                if (condition != null) {
                    org.eclipse.jdt.core.dom.Expression toReplace = (org.eclipse.jdt.core.dom.Expression) condition.getAstNode();
                    context.codeEditor().replaceExpression(toReplace, type);
                }
            });
            menu.getItems().add(menuItem);
        }

        menu.show(button, javafx.geometry.Side.BOTTOM, 0, 0);
    }

    @Override
    public void highlight() {
        if (condition != null) {
            condition.highlight();
        } else {
            super.highlight();
        }
    }

    @Override
    public void unhighlight() {
        if (condition != null) {
            condition.unhighlight();
        } else {
            super.unhighlight();
        }
    }

    @Override
    public int getBreakpointLine(CompilationUnit cu) {
        if (condition != null) {
            return condition.getBreakpointLine(cu);
        }
        return super.getBreakpointLine(cu);
    }

    @Override
    public CodeBlock getHighlightTarget() {
        return condition != null ? condition : this;
    }

    @Override
    public String getDetails() {
        String conditionDetails = (condition != null) ? condition.getDetails() : "no condition";
        return "If Statement (condition: " + conditionDetails + ")";
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/blocks/ListBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractExpressionBlock;
import com.botmaker.core.ExpressionBlock;
import com.botmaker.lsp.CompletionContext;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.Node;
import javafx.scene.control.Button;
import javafx.scene.control.ContextMenu;
import javafx.scene.control.Label;
import javafx.scene.control.MenuItem;
import javafx.scene.layout.HBox;
import javafx.scene.layout.VBox;
import org.eclipse.jdt.core.dom.ArrayInitializer;

import java.util.ArrayList;
import java.util.List;

/**
 * Visual block for array/list literals like {1, 2, 3}
 * Allows users to add, remove, and edit elements inline
 */
public class ListBlock extends AbstractExpressionBlock {

    private final List<ExpressionBlock> elements = new ArrayList<>();

    public ListBlock(String id, ArrayInitializer astNode) {
        super(id, astNode);
        for (Object expr : astNode.expressions()) {
            // The BlockFactory handles the recursive creation of children,
            // we just hold the references.
        }
    }

    public List<ExpressionBlock> getElements() {
        return elements;
    }

    public void addElement(ExpressionBlock element) {
        this.elements.add(element);
    }

    public void clearElements() {
        this.elements.clear();
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        VBox container = new VBox(5);
        container.setAlignment(Pos.TOP_LEFT);
        container.getStyleClass().add("list-block");

        // Add padding and a slight background diff for nested lists
        // (You should add .nested-list to your CSS, or we use inline style for now)
        if (this.astNode.getParent() instanceof ArrayInitializer) {
            container.setStyle("-fx-background-color: rgba(255,255,255,0.1); -fx-background-radius: 4; -fx-border-color: rgba(255,255,255,0.2); -fx-border-width: 1;");
            container.setPadding(new Insets(4, 8, 4, 8));
        } else {
            container.setPadding(new Insets(8, 12, 8, 12));
        }

        // Header row: "List [...]" label + Add button
        HBox headerRow = new HBox(8);
        headerRow.setAlignment(Pos.CENTER_LEFT);

        // Determine depth/context for label
        String labelText = (this.astNode.getParent() instanceof ArrayInitializer) ? "Sub-List" : "List";
        Label listLabel = new Label(labelText + " [" + elements.size() + "]");
        listLabel.getStyleClass().add("list-label");

        Button addButton = new Button("+");
        addButton.getStyleClass().add("expression-add-button");
        // Compact the button slightly for nested views
        addButton.setStyle("-fx-font-size: 10px; -fx-padding: 2px 6px;");
        addButton.setOnAction(e -> showAddElementMenu(addButton, context, elements.size()));

        headerRow.getChildren().addAll(listLabel, addButton);
        container.getChildren().add(headerRow);

        // Display each element with controls
        if (elements.isEmpty()) {
            Label emptyLabel = new Label("(empty)");
            emptyLabel.setStyle("-fx-font-style: italic; -fx-text-fill: rgba(255,255,255,0.6); -fx-font-size: 10px;");
            container.getChildren().add(emptyLabel);
        } else {
            VBox elementsContainer = new VBox(2); // Tighter spacing
            elementsContainer.setPadding(new Insets(2, 0, 0, 10)); // Indent content

            for (int i = 0; i < elements.size(); i++) {
                HBox elementRow = createElementRow(i, elements.get(i), context);
                elementsContainer.getChildren().add(elementRow);
            }

            container.getChildren().add(elementsContainer);
        }

        return container;
    }

    private HBox createElementRow(int index, ExpressionBlock element, CompletionContext context) {
        HBox row = new HBox(5);
        row.setAlignment(Pos.CENTER_LEFT);

        // Index label
        Label indexLabel = new Label(String.valueOf(index));
        indexLabel.setStyle("-fx-font-family: monospace; -fx-text-fill: #888; -fx-min-width: 15px; -fx-font-size: 10px;");

        // Element display
        Node elementNode = element.getUINode(context);

        // Logic to handle nested UI resizing
        if (element instanceof ListBlock) {
            // Allow nested list to expand
            HBox.setHgrow(elementNode, javafx.scene.layout.Priority.ALWAYS);
        }

        // Change button
        Button changeButton = new Button("↻");
        changeButton.getStyleClass().add("icon-button");
        changeButton.setStyle("-fx-font-size: 9px; -fx-padding: 1px 4px; -fx-opacity: 0.6;");
        changeButton.setOnAction(e -> showChangeElementMenu(changeButton, context, index));

        // Delete button
        Button deleteButton = new Button("✕");
        deleteButton.getStyleClass().add("icon-button");
        deleteButton.setStyle("-fx-font-size: 9px; -fx-padding: 1px 4px; -fx-text-fill: #E74C3C; -fx-opacity: 0.6;");
        deleteButton.setOnAction(e -> deleteElement(index, context));

        // Hover effects for buttons
        row.setOnMouseEntered(e -> {
            changeButton.setStyle("-fx-font-size: 9px; -fx-padding: 1px 4px; -fx-opacity: 1.0;");
            deleteButton.setStyle("-fx-font-size: 9px; -fx-padding: 1px 4px; -fx-text-fill: #E74C3C; -fx-opacity: 1.0;");
        });
        row.setOnMouseExited(e -> {
            changeButton.setStyle("-fx-font-size: 9px; -fx-padding: 1px 4px; -fx-opacity: 0.6;");
            deleteButton.setStyle("-fx-font-size: 9px; -fx-padding: 1px 4px; -fx-text-fill: #E74C3C; -fx-opacity: 0.6;");
        });

        row.getChildren().addAll(indexLabel, elementNode, changeButton, deleteButton);
        return row;
    }

    // ... (Rest of methods: showAddElementMenu, showChangeElementMenu, deleteElement, getDetails remain the same)
    // Ensure AddableExpression.values() now includes LIST, so the menu automatically picks it up.

    private void showAddElementMenu(Button button, CompletionContext context, int insertIndex) {
        ContextMenu menu = new ContextMenu();

        for (com.botmaker.ui.AddableExpression type : com.botmaker.ui.AddableExpression.values()) {
            MenuItem menuItem = new MenuItem(type.getDisplayName());
            menuItem.setOnAction(e -> {
                context.codeEditor().addElementToArrayInitializer(
                        (ArrayInitializer) this.astNode,
                        type,
                        insertIndex
                );
            });
            menu.getItems().add(menuItem);
        }
        menu.show(button, javafx.geometry.Side.BOTTOM, 0, 0);
    }

    private void showChangeElementMenu(Button button, CompletionContext context, int elementIndex) {
        ContextMenu menu = new ContextMenu();

        for (com.botmaker.ui.AddableExpression type : com.botmaker.ui.AddableExpression.values()) {
            MenuItem menuItem = new MenuItem(type.getDisplayName());
            menuItem.setOnAction(e -> {
                if (elementIndex < elements.size()) {
                    ExpressionBlock oldElement = elements.get(elementIndex);
                    context.codeEditor().replaceExpression(
                            (org.eclipse.jdt.core.dom.Expression) oldElement.getAstNode(),
                            type
                    );
                }
            });
            menu.getItems().add(menuItem);
        }
        menu.show(button, javafx.geometry.Side.BOTTOM, 0, 0);
    }

    private void deleteElement(int index, CompletionContext context) {
        if (index >= 0 && index < elements.size()) {
            context.codeEditor().deleteElementFromArrayInitializer(
                    (ArrayInitializer) this.astNode,
                    index
            );
        }
    }

    @Override
    public String getDetails() {
        return "List (" + elements.size() + ")";
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/blocks/LiteralBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractExpressionBlock;
import com.botmaker.lsp.CompletionContext;
import javafx.scene.Cursor;
import javafx.scene.Node;
import javafx.scene.control.TextField;
import javafx.scene.layout.HBox;
import org.eclipse.jdt.core.dom.Expression;

public class LiteralBlock<T> extends AbstractExpressionBlock {
    private final T value;

    public LiteralBlock(String id, Expression astNode, T value) {
        super(id, astNode);
        this.value = value;
    }

    public T getValue() {
        return value;
    }

    public Class<?> getValueType() {
        if (value == null) return null;
        return value.getClass();
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        String initialText = (value instanceof String) ? (String) value : String.valueOf(value);
        TextField textField = new TextField(initialText);

        if (initialText.isEmpty() && value instanceof String) {
            textField.setPromptText("Type a value...");
        }

        textField.setCursor(Cursor.TEXT);
        textField.getStyleClass().add("literal-text-field"); // Use specific style class

        textField.focusedProperty().addListener((obs, oldVal, newVal) -> {
            if (!newVal) {
                String newText = textField.getText();
                String oldText = (value instanceof String) ? (String) value : String.valueOf(value);

                if (!newText.equals(oldText)) {
                    // Handle the special synthetic case for an empty println
                    if (this.astNode instanceof org.eclipse.jdt.core.dom.MethodInvocation) {
                        org.eclipse.jdt.core.dom.MethodInvocation mi = (org.eclipse.jdt.core.dom.MethodInvocation) this.astNode;
                        context.codeEditor().addStringArgumentToMethodInvocation(mi, newText);
                    } else {
                        // This is the normal case for editing an existing literal
                        context.codeEditor().replaceLiteralValue((Expression) this.astNode, newText);
                    }
                }
            }
        });

        HBox container = new HBox(textField);
        container.setAlignment(javafx.geometry.Pos.CENTER_LEFT);
        container.getStyleClass().add("literal-block");
        return container;
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/blocks/MainBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractCodeBlock;
import com.botmaker.core.BlockWithChildren;
import com.botmaker.core.BodyBlock;
import com.botmaker.core.CodeBlock;
import com.botmaker.lsp.CompletionContext;

import javafx.geometry.Insets;
import javafx.scene.Node;
import javafx.scene.control.Label;
import javafx.scene.layout.VBox;
import org.eclipse.jdt.core.dom.ASTNode;

import java.util.ArrayList;
import java.util.List;

public class MainBlock extends AbstractCodeBlock implements BlockWithChildren {

    private BodyBlock mainBody;

    public MainBlock(String id, ASTNode astNode) {
        super(id, astNode);
    }

    public void setMainBody(BodyBlock mainBody) {
        this.mainBody = mainBody;
    }

    @Override
    public List<CodeBlock> getChildren() {
        List<CodeBlock> children = new ArrayList<>();
        if (mainBody != null) {
            children.add(mainBody);
        }
        return children;
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        VBox container = new VBox(5);
        container.getStyleClass().add("main-block");
        container.setPadding(new Insets(10));

        Label header = new Label("Main");
        header.getStyleClass().add("main-block-header");
        container.getChildren().add(header);

        if (mainBody != null) {
            container.getChildren().add(mainBody.getUINode(context));
        }

        return container;
    }
}


=================================================================================
FILE: ./src/main/java/com/botmaker/blocks/PrintBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractStatementBlock;
import com.botmaker.core.ExpressionBlock;
import com.botmaker.lsp.CompletionContext;
import javafx.geometry.Pos;
import javafx.scene.Node;
import javafx.scene.layout.HBox;
import javafx.scene.text.Text;
import org.eclipse.jdt.core.dom.ExpressionStatement;
import org.eclipse.jdt.core.dom.MethodInvocation;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

public class PrintBlock extends AbstractStatementBlock {

    private final List<ExpressionBlock> arguments = new ArrayList<>();

    public PrintBlock(String id, ExpressionStatement astNode) {
        super(id, astNode);
    }

    public List<ExpressionBlock> getArguments() {
        return arguments;
    }

    public void addArgument(ExpressionBlock argument) {
        this.arguments.add(argument);
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        HBox container = new HBox(5);
        container.setAlignment(Pos.CENTER_LEFT);
        container.getStyleClass().add("print-block");

        container.getChildren().add(new Text("Print:"));

        if (arguments.isEmpty()) {
            container.getChildren().add(createExpressionDropZone(context));
        } else {
            for (ExpressionBlock arg : arguments) {
                container.getChildren().add(arg.getUINode(context));
            }
        }

        javafx.scene.control.Button addButton = new javafx.scene.control.Button("+");
        javafx.scene.control.ContextMenu contextMenu = new javafx.scene.control.ContextMenu();

        for (com.botmaker.ui.AddableExpression type : com.botmaker.ui.AddableExpression.values()) {
            javafx.scene.control.MenuItem menuItem = new javafx.scene.control.MenuItem(type.getDisplayName());
            menuItem.setOnAction(e -> {
                if (!arguments.isEmpty()) {
                    // We are assuming one argument for now
                    org.eclipse.jdt.core.dom.Expression toReplace = (org.eclipse.jdt.core.dom.Expression) arguments.get(0).getAstNode();
                    context.codeEditor().replaceExpression(toReplace, type);
                }
            });
            contextMenu.getItems().add(menuItem);
        }

        addButton.setOnAction(e -> contextMenu.show(addButton, javafx.geometry.Side.BOTTOM, 0, 0));
        container.getChildren().add(addButton);

        javafx.scene.control.Button deleteButton = new javafx.scene.control.Button("X");
        deleteButton.setOnAction(e -> {
            context.codeEditor().deleteStatement((org.eclipse.jdt.core.dom.Statement) this.astNode);
        });

        javafx.scene.layout.Pane spacer = new javafx.scene.layout.Pane();
        HBox.setHgrow(spacer, javafx.scene.layout.Priority.ALWAYS);

        container.getChildren().addAll(spacer, deleteButton);

        return container;
    }

    @Override
    public String getDetails() {
        String argsString = arguments.stream()
                .map(ExpressionBlock::getDetails)
                .collect(Collectors.joining(", "));
        return "Print Statement: " + argsString;
    }
}


=================================================================================
FILE: ./src/main/java/com/botmaker/blocks/ReadInputBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractStatementBlock;
import com.botmaker.core.ExpressionBlock;
import com.botmaker.lsp.CompletionContext;
import javafx.geometry.Pos;
import javafx.scene.Node;
import javafx.scene.control.Label;
import javafx.scene.layout.HBox;
import org.eclipse.jdt.core.dom.VariableDeclarationStatement;

public class ReadInputBlock extends AbstractStatementBlock {

    private ExpressionBlock variableName;
    private String inputType; // "nextLine", "nextInt", "nextDouble", etc.

    public ReadInputBlock(String id, VariableDeclarationStatement astNode, String inputType) {
        super(id, astNode);
        this.inputType = inputType;
    }

    public ExpressionBlock getVariableName() {
        return variableName;
    }

    public void setVariableName(ExpressionBlock variableName) {
        this.variableName = variableName;
    }

    public String getInputType() {
        return inputType;
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        HBox container = new HBox(5);
        container.setAlignment(Pos.CENTER_LEFT);
        container.getStyleClass().add("read-input-block");

        // Display based on input type
        Label typeLabel = new Label(getTypeDisplayName());
        typeLabel.getStyleClass().add("type-label");

        if (variableName != null) {
            container.getChildren().add(variableName.getUINode(context));
        }

        Label equalsLabel = new Label("=");
        Label scannerLabel = new Label("scanner." + inputType + "()");
        scannerLabel.getStyleClass().add("method-call-label");

        container.getChildren().addAll(typeLabel, equalsLabel, scannerLabel);

        // Add spacer and delete button
        javafx.scene.layout.Pane spacer = new javafx.scene.layout.Pane();
        HBox.setHgrow(spacer, javafx.scene.layout.Priority.ALWAYS);

        javafx.scene.control.Button deleteButton = new javafx.scene.control.Button("X");
        deleteButton.setOnAction(e -> {
            context.codeEditor().deleteStatement((org.eclipse.jdt.core.dom.Statement) this.astNode);
        });

        container.getChildren().addAll(spacer, deleteButton);

        return container;
    }

    private String getTypeDisplayName() {
        switch (inputType) {
            case "nextLine":
                return "String";
            case "nextInt":
                return "int";
            case "nextDouble":
                return "double";
            case "nextBoolean":
                return "boolean";
            default:
                return "var";
        }
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/blocks/ReturnBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractStatementBlock;
import com.botmaker.lsp.CompletionContext;
import javafx.geometry.Pos;
import javafx.scene.Node;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Pane;
import javafx.scene.layout.Priority;
import org.eclipse.jdt.core.dom.Statement;

public class ReturnBlock extends AbstractStatementBlock {

    public ReturnBlock(String id, Statement astNode) {
        super(id, astNode);
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        HBox container = new HBox(5);
        container.setAlignment(Pos.CENTER_LEFT);
        container.getStyleClass().add("return-block");

        Label returnLabel = new Label("return");
        returnLabel.getStyleClass().add("keyword-label");

        // Spacer and Delete Button
        Pane spacer = new Pane();
        HBox.setHgrow(spacer, Priority.ALWAYS);

        Button deleteButton = new Button("X");
        deleteButton.setOnAction(e -> {
            context.codeEditor().deleteStatement((Statement) this.astNode);
        });

        container.getChildren().addAll(returnLabel, spacer, deleteButton);

        return container;
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/blocks/SwitchBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractStatementBlock;
import com.botmaker.core.BodyBlock;
import com.botmaker.core.BlockWithChildren;
import com.botmaker.core.CodeBlock;
import com.botmaker.core.ExpressionBlock;
import com.botmaker.lsp.CompletionContext;
import com.botmaker.ui.BlockDragAndDropManager;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.Node;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Pane;
import javafx.scene.layout.Priority;
import javafx.scene.layout.VBox;
import org.eclipse.jdt.core.dom.SwitchStatement;

import java.util.ArrayList;
import java.util.List;

public class SwitchBlock extends AbstractStatementBlock implements BlockWithChildren {

    private ExpressionBlock expression;
    private final List<SwitchCaseBlock> cases = new ArrayList<>();
    private final BlockDragAndDropManager dragAndDropManager;

    public SwitchBlock(String id, SwitchStatement astNode, BlockDragAndDropManager dragAndDropManager) {
        super(id, astNode);
        this.dragAndDropManager = dragAndDropManager;
    }

    public ExpressionBlock getExpression() {
        return expression;
    }

    public void setExpression(ExpressionBlock expression) {
        this.expression = expression;
    }

    public List<SwitchCaseBlock> getCases() {
        return cases;
    }

    public void addCase(SwitchCaseBlock caseBlock) {
        this.cases.add(caseBlock);
    }

    @Override
    public List<CodeBlock> getChildren() {
        List<CodeBlock> children = new ArrayList<>();
        if (expression != null) children.add(expression);
        children.addAll(cases);
        return children;
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        VBox mainContainer = new VBox(5);
        mainContainer.getStyleClass().add("switch-block");

        // Header row with delete button
        HBox headerRow = new HBox(5);
        headerRow.setAlignment(Pos.CENTER_LEFT);

        // Switch expression part
        HBox header = new HBox(5);
        header.setAlignment(Pos.CENTER_LEFT);
        header.getStyleClass().add("switch-header");

        Label switchLabel = new Label("switch");
        switchLabel.getStyleClass().add("keyword-label");

        header.getChildren().add(switchLabel);
        if (expression != null) {
            header.getChildren().add(expression.getUINode(context));
        }

        // Add spacer and delete button
        Pane spacer = new Pane();
        HBox.setHgrow(spacer, Priority.ALWAYS);

        Button deleteButton = new Button("X");
        deleteButton.setOnAction(e -> {
            context.codeEditor().deleteStatement((org.eclipse.jdt.core.dom.Statement) this.astNode);
        });

        headerRow.getChildren().addAll(header, spacer, deleteButton);
        mainContainer.getChildren().add(headerRow);

        // Cases
        VBox casesContainer = new VBox(5);
        casesContainer.getStyleClass().add("switch-cases");
        casesContainer.setPadding(new Insets(5, 0, 0, 20));

        for (SwitchCaseBlock caseBlock : cases) {
            casesContainer.getChildren().add(caseBlock.getUINode(context));
        }

        mainContainer.getChildren().add(casesContainer);

        return mainContainer;
    }

    /**
     * Inner class representing a single case in the switch
     */
    public static class SwitchCaseBlock extends AbstractStatementBlock implements BlockWithChildren {
        private ExpressionBlock caseExpression; // null for default case
        private BodyBlock body;
        private final BlockDragAndDropManager dragAndDropManager;

        public SwitchCaseBlock(String id, org.eclipse.jdt.core.dom.SwitchCase astNode, BlockDragAndDropManager dragAndDropManager) {
            super(id, astNode);
            this.dragAndDropManager = dragAndDropManager;
        }

        public void setCaseExpression(ExpressionBlock caseExpression) {
            this.caseExpression = caseExpression;
        }

        public void setBody(BodyBlock body) {
            this.body = body;
        }

        public boolean isDefault() {
            return caseExpression == null;
        }

        @Override
        public List<CodeBlock> getChildren() {
            List<CodeBlock> children = new ArrayList<>();
            if (caseExpression != null) children.add(caseExpression);
            if (body != null) children.add(body);
            return children;
        }

        @Override
        protected Node createUINode(CompletionContext context) {
            VBox container = new VBox(5);
            container.getStyleClass().add("switch-case-block");

            // Case label
            HBox caseHeader = new HBox(5);
            caseHeader.setAlignment(Pos.CENTER_LEFT);

            if (isDefault()) {
                Label defaultLabel = new Label("default:");
                defaultLabel.getStyleClass().add("keyword-label");
                caseHeader.getChildren().add(defaultLabel);
            } else {
                Label caseLabel = new Label("case");
                caseLabel.getStyleClass().add("keyword-label");
                caseHeader.getChildren().add(caseLabel);
                if (caseExpression != null) {
                    caseHeader.getChildren().add(caseExpression.getUINode(context));
                }
                Label colon = new Label(":");
                caseHeader.getChildren().add(colon);
            }

            container.getChildren().add(caseHeader);

            // Case body
            if (body != null) {
                VBox bodyContainer = new VBox();
                bodyContainer.getStyleClass().add("switch-case-body");
                bodyContainer.setPadding(new Insets(5, 0, 0, 20));
                bodyContainer.getChildren().add(body.getUINode(context));
                container.getChildren().add(bodyContainer);
            }

            return container;
        }
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/blocks/VariableDeclarationBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractStatementBlock;
import com.botmaker.core.ExpressionBlock;
import com.botmaker.lsp.CompletionContext;
import com.botmaker.util.TypeManager;
import javafx.geometry.Pos;
import javafx.scene.Cursor;
import javafx.scene.Node;
import javafx.scene.control.*;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Priority;
import org.eclipse.jdt.core.dom.Type;
import org.eclipse.jdt.core.dom.VariableDeclarationFragment;
import org.eclipse.jdt.core.dom.VariableDeclarationStatement;

public class VariableDeclarationBlock extends AbstractStatementBlock {

    private final String variableName;
    private final Type variableType;
    private ExpressionBlock initializer;

    public VariableDeclarationBlock(String id, VariableDeclarationStatement astNode) {
        super(id, astNode);
        VariableDeclarationFragment fragment = (VariableDeclarationFragment) astNode.fragments().get(0);
        this.variableName = fragment.getName().getIdentifier();
        this.variableType = astNode.getType();
        this.initializer = null;
    }

    public void setInitializer(ExpressionBlock initializer) {
        this.initializer = initializer;
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        HBox container = new HBox(5);
        container.setAlignment(Pos.CENTER_LEFT);
        container.getStyleClass().add("variable-declaration-block");

        // --- TYPE SELECTOR ---
        Label typeLabel = new Label(getDisplayTypeName(variableType));
        typeLabel.getStyleClass().add("type-label");
        typeLabel.setCursor(Cursor.HAND);

        Tooltip tooltip = new Tooltip("Click to change type (List/Base)");
        Tooltip.install(typeLabel, tooltip);

        typeLabel.setOnMouseClicked(e -> showTypeMenu(typeLabel, context));
        container.getChildren().add(typeLabel);

        // --- NAME FIELD ---
        TextField nameField = new TextField(variableName);
        nameField.getStyleClass().add("variable-name-field");
        nameField.setPrefWidth(100);
        nameField.focusedProperty().addListener((obs, oldVal, newVal) -> {
            if (!newVal) {
                String newName = nameField.getText();
                VariableDeclarationFragment fragment = (VariableDeclarationFragment) ((VariableDeclarationStatement) this.astNode).fragments().get(0);
                String currentName = fragment.getName().getIdentifier();

                if (!newName.equals(currentName) && !newName.isEmpty()) {
                    context.codeEditor().replaceSimpleName(fragment.getName(), newName);
                }
            }
        });
        container.getChildren().add(nameField);

        // --- EQUALS ---
        Label equalsLabel = new Label("=");
        equalsLabel.getStyleClass().add("keyword-label");
        container.getChildren().add(equalsLabel);

        // --- INITIALIZER ---
        if (initializer != null) {
            if (initializer.getAstNode() instanceof org.eclipse.jdt.core.dom.ArrayInitializer) {
                container.getChildren().add(createListDisplay(context));
            } else {
                container.getChildren().add(initializer.getUINode(context));
            }
        } else {
            container.getChildren().add(createExpressionDropZone(context));
        }

        // --- ADD BUTTON ---
        Button addButton = new Button("+");
        addButton.getStyleClass().add("expression-add-button");
        addButton.setOnAction(e -> showExpressionMenu(addButton, context));
        container.getChildren().add(addButton);

        // --- SPACER & DELETE ---
        javafx.scene.layout.Pane spacer = new javafx.scene.layout.Pane();
        HBox.setHgrow(spacer, Priority.ALWAYS);

        Button deleteButton = new Button("X");
        deleteButton.setOnAction(e -> {
            context.codeEditor().deleteStatement((org.eclipse.jdt.core.dom.Statement) this.astNode);
        });

        container.getChildren().addAll(spacer, deleteButton);

        return container;
    }

    private void showTypeMenu(Node anchor, CompletionContext context) {
        ContextMenu menu = new ContextMenu();

        String currentStr = variableType.toString();
        boolean isArray = variableType.isArrayType();
        String baseType = isArray ? currentStr.replace("[]", "") : currentStr;

        // 1. Option to toggle List status
        MenuItem toggleList = new MenuItem(isArray ? "Convert to Single Value" : "Convert to List");
        toggleList.setStyle("-fx-font-weight: bold;");
        toggleList.setOnAction(e -> {
            String newType;
            if (isArray) {
                // Remove one level of array (int[][] -> int[])
                int lastIndex = currentStr.lastIndexOf("[]");
                newType = currentStr.substring(0, lastIndex);
            } else {
                // Add array level
                newType = currentStr + "[]";
            }
            context.codeEditor().replaceVariableType((VariableDeclarationStatement) this.astNode, newType);
        });
        menu.getItems().add(toggleList);

        // Option for nested list if already a list
        if (isArray) {
            MenuItem makeNested = new MenuItem("Make List of Lists");
            makeNested.setOnAction(e -> {
                String newType = currentStr + "[]";
                context.codeEditor().replaceVariableType((VariableDeclarationStatement) this.astNode, newType);
            });
            menu.getItems().add(makeNested);
        }

        menu.getItems().add(new SeparatorMenuItem());

        // 2. Change Base Type
        Menu changeBaseMenu = new Menu("Change Base Type");
        for (String type : TypeManager.getFundamentalTypeNames()) {
            MenuItem item = new MenuItem(type);
            item.setOnAction(e -> {
                // Preserve array dimensions, just change base
                String dims = currentStr.substring(currentStr.indexOf(baseType) + baseType.length());
                String newType = type + dims;
                context.codeEditor().replaceVariableType((VariableDeclarationStatement) this.astNode, newType);
            });
            changeBaseMenu.getItems().add(item);
        }
        menu.getItems().add(changeBaseMenu);

        menu.show(anchor, javafx.geometry.Side.BOTTOM, 0, 0);
    }

    private HBox createListDisplay(CompletionContext context) {
        HBox listBox = new HBox(3);
        listBox.setAlignment(Pos.CENTER_LEFT);
        listBox.getStyleClass().add("inline-list-display");

        Label openBracket = new Label("[");
        openBracket.setStyle("-fx-font-weight: bold; -fx-font-size: 14px;");
        listBox.getChildren().add(openBracket);

        if (initializer instanceof ListBlock) {
            ListBlock listBlock = (ListBlock) initializer;
            if (listBlock.getElements().isEmpty()) {
                Label emptyLabel = new Label("empty");
                emptyLabel.setStyle("-fx-font-style: italic; -fx-text-fill: #999; -fx-font-size: 10px;");
                listBox.getChildren().add(emptyLabel);
            } else {
                Label countLabel = new Label(listBlock.getElements().size() + " items");
                countLabel.setStyle("-fx-font-style: italic;");
                listBox.getChildren().add(countLabel);
            }
        } else {
            listBox.getChildren().add(initializer.getUINode(context));
        }

        Label closeBracket = new Label("]");
        closeBracket.setStyle("-fx-font-weight: bold; -fx-font-size: 14px;");
        listBox.getChildren().add(closeBracket);

        return listBox;
    }

    private String getDisplayTypeName(Type type) {
        String typeName = type.toString();
        if (typeName.endsWith("[]")) {
            // Convert "int[][]" to "int list list" for display, or keep symbols
            // Keeping symbols is often clearer for nested lists
            return typeName.replace("[]", " list");
        }
        return typeName;
    }

    private void showExpressionMenu(Button button, CompletionContext context) {
        ContextMenu menu = new ContextMenu();
        for (com.botmaker.ui.AddableExpression type : com.botmaker.ui.AddableExpression.values()) {
            MenuItem menuItem = new MenuItem(type.getDisplayName());
            menuItem.setOnAction(e -> {
                if (initializer != null) {
                    context.codeEditor().replaceExpression(
                            (org.eclipse.jdt.core.dom.Expression) initializer.getAstNode(),
                            type
                    );
                }
            });
            menu.getItems().add(menuItem);
        }
        menu.show(button, javafx.geometry.Side.BOTTOM, 0, 0);
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/blocks/WaitBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractStatementBlock;
import com.botmaker.core.ExpressionBlock;
import com.botmaker.lsp.CompletionContext;
import javafx.geometry.Pos;
import javafx.scene.Node;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Pane;
import javafx.scene.layout.Priority;
import org.eclipse.jdt.core.dom.Statement;

public class WaitBlock extends AbstractStatementBlock {

    private ExpressionBlock duration;

    public WaitBlock(String id, Statement astNode) {
        super(id, astNode);
    }

    public ExpressionBlock getDuration() {
        return duration;
    }

    public void setDuration(ExpressionBlock duration) {
        this.duration = duration;
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        HBox container = new HBox(5);
        container.setAlignment(Pos.CENTER_LEFT);
        container.getStyleClass().add("wait-block");

        Label waitLabel = new Label("Wait");
        waitLabel.getStyleClass().add("keyword-label");

        container.getChildren().add(waitLabel);

        if (duration != null) {
            container.getChildren().add(duration.getUINode(context));
        } else {
            container.getChildren().add(createExpressionDropZone(context));
        }

        Label msLabel = new Label("ms");
        msLabel.getStyleClass().add("keyword-label");
        container.getChildren().add(msLabel);

        // Spacer and Delete Button
        Pane spacer = new Pane();
        HBox.setHgrow(spacer, Priority.ALWAYS);

        Button deleteButton = new Button("X");
        deleteButton.setOnAction(e -> {
            context.codeEditor().deleteStatement((Statement) this.astNode);
        });

        container.getChildren().addAll(spacer, deleteButton);

        return container;
    }

    @Override
    public String getDetails() {
        return "Wait: " + (duration != null ? duration.getDetails() : "...");
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/blocks/WhileBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractStatementBlock;
import com.botmaker.core.BodyBlock;
import com.botmaker.core.BlockWithChildren;
import com.botmaker.core.CodeBlock;
import com.botmaker.core.ExpressionBlock;
import com.botmaker.lsp.CompletionContext;
import com.botmaker.ui.BlockDragAndDropManager;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.Node;
import javafx.scene.control.Button;
import javafx.scene.control.ContextMenu;
import javafx.scene.control.Label;
import javafx.scene.control.MenuItem;
import javafx.scene.layout.HBox;
import javafx.scene.layout.VBox;
import org.eclipse.jdt.core.dom.WhileStatement;

import java.util.ArrayList;
import java.util.List;

public class WhileBlock extends AbstractStatementBlock implements BlockWithChildren {

    private ExpressionBlock condition;
    private BodyBlock body;
    private final BlockDragAndDropManager dragAndDropManager;

    public WhileBlock(String id, WhileStatement astNode, BlockDragAndDropManager dragAndDropManager) {
        super(id, astNode);
        this.dragAndDropManager = dragAndDropManager;
    }

    public ExpressionBlock getCondition() {
        return condition;
    }

    public void setCondition(ExpressionBlock condition) {
        this.condition = condition;
    }

    public BodyBlock getBody() {
        return body;
    }

    public void setBody(BodyBlock body) {
        this.body = body;
    }

    @Override
    public List<CodeBlock> getChildren() {
        List<CodeBlock> children = new ArrayList<>();
        if (condition != null) children.add(condition);
        if (body != null) children.add(body);
        return children;
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        VBox mainContainer = new VBox(5);
        mainContainer.getStyleClass().add("while-block");

        // Header row with delete button
        HBox headerRow = new HBox(5);
        headerRow.setAlignment(Pos.CENTER_LEFT);

        // While condition part
        HBox header = new HBox(5);
        header.setAlignment(Pos.CENTER_LEFT);
        header.getStyleClass().add("while-header");

        Label whileLabel = new Label("while");
        whileLabel.getStyleClass().add("keyword-label");
        header.getChildren().add(whileLabel);

        if (condition != null) {
            header.getChildren().add(condition.getUINode(context));
        }

        // + Button for changing condition
        Button addButton = new Button("+");
        addButton.getStyleClass().add("expression-add-button");
        addButton.setOnAction(e -> showExpressionMenu(addButton, context));
        header.getChildren().add(addButton);

        // Add spacer and delete button
        javafx.scene.layout.Pane spacer = new javafx.scene.layout.Pane();
        HBox.setHgrow(spacer, javafx.scene.layout.Priority.ALWAYS);

        javafx.scene.control.Button deleteButton = new javafx.scene.control.Button("X");
        deleteButton.setOnAction(e -> {
            context.codeEditor().deleteStatement((org.eclipse.jdt.core.dom.Statement) this.astNode);
        });

        headerRow.getChildren().addAll(header, spacer, deleteButton);
        mainContainer.getChildren().add(headerRow);

        // Body
        if (body != null) {
            VBox bodyContainer = new VBox();
            bodyContainer.getStyleClass().add("while-body");
            bodyContainer.setPadding(new Insets(5, 0, 0, 20));
            bodyContainer.getChildren().add(body.getUINode(context));
            mainContainer.getChildren().add(bodyContainer);
        }

        return mainContainer;
    }

    private void showExpressionMenu(Button button, CompletionContext context) {
        ContextMenu menu = new ContextMenu();

        for (com.botmaker.ui.AddableExpression type : com.botmaker.ui.AddableExpression.values()) {
            MenuItem menuItem = new MenuItem(type.getDisplayName());
            menuItem.setOnAction(e -> {
                if (condition != null) {
                    org.eclipse.jdt.core.dom.Expression toReplace = (org.eclipse.jdt.core.dom.Expression) condition.getAstNode();
                    context.codeEditor().replaceExpression(toReplace, type);
                }
            });
            menu.getItems().add(menuItem);
        }

        menu.show(button, javafx.geometry.Side.BOTTOM, 0, 0);
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/config/ApplicationConfig.java
=================================================================================

package com.botmaker.config;

import java.nio.file.Path;
import java.nio.file.Paths;

/**
 * Application configuration.
 * Encapsulates all configuration values in one place.
 */
public class ApplicationConfig {

    // Language Server Configuration
    private final Path jdtServerPath;
    private final Path projectPath;
    private final Path workspaceDataPath;

    // Project Configuration
    private final Path sourceFilePath;
    private final Path compiledOutputPath;
    private final String mainClassName;

    // Java Configuration
    private final String javaHome;
    private final String javaExecutable;
    private final String javacExecutable;

    // UI Configuration
    private final int initialWidth;
    private final int initialHeight;

    // Debug Configuration
    private final boolean enableEventLogging;

    private ApplicationConfig(Builder builder) {
        this.jdtServerPath = builder.jdtServerPath;
        this.projectPath = builder.projectPath;
        this.workspaceDataPath = builder.workspaceDataPath;
        this.sourceFilePath = builder.sourceFilePath;
        this.compiledOutputPath = builder.compiledOutputPath;
        this.mainClassName = builder.mainClassName;
        this.javaHome = builder.javaHome;
        this.javaExecutable = builder.javaExecutable;
        this.javacExecutable = builder.javacExecutable;
        this.initialWidth = builder.initialWidth;
        this.initialHeight = builder.initialHeight;
        this.enableEventLogging = builder.enableEventLogging;
    }

    // Getters

    public Path getJdtServerPath() {
        return jdtServerPath;
    }

    public Path getProjectPath() {
        return projectPath;
    }

    public Path getWorkspaceDataPath() {
        return workspaceDataPath;
    }

    public Path getSourceFilePath() {
        return sourceFilePath;
    }

    public Path getCompiledOutputPath() {
        return compiledOutputPath;
    }

    public String getMainClassName() {
        return mainClassName;
    }

    public String getJavaHome() {
        return javaHome;
    }

    public String getJavaExecutable() {
        return javaExecutable;
    }

    public String getJavacExecutable() {
        return javacExecutable;
    }

    public int getInitialWidth() {
        return initialWidth;
    }

    public int getInitialHeight() {
        return initialHeight;
    }

    public boolean isEnableEventLogging() {
        return enableEventLogging;
    }

    /**
     * Creates a default configuration based on current environment
     */
    public static ApplicationConfig createDefault() {
        // Fallback - normally we use forProject()
        String defaultProjectName = "BotMaker";
        return forProject(defaultProjectName);
    }

    /**
     * Creates configuration for a specific project
     * @param projectName The project name (also used as main class name)
     */
    public static ApplicationConfig forProject(String projectName) {
        String javaHome = System.getProperty("java.home");
        String packageName = projectName.toLowerCase();
        String mainClassName = projectName; // Project name IS the main class name

        return new Builder()
                .jdtServerPath(Paths.get("tools/jdt-language-server"))
                .projectPath(Paths.get("projects", projectName))
                .workspaceDataPath(Paths.get(System.getProperty("user.home"), ".jdtls-workspace", projectName))
                .sourceFilePath(Paths.get("projects", projectName, "src/main/java/com", packageName, mainClassName + ".java"))
                .compiledOutputPath(Paths.get("projects", projectName, "build/classes/java/main"))
                .mainClassName("com." + packageName + "." + mainClassName)
                .javaHome(javaHome)
                .javaExecutable(Paths.get(javaHome, "bin", "java").toString())
                .javacExecutable(Paths.get(javaHome, "bin", "javac").toString())
                .initialWidth(600)
                .initialHeight(800)
                .enableEventLogging(false)
                .build();
    }

    /**
     * Builder for ApplicationConfig
     */
    public static class Builder {
        private Path jdtServerPath;
        private Path projectPath;
        private Path workspaceDataPath;
        private Path sourceFilePath;
        private Path compiledOutputPath;
        private String mainClassName;
        private String javaHome;
        private String javaExecutable;
        private String javacExecutable;
        private int initialWidth = 600;
        private int initialHeight = 800;
        private boolean enableEventLogging = false;

        public Builder jdtServerPath(Path jdtServerPath) {
            this.jdtServerPath = jdtServerPath;
            return this;
        }

        public Builder projectPath(Path projectPath) {
            this.projectPath = projectPath;
            return this;
        }

        public Builder workspaceDataPath(Path workspaceDataPath) {
            this.workspaceDataPath = workspaceDataPath;
            return this;
        }

        public Builder sourceFilePath(Path sourceFilePath) {
            this.sourceFilePath = sourceFilePath;
            return this;
        }

        public Builder compiledOutputPath(Path compiledOutputPath) {
            this.compiledOutputPath = compiledOutputPath;
            return this;
        }

        public Builder mainClassName(String mainClassName) {
            this.mainClassName = mainClassName;
            return this;
        }

        public Builder javaHome(String javaHome) {
            this.javaHome = javaHome;
            return this;
        }

        public Builder javaExecutable(String javaExecutable) {
            this.javaExecutable = javaExecutable;
            return this;
        }

        public Builder javacExecutable(String javacExecutable) {
            this.javacExecutable = javacExecutable;
            return this;
        }

        public Builder initialWidth(int initialWidth) {
            this.initialWidth = initialWidth;
            return this;
        }

        public Builder initialHeight(int initialHeight) {
            this.initialHeight = initialHeight;
            return this;
        }

        public Builder enableEventLogging(boolean enableEventLogging) {
            this.enableEventLogging = enableEventLogging;
            return this;
        }

        public ApplicationConfig build() {
            // Validate required fields
            if (jdtServerPath == null) {
                throw new IllegalStateException("jdtServerPath is required");
            }
            if (projectPath == null) {
                throw new IllegalStateException("projectPath is required");
            }
            if (mainClassName == null) {
                throw new IllegalStateException("mainClassName is required");
            }

            return new ApplicationConfig(this);
        }
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/config/Constants.java
=================================================================================

package com.botmaker.config;

/**
 * Application-wide constants
 */
public class Constants {

    // Debugger Configuration
    public static final int DEBUGGER_MAX_CONNECT_RETRIES = 10;
    public static final int DEBUGGER_RETRY_DELAY_MS = 250;
    public static final int DEBUGGER_SHUTDOWN_TIMEOUT_SECONDS = 2;
    public static final int DEBUGGER_EXIT_DELAY_MS = 500;

    // Thread Sleep Times
    public static final int SHORT_SLEEP_MS = 500;

    // JVM Options
    public static final String JVM_MAX_HEAP = "-Xmx1G";
    public static final String JVM_ENTITY_SIZE_LIMIT = "-Djdk.xml.maxGeneralEntitySizeLimit=0";
    public static final String JVM_TOTAL_ENTITY_SIZE_LIMIT = "-Djdk.xml.totalEntitySizeLimit=0";

    // LSP Configuration
    public static final String LSP_DETECT_VM_DISABLED = "-DDetectVMInstallationsJob.disabled=true";
    public static final String LSP_FILE_ENCODING = "-Dfile.encoding=UTF-8";
    public static final String LSP_LOG_DISABLE = "-Xlog:disable";
    public static final String LSP_DEPENDENCY_COLLECTOR = "-Daether.dependencyCollector.impl=bf";

    // Debug Flags (disable for production)
    public static final boolean LSP_LOG_PROTOCOL = true;
    public static final String LSP_LOG_LEVEL = "ALL";

    private Constants() {} // Prevent instantiation
}

=================================================================================
FILE: ./src/main/java/com/botmaker/core/AbstractCodeBlock.java
=================================================================================

package com.botmaker.core;

import com.botmaker.lsp.CompletionContext;
import javafx.beans.binding.Bindings;
import javafx.geometry.Insets;
import javafx.scene.Node;
import javafx.scene.control.ContextMenu;
import javafx.scene.control.MenuItem;
import javafx.scene.control.Tooltip;
import javafx.scene.layout.Pane;
import javafx.scene.layout.Region;
import javafx.scene.paint.Color;
import javafx.scene.shape.Circle;
import org.eclipse.jdt.core.dom.ASTNode;
import org.eclipse.jdt.core.dom.CompilationUnit;

public abstract class AbstractCodeBlock implements CodeBlock {
    protected final String id;
    protected final ASTNode astNode;

    protected Node uiNode;
    private javafx.scene.control.Tooltip errorTooltip;

    // Breakpoint State
    protected boolean isBreakpoint = false;
    private Circle breakpointCircle;

    // Constants
    private static final double GUTTER_PADDING = 12.0; // Space reserved on the left
    private static final double CIRCLE_RADIUS = 4.0;

    public AbstractCodeBlock(String id, ASTNode astNode) {
        this.id = id;
        this.astNode = astNode;
    }

    @Override
    public String getId() { return id; }

    @Override
    public ASTNode getAstNode() { return astNode; }

    @Override
    public Node getUINode(CompletionContext context) {
        if (uiNode == null) {
            // 1. Create the standard UI
            this.uiNode = createUINode(context);

            // 2. Inject the visual Gutter (Padding + Circle)
            if (uiNode instanceof Region) {
                Region region = (Region) uiNode;

                // Add left padding to make room for the circle
                Insets existing = region.getPadding();
                region.setPadding(new Insets(
                        existing.getTop(),
                        existing.getRight(),
                        existing.getBottom(),
                        existing.getLeft() + GUTTER_PADDING
                ));

                // If the UI node allows children (Pane), add the floating circle
                if (uiNode instanceof Pane) {
                    Pane pane = (Pane) uiNode;

                    breakpointCircle = new Circle(CIRCLE_RADIUS, Color.RED);
                    breakpointCircle.setManaged(false); // Don't affect flow layout
                    breakpointCircle.setVisible(false); // Hidden by default

                    // Position: Center vertically, placed inside the left padding
                    // x = (Padding / 2) roughly centers it in the gutter
                    breakpointCircle.setLayoutX(GUTTER_PADDING / 2 + existing.getLeft());
                    breakpointCircle.centerYProperty().bind(pane.heightProperty().divide(2));

                    pane.getChildren().add(breakpointCircle);
                }
            }

            // 3. Setup Interaction
            setupBreakpointInteraction();

            // 4. Discovery Tooltip
            Tooltip tip = new Tooltip("Right-click to toggle breakpoint");
            Tooltip.install(uiNode, tip);
        }

        updateBreakpointVisuals();
        return uiNode;
    }

    private void setupBreakpointInteraction() {
        if (uiNode == null) return;

        ContextMenu contextMenu = new ContextMenu();
        MenuItem toggleBpItem = new MenuItem("Toggle Breakpoint");
        toggleBpItem.setOnAction(ev -> toggleBreakpoint());
        contextMenu.getItems().add(toggleBpItem);

        uiNode.setOnContextMenuRequested(e -> {
            toggleBpItem.setText(isBreakpoint ? "Remove Breakpoint 🔴" : "Add Breakpoint ⚪");
            contextMenu.show(uiNode, e.getScreenX(), e.getScreenY());
            e.consume();
        });
    }

    @Override
    public Node getUINode() { return uiNode; }

    @Override
    public void highlight() {
        if (uiNode != null && !uiNode.getStyleClass().contains("highlighted")) {
            uiNode.getStyleClass().add("highlighted");
        }
    }

    @Override
    public void unhighlight() {
        if (uiNode != null) {
            uiNode.getStyleClass().remove("highlighted");
        }
    }

    @Override
    public void setError(String message) {
        if (uiNode != null) {
            if (!uiNode.getStyleClass().contains("error-block")) {
                uiNode.getStyleClass().add("error-block");
            }
            if (errorTooltip == null) {
                errorTooltip = new Tooltip(message);
                Tooltip.install(uiNode, errorTooltip);
            } else {
                errorTooltip.setText(message);
            }
        }
    }

    @Override
    public void clearError() {
        if (uiNode != null) {
            uiNode.getStyleClass().remove("error-block");
            if (errorTooltip != null) {
                Tooltip.uninstall(uiNode, errorTooltip);
                errorTooltip = null;
            }
        }
    }

    @Override
    public int getBreakpointLine(CompilationUnit cu) {
        if (cu == null || astNode == null) return -1;
        return cu.getLineNumber(astNode.getStartPosition());
    }

    @Override
    public CodeBlock getHighlightTarget() { return this; }

    @Override
    public String getDetails() {
        return this.getClass().getSimpleName() + " (ID: " + this.getId() + ")";
    }

    @Override
    public boolean isBreakpoint() { return isBreakpoint; }

    @Override
    public void setBreakpoint(boolean enabled) {
        this.isBreakpoint = enabled;
        updateBreakpointVisuals();
    }

    @Override
    public void toggleBreakpoint() {
        setBreakpoint(!isBreakpoint);
        if (uiNode != null) {
            uiNode.fireEvent(new com.botmaker.ui.BlockEvent.BreakpointToggleEvent(this, isBreakpoint));
        }
    }

    private void updateBreakpointVisuals() {
        // Update the circle visibility
        if (breakpointCircle != null) {
            breakpointCircle.setVisible(isBreakpoint);
        }

        // Optional: Keep the red border as secondary reinforcement, or remove if circle is enough
        if (uiNode != null) {
            String style = uiNode.getStyle();
            String borderStyle = "-fx-border-color: #e74c3c; -fx-border-width: 0 0 0 2; -fx-border-style: solid;";

            if (isBreakpoint) {
                if (!style.contains("-fx-border-color: #e74c3c")) {
                    uiNode.setStyle(style + borderStyle);
                }
            } else {
                uiNode.setStyle(style.replace(borderStyle, ""));
            }
        }
    }

    protected Node createExpressionDropZone(CompletionContext context) {
        Region dropZone = new Region();
        context.dragAndDropManager().addExpressionDropHandlers(dropZone);
        return dropZone;
    }

    protected abstract Node createUINode(CompletionContext context);
}

=================================================================================
FILE: ./src/main/java/com/botmaker/core/AbstractExpressionBlock.java
=================================================================================

package com.botmaker.core;

import org.eclipse.jdt.core.dom.ASTNode;

public abstract class AbstractExpressionBlock extends AbstractCodeBlock implements ExpressionBlock {
    public AbstractExpressionBlock(String id, ASTNode astNode) {
        super(id, astNode);
    }
}


=================================================================================
FILE: ./src/main/java/com/botmaker/core/AbstractStatementBlock.java
=================================================================================

package com.botmaker.core;

import org.eclipse.jdt.core.dom.ASTNode;

public abstract class AbstractStatementBlock extends AbstractCodeBlock implements StatementBlock {
    public AbstractStatementBlock(String id, ASTNode astNode) {
        super(id, astNode);
    }
}


=================================================================================
FILE: ./src/main/java/com/botmaker/core/BlockWithChildren.java
=================================================================================

package com.botmaker.core;

import java.util.List;

public interface BlockWithChildren {
    List<CodeBlock> getChildren();
}


=================================================================================
FILE: ./src/main/java/com/botmaker/core/BodyBlock.java
=================================================================================

package com.botmaker.core;

import com.botmaker.core.AbstractStatementBlock;
import com.botmaker.lsp.CompletionContext;
import com.botmaker.ui.BlockDragAndDropManager;
import javafx.scene.Cursor;
import javafx.scene.Node;
import javafx.scene.layout.Priority;
import javafx.scene.layout.VBox;

import java.util.ArrayList;
import java.util.List;

public class BodyBlock extends AbstractStatementBlock implements BlockWithChildren {
    private final List<StatementBlock> statements = new ArrayList<>();
    private final BlockDragAndDropManager dragAndDropManager;

    public BodyBlock(String id, org.eclipse.jdt.core.dom.Block astNode, BlockDragAndDropManager dragAndDropManager) {
        super(id, astNode);
        this.dragAndDropManager = dragAndDropManager;
    }

    public void addStatement(StatementBlock statement) {
        statements.add(statement);
    }

    public List<StatementBlock> getStatements() {
        return new ArrayList<>(statements);
    }

    public void removeStatement(StatementBlock statement) {
        statements.remove(statement);
    }

    public void insertStatement(int index, StatementBlock statement) {
        if (index < 0 || index > statements.size()) {
            throw new IndexOutOfBoundsException("Index: " + index + ", Size: " + statements.size());
        }
        statements.add(index, statement);
    }

    @Override
    public List<CodeBlock> getChildren() {
        return new ArrayList<>(statements);
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        VBox container = new VBox();
        container.getStyleClass().add("body-block");
        VBox.setVgrow(container, Priority.ALWAYS);

        if (statements.isEmpty()) {
            javafx.scene.control.Label placeholder = new javafx.scene.control.Label("Drag block here");
            placeholder.getStyleClass().add("empty-body-placeholder");
            placeholder.setMouseTransparent(true);
            container.getChildren().add(placeholder);
            container.setAlignment(javafx.geometry.Pos.CENTER);
            container.setMinHeight(30);
            dragAndDropManager.addEmptyBodyDropHandlers(container, this);
        } else {
            // Add a separator at the beginning
            container.getChildren().add(createSeparatorWithHandlers(this, 0));

            for (int i = 0; i < statements.size(); i++) {
                StatementBlock statement = statements.get(i);
                Node statementNode = statement.getUINode(context);

                // Make the statement block draggable for repositioning
                makeStatementDraggable(statementNode, statement);

                container.getChildren().add(statementNode);
                // Add a separator after each statement
                container.getChildren().add(createSeparatorWithHandlers(this, i + 1));
            }
        }
        return container;
    }

    /**
     * Makes a statement block's UI node draggable so it can be repositioned.
     */
    private void makeStatementDraggable(Node statementNode, StatementBlock statement) {
        // Add visual cue that the block is draggable
        statementNode.setOnMouseEntered(e -> {
            statementNode.setCursor(Cursor.OPEN_HAND);
        });

        statementNode.setOnMouseExited(e -> {
            statementNode.setCursor(Cursor.DEFAULT);
        });

        // Register with the drag and drop manager
        dragAndDropManager.makeBlockMovable(statementNode, statement, this);
    }

    private Node createSeparatorWithHandlers(BodyBlock targetBody, int insertionIndex) {
        javafx.scene.layout.Region separator = dragAndDropManager.createSeparator();
        separator.getStyleClass().add("body-block-separator");
        StatementBlock adjacentBlock = (insertionIndex < statements.size()) ? statements.get(insertionIndex) : null;
        dragAndDropManager.addSeparatorDragHandlers(separator, targetBody, insertionIndex, adjacentBlock);
        return separator;
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/core/CodeBlock.java
=================================================================================

package com.botmaker.core;

import com.botmaker.lsp.CompletionContext;
import javafx.scene.Node;
import org.eclipse.jdt.core.dom.ASTNode;
import org.eclipse.jdt.core.dom.CompilationUnit;

public interface CodeBlock {
    String getId();
    ASTNode getAstNode();
    Node getUINode(CompletionContext context);
    Node getUINode();

    // Visual State
    void highlight();
    void unhighlight();
    void setError(String message);
    void clearError();

    // Breakpoint Logic
    void setBreakpoint(boolean enabled);
    boolean isBreakpoint();
    void toggleBreakpoint();

    // Debugging
    int getBreakpointLine(CompilationUnit cu);
    CodeBlock getHighlightTarget();
    String getDetails();
}

=================================================================================
FILE: ./src/main/java/com/botmaker/core/ExpressionBlock.java
=================================================================================

package com.botmaker.core;

/**
 * A block that represents a value that can be evaluated.
 * Examples: a literal "hello", a variable `x`, a calculation `2 + 2`.
 */
public interface ExpressionBlock extends CodeBlock {
}


=================================================================================
FILE: ./src/main/java/com/botmaker/core/StatementBlock.java
=================================================================================

package com.botmaker.core;

/**
 * A block that represents a complete action or step in execution.
 * Examples: a variable declaration, an if-statement, a method call.
 */
public interface StatementBlock extends CodeBlock {
}


=================================================================================
FILE: ./src/main/java/com/botmaker/di/DependencyContainer.java
=================================================================================

package com.botmaker.di;

import java.util.HashMap;
import java.util.Map;
import java.util.function.Supplier;

/**
 * Simple dependency injection container.
 * Manages service lifecycle and provides dependency resolution.
 * Phase 3: Fixed ConcurrentModificationException
 */
public class DependencyContainer {

    private final Map<Class<?>, Object> singletons = new HashMap<>();
    private final Map<Class<?>, Supplier<?>> factories = new HashMap<>();

    /**
     * Register a singleton instance
     */
    public <T> void registerSingleton(Class<T> type, T instance) {
        if (instance == null) {
            throw new IllegalArgumentException("Instance cannot be null");
        }
        singletons.put(type, instance);
    }

    /**
     * Register a factory for creating instances
     */
    public <T> void registerFactory(Class<T> type, Supplier<T> factory) {
        if (factory == null) {
            throw new IllegalArgumentException("Factory cannot be null");
        }
        factories.put(type, factory);
    }

    /**
     * Register a lazy singleton using a factory
     * The instance will be created on first access and cached
     */
    public <T> void registerLazySingleton(Class<T> type, Supplier<T> factory) {
        if (factory == null) {
            throw new IllegalArgumentException("Factory cannot be null");
        }
        factories.put(type, factory);
    }

    /**
     * Resolve a dependency
     */
    @SuppressWarnings("unchecked")
    public <T> T resolve(Class<T> type) {
        // Check if we have a singleton instance
        Object instance = singletons.get(type);
        if (instance != null) {
            return (T) instance;
        }

        // Check if we have a factory
        Supplier<?> factory = factories.get(type);
        if (factory != null) {
            // PHASE 3 FIX: Create instance first, then cache it
            // This avoids ConcurrentModificationException
            T newInstance = (T) factory.get();

            // Cache the instance for future use
            singletons.put(type, newInstance);

            // Remove the factory since we don't need it anymore
            // (optional - keeps memory clean)
            factories.remove(type);

            return newInstance;
        }

        throw new IllegalStateException("No registration found for type: " + type.getName());
    }

    /**
     * Check if a type is registered
     */
    public boolean isRegistered(Class<?> type) {
        return singletons.containsKey(type) || factories.containsKey(type);
    }

    /**
     * Remove a registration
     */
    public void unregister(Class<?> type) {
        singletons.remove(type);
        factories.remove(type);
    }

    /**
     * Clear all registrations
     */
    public void clear() {
        singletons.clear();
        factories.clear();
    }

    /**
     * Get count of registered types
     */
    public int getRegistrationCount() {
        return singletons.size() + factories.size();
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/events/AbstractApplicationEvent.java
=================================================================================

package com.botmaker.events;

/**
 * Abstract base class for events that provides common functionality
 */
public abstract class AbstractApplicationEvent implements ApplicationEvent {
    private final long timestamp;
    private final String source;

    protected AbstractApplicationEvent() {
        this(null);
    }

    protected AbstractApplicationEvent(String source) {
        this.timestamp = System.currentTimeMillis();
        this.source = source != null ? source : getClass().getSimpleName();
    }

    @Override
    public long getTimestamp() {
        return timestamp;
    }

    @Override
    public String getSource() {
        return source;
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/events/ApplicationEvent.java
=================================================================================

package com.botmaker.events;

/**
 * Base interface for all application events.
 * Events represent things that have happened in the application.
 */
public interface ApplicationEvent {
    /**
     * Timestamp when the event was created
     */
    long getTimestamp();

    /**
     * Optional source identifier for debugging
     */
    default String getSource() {
        return getClass().getSimpleName();
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/events/CoreApplicationEvents.java
=================================================================================

package com.botmaker.events;

import com.botmaker.core.CodeBlock;
import org.eclipse.lsp4j.Diagnostic;
import java.util.Collections;
import java.util.List;

public class CoreApplicationEvents {

    // ... (Keep existing events: CodeUpdatedEvent, DiagnosticsUpdatedEvent, UIRefreshRequestedEvent, BlockHighlightEvent) ...

    public static class CodeUpdatedEvent extends AbstractApplicationEvent {
        private final String newCode;
        private final String previousCode;
        public CodeUpdatedEvent(String newCode, String previousCode) {
            this.newCode = newCode;
            this.previousCode = previousCode;
        }
        public String getNewCode() { return newCode; }
        public String getPreviousCode() { return previousCode; }
    }

    public static class DiagnosticsUpdatedEvent extends AbstractApplicationEvent {
        private final List<Diagnostic> diagnostics;
        public DiagnosticsUpdatedEvent(List<Diagnostic> diagnostics) {
            this.diagnostics = diagnostics != null ? List.copyOf(diagnostics) : Collections.emptyList();
        }
        public List<Diagnostic> getDiagnostics() { return diagnostics; }
    }

    public static class UIRefreshRequestedEvent extends AbstractApplicationEvent {
        private final String code;
        public UIRefreshRequestedEvent(String code) { this.code = code; }
        public String getCode() { return code; }
    }

    public static class BlockHighlightEvent extends AbstractApplicationEvent {
        private final CodeBlock block;
        public BlockHighlightEvent(CodeBlock block) { this.block = block; }
        public CodeBlock getBlock() { return block; }
    }

    public static class CompilationRequestedEvent extends AbstractApplicationEvent {}
    public static class ExecutionRequestedEvent extends AbstractApplicationEvent {}
    public static class DebugStartRequestedEvent extends AbstractApplicationEvent {}

    public static class DebugSessionStartedEvent extends AbstractApplicationEvent {}
    public static class DebugSessionResumedEvent extends AbstractApplicationEvent {}
    public static class DebugSessionFinishedEvent extends AbstractApplicationEvent {}

    public static class DebugSessionPausedEvent extends AbstractApplicationEvent {
        private final int lineNumber;
        private final CodeBlock block;
        public DebugSessionPausedEvent(int lineNumber, CodeBlock block) {
            this.lineNumber = lineNumber;
            this.block = block;
        }
        public int getLineNumber() { return lineNumber; }
        public CodeBlock getBlock() { return block; }
    }

    public static class StatusMessageEvent extends AbstractApplicationEvent {
        private final String message;
        public StatusMessageEvent(String message) { this.message = message; }
        public String getMessage() { return message; }
    }

    public static class UIBlocksUpdatedEvent extends AbstractApplicationEvent {
        private final com.botmaker.blocks.MainBlock rootBlock;
        public UIBlocksUpdatedEvent(com.botmaker.blocks.MainBlock rootBlock) {
            super("CodeEditorService");
            this.rootBlock = rootBlock;
        }
        public com.botmaker.blocks.MainBlock getRootBlock() { return rootBlock; }
    }

    public static class OutputAppendedEvent extends AbstractApplicationEvent {
        private final String text;
        public OutputAppendedEvent(String text) { this.text = text; }
        public String getText() { return text; }
    }

    public static class OutputClearedEvent extends AbstractApplicationEvent {}
    public static class OutputSetEvent extends AbstractApplicationEvent {
        private final String text;
        public OutputSetEvent(String text) { this.text = text; }
        public String getText() { return text; }
    }

    public static class UndoRequestedEvent extends AbstractApplicationEvent {
        public UndoRequestedEvent() { super("User"); }
    }

    public static class RedoRequestedEvent extends AbstractApplicationEvent {
        public RedoRequestedEvent() { super("User"); }
    }

    /**
     * Fired whenever the history stack changes (to enable/disable UI buttons)
     */
    public static class HistoryStateChangedEvent extends AbstractApplicationEvent {
        private final boolean canUndo;
        private final boolean canRedo;

        public HistoryStateChangedEvent(boolean canUndo, boolean canRedo) {
            this.canUndo = canUndo;
            this.canRedo = canRedo;
        }

        public boolean canUndo() { return canUndo; }
        public boolean canRedo() { return canRedo; }
    }


    // ADD THESE EVENT CLASSES TO CoreApplicationEvents.java:

    /**
     * Fired when a user requests to stop the currently running program
     */
    public static class StopRunRequestedEvent extends AbstractApplicationEvent {
        public StopRunRequestedEvent() {
            super("User");
        }
    }

    /**
     * Fired when a program starts executing (not debugging)
     */
    public static class ProgramStartedEvent extends AbstractApplicationEvent {
        public ProgramStartedEvent() {
            super("ExecutionService");
        }
    }

    /**
     * Fired when a program stops executing (completed or terminated)
     */
    public static class ProgramStoppedEvent extends AbstractApplicationEvent {
        public ProgramStoppedEvent() {
            super("ExecutionService");
        }
    }
    /**
     * Fired when a user wants to step over the current line
     */
    public static class DebugStepOverRequestedEvent extends AbstractApplicationEvent {
        public DebugStepOverRequestedEvent() {
            super("User");
        }
    }

    public static class DebugStopRequestedEvent extends AbstractApplicationEvent {
        public DebugStopRequestedEvent() {
            super("User");
        }
    }

    /**
     * Fired when a user wants to continue execution until the next breakpoint
     */
    public static class DebugContinueRequestedEvent extends AbstractApplicationEvent {
        public DebugContinueRequestedEvent() {
            super("User");
        }
    }

    /**
     * Fired when a user toggles a breakpoint on a block
     */
    public static class BreakpointToggledEvent extends AbstractApplicationEvent {
        private final CodeBlock block;
        private final boolean isEnabled;

        public BreakpointToggledEvent(CodeBlock block, boolean isEnabled) {
            super("User");
            this.block = block;
            this.isEnabled = isEnabled;
        }

        public CodeBlock getBlock() { return block; }
        public boolean isEnabled() { return isEnabled; }
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/events/EventBus.java
=================================================================================

package com.botmaker.events;

import javafx.application.Platform;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.function.Consumer;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * Central event bus for application-wide event communication.
 * Thread-safe and supports both synchronous and asynchronous event delivery.
 */
public class EventBus {
    private static final Logger LOGGER = Logger.getLogger(EventBus.class.getName());

    private final Map<Class<? extends ApplicationEvent>, List<EventHandler<?>>> handlers;
    private final boolean enableLogging;

    public EventBus() {
        this(false);
    }

    public EventBus(boolean enableLogging) {
        this.handlers = new ConcurrentHashMap<>();
        this.enableLogging = enableLogging;
    }

    /**
     * Subscribe to events of a specific type
     */
    public <T extends ApplicationEvent> void subscribe(Class<T> eventType, Consumer<T> handler) {
        subscribe(eventType, handler, false);
    }

    /**
     * Subscribe to events with option to run on JavaFX thread
     */
    public <T extends ApplicationEvent> void subscribe(
            Class<T> eventType,
            Consumer<T> handler,
            boolean runOnFxThread) {

        handlers.computeIfAbsent(eventType, k -> new CopyOnWriteArrayList<>())
                .add(new EventHandler<>(handler, runOnFxThread));

        if (enableLogging) {
            LOGGER.info("Subscribed to " + eventType.getSimpleName());
        }
    }

    /**
     * Publish an event to all subscribers
     */
    public void publish(ApplicationEvent event) {
        if (event == null) {
            return;
        }

        if (enableLogging) {
            LOGGER.info("Publishing: " + event.getSource());
        }

        Class<? extends ApplicationEvent> eventType = event.getClass();
        List<EventHandler<?>> eventHandlers = handlers.get(eventType);

        if (eventHandlers == null || eventHandlers.isEmpty()) {
            if (enableLogging) {
                LOGGER.warning("No handlers for event: " + eventType.getSimpleName());
            }
            return;
        }

        for (EventHandler<?> handler : eventHandlers) {
            try {
                handler.handle(event);
            } catch (Exception e) {
                LOGGER.log(Level.SEVERE, "Error handling event: " + eventType.getSimpleName(), e);
            }
        }
    }

    /**
     * Unsubscribe a specific handler from an event type
     */
    public <T extends ApplicationEvent> void unsubscribe(Class<T> eventType, Consumer<T> handler) {
        List<EventHandler<?>> eventHandlers = handlers.get(eventType);
        if (eventHandlers != null) {
            eventHandlers.removeIf(h -> h.getHandler() == handler);
        }
    }

    /**
     * Clear all handlers for a specific event type
     */
    public void clearHandlers(Class<? extends ApplicationEvent> eventType) {
        handlers.remove(eventType);
    }

    /**
     * Clear all handlers
     */
    public void clearAllHandlers() {
        handlers.clear();
    }

    /**
     * Get count of handlers for an event type (useful for debugging)
     */
    public int getHandlerCount(Class<? extends ApplicationEvent> eventType) {
        List<EventHandler<?>> eventHandlers = handlers.get(eventType);
        return eventHandlers != null ? eventHandlers.size() : 0;
    }

    /**
     * Internal wrapper for event handlers
     */
    private static class EventHandler<T extends ApplicationEvent> {
        private final Consumer<T> handler;
        private final boolean runOnFxThread;

        EventHandler(Consumer<T> handler, boolean runOnFxThread) {
            this.handler = handler;
            this.runOnFxThread = runOnFxThread;
        }

        @SuppressWarnings("unchecked")
        void handle(ApplicationEvent event) {
            if (runOnFxThread && !Platform.isFxApplicationThread()) {
                Platform.runLater(() -> handler.accept((T) event));
            } else {
                handler.accept((T) event);
            }
        }

        Consumer<T> getHandler() {
            return handler;
        }
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/lsp/CompletionContext.java
=================================================================================

package com.botmaker.lsp;

import com.botmaker.parser.CodeEditor;
import com.botmaker.ui.BlockDragAndDropManager;
import org.eclipse.lsp4j.services.LanguageServer;

/**
 * Context object passed to blocks for UI rendering and editing operations.
 * Phase 3: Removed Main dependency - blocks now use only what they need.
 */
public record CompletionContext(
        CodeEditor codeEditor,
        LanguageServer server,
        String docUri,
        String sourceCode,
        long docVersion,
        BlockDragAndDropManager dragAndDropManager
) {
    // All the data blocks need, without Main reference
}

=================================================================================
FILE: ./src/main/java/com/botmaker/lsp/JdtLanguageServerLauncher.java
=================================================================================

package com.botmaker.lsp;

import com.botmaker.config.Constants;
import org.eclipse.lsp4j.jsonrpc.Launcher;
import org.eclipse.lsp4j.launch.LSPLauncher;
import org.eclipse.lsp4j.services.LanguageClient;
import org.eclipse.lsp4j.services.LanguageServer;
import org.eclipse.lsp4j.*;

import java.io.*;
import java.nio.file.*;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.function.Consumer;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.stream.Stream;

public class JdtLanguageServerLauncher {

    private final Process process;
    private final LanguageServer server;

    public JdtLanguageServerLauncher(
            Path jdtlsPath,
            Path projectPath,
            Path workspaceData,
            Consumer<PublishDiagnosticsParams> diagnosticsConsumer) throws Exception {

        // --- LOGGING START ---
        System.out.println("Initializing JDT LS...");
        System.out.println("  JDT Path: " + jdtlsPath);
        System.out.println("  Project: " + projectPath);
        System.out.println("  Workspace: " + workspaceData);
        // --- LOGGING END ---

        // Suppress LSP4J warnings about unsupported notifications
        Logger.getLogger("org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint").setLevel(Level.SEVERE);
        Logger.getLogger("org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer").setLevel(Level.SEVERE);

        // Find the Equinox launcher JAR
        Path launcherJar = Files.list(jdtlsPath.resolve("plugins"))
                .filter(p -> p.getFileName().toString().startsWith("org.eclipse.equinox.launcher_"))
                .findFirst()
                .orElseThrow(() -> new RuntimeException("Launcher JAR not found"));

        String javaExecutable = Paths.get(System.getProperty("java.home"), "bin", "java").toString();

        // USE the projectPath parameter (not hardcoded)
        Path projectDir = projectPath.toAbsolutePath().normalize();

        // USE the workspaceData parameter (not hardcoded)
        Files.createDirectories(workspaceData);

        // Build command with all necessary flags from VS Code implementation
        List<String> command = new ArrayList<>(Arrays.asList(
                javaExecutable,
                // Java 25 specific flags
                Constants.JVM_ENTITY_SIZE_LIMIT,
                Constants.JVM_TOTAL_ENTITY_SIZE_LIMIT,
                // Module system flags
                "--add-modules=ALL-SYSTEM",
                "--add-opens", "java.base/java.util=ALL-UNNAMED",
                "--add-opens", "java.base/java.lang=ALL-UNNAMED",
                "--add-opens", "java.base/sun.nio.fs=ALL-UNNAMED",
                // Eclipse/JDT configuration
                "-Declipse.application=org.eclipse.jdt.ls.core.id1",
                "-Dosgi.bundles.defaultStartLevel=4",
                "-Declipse.product=org.eclipse.jdt.ls.core.product",
                Constants.LSP_DETECT_VM_DISABLED,
                Constants.LSP_FILE_ENCODING,
                Constants.LSP_LOG_DISABLE,
                Constants.JVM_MAX_HEAP,
                Constants.LSP_DEPENDENCY_COLLECTOR,
                "--enable-native-access=javafx.graphics"
        ));

        // Add debug logging conditionally
        if (Constants.LSP_LOG_PROTOCOL) {
            command.add("-Dlog.protocol=true");
            command.add("-Dlog.level=" + Constants.LSP_LOG_LEVEL);
        }

        command.addAll(Arrays.asList(
                "-jar", launcherJar.toString(),
                "-configuration", jdtlsPath.resolve("config_linux").toString(),
                "-data", workspaceData.toAbsolutePath().normalize().toString()
        ));

        ProcessBuilder pb = new ProcessBuilder(command);
        process = pb.start();

        // Log the error stream separately to see any server-side issues.
        new Thread(() -> {
            try (BufferedReader br = new BufferedReader(new InputStreamReader(process.getErrorStream()))) {
                String line;
                while ((line = br.readLine()) != null) {
                    System.err.println("[JDT LS ERR] " + line);
                }
            } catch (IOException ignored) {}
        }).start();

        // Connect LSP4J client to the process
        Launcher<LanguageServer> launcher = LSPLauncher.createClientLauncher(
                new SimpleLanguageClient(diagnosticsConsumer),
                process.getInputStream(),
                process.getOutputStream()
        );

        launcher.startListening();
        server = launcher.getRemoteProxy();

        // Initialize LSP params
        InitializeParams init = new InitializeParams();
        init.setProcessId((int) ProcessHandle.current().pid());

        // Set up client capabilities
        ClientCapabilities capabilities = new ClientCapabilities();
        WorkspaceClientCapabilities workspaceCaps = new WorkspaceClientCapabilities();
        workspaceCaps.setDidChangeConfiguration(new DidChangeConfigurationCapabilities(true));
        workspaceCaps.setWorkspaceFolders(true);
        capabilities.setWorkspace(workspaceCaps);

        TextDocumentClientCapabilities textDocCaps = new TextDocumentClientCapabilities();
        capabilities.setTextDocument(textDocCaps);

        init.setCapabilities(capabilities);

        // Add workspace folder - this should point to your actual project
        WorkspaceFolder folder = new WorkspaceFolder(projectDir.toUri().toString());
        init.setWorkspaceFolders(List.of(folder));
        init.setRootUri(folder.getUri());

        System.out.println("Workspace root: " + folder.getUri());
        System.out.println("Workspace data: " + workspaceData);

        // Initialize the server
        InitializeResult result = server.initialize(init).get();
        System.out.println("Server initialized: " + result.getCapabilities());

        // Send initialized notification
        server.initialized(new InitializedParams());
    }

    public LanguageServer getServer() {
        return server;
    }

    public void stop() {
        try { server.shutdown().get(); } catch (Exception ignored) {}
        server.exit();
        process.destroy();
    }

    /**
     * Forcefully deletes the workspace cache directory.
     * Call this BEFORE creating the launcher if you suspect corruption.
     */
    public static void cleanupWorkspace(Path workspaceData) {
        if (!Files.exists(workspaceData)) return;

        System.out.println("Cleaning up JDT workspace cache: " + workspaceData);
        try (Stream<Path> walk = Files.walk(workspaceData)) {
            walk.sorted(Comparator.reverseOrder())
                    .map(Path::toFile)
                    .forEach(File::delete);
            System.out.println("Cache cleared successfully.");
        } catch (IOException e) {
            System.err.println("Failed to clear workspace cache: " + e.getMessage());
            // Try to delete at least the lock file
            try {
                Files.deleteIfExists(workspaceData.resolve(".metadata/.lock"));
                System.out.println("Deleted .lock file as fallback.");
            } catch (IOException ex) {
                ex.printStackTrace();
            }
        }
    }

    // Minimal LSP client
    static class SimpleLanguageClient implements LanguageClient {
        private final Consumer<PublishDiagnosticsParams> diagnosticsConsumer;

        public SimpleLanguageClient(Consumer<PublishDiagnosticsParams> diagnosticsConsumer) {
            this.diagnosticsConsumer = diagnosticsConsumer;
        }

        @Override
        public void telemetryEvent(Object o) {
            System.out.println("[Telemetry] " + o);
        }

        @Override
        public void publishDiagnostics(PublishDiagnosticsParams diagnostics) {
            System.out.println("[Diagnostics] " + diagnostics.getUri() + " -> " + diagnostics.getDiagnostics().size() + " issues");
            if (diagnosticsConsumer != null) {
                diagnosticsConsumer.accept(diagnostics);
            }
        }

        @Override
        public void showMessage(MessageParams messageParams) {
            System.out.println("[Message] " + messageParams.getMessage());
        }

        @Override
        public CompletableFuture<MessageActionItem> showMessageRequest(ShowMessageRequestParams showMessageRequestParams) {
            System.out.println("[MessageRequest] " + showMessageRequestParams.getMessage());
            return CompletableFuture.completedFuture(null);
        }

        @Override
        public void logMessage(MessageParams messageParams) {
            System.out.println("[Log] " + messageParams.getMessage());
        }

        @Override
        public CompletableFuture<Void> registerCapability(RegistrationParams params) {
            System.out.println("[RegisterCapability] " + params.getRegistrations().size() + " capabilities");
            return CompletableFuture.completedFuture(null);
        }

        @Override
        public CompletableFuture<Void> unregisterCapability(UnregistrationParams params) {
            System.out.println("[UnregisterCapability] " + params.getUnregisterations().size() + " capabilities");
            return CompletableFuture.completedFuture(null);
        }
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/Main.java
=================================================================================

package com.botmaker;

import com.botmaker.config.ApplicationConfig;
import com.botmaker.core.BodyBlock;
import com.botmaker.core.StatementBlock;
import com.botmaker.di.DependencyContainer;
import com.botmaker.events.CoreApplicationEvents;
import com.botmaker.events.EventBus;
import com.botmaker.parser.AstRewriter;
import com.botmaker.parser.BlockFactory;
import com.botmaker.project.ProjectConfig;
import com.botmaker.runtime.CodeExecutionService;
import com.botmaker.services.*;
import com.botmaker.state.ApplicationState;
import com.botmaker.ui.BlockDragAndDropManager;
import com.botmaker.ui.ProjectSelectionScreen;
import com.botmaker.ui.UIManager;
import com.botmaker.util.BlockLookupHelper;
import com.botmaker.validation.DiagnosticsManager;
import javafx.application.Application;
import javafx.application.Platform;
import javafx.scene.control.Alert;
import javafx.stage.Stage;

import java.nio.file.Files;
import java.nio.file.Paths;

public class Main extends Application {

    private DependencyContainer container;
    private LanguageServerService languageServerService;

    @Override
    public void start(Stage primaryStage) throws Exception {
        String lastProject = ProjectConfig.getLastOpened();

        // NOTE: Auto-load disabled if we want to force the cache option availability
        // But for convenience, we check if it exists.
        // If you are stuck in a crash loop, delete .botmaker-config.json manually once.
        if (lastProject != null && projectExists(lastProject)) {
            System.out.println("Auto-loading last project: " + lastProject);
            openProject(primaryStage, lastProject, false); // Default: don't clear cache on auto-load
        } else {
            showProjectSelection(primaryStage);
        }
    }

    private void showProjectSelection(Stage primaryStage) {
        ProjectSelectionScreen selectionScreen = new ProjectSelectionScreen(
                primaryStage,
                (projectName, clearCache) -> openProject(primaryStage, projectName, clearCache)
        );

        primaryStage.setScene(selectionScreen.createScene());
        primaryStage.setTitle("BotMaker - Select Project");
        primaryStage.show();
    }

    private boolean projectExists(String projectName) {
        return Files.exists(Paths.get("projects", projectName)) &&
                Files.exists(Paths.get("projects", projectName, "build.gradle"));
    }

    private void openProject(Stage primaryStage, String projectName, boolean clearCache) {
        try {
            ProjectConfig.updateLastOpened(projectName);

            container = new DependencyContainer();
            ApplicationConfig config = ApplicationConfig.forProject(projectName);

            setupDependencies(config, primaryStage);

            // --- INJECT CLEAR CACHE FLAG ---
            if (clearCache) {
                LanguageServerService lss = container.resolve(LanguageServerService.class);
                lss.setShouldClearCache(true);
            }

            initializeServices();

            UIManager uiManager = container.resolve(UIManager.class);
            primaryStage.setScene(uiManager.createScene());
            primaryStage.setTitle("BotMaker Blocks - " + projectName);

            CodeEditorService codeEditorService = container.resolve(CodeEditorService.class);
            codeEditorService.loadInitialCode();

            primaryStage.show();

            primaryStage.setOnCloseRequest(e -> {
                e.consume();
                new Thread(() -> {
                    try {
                        if (languageServerService != null) {
                            System.out.println("Shutting down Language Server...");
                            languageServerService.shutdown();
                            System.out.println("Language Server shut down successfully.");
                        }
                    } catch (Exception ex) {
                        System.err.println("Error during shutdown: " + ex.getMessage());
                    } finally {
                        Platform.runLater(() -> {
                            Platform.exit();
                            System.exit(0);
                        });
                    }
                }).start();
            });

        } catch (Exception e) {
            e.printStackTrace();
            showErrorDialog("Error opening project: " + e.getMessage());
            if (ProjectConfig.getLastOpened() != null) {
                showProjectSelection(primaryStage);
            }
        }
    }

    // ... rest of Main.java (setupDependencies, initializeServices, showErrorDialog) ...
    // COPY EXISTING METHODS HERE

    private void showErrorDialog(String message) {
        Alert alert = new Alert(Alert.AlertType.ERROR);
        alert.setTitle("Error");
        alert.setHeaderText("Failed to open project");
        alert.setContentText(message);
        alert.showAndWait();
    }

    private void setupDependencies(ApplicationConfig config, Stage primaryStage) {
        container.registerSingleton(ApplicationConfig.class, config);
        container.registerSingleton(ApplicationState.class, new ApplicationState());
        container.registerSingleton(EventBus.class, new EventBus(config.isEnableEventLogging()));

        container.registerSingleton(BlockFactory.class, new BlockFactory());
        container.registerSingleton(AstRewriter.class, new AstRewriter());
        container.registerSingleton(
                com.botmaker.validation.DiagnosticsManager.class,
                new com.botmaker.validation.DiagnosticsManager()
        );

        container.registerSingleton(BlockDragAndDropManager.class,
                new BlockDragAndDropManager(null)
        );

        // IMPORTANT: This must return the SAME instance if resolved multiple times
        // using registerSingleton for the factory result logic in container
        container.registerLazySingleton(LanguageServerService.class, () ->
                new LanguageServerService(
                        container.resolve(ApplicationConfig.class),
                        container.resolve(ApplicationState.class),
                        container.resolve(EventBus.class),
                        container.resolve(com.botmaker.validation.DiagnosticsManager.class)
                )
        );

        container.registerLazySingleton(CodeExecutionService.class, () -> {
            EventBus eventBus = container.resolve(EventBus.class);
            return new CodeExecutionService(
                    text -> eventBus.publish(new CoreApplicationEvents.OutputAppendedEvent(text)),
                    () -> eventBus.publish(new CoreApplicationEvents.OutputClearedEvent()),
                    text -> eventBus.publish(new CoreApplicationEvents.OutputSetEvent(text)),
                    msg -> eventBus.publish(new CoreApplicationEvents.StatusMessageEvent(msg)),
                    container.resolve(DiagnosticsManager.class),
                    container.resolve(ApplicationConfig.class)
            );
        });

        container.registerLazySingleton(CodeEditorService.class, () ->
                new CodeEditorService(
                        container.resolve(ApplicationConfig.class),
                        container.resolve(ApplicationState.class),
                        container.resolve(EventBus.class),
                        container.resolve(BlockFactory.class),
                        container.resolve(AstRewriter.class),
                        container.resolve(BlockDragAndDropManager.class),
                        container.resolve(LanguageServerService.class),
                        container.resolve(com.botmaker.validation.DiagnosticsManager.class)
                )
        );

        container.registerLazySingleton(ExecutionService.class, () ->
                new ExecutionService(
                        container.resolve(ApplicationConfig.class),
                        container.resolve(ApplicationState.class),
                        container.resolve(EventBus.class),
                        container.resolve(CodeExecutionService.class),
                        container.resolve(com.botmaker.validation.DiagnosticsManager.class)
                )
        );

        container.registerLazySingleton(DebuggingService.class, () ->
                new DebuggingService(
                        container.resolve(ApplicationState.class),
                        container.resolve(EventBus.class),
                        container.resolve(CodeExecutionService.class),
                        container.resolve(BlockFactory.class),
                        container.resolve(ApplicationConfig.class)
                )
        );

        container.registerLazySingleton(UIManager.class, () -> {
            UIManager uiManager = new UIManager(
                    container.resolve(BlockDragAndDropManager.class),
                    container.resolve(EventBus.class),
                    container.resolve(CodeEditorService.class),
                    container.resolve(com.botmaker.validation.DiagnosticsManager.class),
                    primaryStage
            );
            uiManager.setOnSelectProject(v -> showProjectSelection(primaryStage));
            return uiManager;
        });
    }

    private void initializeServices() throws Exception {
        languageServerService = container.resolve(LanguageServerService.class);
        languageServerService.initialize();

        CodeEditorService codeEditorService = container.resolve(CodeEditorService.class);
        ApplicationState state = container.resolve(ApplicationState.class);
        BlockDragAndDropManager dragAndDropManager = container.resolve(BlockDragAndDropManager.class);

        dragAndDropManager.setCallback(dropInfo ->
                codeEditorService.getCodeEditor().addStatement(
                        dropInfo.targetBody(),
                        dropInfo.type(),
                        dropInfo.insertionIndex()
                )
        );

        dragAndDropManager.setMoveCallback(moveInfo -> {
            System.out.println("Move callback triggered for blockId: " + moveInfo.blockId());
            StatementBlock blockToMove = BlockLookupHelper.findBlockById(
                    moveInfo.blockId(),
                    state.getNodeToBlockMap()
            );

            if (blockToMove != null) {
                BodyBlock sourceBody = BlockLookupHelper.findParentBody(
                        blockToMove,
                        state.getNodeToBlockMap()
                );

                if (sourceBody != null) {
                    codeEditorService.getCodeEditor().moveStatement(
                            blockToMove,
                            sourceBody,
                            moveInfo.targetBody(),
                            moveInfo.insertionIndex()
                    );
                }
            }
        });

        container.resolve(ExecutionService.class);
        container.resolve(DebuggingService.class);
        container.resolve(UIManager.class);
    }

    public static void main(String[] args) {
        launch(args);
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/parser/AstRewriter.java
=================================================================================

package com.botmaker.parser;

import com.botmaker.core.BodyBlock;
import com.botmaker.core.StatementBlock;
import com.botmaker.ui.AddableBlock;
import com.botmaker.ui.AddableExpression;
import com.botmaker.util.DefaultNames;
import com.botmaker.util.TypeManager;

import org.eclipse.jdt.core.dom.*;
import org.eclipse.jdt.core.dom.rewrite.*;
import org.eclipse.jface.text.Document;
import org.eclipse.jface.text.IDocument;
import org.eclipse.text.edits.TextEdit;

import java.util.List;

public class AstRewriter {

    /**
     * Moves a statement from one position to another, potentially across different bodies.
     * @param cu The compilation unit
     * @param originalCode The current source code
     * @param blockToMove The StatementBlock to move
     * @param sourceBody The BodyBlock containing the statement (can be same as targetBody)
     * @param targetBody The BodyBlock where the statement should be moved to
     * @param targetIndex The index in the target body where the statement should be inserted
     * @return The updated source code
     */
    public String moveStatement(CompilationUnit cu, String originalCode,
                                StatementBlock blockToMove, BodyBlock sourceBody,
                                BodyBlock targetBody, int targetIndex) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);

        Statement statement = (Statement) blockToMove.getAstNode();
        Block sourceBlock = (Block) sourceBody.getAstNode();
        Block targetBlock = (Block) targetBody.getAstNode();

        // Get the list rewriters for both source and target
        ListRewrite sourceListRewrite = rewriter.getListRewrite(sourceBlock, Block.STATEMENTS_PROPERTY);
        ListRewrite targetListRewrite = rewriter.getListRewrite(targetBlock, Block.STATEMENTS_PROPERTY);

        // If moving to the exact same position (same body, same index), do nothing
        if (sourceBody == targetBody) {
            int currentIndex = sourceBlock.statements().indexOf(statement);
            if (currentIndex == targetIndex) {
                return originalCode;
            }
        }

        // Create a copy of the statement for the new location
        Statement copiedStatement = (Statement) ASTNode.copySubtree(ast, statement);

        // Remove from source and insert at target
        sourceListRewrite.remove(statement, null);
        targetListRewrite.insertAt(copiedStatement, targetIndex, null);

        IDocument document = new Document(originalCode);
        try {
            TextEdit edits = rewriter.rewriteAST(document, null);
            edits.apply(document);
            return document.get();
        } catch (Exception e) {
            e.printStackTrace();
            return originalCode;
        }
    }

    public String addStatement(CompilationUnit cu, String originalCode, BodyBlock targetBody, AddableBlock type, int index) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);

        if (type == AddableBlock.COMMENT) {
            // SPECIAL HANDLING FOR COMMENTS
            // We use a String Placeholder. It is not a real statement, but JDT ListRewrite accepts it.
            // ASTNode.EMPTY_STATEMENT is passed as a type hint for formatting.
            Statement commentPlaceholder = (Statement) rewriter.createStringPlaceholder("// Comment", ASTNode.EMPTY_STATEMENT);

            Block targetAstBlock = (Block) targetBody.getAstNode();
            ListRewrite listRewrite = rewriter.getListRewrite(targetAstBlock, Block.STATEMENTS_PROPERTY);
            listRewrite.insertAt(commentPlaceholder, index, null);
        } else {
            // Standard Statement Handling
            Statement newStatement = createDefaultStatement(ast, type);
            if (newStatement == null) return originalCode;

            Block targetAstBlock = (Block) targetBody.getAstNode();
            ListRewrite listRewrite = rewriter.getListRewrite(targetAstBlock, Block.STATEMENTS_PROPERTY);
            listRewrite.insertAt(newStatement, index, null);
        }

        return applyRewrite(rewriter, originalCode);
    }

    private String applyRewrite(ASTRewrite rewriter, String originalCode) {
        IDocument document = new Document(originalCode);
        try {
            TextEdit edits = rewriter.rewriteAST(document, null);
            edits.apply(document);
            return document.get();
        } catch (Exception e) {
            e.printStackTrace();
            return originalCode;
        }
    }

    public String replaceExpression(CompilationUnit cu, String originalCode, Expression toReplace, com.botmaker.ui.AddableExpression type) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);

        Expression newExpression = createDefaultExpression(ast, type);
        if (newExpression == null) {
            return originalCode;
        }

        rewriter.replace(toReplace, newExpression, null);

        IDocument document = new Document(originalCode);
        try {
            TextEdit edits = rewriter.rewriteAST(document, null);
            edits.apply(document);
            return document.get();
        } catch (Exception e) {
            e.printStackTrace();
            return originalCode;
        }
    }

    public String updateComment(String originalCode, Comment commentNode, String newText) {
        try {
            IDocument document = new Document(originalCode);

            String replacement;
            if (newText.contains("\n")) {
                // Use Block Comment for multi-line text
                replacement = "/* " + newText + " */";
            } else {
                // Use Line Comment for single-line text
                replacement = "// " + newText;
            }

            // Directly replace the text range in the document
            document.replace(commentNode.getStartPosition(), commentNode.getLength(), replacement);

            return document.get();
        } catch (Exception e) {
            e.printStackTrace();
            return originalCode;
        }
    }

    /**
     * Deletes a comment node by removing its text range.
     */
    public String deleteComment(String originalCode, Comment commentNode) {
        try {
            IDocument document = new Document(originalCode);
            // Replace content with empty string
            document.replace(commentNode.getStartPosition(), commentNode.getLength(), "");
            return document.get();
        } catch (Exception e) {
            e.printStackTrace();
            return originalCode;
        }
    }


    public String replaceLiteral(CompilationUnit cu, String originalCode, Expression toReplace, String newLiteralValue) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);

        Expression newExpression;
        if (toReplace instanceof StringLiteral) {
            StringLiteral newString = ast.newStringLiteral();
            newString.setLiteralValue(newLiteralValue);
            newExpression = newString;
        } else if (toReplace instanceof NumberLiteral) {
            newExpression = ast.newNumberLiteral(newLiteralValue);
        } else if (toReplace instanceof BooleanLiteral) {
            newExpression = ast.newBooleanLiteral(Boolean.parseBoolean(newLiteralValue));
        } else {
            return originalCode;
        }

        rewriter.replace(toReplace, newExpression, null);

        IDocument document = new Document(originalCode);
        try {
            TextEdit edits = rewriter.rewriteAST(document, null);
            edits.apply(document);
            return document.get();
        } catch (Exception e) {
            e.printStackTrace();
            return originalCode;
        }
    }

    public String addArgumentToMethodInvocation(CompilationUnit cu, String originalCode, MethodInvocation mi, Expression newArgument) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);
        ListRewrite listRewrite = rewriter.getListRewrite(mi, MethodInvocation.ARGUMENTS_PROPERTY);
        listRewrite.insertLast(newArgument, null);

        IDocument document = new Document(originalCode);
        try {
            TextEdit edits = rewriter.rewriteAST(document, null);
            edits.apply(document);
            return document.get();
        } catch (Exception e) {
            e.printStackTrace();
            return originalCode;
        }
    }

    public String replaceSimpleName(CompilationUnit cu, String originalCode, SimpleName toReplace, String newName) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);
        SimpleName newSimpleName = ast.newSimpleName(newName);
        rewriter.replace(toReplace, newSimpleName, null);

        IDocument document = new Document(originalCode);
        try {
            TextEdit edits = rewriter.rewriteAST(document, null);
            edits.apply(document);
            return document.get();
        } catch (Exception e) {
            e.printStackTrace();
            return originalCode;
        }
    }

    public String deleteNode(CompilationUnit cu, String originalCode, ASTNode toDelete) {
        ASTRewrite rewriter = ASTRewrite.create(cu.getAST());
        rewriter.remove(toDelete, null);

        IDocument document = new Document(originalCode);
        try {
            TextEdit edits = rewriter.rewriteAST(document, null);
            edits.apply(document);
            return document.get();
        } catch (Exception e) {
            e.printStackTrace();
            return originalCode;
        }
    }

    public String deleteElseFromIfStatement(CompilationUnit cu, String originalCode, IfStatement ifStatement) {
        ASTRewrite rewriter = ASTRewrite.create(cu.getAST());
        if (ifStatement.getElseStatement() != null) {
            rewriter.remove(ifStatement.getElseStatement(), null);
        } else {
            return originalCode;
        }
        IDocument document = new Document(originalCode);
        try {
            TextEdit edits = rewriter.rewriteAST(document, null);
            edits.apply(document);
            return document.get();
        } catch (Exception e) {
            e.printStackTrace();
            return originalCode;
        }
    }

    public String convertElseToElseIf(CompilationUnit cu, String originalCode, IfStatement ifStatement) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);
        Statement elseStatement = ifStatement.getElseStatement();
        if (elseStatement == null || elseStatement.getNodeType() != ASTNode.BLOCK) {
            return originalCode;
        }
        IfStatement newElseIf = ast.newIfStatement();
        newElseIf.setExpression(ast.newBooleanLiteral(true));
        newElseIf.setThenStatement((Block) ASTNode.copySubtree(ast, elseStatement));
        rewriter.replace(elseStatement, newElseIf, null);
        IDocument document = new Document(originalCode);
        try {
            TextEdit edits = rewriter.rewriteAST(document, null);
            edits.apply(document);
            return document.get();
        } catch (Exception e) {
            e.printStackTrace();
            return originalCode;
        }
    }

    public String addElseToIfStatement(CompilationUnit cu, String originalCode, IfStatement ifStatement) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);

        if (ifStatement.getElseStatement() == null) {
            Block elseBlock = ast.newBlock();
            rewriter.set(ifStatement, IfStatement.ELSE_STATEMENT_PROPERTY, elseBlock, null);
        } else {
            return originalCode;
        }

        IDocument document = new Document(originalCode);
        try {
            TextEdit edits = rewriter.rewriteAST(document, null);
            edits.apply(document);
            return document.get();
        } catch (Exception e) {
            e.printStackTrace();
            return originalCode;
        }
    }

    // ADD THIS METHOD TO AstRewriter.java - replaces the existing createDefaultExpression

    private Expression createDefaultExpression(AST ast, AddableExpression type) {
        switch (type) {
            case TEXT:
                StringLiteral newString = ast.newStringLiteral();
                newString.setLiteralValue("text");
                return newString;

            case NUMBER:
                return ast.newNumberLiteral("0");

            case TRUE:
                return ast.newBooleanLiteral(true);

            case FALSE:
                return ast.newBooleanLiteral(false);

            case VARIABLE:
                return ast.newSimpleName(DefaultNames.DEFAULT_VARIABLE);

            // NEW: Handle Sub-List creation
            case LIST:
                return ast.newArrayInitializer();

            case ADD:
            case SUBTRACT:
            case MULTIPLY:
            case DIVIDE:
            case MODULO:
                // Create a binary expression: variable <op> 0
                InfixExpression infixExpr = ast.newInfixExpression();
                infixExpr.setLeftOperand(ast.newSimpleName(DefaultNames.DEFAULT_VARIABLE));
                infixExpr.setRightOperand(ast.newNumberLiteral("0"));

                // Set the operator based on type
                switch (type) {
                    case ADD:
                        infixExpr.setOperator(InfixExpression.Operator.PLUS);
                        break;
                    case SUBTRACT:
                        infixExpr.setOperator(InfixExpression.Operator.MINUS);
                        break;
                    case MULTIPLY:
                        infixExpr.setOperator(InfixExpression.Operator.TIMES);
                        break;
                    case DIVIDE:
                        infixExpr.setOperator(InfixExpression.Operator.DIVIDE);
                        break;
                    case MODULO:
                        infixExpr.setOperator(InfixExpression.Operator.REMAINDER);
                        break;
                }
                return infixExpr;

            default:
                return null;
        }
    }

    private Statement createDefaultStatement(AST ast, AddableBlock type) {
        switch (type) {
            case PRINT:
                // System.out.println("");
                MethodInvocation println = ast.newMethodInvocation();
                println.setExpression(ast.newQualifiedName(
                        ast.newSimpleName("System"),
                        ast.newSimpleName("out"))
                );
                println.setName(ast.newSimpleName("println"));
                StringLiteral emptyString = ast.newStringLiteral();
                emptyString.setLiteralValue("");
                println.arguments().add(emptyString);
                return ast.newExpressionStatement(println);
            case DECLARE_INT: {
                VariableDeclarationFragment fragment = ast.newVariableDeclarationFragment();
                fragment.setName(ast.newSimpleName(DefaultNames.DEFAULT_INT));
                fragment.setInitializer(ast.newNumberLiteral("0"));
                VariableDeclarationStatement varDecl = ast.newVariableDeclarationStatement(fragment);
                varDecl.setType(ast.newPrimitiveType(PrimitiveType.INT));
                return varDecl;
            }

            case DECLARE_DOUBLE: {
                VariableDeclarationFragment fragment = ast.newVariableDeclarationFragment();
                fragment.setName(ast.newSimpleName(DefaultNames.DEFAULT_DOUBLE));
                fragment.setInitializer(ast.newNumberLiteral("0.0"));
                VariableDeclarationStatement varDecl = ast.newVariableDeclarationStatement(fragment);
                varDecl.setType(ast.newPrimitiveType(PrimitiveType.DOUBLE));
                return varDecl;
            }

            case DECLARE_BOOLEAN: {
                VariableDeclarationFragment fragment = ast.newVariableDeclarationFragment();
                fragment.setName(ast.newSimpleName(DefaultNames.DEFAULT_BOOLEAN));
                fragment.setInitializer(ast.newBooleanLiteral(false));
                VariableDeclarationStatement varDecl = ast.newVariableDeclarationStatement(fragment);
                varDecl.setType(ast.newPrimitiveType(PrimitiveType.BOOLEAN));
                return varDecl;
            }

            case DECLARE_STRING: {
                VariableDeclarationFragment fragment = ast.newVariableDeclarationFragment();
                fragment.setName(ast.newSimpleName(DefaultNames.DEFAULT_STRING));
                fragment.setInitializer(ast.newStringLiteral());
                VariableDeclarationStatement varDecl = ast.newVariableDeclarationStatement(fragment);
                varDecl.setType(TypeManager.createTypeNode(ast, "String"));
                return varDecl;
            }
            case DECLARE_ARRAY: {
                VariableDeclarationFragment fragment = ast.newVariableDeclarationFragment();
                fragment.setName(ast.newSimpleName("myList"));

                // Default to int[]
                ArrayInitializer initializer = ast.newArrayInitializer();
                // Add one dummy element so it's visible
                initializer.expressions().add(ast.newNumberLiteral("0"));

                ArrayCreation arrayCreation = ast.newArrayCreation();
                arrayCreation.setType(ast.newArrayType(ast.newPrimitiveType(PrimitiveType.INT)));
                arrayCreation.setInitializer(initializer);

                fragment.setInitializer(arrayCreation);

                VariableDeclarationStatement varDecl = ast.newVariableDeclarationStatement(fragment);
                varDecl.setType(ast.newArrayType(ast.newPrimitiveType(PrimitiveType.INT)));
                return varDecl;
            }
            case IF:
                // if (true) {}
                IfStatement ifStatement = ast.newIfStatement();
                ifStatement.setExpression(ast.newBooleanLiteral(true));
                ifStatement.setThenStatement(ast.newBlock());
                return ifStatement;

            case WHILE:
                // while (true) {}
                WhileStatement whileStatement = ast.newWhileStatement();
                whileStatement.setExpression(ast.newBooleanLiteral(true));
                whileStatement.setBody(ast.newBlock());
                return whileStatement;

            case FOR:
                // Enhanced for loop (foreach): for(String item : array) {}
                EnhancedForStatement enhancedFor = ast.newEnhancedForStatement();

                // Parameter: String item
                SingleVariableDeclaration parameter = ast.newSingleVariableDeclaration();
                parameter.setType(TypeManager.createTypeNode(ast, "String"));
                parameter.setName(ast.newSimpleName("item"));
                enhancedFor.setParameter(parameter);

                // Expression: array (or any collection)
                enhancedFor.setExpression(ast.newSimpleName("array"));

                // Body
                enhancedFor.setBody(ast.newBlock());

                return enhancedFor;

            case BREAK:
                return ast.newBreakStatement();

            case CONTINUE:
                return ast.newContinueStatement();

            case ASSIGNMENT: {
                // variable = 0
                Assignment assignment = ast.newAssignment();
                assignment.setLeftHandSide(ast.newSimpleName(DefaultNames.DEFAULT_VARIABLE));
                assignment.setOperator(Assignment.Operator.ASSIGN);
                assignment.setRightHandSide(ast.newNumberLiteral("0"));
                return ast.newExpressionStatement(assignment);
            }

            case READ_LINE: {
                // String input = scanner.nextLine()
                VariableDeclarationFragment fragment = ast.newVariableDeclarationFragment();
                fragment.setName(ast.newSimpleName("input"));

                MethodInvocation scannerCall = ast.newMethodInvocation();
                scannerCall.setExpression(ast.newSimpleName("scanner"));
                scannerCall.setName(ast.newSimpleName("nextLine"));
                fragment.setInitializer(scannerCall);

                VariableDeclarationStatement varDecl = ast.newVariableDeclarationStatement(fragment);
                varDecl.setType(TypeManager.createTypeNode(ast, "String"));
                return varDecl;
            }

            case READ_INT: {
                // int num = scanner.nextInt()
                VariableDeclarationFragment fragment = ast.newVariableDeclarationFragment();
                fragment.setName(ast.newSimpleName("num"));

                MethodInvocation scannerCall = ast.newMethodInvocation();
                scannerCall.setExpression(ast.newSimpleName("scanner"));
                scannerCall.setName(ast.newSimpleName("nextInt"));
                fragment.setInitializer(scannerCall);

                VariableDeclarationStatement varDecl = ast.newVariableDeclarationStatement(fragment);
                varDecl.setType(ast.newPrimitiveType(PrimitiveType.INT));
                return varDecl;
            }

            case READ_DOUBLE: {
                // double num = scanner.nextDouble()
                VariableDeclarationFragment fragment = ast.newVariableDeclarationFragment();
                fragment.setName(ast.newSimpleName("num"));

                MethodInvocation scannerCall = ast.newMethodInvocation();
                scannerCall.setExpression(ast.newSimpleName("scanner"));
                scannerCall.setName(ast.newSimpleName("nextDouble"));
                fragment.setInitializer(scannerCall);

                VariableDeclarationStatement varDecl = ast.newVariableDeclarationStatement(fragment);
                varDecl.setType(ast.newPrimitiveType(PrimitiveType.DOUBLE));
                return varDecl;
            }

            case DO_WHILE:
                // do { } while (true)
                DoStatement doStatement = ast.newDoStatement();
                doStatement.setExpression(ast.newBooleanLiteral(true));
                doStatement.setBody(ast.newBlock());
                return doStatement;

            case SWITCH:
                // switch (variable) { default: break; }
                SwitchStatement switchStatement = ast.newSwitchStatement();
                switchStatement.setExpression(ast.newSimpleName(DefaultNames.DEFAULT_VARIABLE));

                // Add a default case
                SwitchCase defaultCase = ast.newSwitchCase();
                // In JDT AST, a SwitchCase with empty/null expression is treated as 'default'.
                // We do NOT call setDefault(true) as it doesn't exist in modern AST.

                switchStatement.statements().add(defaultCase);

                BreakStatement breakStmt = ast.newBreakStatement();
                switchStatement.statements().add(breakStmt);

                return switchStatement;

            case CASE:
                // case 0:
                SwitchCase switchCase = ast.newSwitchCase();
                // We assume JDK 8+ style (case expression:)
                // In newer JDT versions, we use expressions().add()
                try {
                    // Using reflection to handle different JDT versions if necessary,
                    // but assuming we are on a modern version based on AST.getJLSLatest()
                    switchCase.expressions().add(ast.newNumberLiteral("0"));
                } catch (Exception e) {
                    // Fallback for older JDT where setExpression is used
                    // switchCase.setExpression(ast.newNumberLiteral("0"));
                }
                return switchCase;

            case RETURN:
                // return;
                return ast.newReturnStatement();

            case WAIT:
                // try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); }
                TryStatement tryStmt = ast.newTryStatement();
                Block tryBody = ast.newBlock();

                // Thread.sleep(1000)
                MethodInvocation sleepCall = ast.newMethodInvocation();
                sleepCall.setExpression(ast.newSimpleName("Thread"));
                sleepCall.setName(ast.newSimpleName("sleep"));
                sleepCall.arguments().add(ast.newNumberLiteral("1000"));

                tryBody.statements().add(ast.newExpressionStatement(sleepCall));
                tryStmt.setBody(tryBody);

                // catch (InterruptedException e)
                CatchClause catchClause = ast.newCatchClause();
                SingleVariableDeclaration exceptionDecl = ast.newSingleVariableDeclaration();
                exceptionDecl.setType(ast.newSimpleType(ast.newSimpleName("InterruptedException")));
                exceptionDecl.setName(ast.newSimpleName("e"));
                catchClause.setException(exceptionDecl);

                // e.printStackTrace()
                Block catchBody = ast.newBlock();
                MethodInvocation printStackTrace = ast.newMethodInvocation();
                printStackTrace.setExpression(ast.newSimpleName("e"));
                printStackTrace.setName(ast.newSimpleName("printStackTrace"));
                catchBody.statements().add(ast.newExpressionStatement(printStackTrace));
                catchClause.setBody(catchBody);

                tryStmt.catchClauses().add(catchClause);
                return tryStmt;
            case COMMENT:
                // Comments are special - they're not real statements
                // We'll use an EmptyStatement as a placeholder
                // The actual comment text is stored in the CommentBlock
                EmptyStatement emptyStmt = ast.newEmptyStatement();
                return emptyStmt;

            default:
                return null;
        }
    }

    public String addElementToArrayInitializer(
            CompilationUnit cu,
            String originalCode,
            ArrayInitializer arrayInit,
            com.botmaker.ui.AddableExpression type,
            int insertIndex) {

        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);

        // Create the new expression based on type
        Expression newElement = createDefaultExpression(ast, type);
        if (newElement == null) {
            return originalCode;
        }

        // Use ListRewrite to insert the element
        ListRewrite listRewrite = rewriter.getListRewrite(
                arrayInit,
                ArrayInitializer.EXPRESSIONS_PROPERTY
        );

        listRewrite.insertAt(newElement, insertIndex, null);

        return applyRewrite(rewriter, originalCode);
    }

    /**
     * Deletes an element from an ArrayInitializer at the specified index
     */
    public String deleteElementFromArrayInitializer(
            CompilationUnit cu,
            String originalCode,
            ArrayInitializer arrayInit,
            int elementIndex) {

        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);

        // Get the list of expressions
        @SuppressWarnings("unchecked")
        List<Expression> expressions = arrayInit.expressions();

        if (elementIndex < 0 || elementIndex >= expressions.size()) {
            return originalCode; // Invalid index
        }

        Expression toRemove = expressions.get(elementIndex);

        // Use ListRewrite to remove the element
        ListRewrite listRewrite = rewriter.getListRewrite(
                arrayInit,
                ArrayInitializer.EXPRESSIONS_PROPERTY
        );

        listRewrite.remove(toRemove, null);

        return applyRewrite(rewriter, originalCode);
    }


    private Expression createDefaultInitializer(AST ast, String typeName) {
        switch (typeName) {
            case "int":
            case "long":
            case "short":
            case "byte":
                return ast.newNumberLiteral("0");
            case "double":
            case "float":
                return ast.newNumberLiteral("0.0");
            case "boolean":
                return ast.newBooleanLiteral(false);
            case "char":
                CharacterLiteral literal = ast.newCharacterLiteral();
                literal.setCharValue('a');
                return literal;
            case "String":
                StringLiteral stringLiteral = ast.newStringLiteral();
                stringLiteral.setLiteralValue("");
                return stringLiteral;
            default:
                return ast.newNullLiteral();
        }
    }
// [Inside AstRewriter class]

    public String replaceAssignmentOperator(CompilationUnit cu, String originalCode, Assignment assignment, Assignment.Operator newOp) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);

        // Create a new assignment with the same operands but new operator
        Assignment newAssignment = ast.newAssignment();
        newAssignment.setLeftHandSide((Expression)
                ASTNode.copySubtree(ast, assignment.getLeftHandSide()));
        newAssignment.setRightHandSide((Expression)
                ASTNode.copySubtree(ast, assignment.getRightHandSide()));
        newAssignment.setOperator(newOp);

        rewriter.replace(assignment, newAssignment, null);

        org.eclipse.jface.text.IDocument document = new org.eclipse.jface.text.Document(originalCode);
        try {
            org.eclipse.text.edits.TextEdit edits = rewriter.rewriteAST(document, null);
            edits.apply(document);
            return document.get();
        } catch (Exception e) {
            e.printStackTrace();
            return originalCode;
        }
    }

    // Also handle Prefix expressions (++ / --)
    public String replacePrefixOperator(CompilationUnit cu, String originalCode, PrefixExpression prefix, PrefixExpression.Operator newOp) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);

        PrefixExpression newPrefix = ast.newPrefixExpression();
        newPrefix.setOperand((Expression)
                ASTNode.copySubtree(ast, prefix.getOperand()));
        newPrefix.setOperator(newOp);

        rewriter.replace(prefix, newPrefix, null);

        org.eclipse.jface.text.IDocument document = new org.eclipse.jface.text.Document(originalCode);
        try {
            org.eclipse.text.edits.TextEdit edits = rewriter.rewriteAST(document, null);
            edits.apply(document);
            return document.get();
        } catch (Exception e) {
            e.printStackTrace();
            return originalCode;
        }
    }

    // Also handle Postfix expressions (variable++ / variable--)
    public String replacePostfixOperator(CompilationUnit cu, String originalCode, PostfixExpression postfix, PostfixExpression.Operator newOp) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);

        PostfixExpression newPostfix = ast.newPostfixExpression();
        newPostfix.setOperand((Expression)
                ASTNode.copySubtree(ast, postfix.getOperand()));
        newPostfix.setOperator(newOp);

        rewriter.replace(postfix, newPostfix, null);

        org.eclipse.jface.text.IDocument document = new org.eclipse.jface.text.Document(originalCode);
        try {
            org.eclipse.text.edits.TextEdit edits = rewriter.rewriteAST(document, null);
            edits.apply(document);
            return document.get();
        } catch (Exception e) {
            e.printStackTrace();
            return originalCode;
        }
    }
    public String replaceVariableType(CompilationUnit cu, String originalCode, VariableDeclarationStatement varDecl, String newTypeName) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);

        Type newType = TypeManager.createTypeNode(ast, newTypeName);
        rewriter.replace(varDecl.getType(), newType, null);

        if (!varDecl.fragments().isEmpty()) {
            VariableDeclarationFragment fragment = (VariableDeclarationFragment) varDecl.fragments().get(0);
            Expression currentInitializer = fragment.getInitializer();

            boolean isNewTypeArray = newTypeName.endsWith("[]");
            boolean isCurrentTypeArray = currentInitializer instanceof ArrayCreation || currentInitializer instanceof ArrayInitializer;

            Expression newInitializer = null;

            if (isNewTypeArray) {
                if (!isCurrentTypeArray) {
                    // Switching Primitive -> Array: Create new empty array
                    ArrayCreation creation = ast.newArrayCreation();
                    // We need the element type for 'new int[]' part.
                    // Rough logic: strip one pair of [] for the creation type
                    String elementTypeName = newTypeName.substring(0, newTypeName.lastIndexOf("[]"));
                    creation.setType((ArrayType) TypeManager.createTypeNode(ast, newTypeName));
                    creation.setInitializer(ast.newArrayInitializer());
                    newInitializer = creation;
                } else {
                    // Array -> Array (e.g. int[] to String[]): Keep structure, but types might mismatch.
                    // Ideally we walk the tree, but for stability, let's reset to empty array
                    // or just update the type part of ArrayCreation if it exists.
                    if (currentInitializer instanceof ArrayCreation) {
                        ArrayCreation oldAc = (ArrayCreation) currentInitializer;
                        ArrayCreation newAc = ast.newArrayCreation();
                        newAc.setType((ArrayType) TypeManager.createTypeNode(ast, newTypeName));
                        // Preserve elements if possible? Complex. Let's reset to empty for safety.
                        newAc.setInitializer(ast.newArrayInitializer());
                        newInitializer = newAc;
                    }
                }
            } else {
                // Switching Array -> Primitive
                newInitializer = createDefaultInitializer(ast, newTypeName);
            }

            if (newInitializer != null) {
                rewriter.replace(currentInitializer, newInitializer, null);
            }
        }

        IDocument document = new Document(originalCode);
        try {
            TextEdit edits = rewriter.rewriteAST(document, null);
            edits.apply(document);
            return document.get();
        } catch (Exception e) {
            e.printStackTrace();
            return originalCode;
        }
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/parser/BlockFactory.java
=================================================================================

package com.botmaker.parser;

import com.botmaker.blocks.*;
import com.botmaker.core.*;
import com.botmaker.ui.BlockDragAndDropManager;
import com.botmaker.util.BlockIdPrefix;
import org.eclipse.jdt.core.dom.*;
import org.eclipse.jdt.core.dom.IMethodBinding;
import org.eclipse.jdt.core.dom.ITypeBinding;

import java.util.*;

public class BlockFactory {

    private CompilationUnit ast;
    private String currentSourceCode;
    // Cache for all comments in the file
    private List<Comment> allComments;
    private boolean markNewIdentifiersAsUnedited = false;

    public MainBlock convert(String javaCode, Map<ASTNode, CodeBlock> nodeToBlockMap, BlockDragAndDropManager manager) {
        this.currentSourceCode = javaCode;
        try {
            ASTParser parser = ASTParser.newParser(AST.getJLSLatest());
            parser.setSource(javaCode.toCharArray());
            parser.setResolveBindings(true);
            parser.setKind(ASTParser.K_COMPILATION_UNIT);
            parser.setUnitName("Demo.java");
            parser.setEnvironment(null, null, null, true);
            this.ast = (CompilationUnit) parser.createAST(null);

            // 1. Extract ALL comments from the global list
            this.allComments = new ArrayList<>();
            for (Object obj : ast.getCommentList()) {
                if (obj instanceof Comment && !(obj instanceof Javadoc)) {
                    allComments.add((Comment) obj);
                }
            }

            MainMethodVisitor visitor = new MainMethodVisitor();
            ast.accept(visitor);

            return visitor.getMainMethodDeclaration()
                    .map(mainMethodDecl -> {
                        MainBlock mainBlock = new MainBlock(BlockIdPrefix.generate(BlockIdPrefix.MAIN, mainMethodDecl), mainMethodDecl);
                        nodeToBlockMap.put(mainMethodDecl, mainBlock);
                        visitor.getMainMethodBody().ifPresent(bodyAstNode -> {
                            BodyBlock bodyBlock = parseBodyBlock(bodyAstNode, nodeToBlockMap, manager);
                            mainBlock.setMainBody(bodyBlock);
                        });
                        return mainBlock;
                    })
                    .orElse(null);
        } finally {
            setMarkNewIdentifiersAsUnedited(false);
        }
    }

    /**
     * Enable marking of newly created identifiers as unedited
     * Call this before converting code that contains newly added blocks
     */
    public void setMarkNewIdentifiersAsUnedited(boolean mark) {
        this.markNewIdentifiersAsUnedited = mark;
    }

    private BodyBlock parseBodyBlock(Block astBlock, Map<ASTNode, CodeBlock> nodeToBlockMap, BlockDragAndDropManager manager) {
        BodyBlock bodyBlock = new BodyBlock(BlockIdPrefix.generate(BlockIdPrefix.BODY, astBlock), astBlock, manager);
        nodeToBlockMap.put(astBlock, bodyBlock);

        List<CodeBlock> allChildren = new ArrayList<>();

        // A. Add all real Java Statements
        for (Object statementObj : astBlock.statements()) {
            Statement statement = (Statement) statementObj;
            parseStatement(statement, nodeToBlockMap, manager).ifPresent(allChildren::add);
        }

        // B. Find Comments that belong physically inside this block
        int blockStart = astBlock.getStartPosition() + 1; // Skip '{'
        int blockEnd = astBlock.getStartPosition() + astBlock.getLength() - 1; // Skip '}'

        for (Comment comment : allComments) {
            int cPos = comment.getStartPosition();

            // 1. Is the comment inside this body?
            if (cPos > blockStart && cPos < blockEnd) {

                // 2. Is the comment captured by a child statement?
                // (e.g., inside an IF block that is inside this body)
                boolean isInsideChild = false;
                for (Object stmtObj : astBlock.statements()) {
                    Statement s = (Statement) stmtObj;
                    if (cPos >= s.getStartPosition() && cPos <= s.getStartPosition() + s.getLength()) {
                        isInsideChild = true;
                        break;
                    }
                }

                // If it's not inside a child, it belongs to us
                if (!isInsideChild) {
                    allChildren.add(parseCommentBlock(comment, nodeToBlockMap));
                }
            }
        }

        // C. Sort everything by start position so comments appear in context
        allChildren.sort(Comparator.comparingInt(b -> b.getAstNode().getStartPosition()));

        // D. Add to the BodyBlock
        for (CodeBlock cb : allChildren) {
            if (cb instanceof StatementBlock) {
                bodyBlock.addStatement((StatementBlock) cb);
            }
        }

        return bodyBlock;
    }


    private Optional<StatementBlock> parseStatement(Statement astStatement, Map<ASTNode, CodeBlock> nodeToBlockMap, BlockDragAndDropManager manager) {
        if (astStatement instanceof Block) {
            return Optional.of(parseBodyBlock((Block) astStatement, nodeToBlockMap, manager));
        }
        if (astStatement instanceof VariableDeclarationStatement) {
            VariableDeclarationStatement varDecl = (VariableDeclarationStatement) astStatement;
            // Check if it's a scanner read input
            if (isReadInputStatement(varDecl)) {
                return Optional.of(parseReadInputStatement(varDecl, nodeToBlockMap));
            }
            return Optional.of(parseVariableDeclaration(varDecl, nodeToBlockMap));
        }
        if (astStatement instanceof IfStatement) {
            return Optional.of(parseIfStatement((IfStatement) astStatement, nodeToBlockMap, manager));
        }
        if (astStatement instanceof WhileStatement) {
            return Optional.of(parseWhileStatement((WhileStatement) astStatement, nodeToBlockMap, manager));
        }
        if (astStatement instanceof ReturnStatement) {
            return Optional.of(parseReturnStatement((ReturnStatement) astStatement, nodeToBlockMap));
        }
        if (astStatement instanceof EnhancedForStatement) {
            return Optional.of(parseForStatement((EnhancedForStatement) astStatement, nodeToBlockMap, manager));
        }
        if (astStatement instanceof DoStatement) {
            return Optional.of(parseDoWhileStatement((DoStatement) astStatement, nodeToBlockMap, manager));
        }
        if (astStatement instanceof SwitchStatement) {
            return Optional.of(parseSwitchStatement((SwitchStatement) astStatement, nodeToBlockMap, manager));
        }
        if (astStatement instanceof BreakStatement) {
            return Optional.of(parseBreakStatement((BreakStatement) astStatement, nodeToBlockMap));
        }
        if (astStatement instanceof ContinueStatement) {
            return Optional.of(parseContinueStatement((ContinueStatement) astStatement, nodeToBlockMap));
        }
        if (astStatement instanceof ExpressionStatement) {
            Expression expression = ((ExpressionStatement) astStatement).getExpression();
            if (isPrintStatement(expression)) {
                return Optional.of(parsePrintStatement((ExpressionStatement) astStatement, nodeToBlockMap));
            }
            if (expression instanceof Assignment) {
                return Optional.of(parseAssignmentStatement((ExpressionStatement) astStatement, nodeToBlockMap));
            }
            if (expression instanceof PostfixExpression) {
                PostfixExpression postfix = (PostfixExpression) expression;
                if (postfix.getOperator() == PostfixExpression.Operator.INCREMENT ||
                        postfix.getOperator() == PostfixExpression.Operator.DECREMENT) {
                    return Optional.of(parseAssignmentStatement((ExpressionStatement) astStatement, nodeToBlockMap));
                }
            }
            if (expression instanceof PrefixExpression) {
                PrefixExpression prefix = (PrefixExpression) expression;
                if (prefix.getOperator() == PrefixExpression.Operator.INCREMENT ||
                        prefix.getOperator() == PrefixExpression.Operator.DECREMENT) {
                    return Optional.of(parseAssignmentStatement((ExpressionStatement) astStatement, nodeToBlockMap));
                }
            }
        }
        if (astStatement instanceof TryStatement) {
            TryStatement tryStmt = (TryStatement) astStatement;
            if (isWaitStatement(tryStmt)) {
                return Optional.of(parseWaitStatement(tryStmt, nodeToBlockMap));
            }
        }
        return Optional.empty();
    }

    private boolean isWaitStatement(TryStatement tryStmt) {
        // Check if body has exactly one statement
        if (tryStmt.getBody().statements().size() != 1) return false;

        Statement firstStmt = (Statement) tryStmt.getBody().statements().getFirst();
        if (!(firstStmt instanceof ExpressionStatement)) return false;

        Expression expr = ((ExpressionStatement) firstStmt).getExpression();
        if (!(expr instanceof MethodInvocation)) return false;

        MethodInvocation mi = (MethodInvocation) expr;

        // Check for Thread.sleep
        if (!"sleep".equals(mi.getName().getIdentifier())) return false;

        Expression scope = mi.getExpression();
        return scope != null && "Thread".equals(scope.toString());
    }

    // 3. logic to create the visual block
    private WaitBlock parseWaitStatement(TryStatement astNode, Map<ASTNode, CodeBlock> nodeToBlockMap) {
        System.out.println("Creating WaitBlock for: " + astNode);
        WaitBlock waitBlock = new WaitBlock(BlockIdPrefix.generate(BlockIdPrefix.WAIT, astNode), astNode);
        nodeToBlockMap.put(astNode, waitBlock);

        // Extract the argument from Thread.sleep(arg) inside the try block
        Statement innerStmt = (Statement) astNode.getBody().statements().getFirst();
        ExpressionStatement exprStmt = (ExpressionStatement) innerStmt;
        MethodInvocation mi = (MethodInvocation) exprStmt.getExpression();

        if (!mi.arguments().isEmpty()) {
            Expression arg = (Expression) mi.arguments().getFirst();
            parseExpression(arg, nodeToBlockMap).ifPresent(waitBlock::setDuration);
        }

        return waitBlock;
    }

    private ReturnBlock parseReturnStatement(ReturnStatement astNode, Map<ASTNode, CodeBlock> nodeToBlockMap) {
        System.out.println("Creating ReturnBlock for: " + astNode);
        ReturnBlock returnBlock = new ReturnBlock(BlockIdPrefix.generate(BlockIdPrefix.RETURN, astNode), astNode);
        nodeToBlockMap.put(astNode, returnBlock);
        return returnBlock;
    }

    private DoWhileBlock parseDoWhileStatement(DoStatement astNode, Map<ASTNode, CodeBlock> nodeToBlockMap, BlockDragAndDropManager manager) {
        System.out.println("Creating DoWhileBlock for: " + astNode);
        DoWhileBlock doWhileBlock = new DoWhileBlock(BlockIdPrefix.generate(BlockIdPrefix.DO_WHILE, astNode), astNode, manager);
        nodeToBlockMap.put(astNode, doWhileBlock);

        // Parse body first (do part)
        if (astNode.getBody() instanceof Block) {
            doWhileBlock.setBody(parseBodyBlock((Block) astNode.getBody(), nodeToBlockMap, manager));
        }

        // Parse condition (while part)
        if (astNode.getExpression() != null) {
            parseExpression(astNode.getExpression(), nodeToBlockMap).ifPresent(doWhileBlock::setCondition);
        }

        return doWhileBlock;
    }

    // Parse switch statement
    private SwitchBlock parseSwitchStatement(SwitchStatement astNode, Map<ASTNode, CodeBlock> nodeToBlockMap, BlockDragAndDropManager manager) {
        System.out.println("Creating SwitchBlock for: " + astNode);
        SwitchBlock switchBlock = new SwitchBlock(BlockIdPrefix.generate(BlockIdPrefix.SWITCH, astNode), astNode, manager);
        nodeToBlockMap.put(astNode, switchBlock);

        // Parse the switch expression
        if (astNode.getExpression() != null) {
            parseExpression(astNode.getExpression(), nodeToBlockMap).ifPresent(switchBlock::setExpression);
        }

        // Parse switch cases
        List<Statement> statements = astNode.statements();
        BodyBlock currentCaseBody = null;
        SwitchBlock.SwitchCaseBlock currentCase = null;

        for (Statement stmt : statements) {
            if (stmt instanceof SwitchCase) {
                // Start a new case
                SwitchCase switchCase = (SwitchCase) stmt;
                String caseId = BlockIdPrefix.generate(BlockIdPrefix.SWITCH + "_case_", switchCase);
                currentCase = new SwitchBlock.SwitchCaseBlock(caseId, switchCase, manager);
                nodeToBlockMap.put(switchCase, currentCase);

                // Parse case expression (null for default)
                if (!switchCase.isDefault() && !switchCase.expressions().isEmpty()) {
                    Expression caseExpr = (Expression) switchCase.expressions().getFirst();
                    parseExpression(caseExpr, nodeToBlockMap).ifPresent(currentCase::setCaseExpression);
                }

                // Create body for this case
                currentCaseBody = new BodyBlock(
                        BlockIdPrefix.generate(BlockIdPrefix.BODY, switchCase),
                        ast.getAST().newBlock(), // FIX: Access AST from CompilationUnit
                        manager
                );
                currentCase.setBody(currentCaseBody);
                switchBlock.addCase(currentCase);

            } else if (currentCaseBody != null) {
                // Add statement to current case body
                parseStatement(stmt, nodeToBlockMap, manager).ifPresent(currentCaseBody::addStatement);
            }
        }

        return switchBlock;
    }

    private CommentBlock parseCommentBlock(Comment astNode, Map<ASTNode, CodeBlock> nodeToBlockMap) {
        String text = "Comment";

        // Extract text from source string based on range
        if (currentSourceCode != null) {
            try {
                int start = astNode.getStartPosition();
                int length = astNode.getLength();
                String raw = currentSourceCode.substring(start, start + length);

                if (astNode.isLineComment()) {
                    // Remove "//"
                    text = raw.substring(2).trim();
                } else if (astNode.isBlockComment()) {
                    // Remove "/*" and "*/"
                    if (raw.length() >= 4) {
                        text = raw.substring(2, raw.length() - 2).trim();
                    }
                }
            } catch (Exception ignored) {}
        }

        CommentBlock commentBlock = new CommentBlock(
                BlockIdPrefix.generate(BlockIdPrefix.COMMENT, astNode),
                astNode,
                text
        );
        nodeToBlockMap.put(astNode, commentBlock);
        return commentBlock;
    }

    private VariableDeclarationBlock parseVariableDeclaration(VariableDeclarationStatement astNode, Map<ASTNode, CodeBlock> nodeToBlockMap) {
        System.out.println("Creating VariableDeclarationBlock for: " + astNode);
        VariableDeclarationBlock varBlock = new VariableDeclarationBlock(BlockIdPrefix.generate(BlockIdPrefix.VARIABLE, astNode), astNode);
        nodeToBlockMap.put(astNode, varBlock);
        VariableDeclarationFragment fragment = (VariableDeclarationFragment) astNode.fragments().getFirst();

        if (fragment.getInitializer() != null) {
            parseExpression(fragment.getInitializer(), nodeToBlockMap).ifPresent(varBlock::setInitializer);
        }
        return varBlock;
    }

    private IfBlock parseIfStatement(IfStatement astNode, Map<ASTNode, CodeBlock> nodeToBlockMap, BlockDragAndDropManager manager) {
        System.out.println("Creating IfBlock for: " + astNode);
        IfBlock ifBlock = new IfBlock(BlockIdPrefix.generate(BlockIdPrefix.IF, astNode), astNode);
        nodeToBlockMap.put(astNode, ifBlock);
        parseExpression(astNode.getExpression(), nodeToBlockMap).ifPresent(ifBlock::setCondition);

        if (astNode.getThenStatement() instanceof Block) {
            ifBlock.setThenBody(parseBodyBlock((Block) astNode.getThenStatement(), nodeToBlockMap, manager));
        }

        Statement elseStmt = astNode.getElseStatement();
        if (elseStmt != null) {
            parseStatement(elseStmt, nodeToBlockMap, manager).ifPresent(ifBlock::setElseStatement);
        }

        return ifBlock;
    }

    private PrintBlock parsePrintStatement(ExpressionStatement astNode, Map<ASTNode, CodeBlock> nodeToBlockMap) {
        System.out.println("Creating PrintBlock for: " + astNode);
        PrintBlock printBlock = new PrintBlock(BlockIdPrefix.generate(BlockIdPrefix.PRINT, astNode), astNode);
        nodeToBlockMap.put(astNode, printBlock);

        MethodInvocation methodInvocation = (MethodInvocation) astNode.getExpression();

        if (methodInvocation.arguments().isEmpty()) {
            System.out.println("Creating synthetic String LiteralBlock for empty println");
            LiteralBlock<String> block = new LiteralBlock<>(BlockIdPrefix.generate(BlockIdPrefix.SYNTHETIC_STRING, astNode), methodInvocation, "");
            printBlock.addArgument(block);
        } else {
            for (Object arg : methodInvocation.arguments()) {
                parseExpression((Expression) arg, nodeToBlockMap).ifPresent(printBlock::addArgument);
            }
        }
        return printBlock;
    }


    private boolean isReadInputStatement(VariableDeclarationStatement varDecl) {
        if (varDecl.fragments().isEmpty()) return false;
        VariableDeclarationFragment fragment = (VariableDeclarationFragment) varDecl.fragments().getFirst();
        Expression initializer = fragment.getInitializer();

        if (initializer instanceof MethodInvocation) {
            MethodInvocation mi = (MethodInvocation) initializer;
            Expression expr = mi.getExpression();
            if (expr instanceof SimpleName) {
                SimpleName name = (SimpleName) expr;
                String methodName = mi.getName().getIdentifier();
                return name.getIdentifier().equals("scanner") &&
                        (methodName.equals("nextLine") || methodName.equals("nextInt") ||
                                methodName.equals("nextDouble") || methodName.equals("nextBoolean"));
            }
        }
        return false;
    }

    // Parse while statement
    private WhileBlock parseWhileStatement(WhileStatement astNode, Map<ASTNode, CodeBlock> nodeToBlockMap, BlockDragAndDropManager manager) {
        System.out.println("Creating WhileBlock for: " + astNode);
        WhileBlock whileBlock = new WhileBlock(BlockIdPrefix.generate(BlockIdPrefix.WHILE, astNode), astNode, manager);
        nodeToBlockMap.put(astNode, whileBlock);

        parseExpression(astNode.getExpression(), nodeToBlockMap).ifPresent(whileBlock::setCondition);

        if (astNode.getBody() instanceof Block) {
            whileBlock.setBody(parseBodyBlock((Block) astNode.getBody(), nodeToBlockMap, manager));
        }

        return whileBlock;
    }

    private ForBlock parseForStatement(EnhancedForStatement astNode, Map<ASTNode, CodeBlock> nodeToBlockMap, BlockDragAndDropManager manager) {
        System.out.println("Creating ForBlock (foreach) for: " + astNode);
        ForBlock forBlock = new ForBlock(BlockIdPrefix.generate(BlockIdPrefix.FOR, astNode), astNode, manager);
        nodeToBlockMap.put(astNode, forBlock);

        // Parse the variable parameter (e.g., "String item")
        SingleVariableDeclaration param = astNode.getParameter();
        if (param != null) {
            // Create an identifier block for the variable name
            parseExpression(param.getName(), nodeToBlockMap).ifPresent(forBlock::setVariable);
        }

        // Parse the collection/array expression
        if (astNode.getExpression() != null) {
            parseExpression(astNode.getExpression(), nodeToBlockMap).ifPresent(forBlock::setCollection);
        }

        // Parse the body
        if (astNode.getBody() instanceof Block) {
            forBlock.setBody(parseBodyBlock((Block) astNode.getBody(), nodeToBlockMap, manager));
        }

        return forBlock;
    }

    // Parse break statement
    private BreakBlock parseBreakStatement(BreakStatement astNode, Map<ASTNode, CodeBlock> nodeToBlockMap) {
        System.out.println("Creating BreakBlock for: " + astNode);
        BreakBlock breakBlock = new BreakBlock(BlockIdPrefix.generate(BlockIdPrefix.BREAK, astNode), astNode);
        nodeToBlockMap.put(astNode, breakBlock);
        return breakBlock;
    }

    // Parse continue statement
    private ContinueBlock parseContinueStatement(ContinueStatement astNode, Map<ASTNode, CodeBlock> nodeToBlockMap) {
        System.out.println("Creating ContinueBlock for: " + astNode);
        ContinueBlock continueBlock = new ContinueBlock(BlockIdPrefix.generate(BlockIdPrefix.CONTINUE, astNode), astNode);
        nodeToBlockMap.put(astNode, continueBlock);
        return continueBlock;
    }

    // Parse assignment statement
    private AssignmentBlock parseAssignmentStatement(ExpressionStatement astNode, Map<ASTNode, CodeBlock> nodeToBlockMap) {
        System.out.println("Creating AssignmentBlock for: " + astNode);
        AssignmentBlock assignBlock = new AssignmentBlock(BlockIdPrefix.generate(BlockIdPrefix.ASSIGNMENT, astNode), astNode);
        nodeToBlockMap.put(astNode, assignBlock);

        Assignment assignment = (Assignment) astNode.getExpression();
        parseExpression(assignment.getLeftHandSide(), nodeToBlockMap).ifPresent(assignBlock::setLeftHandSide);
        parseExpression(assignment.getRightHandSide(), nodeToBlockMap).ifPresent(assignBlock::setRightHandSide);

        return assignBlock;
    }

    // Parse read input statement
    private ReadInputBlock parseReadInputStatement(VariableDeclarationStatement astNode, Map<ASTNode, CodeBlock> nodeToBlockMap) {
        System.out.println("Creating ReadInputBlock for: " + astNode);

        VariableDeclarationFragment fragment = (VariableDeclarationFragment) astNode.fragments().getFirst();
        MethodInvocation mi = (MethodInvocation) fragment.getInitializer();
        String inputType = mi.getName().getIdentifier();

        ReadInputBlock readBlock = new ReadInputBlock(
                BlockIdPrefix.generate(BlockIdPrefix.READ_INPUT, astNode), astNode, inputType
        );
        nodeToBlockMap.put(astNode, readBlock);

        parseExpression(fragment.getName(), nodeToBlockMap).ifPresent(readBlock::setVariableName);

        return readBlock;
    }

    private BinaryExpressionBlock parseBinaryExpression(InfixExpression astNode, Map<ASTNode, CodeBlock> nodeToBlockMap) {
        System.out.println("Creating BinaryExpressionBlock for: " + astNode);
        BinaryExpressionBlock binaryBlock = new BinaryExpressionBlock(BlockIdPrefix.generate(BlockIdPrefix.BINARY, astNode), astNode);
        nodeToBlockMap.put(astNode, binaryBlock);
        parseExpression(astNode.getLeftOperand(), nodeToBlockMap).ifPresent(binaryBlock::setLeftOperand);
        parseExpression(astNode.getRightOperand(), nodeToBlockMap).ifPresent(binaryBlock::setRightOperand);
        return binaryBlock;
    }

    private Optional<ExpressionBlock> parseExpression(Expression astExpression, Map<ASTNode, CodeBlock> nodeToBlockMap) {
        if (astExpression instanceof StringLiteral) {
            System.out.println("Creating String LiteralBlock for: " + astExpression);
            StringLiteral literalNode = (StringLiteral) astExpression;
            LiteralBlock<String> block = new LiteralBlock<>(BlockIdPrefix.generate(BlockIdPrefix.STRING, literalNode), literalNode, literalNode.getLiteralValue());
            nodeToBlockMap.put(astExpression, block);
            return Optional.of(block);
        }

        if (astExpression instanceof NumberLiteral) {
            System.out.println("Creating Number LiteralBlock for: " + astExpression);
            NumberLiteral literalNode = (NumberLiteral) astExpression;
            String token = literalNode.getToken();
            ExpressionBlock block;
            if (token.toLowerCase().endsWith("f")) {
                block = new LiteralBlock<>(BlockIdPrefix.generate(BlockIdPrefix.NUMBER_FLOAT, literalNode), literalNode, Float.parseFloat(token));
            } else if (token.contains(".") || token.toLowerCase().endsWith("d")) {
                block = new LiteralBlock<>(BlockIdPrefix.generate(BlockIdPrefix.NUMBER_DOUBLE, literalNode), literalNode, Double.parseDouble(token));
            } else {
                block = new LiteralBlock<>(BlockIdPrefix.generate(BlockIdPrefix.NUMBER_INT, literalNode), literalNode, Integer.parseInt(token));
            }
            nodeToBlockMap.put(astExpression, block);
            return Optional.of(block);
        }

        if (astExpression instanceof BooleanLiteral) {
            System.out.println("Creating Boolean LiteralBlock for: " + astExpression);
            BooleanLiteral literalNode = (BooleanLiteral) astExpression;
            LiteralBlock<Boolean> block = new LiteralBlock<>(BlockIdPrefix.generate(BlockIdPrefix.BOOLEAN, literalNode), literalNode, literalNode.booleanValue());
            nodeToBlockMap.put(astExpression, block);
            return Optional.of(block);
        }

        // NEW: Handle ArrayInitializer (list literals)
        if (astExpression instanceof ArrayInitializer) {
            System.out.println("Creating ListBlock for: " + astExpression);
            ArrayInitializer arrayInit = (ArrayInitializer) astExpression;
            ListBlock listBlock = new ListBlock(BlockIdPrefix.generate(BlockIdPrefix.LIST, arrayInit), arrayInit);
            nodeToBlockMap.put(astExpression, listBlock);

            // Parse each element recursively
            for (Object expr : arrayInit.expressions()) {
                parseExpression((Expression) expr, nodeToBlockMap).ifPresent(listBlock::addElement);
            }

            return Optional.of(listBlock);
        }

        if (astExpression instanceof SimpleName) {
            // Do not convert type names into identifier blocks
            if (astExpression.getParent() instanceof Type) {
                return Optional.empty();
            }
            System.out.println("Creating IdentifierBlock for: " + astExpression);
            SimpleName simpleName = (SimpleName) astExpression;

            // Mark as unedited if this identifier was just auto-generated
            // The flag is set externally via setMarkNewIdentifiersAsUnedited()
            IdentifierBlock block = new IdentifierBlock(
                    BlockIdPrefix.generate(BlockIdPrefix.IDENTIFIER, astExpression),
                    simpleName,
                    markNewIdentifiersAsUnedited
            );
            nodeToBlockMap.put(astExpression, block);
            return Optional.of(block);
        }

        if (astExpression instanceof InfixExpression) {
            return Optional.of(parseBinaryExpression((InfixExpression) astExpression, nodeToBlockMap));
        }

        return Optional.empty();
    }


    private boolean isPrintStatement(Expression expression) {
        if (!(expression instanceof MethodInvocation)) {
            return false;
        }
        MethodInvocation method = (MethodInvocation) expression;

        if (!method.getName().getIdentifier().equals("println")) {
            return false;
        }

        if (method.arguments().isEmpty()) {
            return method.toString().startsWith("System.out.println");
        } else {
            Expression expr = method.getExpression();
            return expr != null && "System.out".equals(expr.toString());
        }
    }

    public CompilationUnit getCompilationUnit() {
        return ast;
    }

    private static class MainMethodVisitor extends ASTVisitor {
        private MethodDeclaration mainMethodDeclaration;

        @Override
        public boolean visit(MethodDeclaration node) {
            if ("main".equals(node.getName().getIdentifier())) {
                mainMethodDeclaration = node;
                return false;
            }
            return true;
        }

        public Optional<MethodDeclaration> getMainMethodDeclaration() {
            return Optional.ofNullable(mainMethodDeclaration);
        }

        public Optional<Block> getMainMethodBody() {
            return Optional.ofNullable(mainMethodDeclaration != null ? mainMethodDeclaration.getBody() : null);
        }
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/parser/BlockIdPrefix.java
=================================================================================

package com.botmaker.util;

/**
 * Constants for block ID prefixes
 */
public class BlockIdPrefix {
    public static final String MAIN = "main_";
    public static final String BODY = "body_";
    public static final String VARIABLE = "var_";
    public static final String IF = "if_";
    public static final String WHILE = "while_";
    public static final String FOR = "for_";
    public static final String BREAK = "break_";
    public static final String CONTINUE = "continue_";
    public static final String ASSIGNMENT = "assign_";
    public static final String INCREMENT = "inc_";
    public static final String DECREMENT = "dec_";
    public static final String READ_INPUT = "read_";
    public static final String PRINT = "print_";
    public static final String BINARY = "binary_";
    public static final String STRING = "string_";
    public static final String NUMBER_FLOAT = "float_";
    public static final String NUMBER_DOUBLE = "double_";
    public static final String NUMBER_INT = "int_";
    public static final String BOOLEAN = "boolean_";
    public static final String IDENTIFIER = "id_";
    public static final String SYNTHETIC_STRING = "synthetic_string_";
    public static final String DO_WHILE = "do_while_";
    public static final String SWITCH = "switch_";
    public static final String RETURN = "return_";
    public static final String COMMENT = "comment_";
    public static final String WAIT = "wait_";
    public static final String LIST = "list_";

    private BlockIdPrefix() {} // Prevent instantiation

    /**
     * Generate ID with prefix and hash
     */
    public static String generate(String prefix, Object node) {
        return prefix + node.hashCode();
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/parser/CodeEditor.java
=================================================================================

package com.botmaker.parser;

import com.botmaker.state.*;
import com.botmaker.core.BodyBlock;
import com.botmaker.core.StatementBlock;
import com.botmaker.events.CoreApplicationEvents;
import com.botmaker.events.EventBus;
import com.botmaker.ui.AddableBlock;
import org.eclipse.jdt.core.dom.*;

public class CodeEditor {

    private final ApplicationState state;
    private final EventBus eventBus;
    private final AstRewriter astRewriter;
    private final BlockFactory blockFactory;

    public CodeEditor(ApplicationState state, EventBus eventBus,
                      AstRewriter astRewriter, BlockFactory blockFactory) {
        this.state = state;
        this.eventBus = eventBus;
        this.astRewriter = astRewriter;
        this.blockFactory = blockFactory;
    }

    private String getCurrentCode() {
        return state.getCurrentCode();
    }

    private CompilationUnit getCompilationUnit() {
        return state.getCompilationUnit().orElse(null);
    }

    private void triggerUpdate(String newCode) {
        String previousCode = getCurrentCode();
        eventBus.publish(new CoreApplicationEvents.CodeUpdatedEvent(newCode, previousCode));
    }

    public void moveStatement(StatementBlock blockToMove, BodyBlock sourceBody,
                              BodyBlock targetBody, int targetIndex) {
        String newCode = astRewriter.moveStatement(
                getCompilationUnit(),
                getCurrentCode(),
                blockToMove,
                sourceBody,
                targetBody,
                targetIndex
        );
        triggerUpdate(newCode);
    }

    public void replaceLiteralValue(Expression toReplace, String newLiteralValue) {
        String newCode = astRewriter.replaceLiteral(
                getCompilationUnit(),
                getCurrentCode(),
                toReplace,
                newLiteralValue
        );
        triggerUpdate(newCode);
    }

    public void addStringArgumentToMethodInvocation(MethodInvocation mi, String text) {
        CompilationUnit cu = getCompilationUnit();
        if (cu == null) return;

        AST ast = cu.getAST();
        StringLiteral newArg = ast.newStringLiteral();
        newArg.setLiteralValue(text);

        String newCode = astRewriter.addArgumentToMethodInvocation(
                cu,
                getCurrentCode(),
                mi,
                newArg
        );
        triggerUpdate(newCode);
    }

    public void addElementToArrayInitializer(
            org.eclipse.jdt.core.dom.ArrayInitializer arrayInit,
            com.botmaker.ui.AddableExpression type,
            int insertIndex) {

        blockFactory.setMarkNewIdentifiersAsUnedited(true);
        String newCode = astRewriter.addElementToArrayInitializer(
                getCompilationUnit(),
                getCurrentCode(),
                arrayInit,
                type,
                insertIndex
        );
        triggerUpdate(newCode);
    }

    public void deleteElementFromArrayInitializer(
            org.eclipse.jdt.core.dom.ArrayInitializer arrayInit,
            int elementIndex) {

        String newCode = astRewriter.deleteElementFromArrayInitializer(
                getCompilationUnit(),
                getCurrentCode(),
                arrayInit,
                elementIndex
        );
        triggerUpdate(newCode);
    }

    public void updateComment(Comment commentNode, String newText) {
        String newCode = astRewriter.updateComment(
                getCurrentCode(),
                commentNode,
                newText
        );
        triggerUpdate(newCode);
    }

    public void deleteComment(Comment commentNode) {
        String newCode = astRewriter.deleteComment(
                getCurrentCode(),
                commentNode
        );
        triggerUpdate(newCode);
    }

    public void replaceExpression(Expression toReplace, com.botmaker.ui.AddableExpression type) {
        blockFactory.setMarkNewIdentifiersAsUnedited(true);
        String newCode = astRewriter.replaceExpression(
                getCompilationUnit(),
                getCurrentCode(),
                toReplace,
                type
        );
        triggerUpdate(newCode);
    }

    public void addStatement(BodyBlock targetBody, AddableBlock type, int index) {
        blockFactory.setMarkNewIdentifiersAsUnedited(true);
        String newCode = astRewriter.addStatement(
                getCompilationUnit(),
                getCurrentCode(),
                targetBody,
                type,
                index
        );
        triggerUpdate(newCode);
    }

    public void deleteElseFromIfStatement(IfStatement ifStmt) {
        String newCode = astRewriter.deleteElseFromIfStatement(
                getCompilationUnit(),
                getCurrentCode(),
                ifStmt
        );
        triggerUpdate(newCode);
    }

    public void convertElseToElseIf(IfStatement ifStmt) {
        String newCode = astRewriter.convertElseToElseIf(
                getCompilationUnit(),
                getCurrentCode(),
                ifStmt
        );
        triggerUpdate(newCode);
    }

    public void addElseToIfStatement(IfStatement ifStmt) {
        String newCode = astRewriter.addElseToIfStatement(
                getCompilationUnit(),
                getCurrentCode(),
                ifStmt
        );
        triggerUpdate(newCode);
    }

    public void replaceSimpleName(SimpleName toReplace, String newName) {
        String newCode = astRewriter.replaceSimpleName(
                getCompilationUnit(),
                getCurrentCode(),
                toReplace,
                newName
        );
        triggerUpdate(newCode);
    }

    public void deleteStatement(Statement toDelete) {
        String newCode = astRewriter.deleteNode(
                getCompilationUnit(),
                getCurrentCode(),
                toDelete
        );
        triggerUpdate(newCode);
    }

    public void replaceVariableType(VariableDeclarationStatement toReplace, String newTypeName) {
        String newCode = astRewriter.replaceVariableType(
                getCompilationUnit(),
                getCurrentCode(),
                toReplace,
                newTypeName
        );
        triggerUpdate(newCode);
    }

    // --- FIX START: Manual Mapping instead of .values() ---

    public void updateAssignmentOperator(org.eclipse.jdt.core.dom.ASTNode node, String newOperatorSymbol) {
        String newCode = null;

        if (node instanceof Assignment) {
            Assignment.Operator op = getAssignmentOperator(newOperatorSymbol);
            if (op != null) {
                newCode = astRewriter.replaceAssignmentOperator(getCompilationUnit(), getCurrentCode(), (Assignment) node, op);
            }
        } else if (node instanceof org.eclipse.jdt.core.dom.PrefixExpression) {
            org.eclipse.jdt.core.dom.PrefixExpression.Operator op = getPrefixOperator(newOperatorSymbol);
            if (op != null) {
                newCode = astRewriter.replacePrefixOperator(getCompilationUnit(), getCurrentCode(), (org.eclipse.jdt.core.dom.PrefixExpression) node, op);
            }
        } else if (node instanceof org.eclipse.jdt.core.dom.PostfixExpression) {
            org.eclipse.jdt.core.dom.PostfixExpression.Operator op = getPostfixOperator(newOperatorSymbol);
            if (op != null) {
                newCode = astRewriter.replacePostfixOperator(getCompilationUnit(), getCurrentCode(), (org.eclipse.jdt.core.dom.PostfixExpression) node, op);
            }
        }

        if (newCode != null) {
            triggerUpdate(newCode);
        }
    }

    private Assignment.Operator getAssignmentOperator(String symbol) {
        // Manual mapping because JDT Operators are not Enums
        if ("=".equals(symbol)) return Assignment.Operator.ASSIGN;
        if ("+=".equals(symbol)) return Assignment.Operator.PLUS_ASSIGN;
        if ("-=".equals(symbol)) return Assignment.Operator.MINUS_ASSIGN;
        if ("*=".equals(symbol)) return Assignment.Operator.TIMES_ASSIGN;
        if ("/=".equals(symbol)) return Assignment.Operator.DIVIDE_ASSIGN;
        if ("%=".equals(symbol)) return Assignment.Operator.REMAINDER_ASSIGN;
        // Add other assignment operators if necessary (e.g. &=, |=, etc.)
        return null;
    }

    private org.eclipse.jdt.core.dom.PrefixExpression.Operator getPrefixOperator(String symbol) {
        if ("++".equals(symbol)) return org.eclipse.jdt.core.dom.PrefixExpression.Operator.INCREMENT;
        if ("--".equals(symbol)) return org.eclipse.jdt.core.dom.PrefixExpression.Operator.DECREMENT;
        return null;
    }

    private org.eclipse.jdt.core.dom.PostfixExpression.Operator getPostfixOperator(String symbol) {
        if ("++".equals(symbol)) return org.eclipse.jdt.core.dom.PostfixExpression.Operator.INCREMENT;
        if ("--".equals(symbol)) return org.eclipse.jdt.core.dom.PostfixExpression.Operator.DECREMENT;
        return null;
    }
    // --- FIX END ---
}

=================================================================================
FILE: ./src/main/java/com/botmaker/project/ProjectConfig.java
=================================================================================

package com.botmaker.project;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.List;

/**
 * Configuration for BotMaker projects, stored in projects/.botmaker-config.json
 */
public class ProjectConfig {

    private static final Path CONFIG_FILE = Paths.get("projects/.botmaker-config.json");
    private static final Gson GSON = new GsonBuilder()
            .setPrettyPrinting()
            .create();

    private String lastOpenedProject;
    private List<ProjectEntry> recentProjects;

    public ProjectConfig() {
        this.recentProjects = new ArrayList<>();
    }

    public String getLastOpenedProject() {
        return lastOpenedProject;
    }

    public void setLastOpenedProject(String projectName) {
        this.lastOpenedProject = projectName;
    }

    public List<ProjectEntry> getRecentProjects() {
        return recentProjects;
    }

    public void addRecentProject(String projectName) {
        // Remove if already exists
        recentProjects.removeIf(p -> p.getName().equals(projectName));

        // Add at the beginning
        ProjectEntry entry = new ProjectEntry(projectName);
        recentProjects.add(0, entry);

        // Keep only last 10 projects
        if (recentProjects.size() > 10) {
            recentProjects = recentProjects.subList(0, 10);
        }
    }

    /**
     * Loads the configuration from disk
     */
    public static ProjectConfig load() {
        try {
            if (Files.exists(CONFIG_FILE)) {
                String json = Files.readString(CONFIG_FILE);
                return GSON.fromJson(json, ProjectConfig.class);
            }
        } catch (Exception e) {
            System.err.println("Failed to load project config: " + e.getMessage());
        }

        // Return default config if file doesn't exist or can't be read
        return new ProjectConfig();
    }

    /**
     * Saves the configuration to disk
     */
    public void save() {
        try {
            // Ensure projects directory exists
            Files.createDirectories(CONFIG_FILE.getParent());

            // Write JSON
            String json = GSON.toJson(this);
            Files.writeString(CONFIG_FILE, json);
        } catch (IOException e) {
            System.err.println("Failed to save project config: " + e.getMessage());
        }
    }

    /**
     * Updates the last opened project and saves
     */
    public static void updateLastOpened(String projectName) {
        ProjectConfig config = load();
        config.setLastOpenedProject(projectName);
        config.addRecentProject(projectName);
        config.save();
    }

    /**
     * Gets the last opened project name, or null if none
     */
    public static String getLastOpened() {
        ProjectConfig config = load();
        return config.getLastOpenedProject();
    }

    /**
     * Represents a recent project entry
     */
    public static class ProjectEntry {
        private String name;
        private String lastOpened; // ISO-8601 timestamp string

        public ProjectEntry() {
            // For Gson
        }

        public ProjectEntry(String name) {
            this.name = name;
            this.lastOpened = LocalDateTime.now().format(DateTimeFormatter.ISO_LOCAL_DATE_TIME);
        }

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }

        public String getLastOpened() {
            return lastOpened;
        }

        public void setLastOpened(String lastOpened) {
            this.lastOpened = lastOpened;
        }

        /**
         * Gets the last opened time as LocalDateTime
         */
        public LocalDateTime getLastOpenedDateTime() {
            try {
                return LocalDateTime.parse(lastOpened, DateTimeFormatter.ISO_LOCAL_DATE_TIME);
            } catch (Exception e) {
                return LocalDateTime.now();
            }
        }
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/project/ProjectCreator.java
=================================================================================

package com.botmaker.project;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

/**
 * Handles creation of new Gradle projects with proper structure
 */
public class ProjectCreator {

    private static final Path PROJECTS_ROOT = Paths.get("projects");

    /**
     * Creates a new Gradle project with standard structure
     *
     * @param projectName The name of the project to create
     * @throws IOException if project creation fails
     * @throws IllegalArgumentException if project name is invalid or already exists
     */
    public void createProject(String projectName) throws IOException {
        // Validate project name
        validateProjectName(projectName);

        // Check if project already exists
        if (projectExists(projectName)) {
            throw new IllegalArgumentException("Project '" + projectName + "' already exists");
        }

        // Create project structure
        Path projectPath = PROJECTS_ROOT.resolve(projectName);
        createProjectStructure(projectPath, projectName);

        System.out.println("Successfully created project: " + projectName);
    }

    /**
     * Validates the project name
     */
    private void validateProjectName(String projectName) {
        if (projectName == null || projectName.trim().isEmpty()) {
            throw new IllegalArgumentException("Project name cannot be empty");
        }

        // Check for valid Java class name (starts with letter, contains only letters/digits)
        if (!projectName.matches("^[A-Z][a-zA-Z0-9]*$")) {
            throw new IllegalArgumentException(
                    "Project name must start with an uppercase letter and contain only letters and numbers"
            );
        }

        // Check length
        if (projectName.length() < 2 || projectName.length() > 50) {
            throw new IllegalArgumentException("Project name must be between 2 and 50 characters");
        }
    }

    /**
     * Checks if a project already exists
     */
    public boolean projectExists(String projectName) {
        Path projectPath = PROJECTS_ROOT.resolve(projectName);
        return Files.exists(projectPath);
    }

    /**
     * Creates the complete project structure
     */
    private void createProjectStructure(Path projectPath, String projectName) throws IOException {
        // Create directories
        Files.createDirectories(projectPath);

        String packageName = projectName.toLowerCase();
        Path srcPath = projectPath.resolve("src/main/java/com/" + packageName);
        Files.createDirectories(srcPath);

        Path gradlePath = projectPath.resolve("gradle/wrapper");
        Files.createDirectories(gradlePath);

        // Create build.gradle
        createBuildGradle(projectPath, projectName);

        // Create settings.gradle
        createSettingsGradle(projectPath, projectName);

        // Create gradle-wrapper.properties
        createGradleWrapperProperties(gradlePath);

        // Create gradlew scripts
        createGradlewScripts(projectPath);

        // Create main Java file
        createMainJavaFile(srcPath, projectName, packageName);
    }

    /**
     * Creates build.gradle file
     */
    private void createBuildGradle(Path projectPath, String projectName) throws IOException {
        String packageName = projectName.toLowerCase();
        String content = String.format("""
            plugins {
                id 'java'
                id 'application'
            }
            
            group = 'com.%s'
            version = '0.0.1-SNAPSHOT'
            
            repositories {
                mavenCentral()
            }
            
            application {
                mainClass = 'com.%s.%s'
            }
            
            java {
                sourceCompatibility = JavaVersion.VERSION_17
                targetCompatibility = JavaVersion.VERSION_17
            }
            """, packageName, packageName, projectName);

        Files.writeString(projectPath.resolve("build.gradle"), content);
    }

    /**
     * Creates settings.gradle file
     */
    private void createSettingsGradle(Path projectPath, String projectName) throws IOException {
        String content = String.format("""
            
            pluginManagement {
                repositories {
                    gradlePluginPortal()
                    mavenCentral()
                }
            }
            
            
            
            rootProject.name = '%s'
            
            """, projectName);

        Files.writeString(projectPath.resolve("settings.gradle"), content);
    }

    /**
     * Creates gradle-wrapper.properties file
     */
    private void createGradleWrapperProperties(Path gradlePath) throws IOException {
        String content = """
            distributionBase=GRADLE_USER_HOME
            distributionPath=wrapper/dists
            distributionUrl=https\\://services.gradle.org/distributions/gradle-9.1.0-bin.zip
            networkTimeout=10000
            validateDistributionUrl=true
            zipStoreBase=GRADLE_USER_HOME
            zipStorePath=wrapper/dists
            """;

        Files.writeString(gradlePath.resolve("gradle-wrapper.properties"), content);
    }

    /**
     * Creates gradlew scripts (Unix and Windows)
     */
    private void createGradlewScripts(Path projectPath) throws IOException {
        // Create Unix gradlew script
        String gradlewUnix = """
            #!/bin/sh
            
            #
            # Copyright © 2015 the original authors.
            #
            # Licensed under the Apache License, Version 2.0 (the "License");
            # you may not use this file except in compliance with the License.
            # You may obtain a copy of the License at
            #
            #      https://www.apache.org/licenses/LICENSE-2.0
            #
            # Unless required by applicable law or agreed to in writing, software
            # distributed under the License is distributed on an "AS IS" BASIS,
            # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
            # See the License for the specific language governing permissions and
            # limitations under the License.
            #
            
            ##############################################################################
            #
            #   Gradle start up script for POSIX generated by Gradle.
            #
            ##############################################################################
            
            # Attempt to set APP_HOME
            app_path=$0
            
            APP_HOME=${app_path%"${app_path##*/}"}
            APP_BASE_NAME=${0##*/}
            APP_HOME=$( cd -P "${APP_HOME:-./}" > /dev/null && printf '%s\\n' "$PWD" ) || exit
            
            DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'
            
            JAVACMD=java
            if [ -n "$JAVA_HOME" ] ; then
                if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
                    JAVACMD=$JAVA_HOME/jre/sh/java
                else
                    JAVACMD=$JAVA_HOME/bin/java
                fi
            fi
            
            exec "$JAVACMD" "$@"
            """;

        Path gradlewPath = projectPath.resolve("gradlew");
        Files.writeString(gradlewPath, gradlewUnix);

        // Make it executable on Unix systems
        try {
            gradlewPath.toFile().setExecutable(true);
        } catch (Exception e) {
            System.err.println("Warning: Could not set gradlew as executable: " + e.getMessage());
        }

        // Create Windows gradlew.bat script
        String gradlewBat = """
            @rem
            @rem Copyright 2015 the original author or authors.
            @rem
            @rem Licensed under the Apache License, Version 2.0 (the "License");
            @rem you may not use this file except in compliance with the License.
            @rem You may obtain a copy of the License at
            @rem
            @rem      https://www.apache.org/licenses/LICENSE-2.0
            @rem
            @rem Unless required by applicable law or agreed to in writing, software
            @rem distributed under the License is distributed on an "AS IS" BASIS,
            @rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
            @rem See the License for the specific language governing permissions and
            @rem limitations under the License.
            @rem
            
            @if "%DEBUG%"=="" @echo off
            
            set DIRNAME=%~dp0
            if "%DIRNAME%"=="" set DIRNAME=.
            set APP_BASE_NAME=%~n0
            
            set DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"
            
            set JAVA_EXE=java.exe
            if defined JAVA_HOME goto findJavaFromJavaHome
            
            %JAVA_EXE% -version >NUL 2>&1
            if %ERRORLEVEL% equ 0 goto execute
            
            :findJavaFromJavaHome
            set JAVA_HOME=%JAVA_HOME:"=%
            set JAVA_EXE=%JAVA_HOME%/bin/java.exe
            
            :execute
            "%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -jar "%DIRNAME%\\gradle\\wrapper\\gradle-wrapper.jar" %*
            
            :end
            if %ERRORLEVEL% equ 0 goto mainEnd
            
            :fail
            exit /b %ERRORLEVEL%
            
            :mainEnd
            """;

        Files.writeString(projectPath.resolve("gradlew.bat"), gradlewBat);
    }

    /**
     * Creates the main Java source file
     */
    private void createMainJavaFile(Path srcPath, String projectName, String packageName) throws IOException {
        String content = String.format("""
            package com.%s;
            
            public class %s {
                public static void main(String[] args) {
                    System.out.println("Hello from %s!");
                }
            }
            """, packageName, projectName, projectName);

        Files.writeString(srcPath.resolve(projectName + ".java"), content);
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/project/ProjectInfo.java
=================================================================================

package com.botmaker.project;

import java.nio.file.Path;
import java.time.LocalDateTime;

/**
 * Information about a project
 */
public class ProjectInfo {
    private final String name;
    private final Path projectPath;
    private final LocalDateTime lastModified;

    public ProjectInfo(String name, Path projectPath, LocalDateTime lastModified) {
        this.name = name;
        this.projectPath = projectPath;
        this.lastModified = lastModified;
    }

    public String getName() {
        return name;
    }

    public Path getProjectPath() {
        return projectPath;
    }

    public LocalDateTime getLastModified() {
        return lastModified;
    }

    @Override
    public String toString() {
        return name;
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/project/ProjectManager.java
=================================================================================

package com.botmaker.project;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.attribute.FileTime;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Stream;

/**
 * Manages project discovery and listing
 */
public class ProjectManager {

    private static final Path PROJECTS_ROOT = Paths.get("projects");

    /**
     * Lists all available projects
     */
    public List<ProjectInfo> listProjects() {
        List<ProjectInfo> projects = new ArrayList<>();

        if (!Files.exists(PROJECTS_ROOT)) {
            return projects;
        }

        try (Stream<Path> paths = Files.list(PROJECTS_ROOT)) {
            paths.filter(Files::isDirectory)
                    .filter(this::isValidProject)
                    .forEach(projectPath -> {
                        try {
                            String projectName = projectPath.getFileName().toString();
                            FileTime lastModified = Files.getLastModifiedTime(projectPath);
                            LocalDateTime modifiedDate = LocalDateTime.ofInstant(
                                    lastModified.toInstant(),
                                    ZoneId.systemDefault()
                            );
                            projects.add(new ProjectInfo(projectName, projectPath, modifiedDate));
                        } catch (IOException e) {
                            System.err.println("Error reading project: " + projectPath);
                        }
                    });
        } catch (IOException e) {
            System.err.println("Error listing projects: " + e.getMessage());
        }

        return projects;
    }

    /**
     * Checks if a directory is a valid project
     * (has src/main/java structure and build.gradle)
     */
    private boolean isValidProject(Path projectPath) {
        Path srcPath = projectPath.resolve("src/main/java");
        Path buildGradle = projectPath.resolve("build.gradle");
        boolean isValid = Files.exists(srcPath) && Files.exists(buildGradle);

        // Debug output
        System.out.println("Checking project: " + projectPath);
        System.out.println("  src/main/java exists: " + Files.exists(srcPath));
        System.out.println("  build.gradle exists: " + Files.exists(buildGradle));
        System.out.println("  Valid: " + isValid);

        return isValid;
    }

    /**
     * Gets the source file path for a project
     */
    public Path getSourceFilePath(String projectName) {
        String packageName = projectName.toLowerCase();
        return PROJECTS_ROOT
                .resolve(projectName)
                .resolve("src/main/java/com")
                .resolve(packageName)
                .resolve(projectName + ".java");
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/runtime/CodeExecutionService.java
=================================================================================

package com.botmaker.runtime;

import com.botmaker.config.ApplicationConfig;
import com.botmaker.validation.DiagnosticsManager;
import javafx.application.Platform;

import java.io.IOException;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.function.Consumer;

public class CodeExecutionService {

    private final Consumer<String> appendOutputConsumer;
    private final Runnable clearOutputConsumer;
    private final Consumer<String> statusConsumer;
    private final Consumer<String> setOutputConsumer;
    private final DiagnosticsManager diagnosticsManager;
    private final ApplicationConfig config;

    private volatile Process currentRunningProcess;
    private final AtomicBoolean isRunning = new AtomicBoolean(false);

    private static final int MAX_UI_BUFFER_SIZE = 4096;
    private static final int UI_UPDATE_RATE_MS = 100;

    public CodeExecutionService(
            Consumer<String> appendOutputConsumer,
            Runnable clearOutputConsumer,
            Consumer<String> setOutputConsumer,
            Consumer<String> statusConsumer,
            DiagnosticsManager diagnosticsManager,
            ApplicationConfig config) {
        this.appendOutputConsumer = appendOutputConsumer;
        this.clearOutputConsumer = clearOutputConsumer;
        this.setOutputConsumer = setOutputConsumer;
        this.statusConsumer = statusConsumer;
        this.diagnosticsManager = diagnosticsManager;
        this.config = config;
    }

    /**
     * BLOCKING method to run code.
     * Must be called from a background thread.
     */
    public void runCode(String code) {
        // 1. Validation
        if (diagnosticsManager.hasErrors()) {
            Platform.runLater(() -> statusConsumer.accept("Run aborted due to errors."));
            return;
        }

        if (isRunning.get()) {
            Platform.runLater(() -> statusConsumer.accept("Program is already running. Stop it first."));
            return;
        }

        try {
            Path sourceFilePath = config.getSourceFilePath();
            Path compiledOutputPath = config.getCompiledOutputPath();

            // 2. Compile (Blocking)
            if (!compileAndWait(code, sourceFilePath, compiledOutputPath)) {
                Platform.runLater(() -> statusConsumer.accept("Run aborted due to compilation failure."));
                return;
            }

            // 3. Setup Execution
            Platform.runLater(() -> {
                statusConsumer.accept("Running... (Press Stop to terminate)");
                clearOutputConsumer.run();
            });

            isRunning.set(true);

            String classPath = compiledOutputPath.toString();
            String className = config.getMainClassName();
            String javaExecutable = config.getJavaExecutable();

            ProcessBuilder pb = new ProcessBuilder(javaExecutable, "-cp", classPath, className);
            currentRunningProcess = pb.start();

            // 4. Start IO (Leaky Bucket)
            startLeakyBucketReader(currentRunningProcess.getInputStream());
            startLeakyBucketReader(currentRunningProcess.getErrorStream());

            // 5. WAIT FOR PROCESS (BLOCKING)
            // This keeps the caller thread alive until the process finishes or is killed.
            int exitCode = currentRunningProcess.waitFor();

            Platform.runLater(() -> {
                if (exitCode == 0) {
                    statusConsumer.accept("Program completed successfully.");
                } else if (exitCode == 143 || exitCode == 130 || exitCode == 1 || exitCode == -1) {
                    statusConsumer.accept("Program stopped.");
                } else {
                    statusConsumer.accept("Program exited with code: " + exitCode);
                }
            });

        } catch (InterruptedException e) {
            Platform.runLater(() -> statusConsumer.accept("Program stopped by user."));
        } catch (Exception e) {
            Platform.runLater(() -> statusConsumer.accept("Error: " + e.getMessage()));
        } finally {
            // Cleanup
            isRunning.set(false);
            currentRunningProcess = null;
        }
    }

    // ... (compileCode, compileAndWait, stopRunningProgram, isRunning, startLeakyBucketReader remain unchanged)

    public void compileCode(String code) {
        // Need to wrap in thread because we made runCode blocking, but compileCode is usually called from UI
        new Thread(() -> {
            try {
                Platform.runLater(() -> setOutputConsumer.accept("Saving and compiling..."));
                Path sourceFilePath = config.getSourceFilePath();
                Path compiledOutputPath = config.getCompiledOutputPath();
                if (compileAndWait(code, sourceFilePath, compiledOutputPath)) {
                    Platform.runLater(() -> setOutputConsumer.accept("Compilation successful."));
                }
            } catch (IOException | InterruptedException e) {
                Platform.runLater(() -> setOutputConsumer.accept("Compilation Error: " + e.getMessage()));
            }
        }).start();
    }

    public boolean compileAndWait(String code, Path sourceFilePath, Path compiledOutputPath) throws IOException, InterruptedException {
        Files.createDirectories(sourceFilePath.getParent());
        Files.writeString(sourceFilePath, code);
        Files.createDirectories(compiledOutputPath);

        String javacExecutable = Paths.get(System.getProperty("java.home"), "bin", "javac").toString();
        ProcessBuilder pb = new ProcessBuilder(javacExecutable, "-g", "-d", compiledOutputPath.toString(), sourceFilePath.toString());
        Process process = pb.start();

        String errors = new String(process.getErrorStream().readAllBytes());
        int exitCode = process.waitFor();

        if (exitCode != 0) {
            Platform.runLater(() -> setOutputConsumer.accept("Compilation Failed:\n" + errors));
            return false;
        }
        return true;
    }

    public void stopRunningProgram() {
        if (currentRunningProcess != null && currentRunningProcess.isAlive()) {
            // Force kill is safest for infinite loops
            currentRunningProcess.destroyForcibly();
        }
    }

    public boolean isRunning() {
        return isRunning.get();
    }

    private void startLeakyBucketReader(InputStream inputStream) {
        final StringBuilder buffer = new StringBuilder();
        final ScheduledExecutorService uiUpdater = Executors.newSingleThreadScheduledExecutor();

        uiUpdater.scheduleAtFixedRate(() -> {
            if (!isRunning.get() && buffer.length() == 0) {
                uiUpdater.shutdown();
                return;
            }

            String textToSend = "";
            synchronized (buffer) {
                if (buffer.length() > 0) {
                    textToSend = buffer.toString();
                    buffer.setLength(0);
                }
            }

            if (!textToSend.isEmpty()) {
                String finalTx = textToSend;
                Platform.runLater(() -> appendOutputConsumer.accept(finalTx));
            }
        }, UI_UPDATE_RATE_MS, UI_UPDATE_RATE_MS, TimeUnit.MILLISECONDS);

        new Thread(() -> {
            byte[] readBuf = new byte[1024];
            int len;
            long droppedBytes = 0;
            try {
                while ((len = inputStream.read(readBuf)) != -1) {
                    synchronized (buffer) {
                        if (buffer.length() >= MAX_UI_BUFFER_SIZE) {
                            droppedBytes += len;
                        } else {
                            if (droppedBytes > 0) {
                                buffer.append("\n[... SKIPPED " + droppedBytes + " BYTES ...]\n");
                                droppedBytes = 0;
                            }
                            int spaceLeft = MAX_UI_BUFFER_SIZE - buffer.length();
                            int writeLen = Math.min(len, spaceLeft);
                            buffer.append(new String(readBuf, 0, writeLen, StandardCharsets.UTF_8));
                        }
                    }
                }
            } catch (IOException ignored) {
            } finally {
                uiUpdater.shutdown();
            }
        }, "Leaky-Reader").start();
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/runtime/DebuggerService.java
=================================================================================

package com.botmaker.runtime;

import com.botmaker.config.Constants;
import com.sun.jdi.*;
import com.sun.jdi.connect.AttachingConnector;
import com.sun.jdi.connect.Connector;
import com.sun.jdi.connect.IllegalConnectorArgumentsException;
import com.sun.jdi.event.*;
import com.sun.jdi.request.BreakpointRequest;
import com.sun.jdi.request.ClassPrepareRequest;
import com.sun.jdi.request.EventRequestManager;
import com.sun.jdi.request.StepRequest;

import java.io.IOException;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CountDownLatch;
import java.util.function.Consumer;

public class DebuggerService {

    // ANSI escape codes
    public static final String ANSI_RESET = "\u001B[0m";
    public static final String ANSI_BLUE = "\u001B[34m";
    public static final String ANSI_GREEN = "\u001B[32m";
    public static final String ANSI_YELLOW = "\u001B[33m";
    public static final String ANSI_RED = "\u001B[31m";

    private VirtualMachine vm;
    private Consumer<LocatableEvent> onPause;
    private Runnable onDisconnect;

    // NEW: Keep track of the thread we are debugging
    private ThreadReference currentThread;

    public void setOnPause(Consumer<LocatableEvent> onPause) { this.onPause = onPause; }
    public void setOnDisconnect(Runnable onDisconnect) { this.onDisconnect = onDisconnect; }

    public void connectAndRun(String mainClassName, int port, List<Integer> breakpointLines) throws IOException, IllegalConnectorArgumentsException, InterruptedException {
        VirtualMachineManager vmMgr = Bootstrap.virtualMachineManager();
        AttachingConnector connector = vmMgr.attachingConnectors().stream()
                .filter(c -> c.transport().name().equals("dt_socket"))
                .findFirst()
                .orElseThrow(() -> new RuntimeException("Socket attaching connector not found"));

        Map<String, Connector.Argument> arguments = connector.defaultArguments();
        arguments.get("port").setValue(String.valueOf(port));
        arguments.get("hostname").setValue("localhost");

        int maxRetries = Constants.DEBUGGER_MAX_CONNECT_RETRIES;
        int retryDelayMs = Constants.DEBUGGER_RETRY_DELAY_MS;
        for (int i = 0; i < maxRetries; i++) {
            try {
                System.out.println(ANSI_BLUE + "Attaching to process on port " + port + " (Attempt " + (i + 1) + ")..." + ANSI_RESET);
                vm = connector.attach(arguments);
                System.out.println(ANSI_BLUE + "Attached to VM: " + vm.name() + ANSI_RESET);
                break;
            } catch (IOException e) {
                if (e instanceof java.net.ConnectException && i < maxRetries - 1) {
                    System.out.println(ANSI_YELLOW + "Connection refused. Retrying in " + retryDelayMs + "ms..." + ANSI_RESET);
                    Thread.sleep(retryDelayMs);
                } else {
                    throw e;
                }
            }
        }

        EventRequestManager erm = vm.eventRequestManager();

        List<ReferenceType> classes = vm.classesByName(mainClassName);
        if (!classes.isEmpty()) {
            setBreakpoints(classes.getFirst(), breakpointLines);
        } else {
            ClassPrepareRequest classPrepareRequest = erm.createClassPrepareRequest();
            classPrepareRequest.addClassFilter(mainClassName);
            classPrepareRequest.enable();
        }

        CountDownLatch listenerReadyLatch = new CountDownLatch(1);
        new Thread(() -> listenForEvents(listenerReadyLatch, mainClassName, breakpointLines)).start();
        listenerReadyLatch.await();

        vm.resume();
    }

    private void listenForEvents(CountDownLatch listenerReadyLatch, String mainClassName, List<Integer> breakpointLines) {
        if (vm == null) return;
        EventQueue eventQueue = vm.eventQueue();
        while (true) {
            try {
                if (listenerReadyLatch != null) {
                    listenerReadyLatch.countDown();
                    listenerReadyLatch = null;
                }

                EventSet eventSet = eventQueue.remove();
                boolean shouldResume = true;

                try {
                    for (Event event : eventSet) {
                        if (event instanceof LocatableEvent) {
                            // BreakpointEvent or StepEvent
                            System.out.println(ANSI_GREEN + "---> Paused at: " + event + ANSI_RESET);

                            // Capture the thread context
                            if (event instanceof BreakpointEvent) {
                                currentThread = ((BreakpointEvent) event).thread();
                            } else if (event instanceof StepEvent) {
                                currentThread = ((StepEvent) event).thread();
                                // Clean up the step request once hit
                                vm.eventRequestManager().deleteEventRequest(event.request());
                            }

                            if (onPause != null) {
                                onPause.accept((LocatableEvent) event);
                            }
                            shouldResume = false; // Keep paused
                        } else if (event instanceof ClassPrepareEvent) {
                            System.out.println(ANSI_YELLOW + "Class Prepared: " + ((ClassPrepareEvent) event).referenceType().name() + ANSI_RESET);
                            ClassPrepareEvent cpe = (ClassPrepareEvent) event;
                            if (cpe.referenceType().name().equals(mainClassName)) {
                                setBreakpoints(cpe.referenceType(), breakpointLines);
                            }
                        } else if (event instanceof VMDisconnectEvent) {
                            System.out.println(ANSI_RED + "VM Disconnected." + ANSI_RESET);
                            if (onDisconnect != null) onDisconnect.run();
                            return;
                        }
                    }
                } finally {
                    if (shouldResume) {
                        eventSet.resume();
                    }
                }
            } catch (InterruptedException | VMDisconnectedException e) {
                if (onDisconnect != null) onDisconnect.run();
                return;
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }

    private void setBreakpoints(ReferenceType refType, List<Integer> lines) {
        if (lines == null || lines.isEmpty()) return;
        try {
            EventRequestManager erm = vm.eventRequestManager();
            // Clear existing breakpoints on this class first if re-setting
            // (Not implementing clear logic here for simplicity, assuming fresh session)

            for (int lineNumber : lines) {
                List<Location> locations = refType.locationsOfLine(lineNumber);
                if (!locations.isEmpty()) {
                    Location loc = locations.get(0);
                    BreakpointRequest bpReq = erm.createBreakpointRequest(loc);
                    bpReq.enable();
                }
            }
        } catch (AbsentInformationException e) {
            System.err.println("No debug info available.");
        }
    }


    public void disconnect() {
        if (vm != null) {
            try {
                System.out.println(ANSI_BLUE + "Disconnecting debugger..." + ANSI_RESET);
                vm.dispose(); // This triggers VMDisconnectEvent in the listener loop
            } catch (VMDisconnectedException e) {
                // Already disconnected, ignore
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }

    // NEW: Step Over Implementation
    public void stepOver() {
        if (vm == null || currentThread == null) return;
        try {
            EventRequestManager erm = vm.eventRequestManager();

            // Clear any existing step requests on this thread
            List<StepRequest> steps = erm.stepRequests();
            for (StepRequest step : steps) {
                if (step.thread().equals(currentThread)) {
                    erm.deleteEventRequest(step);
                }
            }

            // Create new StepOver request
            StepRequest request = erm.createStepRequest(currentThread, StepRequest.STEP_LINE, StepRequest.STEP_OVER);
            request.addCountFilter(1); // Step 1 line
            request.enable();

            vm.resume();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public void resume() {
        if (vm != null) {
            System.out.println(ANSI_BLUE + "Resuming VM..." + ANSI_RESET);
            vm.resume();
        }
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/runtime/DebuggingManager.java
=================================================================================

package com.botmaker.runtime;

import com.botmaker.config.ApplicationConfig;
import com.botmaker.core.CodeBlock;
import com.botmaker.core.StatementBlock;
import com.botmaker.events.CoreApplicationEvents;
import com.botmaker.events.EventBus;
import com.botmaker.parser.BlockFactory;
import com.sun.jdi.connect.IllegalConnectorArgumentsException;
import com.sun.jdi.event.LocatableEvent;
import javafx.application.Platform;
import org.eclipse.jdt.core.dom.ASTNode;
import org.eclipse.jdt.core.dom.CompilationUnit;

import java.io.IOException;
import java.io.InputStream;
import java.net.ServerSocket;
import java.util.*;

public class DebuggingManager {

    private final CodeExecutionService codeExecutionService;
    private final EventBus eventBus;
    private final BlockFactory factory;
    private final ApplicationConfig config;

    private Map<ASTNode, CodeBlock> nodeToBlockMap;
    private DebuggerService debuggerService;
    private Map<Integer, CodeBlock> lineToBlockMap;

    // NEW: Store the running process so we can kill it
    private volatile Process currentProcess;

    public DebuggingManager(
            CodeExecutionService codeExecutionService,
            EventBus eventBus,
            BlockFactory factory,
            ApplicationConfig config) {
        this.codeExecutionService = codeExecutionService;
        this.eventBus = eventBus;
        this.factory = factory;
        this.config = config;
    }

    public void setNodeToBlockMap(Map<ASTNode, CodeBlock> nodeToBlockMap) {
        this.nodeToBlockMap = nodeToBlockMap;
    }

    public void startDebugging(String code) {
        new Thread(() -> {
            try {
                if (!codeExecutionService.compileAndWait(code, config.getSourceFilePath(), config.getCompiledOutputPath())) {
                    eventBus.publish(new CoreApplicationEvents.StatusMessageEvent("Debug aborted due to compilation failure."));
                    return;
                }

                CompilationUnit cu = factory.getCompilationUnit();
                if (cu == null || nodeToBlockMap == null) {
                    eventBus.publish(new CoreApplicationEvents.StatusMessageEvent("Error: Could not parse code to get breakpoints."));
                    return;
                }

                this.lineToBlockMap = new HashMap<>();
                List<Integer> activeBreakpoints = new ArrayList<>();

                for (CodeBlock block : nodeToBlockMap.values()) {
                    int line = block.getBreakpointLine(cu);
                    if (line > 0) {
                        if (!lineToBlockMap.containsKey(line) || block instanceof StatementBlock) {
                            lineToBlockMap.put(line, block);
                        }
                        if (block.isBreakpoint()) {
                            activeBreakpoints.add(line);
                        }
                    }
                }

                if (activeBreakpoints.isEmpty() && !lineToBlockMap.isEmpty()) {
                    lineToBlockMap.keySet().stream()
                            .min(Integer::compareTo)
                            .ifPresent(firstLine -> {
                                activeBreakpoints.add(firstLine);
                                eventBus.publish(new CoreApplicationEvents.StatusMessageEvent("No breakpoints set. Pausing at start (Line " + firstLine + ")."));
                            });
                }

                int freePort;
                try (ServerSocket socket = new ServerSocket(0)) {
                    freePort = socket.getLocalPort();
                }

                eventBus.publish(new CoreApplicationEvents.StatusMessageEvent("Starting debugger on port " + freePort + "..."));
                eventBus.publish(new CoreApplicationEvents.DebugSessionStartedEvent());

                Platform.runLater(() -> eventBus.publish(new CoreApplicationEvents.OutputClearedEvent()));

                String classPath = config.getCompiledOutputPath().toString();
                String className = config.getMainClassName();
                String javaExecutable = config.getJavaExecutable();
                String debugAgent = String.format("-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=%d", freePort);

                ProcessBuilder pb = new ProcessBuilder(javaExecutable, debugAgent, "-cp", classPath, className);

                // NEW: Assign to field
                this.currentProcess = pb.start();

                redirectStream(currentProcess.getInputStream());
                redirectStream(currentProcess.getErrorStream());

                debuggerService = new DebuggerService();
                debuggerService.setOnPause(this::handlePauseEvent);
                debuggerService.setOnDisconnect(this::onDebugSessionFinished);

                debuggerService.connectAndRun(className, freePort, activeBreakpoints);

            } catch (IOException | IllegalConnectorArgumentsException | InterruptedException e) {
                eventBus.publish(new CoreApplicationEvents.StatusMessageEvent("Debugger Error: " + e.getMessage()));
                e.printStackTrace();
            }
        }).start();
    }

    public void continueExecution() {
        if (debuggerService != null) {
            eventBus.publish(new CoreApplicationEvents.DebugSessionResumedEvent());
            debuggerService.resume();
        }
    }

    public void stepOver() {
        if (debuggerService != null) {
            eventBus.publish(new CoreApplicationEvents.DebugSessionResumedEvent());
            debuggerService.stepOver();
        }
    }

    // NEW: Forcefully kill the process and disconnect
    public void stopDebugging() {
        // 1. Disconnect JDI nicely if possible (triggers events)
        if (debuggerService != null) {
            debuggerService.disconnect();
        }

        // 2. Kill the OS process to stop execution immediately
        if (currentProcess != null && currentProcess.isAlive()) {
            try {
                currentProcess.destroyForcibly();
                eventBus.publish(new CoreApplicationEvents.StatusMessageEvent("Debug process terminated."));
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                currentProcess = null;
            }
        }
    }

    private void handlePauseEvent(LocatableEvent event) {
        int lineNumber = event.location().lineNumber();
        CodeBlock block = lineToBlockMap.get(lineNumber);
        CodeBlock target = (block != null) ? block.getHighlightTarget() : null;

        eventBus.publish(new CoreApplicationEvents.DebugSessionPausedEvent(lineNumber, target));
        eventBus.publish(new CoreApplicationEvents.BlockHighlightEvent(target));
        eventBus.publish(new CoreApplicationEvents.StatusMessageEvent(
                "Paused at line: " + lineNumber
        ));
    }

    private void onDebugSessionFinished() {
        eventBus.publish(new CoreApplicationEvents.DebugSessionFinishedEvent());
        eventBus.publish(new CoreApplicationEvents.StatusMessageEvent("Debug session finished."));
        eventBus.publish(new CoreApplicationEvents.BlockHighlightEvent(null));
        this.currentProcess = null;
    }

    private void redirectStream(InputStream stream) {
        new Thread(() -> {
            try (Scanner s = new Scanner(stream)) {
                while (s.hasNextLine()) {
                    String line = s.nextLine();
                    Platform.runLater(() -> eventBus.publish(new CoreApplicationEvents.OutputAppendedEvent(line + "\n")));
                }
            }
        }).start();
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/services/CodeEditorService.java
=================================================================================

package com.botmaker.services;

import com.botmaker.blocks.MainBlock;
import com.botmaker.config.ApplicationConfig;
import com.botmaker.core.CodeBlock;
import com.botmaker.events.CoreApplicationEvents;
import com.botmaker.events.EventBus;
import com.botmaker.lsp.CompletionContext;
import com.botmaker.parser.AstRewriter;
import com.botmaker.parser.BlockFactory;
import com.botmaker.parser.CodeEditor;
import com.botmaker.state.ApplicationState;
import com.botmaker.state.HistoryManager;
import com.botmaker.ui.BlockDragAndDropManager;
import com.botmaker.validation.DiagnosticsManager;
import javafx.application.Platform;

public class CodeEditorService {

    private final ApplicationConfig config;
    private final ApplicationState state;
    private final EventBus eventBus;
    private final BlockFactory blockFactory;
    private final AstRewriter astRewriter;
    private final CodeEditor codeEditor;
    private final BlockDragAndDropManager dragAndDropManager;
    private final LanguageServerService languageServerService;
    private final DiagnosticsManager diagnosticsManager;
    private final HistoryManager historyManager;
    private boolean isRestoringHistory = false;

    public CodeEditorService(
            ApplicationConfig config,
            ApplicationState state,
            EventBus eventBus,
            BlockFactory blockFactory,
            AstRewriter astRewriter,
            BlockDragAndDropManager dragAndDropManager,
            LanguageServerService languageServerService,
            DiagnosticsManager diagnosticsManager) {

        this.config = config;
        this.state = state;
        this.eventBus = eventBus;
        this.blockFactory = blockFactory;
        this.astRewriter = astRewriter;
        this.dragAndDropManager = dragAndDropManager;
        this.languageServerService = languageServerService;
        this.diagnosticsManager = diagnosticsManager;
        this.historyManager = new HistoryManager();
        this.codeEditor = new CodeEditor(state, eventBus, astRewriter, blockFactory);

        setupEventHandlers();
    }

    private void setupEventHandlers() {
        eventBus.subscribe(
                CoreApplicationEvents.UIRefreshRequestedEvent.class,
                event -> Platform.runLater(() -> refreshUI(event.getCode())),
                false
        );

        // NEW: Listen for toggles to update state
        eventBus.subscribe(
                CoreApplicationEvents.BreakpointToggledEvent.class,
                this::handleBreakpointToggle,
                false
        );

        // 1. Record History on Code Updates
        eventBus.subscribe(CoreApplicationEvents.CodeUpdatedEvent.class, this::handleCodeUpdateForHistory, false);

        // 2. Handle Requests
        eventBus.subscribe(CoreApplicationEvents.UndoRequestedEvent.class, e -> undo(), false);
        eventBus.subscribe(CoreApplicationEvents.RedoRequestedEvent.class, e -> redo(), false);

    }

    // Called when block drag-drop or text edit happens
    private void handleCodeUpdateForHistory(CoreApplicationEvents.CodeUpdatedEvent event) {
        // If this update is triggered BY the undo button, don't record it again!
        if (isRestoringHistory) return;

        // Save the PREVIOUS code state before the update happened
        String previousCode = event.getPreviousCode();
        if (previousCode != null && !previousCode.isEmpty()) {
            historyManager.pushState(previousCode);
            broadcastHistoryState();
        }
    }

    private void undo() {
        if (!historyManager.canUndo()) return;
        applyHistoryState(historyManager.undo(state.getCurrentCode()));
    }

    private void redo() {
        if (!historyManager.canRedo()) return;
        applyHistoryState(historyManager.redo(state.getCurrentCode()));
    }

    private void applyHistoryState(String code) {
        isRestoringHistory = true; // Lock recording
        try {
            // This triggers the standard refresh flow (UI update, LSP sync, etc.)
            // We fake a CodeUpdatedEvent so the LanguageServerService picks it up
            eventBus.publish(new CoreApplicationEvents.CodeUpdatedEvent(code, state.getCurrentCode()));
            broadcastHistoryState();
        } finally {
            isRestoringHistory = false; // Unlock
        }
    }

    private void broadcastHistoryState() {
        eventBus.publish(new CoreApplicationEvents.HistoryStateChangedEvent(
                historyManager.canUndo(),
                historyManager.canRedo()
        ));
    }

    private void handleBreakpointToggle(CoreApplicationEvents.BreakpointToggledEvent event) {
        if (event.isEnabled()) {
            state.addBreakpoint(event.getBlock().getId());
        } else {
            state.removeBreakpoint(event.getBlock().getId());
        }
    }

    public void loadInitialCode() {
        String currentCode = state.getCurrentCode();
        historyManager.clear();
        broadcastHistoryState();
        Platform.runLater(() -> refreshUI(currentCode));
    }

    private void refreshUI(String javaCode) {
        state.setCurrentCode(javaCode);
        state.clearNodeToBlockMap();

        if (diagnosticsManager != null) {
            diagnosticsManager.updateSource(state.getMutableNodeToBlockMap(), javaCode);
        }

        MainBlock rootBlock = blockFactory.convert(
                javaCode,
                state.getMutableNodeToBlockMap(),
                dragAndDropManager
        );

        // NEW: Restore breakpoints on newly created blocks
        for (CodeBlock block : state.getNodeToBlockMap().values()) {
            if (state.hasBreakpoint(block.getId())) {
                block.setBreakpoint(true);
            }
        }

        state.setCompilationUnit(blockFactory.getCompilationUnit());

        eventBus.publish(new CoreApplicationEvents.UIBlocksUpdatedEvent(rootBlock));
        eventBus.publish(new CoreApplicationEvents.StatusMessageEvent("UI Refreshed."));
    }

    public CompletionContext createCompletionContext() {
        return new CompletionContext(
                codeEditor,
                languageServerService.getServer(),
                state.getDocUri(),
                state.getCurrentCode(),
                state.getDocVersion(),
                dragAndDropManager
        );
    }

    public CodeEditor getCodeEditor() { return codeEditor; }
    public BlockFactory getBlockFactory() { return blockFactory; }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/services/DebuggingService.java
=================================================================================

package com.botmaker.services;

import com.botmaker.config.ApplicationConfig;
import com.botmaker.events.CoreApplicationEvents;
import com.botmaker.events.EventBus;
import com.botmaker.parser.BlockFactory;
import com.botmaker.runtime.CodeExecutionService;
import com.botmaker.runtime.DebuggingManager;
import com.botmaker.state.ApplicationState;

public class DebuggingService {

    private final ApplicationState state;
    private final EventBus eventBus;
    private final DebuggingManager debuggingManager;

    public DebuggingService(
            ApplicationState state,
            EventBus eventBus,
            CodeExecutionService codeExecutionService,
            BlockFactory blockFactory,
            ApplicationConfig config) {

        this.state = state;
        this.eventBus = eventBus;
        this.debuggingManager = new DebuggingManager(codeExecutionService, eventBus, blockFactory, config);

        setupEventHandlers();
    }

    private void setupEventHandlers() {
        eventBus.subscribe(CoreApplicationEvents.DebugStartRequestedEvent.class, event -> startDebugging(), false);
        eventBus.subscribe(CoreApplicationEvents.DebugStepOverRequestedEvent.class, event -> stepOver(), false);
        eventBus.subscribe(CoreApplicationEvents.DebugContinueRequestedEvent.class, event -> continueExecution(), false);

        // NEW: Subscribe to Stop request
        eventBus.subscribe(CoreApplicationEvents.DebugStopRequestedEvent.class, event -> stopDebugging(), false);
    }

    // Add the delegate method
    public void stopDebugging() {
        debuggingManager.stopDebugging();
    }

    public void startDebugging() {
        debuggingManager.setNodeToBlockMap(state.getNodeToBlockMap());
        debuggingManager.startDebugging(state.getCurrentCode());
    }

    public void stepOver() {
        debuggingManager.stepOver();
    }

    public void continueExecution() {
        debuggingManager.continueExecution();
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/services/ExecutionService.java
=================================================================================

package com.botmaker.services;

import com.botmaker.config.ApplicationConfig;
import com.botmaker.events.CoreApplicationEvents;
import com.botmaker.events.EventBus;
import com.botmaker.runtime.CodeExecutionService;
import com.botmaker.state.ApplicationState;

/**
 * Service wrapper for code execution (compilation and running).
 * Bridges between the event system and the existing CodeExecutionService.
 */
public class ExecutionService {

    private final ApplicationConfig config;
    private final ApplicationState state;
    private final EventBus eventBus;
    private final CodeExecutionService codeExecutionService;
    private final com.botmaker.validation.DiagnosticsManager diagnosticsManager;

    public ExecutionService(
            ApplicationConfig config,
            ApplicationState state,
            EventBus eventBus,
            CodeExecutionService codeExecutionService,
            com.botmaker.validation.DiagnosticsManager diagnosticsManager) {

        this.config = config;
        this.state = state;
        this.eventBus = eventBus;
        this.codeExecutionService = codeExecutionService;
        this.diagnosticsManager = diagnosticsManager;

        setupEventHandlers();
    }

    private void setupEventHandlers() {
        // Subscribe to compilation requests
        eventBus.subscribe(
                CoreApplicationEvents.CompilationRequestedEvent.class,
                event -> compile(),
                false
        );

        // Subscribe to execution requests
        eventBus.subscribe(
                CoreApplicationEvents.ExecutionRequestedEvent.class,
                event -> run(),
                false
        );

        // NEW: Subscribe to stop run requests
        eventBus.subscribe(
                CoreApplicationEvents.StopRunRequestedEvent.class,
                event -> stopRun(),
                false
        );
    }

    /**
     * Compiles the current code
     */
    public void compile() {
        codeExecutionService.compileCode(state.getCurrentCode());
    }

    /**
     * Runs the current code
     */
    public void run() {
        // 1. UI Updates to RUNNING state
        eventBus.publish(new CoreApplicationEvents.ProgramStartedEvent());

        // 2. Thread Starts
        new Thread(() -> {
            // 3. Blocks here while program runs
            codeExecutionService.runCode(state.getCurrentCode());

            // 4. Program finishes/dies, then UI Updates to IDLE state
            eventBus.publish(new CoreApplicationEvents.ProgramStoppedEvent());
        }).start();
    }

    /**
     * NEW: Stops the currently running program
     */
    public void stopRun() {
        codeExecutionService.stopRunningProgram();
        eventBus.publish(new CoreApplicationEvents.ProgramStoppedEvent());
    }

    /**
     * Get the underlying code execution service
     */
    public CodeExecutionService getCodeExecutionService() {
        return codeExecutionService;
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/services/LanguageServerService.java
=================================================================================

package com.botmaker.services;

import com.botmaker.config.ApplicationConfig;
import com.botmaker.config.Constants;
import com.botmaker.events.CoreApplicationEvents;
import com.botmaker.events.EventBus;
import com.botmaker.lsp.JdtLanguageServerLauncher;
import com.botmaker.state.ApplicationState;
import javafx.application.Platform;
import org.eclipse.lsp4j.*;
import org.eclipse.lsp4j.services.LanguageServer;

import java.nio.file.Files;
import java.nio.file.Path;
import java.util.List;

public class LanguageServerService {

    private final ApplicationConfig config;
    private final ApplicationState state;
    private final EventBus eventBus;
    private final com.botmaker.validation.DiagnosticsManager diagnosticsManager;

    private LanguageServer server;
    private JdtLanguageServerLauncher launcher;

    // New flag
    private boolean shouldClearCache = false;

    public LanguageServerService(
            ApplicationConfig config,
            ApplicationState state,
            EventBus eventBus,
            com.botmaker.validation.DiagnosticsManager diagnosticsManager) {
        this.config = config;
        this.state = state;
        this.eventBus = eventBus;
        this.diagnosticsManager = diagnosticsManager;

        setupEventHandlers();
    }

    public void setShouldClearCache(boolean shouldClear) {
        this.shouldClearCache = shouldClear;
    }

    private void setupEventHandlers() {
        eventBus.subscribe(
                CoreApplicationEvents.CodeUpdatedEvent.class,
                this::handleCodeUpdate,
                false
        );
    }

    public void initialize() throws Exception {
        // NEW: Check if we need to clear cache
        if (shouldClearCache) {
            JdtLanguageServerLauncher.cleanupWorkspace(config.getWorkspaceDataPath());
        }

        launcher = new JdtLanguageServerLauncher(
                config.getJdtServerPath(),
                config.getProjectPath(),
                config.getWorkspaceDataPath(),
                (PublishDiagnosticsParams params) -> {
                    Platform.runLater(() -> {
                        List<Diagnostic> diagnostics = params.getDiagnostics();
                        eventBus.publish(new CoreApplicationEvents.DiagnosticsUpdatedEvent(diagnostics));
                    });
                }
        );

        // ... rest of the file stays the same ...
        server = launcher.getServer();

        Path docPath = config.getSourceFilePath().toAbsolutePath().normalize();

        // Ensure the file exists
        if (!Files.exists(docPath)) {
            Files.createDirectories(docPath.getParent());

            // Extract project name and package from main class name
            String mainClassName = config.getMainClassName();
            String[] parts = mainClassName.split("\\.");
            String packageName = parts.length > 1 ? String.join(".", java.util.Arrays.copyOf(parts, parts.length - 1)) : "com.demo";
            String className = parts[parts.length - 1];

            // Create a default file with correct package and class name
            String defaultCode = String.format("""
            package %s;
            public class %s {
                public static void main(String[] args) {
                    System.out.println("Hello from %s!");
                }
            }
            """, packageName, className, className);
            Files.writeString(docPath, defaultCode);
        }

        String docUri = docPath.toUri().toString();
        String currentCode = Files.readString(docPath);

        state.setDocUri(docUri);
        state.setCurrentCode(currentCode);
        state.setDocVersion(1);

        server.getTextDocumentService().didOpen(new DidOpenTextDocumentParams(
                new TextDocumentItem(docUri, "java", (int) state.getDocVersion(), currentCode)
        ));
    }

    // ... shutdown/handlers stay same ...
    private void handleCodeUpdate(CoreApplicationEvents.CodeUpdatedEvent event) {
        try {
            // Write to file
            Path docPath = Path.of(new java.net.URI(state.getDocUri()));
            Files.writeString(docPath, event.getNewCode());

            // Update state
            state.incrementDocVersion();
            state.setCurrentCode(event.getNewCode());

            // Notify LSP server
            server.getTextDocumentService().didChange(new DidChangeTextDocumentParams(
                    new VersionedTextDocumentIdentifier(state.getDocUri(), (int) state.getDocVersion()),
                    List.of(new TextDocumentContentChangeEvent(event.getNewCode()))
            ));

            eventBus.publish(new CoreApplicationEvents.UIRefreshRequestedEvent(event.getNewCode()));

        } catch (Exception e) {
            e.printStackTrace();
            eventBus.publish(new CoreApplicationEvents.StatusMessageEvent(
                    "Error saving file: " + e.getMessage()
            ));
        }
    }

    public void shutdown() {
        if (launcher != null) {
            try {
                System.out.println("Requesting server shutdown...");
                if (server != null) {
                    server.shutdown().get(Constants.DEBUGGER_SHUTDOWN_TIMEOUT_SECONDS, java.util.concurrent.TimeUnit.SECONDS);
                    server.exit();
                }
                Thread.sleep(Constants.SHORT_SLEEP_MS);
            } catch (java.util.concurrent.TimeoutException e) {
                System.err.println("Server shutdown timed out, forcing stop...");
            } catch (Exception e) {
                System.err.println("Error during server shutdown: " + e.getMessage());
            } finally {
                launcher.stop();
            }
        }
    }

    public LanguageServer getServer() {
        return server;
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/state/ApplicationState.java
=================================================================================

package com.botmaker.state;

import com.botmaker.core.CodeBlock;
import org.eclipse.jdt.core.dom.ASTNode;
import org.eclipse.jdt.core.dom.CompilationUnit;

import java.util.*;

/**
 * Central application state container.
 * Manages the current state of the code editor and related metadata.
 * Thread-safe through immutability and defensive copying.
 */
public class ApplicationState {

    // Code-related state
    private String currentCode;
    private String docUri;
    private long docVersion;

    // AST and block mappings
    private CompilationUnit compilationUnit;
    private Map<ASTNode, CodeBlock> nodeToBlockMap;

    // UI state
    private CodeBlock highlightedBlock;

    // Debug state
    private boolean isDebugging;
    private final Set<String> breakpointIds = new HashSet<>();
    public ApplicationState() {
        this.currentCode = "";
        this.docUri = "";
        this.docVersion = 1;
        this.nodeToBlockMap = new HashMap<>();
        this.isDebugging = false;
    }

    // Code state

    public String getCurrentCode() {
        return currentCode;
    }

    public void setCurrentCode(String currentCode) {
        this.currentCode = currentCode != null ? currentCode : "";
    }

    public String getDocUri() {
        return docUri;
    }

    public void setDocUri(String docUri) {
        this.docUri = docUri != null ? docUri : "";
    }

    public long getDocVersion() {
        return docVersion;
    }

    public void incrementDocVersion() {
        this.docVersion++;
    }

    public void setDocVersion(long docVersion) {
        this.docVersion = docVersion;
    }

    // AST and block mappings

    public Optional<CompilationUnit> getCompilationUnit() {
        return Optional.ofNullable(compilationUnit);
    }

    public void setCompilationUnit(CompilationUnit compilationUnit) {
        this.compilationUnit = compilationUnit;
    }

    /**
     * Returns an unmodifiable view of the node-to-block map
     */
    public Map<ASTNode, CodeBlock> getNodeToBlockMap() {
        return Collections.unmodifiableMap(nodeToBlockMap);
    }

    /**
     * Returns the mutable node-to-block map for updates
     */
    public Map<ASTNode, CodeBlock> getMutableNodeToBlockMap() {
        return nodeToBlockMap;
    }

    public void setNodeToBlockMap(Map<ASTNode, CodeBlock> nodeToBlockMap) {
        this.nodeToBlockMap = nodeToBlockMap != null ?
                new HashMap<>(nodeToBlockMap) : new HashMap<>();
    }

    public void clearNodeToBlockMap() {
        this.nodeToBlockMap.clear();
    }

    public Optional<CodeBlock> getBlockForNode(ASTNode node) {
        return Optional.ofNullable(nodeToBlockMap.get(node));
    }

    // UI state

    public Optional<CodeBlock> getHighlightedBlock() {
        return Optional.ofNullable(highlightedBlock);
    }

    public void setHighlightedBlock(CodeBlock block) {
        // Clear previous highlight
        if (this.highlightedBlock != null) {
            this.highlightedBlock.unhighlight();
        }

        this.highlightedBlock = block;

        // Apply new highlight
        if (this.highlightedBlock != null) {
            this.highlightedBlock.highlight();
        }
    }

    public void clearHighlight() {
        setHighlightedBlock(null);
    }

    // Debug state

    public boolean isDebugging() {
        return isDebugging;
    }

    public void setDebugging(boolean debugging) {
        this.isDebugging = debugging;
    }
    // NEW: Breakpoint Management
    public Set<String> getBreakpointIds() {
        return Collections.unmodifiableSet(breakpointIds);
    }

    public void addBreakpoint(String blockId) {
        breakpointIds.add(blockId);
    }

    public void removeBreakpoint(String blockId) {
        breakpointIds.remove(blockId);
    }

    public boolean hasBreakpoint(String blockId) {
        return breakpointIds.contains(blockId);
    }
    // Utility methods

    /**
     * Creates a snapshot of the current state for debugging/logging
     */
    public StateSnapshot createSnapshot() {
        return new StateSnapshot(
                currentCode,
                docUri,
                docVersion,
                nodeToBlockMap.size(),
                highlightedBlock != null,
                isDebugging
        );
    }

    /**
     * Immutable snapshot of state for debugging
     */
    public static class StateSnapshot {
        public final String currentCode;
        public final String docUri;
        public final long docVersion;
        public final int blockCount;
        public final boolean hasHighlight;
        public final boolean isDebugging;

        private StateSnapshot(String currentCode, String docUri, long docVersion,
                              int blockCount, boolean hasHighlight, boolean isDebugging) {
            this.currentCode = currentCode;
            this.docUri = docUri;
            this.docVersion = docVersion;
            this.blockCount = blockCount;
            this.hasHighlight = hasHighlight;
            this.isDebugging = isDebugging;
        }

        @Override
        public String toString() {
            return String.format(
                    "StateSnapshot{docVersion=%d, codeLength=%d, blockCount=%d, hasHighlight=%s, isDebugging=%s}",
                    docVersion, currentCode.length(), blockCount, hasHighlight, isDebugging
            );
        }
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/state/HistoryManager.java
=================================================================================

package com.botmaker.state;

import java.util.Stack;

public class HistoryManager {

    private final Stack<String> undoStack = new Stack<>();
    private final Stack<String> redoStack = new Stack<>();
    private static final int MAX_HISTORY_SIZE = 50; // Limit memory usage

    /**
     * Saves a snapshot of the code.
     * Call this BEFORE applying a new change.
     */
    public void pushState(String code) {
        // Avoid saving duplicates (e.g. if multiple events fire for same code)
        if (!undoStack.isEmpty() && undoStack.peek().equals(code)) {
            return;
        }

        undoStack.push(code);

        // Enforce size limit
        if (undoStack.size() > MAX_HISTORY_SIZE) {
            undoStack.remove(0);
        }

        // New change clears the redo future
        redoStack.clear();
    }

    public boolean canUndo() { return !undoStack.isEmpty(); }
    public boolean canRedo() { return !redoStack.isEmpty(); }

    public String undo(String currentCode) {
        if (!canUndo()) return currentCode;

        // Save current state to Redo stack
        redoStack.push(currentCode);

        // Return previous state
        return undoStack.pop();
    }

    public String redo(String currentCode) {
        if (!canRedo()) return currentCode;

        // Save current state to Undo stack
        undoStack.push(currentCode);

        // Return future state
        return redoStack.pop();
    }

    public void clear() {
        undoStack.clear();
        redoStack.clear();
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/ui/AddableBlock.java
=================================================================================

package com.botmaker.ui;

import com.botmaker.blocks.*;
import com.botmaker.core.StatementBlock;

public enum AddableBlock {
    // --- OUTPUT ---
    PRINT("Print", PrintBlock.class, BlockCategory.OUTPUT),

    // --- FLOW CONTROL ---
    IF("If Statement", IfBlock.class, BlockCategory.FLOW),
    WHILE("While Loop", WhileBlock.class, BlockCategory.LOOPS),
    FOR("For Each Loop", ForBlock.class, BlockCategory.LOOPS),
    DO_WHILE("Do While", DoWhileBlock.class, BlockCategory.LOOPS),
    SWITCH("Switch", SwitchBlock.class, BlockCategory.FLOW),
    CASE("Case", SwitchBlock.SwitchCaseBlock.class, BlockCategory.FLOW),

    // --- CONTROL COMMANDS ---
    BREAK("Break", BreakBlock.class, BlockCategory.CONTROL),
    CONTINUE("Continue", ContinueBlock.class, BlockCategory.CONTROL),
    RETURN("Return", ReturnBlock.class, BlockCategory.CONTROL),
    WAIT("Wait (ms)", WaitBlock.class, BlockCategory.CONTROL),

    // --- VARIABLES ---
    DECLARE_INT("Int Variable", VariableDeclarationBlock.class, BlockCategory.VARIABLES),
    DECLARE_DOUBLE("Double Variable", VariableDeclarationBlock.class, BlockCategory.VARIABLES),
    DECLARE_BOOLEAN("Bool Variable", VariableDeclarationBlock.class, BlockCategory.VARIABLES),
    DECLARE_STRING("String Variable", VariableDeclarationBlock.class, BlockCategory.VARIABLES),

    // NEW: Generic Array Declaration
    DECLARE_ARRAY("Create List", VariableDeclarationBlock.class, BlockCategory.VARIABLES),

    ASSIGNMENT("Set Variable", AssignmentBlock.class, BlockCategory.VARIABLES),

    // --- INPUT ---
    READ_LINE("Read Text", ReadInputBlock.class, BlockCategory.INPUT),
    READ_INT("Read Int", ReadInputBlock.class, BlockCategory.INPUT),
    READ_DOUBLE("Read Double", ReadInputBlock.class, BlockCategory.INPUT),

    // --- UTILITY ---
    COMMENT("Comment", CommentBlock.class, BlockCategory.UTILITY);

    private final String displayName;
    private final Class<? extends StatementBlock> blockClass;
    private final BlockCategory category;

    AddableBlock(String displayName, Class<? extends StatementBlock> blockClass, BlockCategory category) {
        this.displayName = displayName;
        this.blockClass = blockClass;
        this.category = category;
    }

    public String getDisplayName() { return displayName; }
    public Class<? extends StatementBlock> getBlockClass() { return blockClass; }
    public BlockCategory getCategory() { return category; }

    public enum BlockCategory {
        OUTPUT("Output"),
        INPUT("Input"),
        VARIABLES("Variables"),
        FLOW("Logic"),
        LOOPS("Loops"),
        CONTROL("Control"),
        UTILITY("Utility");

        private final String label;
        BlockCategory(String label) { this.label = label; }
        public String getLabel() { return label; }
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/ui/AddableExpression.java
=================================================================================

package com.botmaker.ui;

public enum AddableExpression {
    // Literals
    TEXT("Text"),
    NUMBER("Number"),
    TRUE("True"),
    FALSE("False"),
    VARIABLE("Variable"),

    // NEW: Allow nested lists
    LIST("Sub-List"),

    // Math Operations
    ADD("Addition (+)", "+"),
    SUBTRACT("Subtraction (-)", "-"),
    MULTIPLY("Multiplication (*)", "*"),
    DIVIDE("Division (/)", "/"),
    MODULO("Modulo (%)", "%");

    private final String displayName;
    private final String operator;

    AddableExpression(String displayName) {
        this.displayName = displayName;
        this.operator = null;
    }

    AddableExpression(String displayName, String operator) {
        this.displayName = displayName;
        this.operator = operator;
    }

    public String getDisplayName() {
        return displayName;
    }

    public String getOperator() {
        return operator;
    }

    public boolean isOperation() {
        return operator != null;
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/ui/BlockDragAndDropManager.java
=================================================================================

package com.botmaker.ui;

import com.botmaker.core.BodyBlock;
import com.botmaker.core.StatementBlock;
import javafx.scene.Node;
import javafx.scene.input.ClipboardContent;
import javafx.scene.input.DataFormat;
import javafx.scene.input.Dragboard;
import javafx.scene.input.TransferMode;
import javafx.scene.layout.Region;

import java.util.function.Consumer;

public class BlockDragAndDropManager {

    public static final DataFormat ADDABLE_BLOCK_FORMAT = new DataFormat("application/x-java-addable-block");
    public static final DataFormat EXISTING_BLOCK_FORMAT = new DataFormat("application/x-java-existing-block");

    // Callbacks
    private Consumer<DropInfo> onDrop;
    private Consumer<MoveBlockInfo> onBlockMove;

    public BlockDragAndDropManager(Consumer<DropInfo> onDrop) {
        this.onDrop = onDrop;
    }

    public void setCallback(Consumer<DropInfo> onDrop) {
        this.onDrop = onDrop;
    }

    public void setMoveCallback(Consumer<MoveBlockInfo> onBlockMove) {
        this.onBlockMove = onBlockMove;
    }

    /**
     * Makes a UI node draggable, associating it with a specific type of AddableBlock.
     * @param node The node to make draggable (e.g., a Label in the palette).
     * @param blockType The type of block this node represents.
     */
    public void makeDraggable(Node node, AddableBlock blockType) {
        node.setOnDragDetected(event -> {
            Dragboard db = node.startDragAndDrop(TransferMode.COPY);
            ClipboardContent content = new ClipboardContent();
            content.put(ADDABLE_BLOCK_FORMAT, blockType.name());
            db.setContent(content);
            System.out.println("Drag detected for: " + blockType.name());
            event.consume();
        });
    }

    /**
     * Makes an existing block's UI node draggable for repositioning.
     * @param node The UI node of the block to make draggable.
     * @param block The StatementBlock instance being dragged.
     * @param sourceBody The BodyBlock containing this block.
     */
    public void makeBlockMovable(Node node, StatementBlock block, BodyBlock sourceBody) {
        node.setOnDragDetected(event -> {
            // Only start drag if not clicking on interactive elements
            if (event.getTarget() instanceof javafx.scene.control.Control) {
                return;
            }

            Dragboard db = node.startDragAndDrop(TransferMode.MOVE);
            ClipboardContent content = new ClipboardContent();
            content.put(EXISTING_BLOCK_FORMAT, block.getId());
            db.setContent(content);

            // Visual feedback - make the block semi-transparent while dragging
            node.setOpacity(0.5);

            System.out.println("Dragging existing block: " + block.getDetails());
            event.consume();
        });

        // Reset opacity and release focus when drag is done
        node.setOnDragDone(event -> {
            node.setOpacity(1.0);
            // DON'T consume - let the event propagate to restore normal mouse behavior
            // event.consume();

            // Multiple approaches to ensure drag is fully released
            javafx.application.Platform.runLater(() -> {
                // 1. Find and focus ScrollPane
                javafx.scene.Node current = node;
                javafx.scene.control.ScrollPane scrollPane = null;
                while (current != null) {
                    if (current instanceof javafx.scene.control.ScrollPane) {
                        scrollPane = (javafx.scene.control.ScrollPane) current;
                        break;
                    }
                    current = current.getParent();
                }

                if (scrollPane != null) {
                    // Make sure ScrollPane can receive focus
                    scrollPane.setFocusTraversable(true);
                    scrollPane.requestFocus();

                    // Also try to release any event filters
                    final javafx.scene.control.ScrollPane sp = scrollPane;
                    javafx.application.Platform.runLater(() -> {
                        sp.requestFocus();
                    });
                }
            });
        });
    }

    /**
     * Creates a thin, transparent region to act as a separator and drop target.
     */
    public Region createSeparator() {
        Region separator = new Region();
        separator.setMinHeight(8);
        separator.setStyle("-fx-background-color: transparent;");
        return separator;
    }

    /**
     * Adds all necessary drag-and-drop event handlers to a separator region.
     * Handles both adding new blocks and moving existing blocks.
     * @param separator The region to add handlers to.
     * @param targetBody The body where blocks will be inserted.
     * @param insertionIndex The index in the list where a drop should occur.
     * @param adjacentBlock The block next to the separator, for context (can be null).
     */
    public void addSeparatorDragHandlers(Region separator, BodyBlock targetBody, int insertionIndex, StatementBlock adjacentBlock) {
        String defaultColor = "transparent";
        String hoverColor = "#007bff"; // A distinct blue
        String moveHoverColor = "#28a745"; // Green for moving blocks

        separator.setOnDragEntered(event -> {
            Dragboard db = event.getDragboard();
            if (db.hasContent(ADDABLE_BLOCK_FORMAT)) {
                separator.setStyle("-fx-background-color: " + hoverColor + ";");
                String logMessage = "Hovering insertion point at index: " + insertionIndex;
                if (adjacentBlock != null) {
                    logMessage += " (next to: " + adjacentBlock.getDetails() + ")";
                }
                System.out.println(logMessage);
            } else if (db.hasContent(EXISTING_BLOCK_FORMAT)) {
                separator.setStyle("-fx-background-color: " + moveHoverColor + ";");
                System.out.println("Hovering to move block at index: " + insertionIndex);
            }
            event.consume();
        });

        separator.setOnDragExited(event -> {
            separator.setStyle("-fx-background-color: " + defaultColor);
            event.consume();
        });

        separator.setOnDragOver(event -> {
            Dragboard db = event.getDragboard();
            if (db.hasContent(ADDABLE_BLOCK_FORMAT) || db.hasContent(EXISTING_BLOCK_FORMAT)) {
                event.acceptTransferModes(TransferMode.COPY_OR_MOVE);
            }
            event.consume();
        });

        separator.setOnDragDropped(event -> {
            Dragboard db = event.getDragboard();
            boolean success = false;

            if (db.hasContent(ADDABLE_BLOCK_FORMAT)) {
                // Adding a new block
                String blockTypeName = (String) db.getContent(ADDABLE_BLOCK_FORMAT);
                AddableBlock type = AddableBlock.valueOf(blockTypeName);

                if (onDrop != null) {
                    onDrop.accept(new DropInfo(type, targetBody, insertionIndex));
                    success = true;
                } else {
                    System.err.println("WARNING: onDrop callback not set yet!");
                }
            } else if (db.hasContent(EXISTING_BLOCK_FORMAT)) {
                // Moving an existing block
                String blockId = (String) db.getContent(EXISTING_BLOCK_FORMAT);

                if (onBlockMove != null) {
                    onBlockMove.accept(new MoveBlockInfo(blockId, targetBody, insertionIndex));
                    success = true;
                } else {
                    System.err.println("WARNING: onBlockMove callback not set yet!");
                }
            }

            event.setDropCompleted(success);
            event.consume();
        });
    }

    public void addEmptyBodyDropHandlers(Region target, BodyBlock targetBody) {
        target.setOnDragEntered(event -> {
            if (event.getDragboard().hasContent(ADDABLE_BLOCK_FORMAT) ||
                    event.getDragboard().hasContent(EXISTING_BLOCK_FORMAT)) {
                target.getStyleClass().add("empty-body-drop-hover");
                System.out.println("Added hover class to: " + target.getClass().getSimpleName());
            }
            event.consume();
        });

        target.setOnDragExited(event -> {
            target.getStyleClass().remove("empty-body-drop-hover");
            event.consume();
        });

        target.setOnDragOver(event -> {
            Dragboard db = event.getDragboard();
            if (db.hasContent(ADDABLE_BLOCK_FORMAT) || db.hasContent(EXISTING_BLOCK_FORMAT)) {
                event.acceptTransferModes(TransferMode.COPY_OR_MOVE);
            }
            event.consume();
        });

        target.setOnDragDropped(event -> {
            Dragboard db = event.getDragboard();
            boolean success = false;

            if (db.hasContent(ADDABLE_BLOCK_FORMAT)) {
                // Adding a new block
                String blockTypeName = (String) db.getContent(ADDABLE_BLOCK_FORMAT);
                AddableBlock type = AddableBlock.valueOf(blockTypeName);

                if (onDrop != null) {
                    onDrop.accept(new DropInfo(type, targetBody, 0)); // Always index 0 for empty body
                    success = true;
                } else {
                    System.err.println("WARNING: onDrop callback not set yet!");
                }
            } else if (db.hasContent(EXISTING_BLOCK_FORMAT)) {
                // Moving an existing block
                String blockId = (String) db.getContent(EXISTING_BLOCK_FORMAT);

                if (onBlockMove != null) {
                    onBlockMove.accept(new MoveBlockInfo(blockId, targetBody, 0));
                    success = true;
                } else {
                    System.err.println("WARNING: onBlockMove callback not set yet!");
                }
            }

            event.setDropCompleted(success);
            event.consume();
        });
    }

    public void addExpressionDropHandlers(Region target) {
        String defaultStyle = "-fx-background-color: #f0f0f0; -fx-border-color: #c0c0c0; -fx-border-style: dashed; -fx-min-width: 50; -fx-min-height: 25;";
        String hoverStyle = defaultStyle + "-fx-border-color: #007bff;"; // Highlight with blue

        target.setStyle(defaultStyle);

        target.setOnDragEntered(event -> {
            if (event.getDragboard().hasContent(ADDABLE_BLOCK_FORMAT)) {
                target.setStyle(hoverStyle);
                System.out.println("Hovering expression slot.");
            }
            event.consume();
        });

        target.setOnDragExited(event -> {
            target.setStyle(defaultStyle);
            event.consume();
        });

        target.setOnDragOver(event -> {
            if (event.getDragboard().hasContent(ADDABLE_BLOCK_FORMAT)) {
                event.acceptTransferModes(TransferMode.COPY);
            }
            event.consume();
        });

        target.setOnDragDropped(event -> {
            Dragboard db = event.getDragboard();
            boolean success = false;
            if (db.hasContent(ADDABLE_BLOCK_FORMAT)) {
                String blockTypeName = (String) db.getContent(ADDABLE_BLOCK_FORMAT);
                System.out.println("Cannot drop a Statement block ('" + blockTypeName + "') into an Expression slot.");
                success = true;
            }
            event.setDropCompleted(success);
            event.consume();
        });
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/ui/BlockEvent.java
=================================================================================

package com.botmaker.ui;

import com.botmaker.core.CodeBlock;
import javafx.event.Event;
import javafx.event.EventType;

public class BlockEvent extends Event {
    public static final EventType<BlockEvent> ANY = new EventType<>(Event.ANY, "BLOCK_EVENT");

    public BlockEvent(EventType<? extends Event> eventType) {
        super(eventType);
    }

    public static class BreakpointToggleEvent extends BlockEvent {
        public static final EventType<BreakpointToggleEvent> TOGGLE_BREAKPOINT = new EventType<>(ANY, "TOGGLE_BREAKPOINT");

        private final CodeBlock block;
        private final boolean isEnabled;

        public BreakpointToggleEvent(CodeBlock block, boolean isEnabled) {
            super(TOGGLE_BREAKPOINT);
            this.block = block;
            this.isEnabled = isEnabled;
        }

        public CodeBlock getBlock() { return block; }
        public boolean isEnabled() { return isEnabled; }
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/ui/DropInfo.java
=================================================================================

package com.botmaker.ui;

import com.botmaker.core.BodyBlock;

public record DropInfo(AddableBlock type, BodyBlock targetBody, int insertionIndex) {
}


=================================================================================
FILE: ./src/main/java/com/botmaker/ui/MenuBarManager.java
=================================================================================

package com.botmaker.ui;

import com.botmaker.events.CoreApplicationEvents;
import com.botmaker.events.EventBus;
import javafx.scene.control.Menu;
import javafx.scene.control.MenuBar;
import javafx.scene.control.MenuItem;
import javafx.scene.control.SeparatorMenuItem;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyCodeCombination;
import javafx.scene.input.KeyCombination;
import javafx.stage.Stage;

import java.util.function.Consumer;

/**
 * Manages the application menu bar
 */
public class MenuBarManager {

    private final MenuBar menuBar;
    private final Stage primaryStage;
    private Consumer<Void> onSelectProject;
    private EventBus eventBus;
    private MenuItem undoItem;
    private MenuItem redoItem;
    public MenuBarManager(Stage primaryStage) {
        this.primaryStage = primaryStage;
        this.menuBar = new MenuBar();
        createMenus();
    }

    /**
     * Creates all menus
     */
    private void createMenus() {
        // File menu
        Menu fileMenu = createFileMenu();

        // Edit menu (placeholder for future)
        Menu editMenu = createEditMenu();

        // View menu (placeholder for future)
        Menu viewMenu = createViewMenu();

        // Help menu
        Menu helpMenu = createHelpMenu();

        menuBar.getMenus().addAll(fileMenu, editMenu, viewMenu, helpMenu);
    }

    /**
     * Creates the File menu
     */
    private Menu createFileMenu() {
        Menu fileMenu = new Menu("File");

        // Select Project
        MenuItem selectProjectItem = new MenuItem("Select Project...");
        selectProjectItem.setAccelerator(new KeyCodeCombination(
                KeyCode.O,
                KeyCombination.CONTROL_DOWN,
                KeyCombination.SHIFT_DOWN
        ));
        selectProjectItem.setOnAction(e -> {
            if (onSelectProject != null) {
                onSelectProject.accept(null);
            }
        });

        // Separator
        SeparatorMenuItem separator1 = new SeparatorMenuItem();

        // Exit
        MenuItem exitItem = new MenuItem("Exit");
        exitItem.setAccelerator(new KeyCodeCombination(
                KeyCode.Q,
                KeyCombination.CONTROL_DOWN
        ));

        // UPDATED: Force system exit
        exitItem.setOnAction(e -> {
            javafx.application.Platform.exit(); // Close JavaFX
            System.exit(0); // Kill JVM (stops LSP, Debugger, etc.)
        });

        fileMenu.getItems().addAll(
                selectProjectItem,
                separator1,
                exitItem
        );

        return fileMenu;
    }

    /**
     * Creates the Edit menu
     */
    private Menu createEditMenu() {
        Menu editMenu = new Menu("Edit");

        undoItem = new MenuItem("Undo");
        undoItem.setAccelerator(new KeyCodeCombination(KeyCode.Z, KeyCombination.CONTROL_DOWN));
        undoItem.setDisable(true);
        undoItem.setOnAction(e -> {
            if (eventBus != null) eventBus.publish(new CoreApplicationEvents.UndoRequestedEvent());
        });

        redoItem = new MenuItem("Redo");
        redoItem.setAccelerator(new KeyCodeCombination(KeyCode.Y, KeyCombination.CONTROL_DOWN));
        redoItem.setDisable(true);
        redoItem.setOnAction(e -> {
            if (eventBus != null) eventBus.publish(new CoreApplicationEvents.RedoRequestedEvent());
        });

        SeparatorMenuItem separator = new SeparatorMenuItem();

        MenuItem cutItem = new MenuItem("Cut");
        cutItem.setAccelerator(new KeyCodeCombination(KeyCode.X, KeyCombination.CONTROL_DOWN));
        cutItem.setDisable(true); // Not implemented yet

        MenuItem copyItem = new MenuItem("Copy");
        copyItem.setAccelerator(new KeyCodeCombination(KeyCode.C, KeyCombination.CONTROL_DOWN));
        copyItem.setDisable(true); // Not implemented yet

        MenuItem pasteItem = new MenuItem("Paste");
        pasteItem.setAccelerator(new KeyCodeCombination(KeyCode.V, KeyCombination.CONTROL_DOWN));
        pasteItem.setDisable(true); // Not implemented yet

        editMenu.getItems().addAll(
                undoItem,
                redoItem,
                separator,
                cutItem,
                copyItem,
                pasteItem
        );

        return editMenu;
    }

    /**
     * Creates the View menu
     */
    private Menu createViewMenu() {
        Menu viewMenu = new Menu("View");

        // Placeholder items for future implementation
        MenuItem zoomInItem = new MenuItem("Zoom In");
        zoomInItem.setAccelerator(new KeyCodeCombination(
                KeyCode.PLUS,
                KeyCombination.CONTROL_DOWN
        ));
        zoomInItem.setDisable(true); // Not implemented yet

        MenuItem zoomOutItem = new MenuItem("Zoom Out");
        zoomOutItem.setAccelerator(new KeyCodeCombination(
                KeyCode.MINUS,
                KeyCombination.CONTROL_DOWN
        ));
        zoomOutItem.setDisable(true); // Not implemented yet

        MenuItem resetZoomItem = new MenuItem("Reset Zoom");
        resetZoomItem.setAccelerator(new KeyCodeCombination(
                KeyCode.DIGIT0,
                KeyCombination.CONTROL_DOWN
        ));
        resetZoomItem.setDisable(true); // Not implemented yet

        viewMenu.getItems().addAll(
                zoomInItem,
                zoomOutItem,
                resetZoomItem
        );

        return viewMenu;
    }


    public void setEventBus(EventBus eventBus) {
        this.eventBus = eventBus;
        eventBus.subscribe(CoreApplicationEvents.HistoryStateChangedEvent.class, this::updateMenuState, true);
    }

    private void updateMenuState(CoreApplicationEvents.HistoryStateChangedEvent event) {
        if (undoItem != null) undoItem.setDisable(!event.canUndo());
        if (redoItem != null) redoItem.setDisable(!event.canRedo());
    }

    /**
     * Creates the Help menu
     */
    private Menu createHelpMenu() {
        Menu helpMenu = new Menu("Help");

        MenuItem aboutItem = new MenuItem("About BotMaker");
        aboutItem.setOnAction(e -> showAboutDialog());

        helpMenu.getItems().add(aboutItem);

        return helpMenu;
    }

    /**
     * Shows the about dialog
     */
    private void showAboutDialog() {
        javafx.scene.control.Alert alert = new javafx.scene.control.Alert(
                javafx.scene.control.Alert.AlertType.INFORMATION
        );
        alert.initOwner(primaryStage);
        alert.setTitle("About BotMaker");
        alert.setHeaderText("BotMaker Blocks");
        alert.setContentText(
                "Version: 1.0.0\n\n" +
                        "A visual block-based programming environment for Java.\n\n" +
                        "Build Java applications using drag-and-drop blocks!"
        );
        alert.showAndWait();
    }

    /**
     * Gets the menu bar
     */
    public MenuBar getMenuBar() {
        return menuBar;
    }

    /**
     * Sets the callback for when "Select Project" is clicked
     */
    public void setOnSelectProject(Consumer<Void> callback) {
        this.onSelectProject = callback;
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/ui/MoveBlockInfo.java
=================================================================================

package com.botmaker.ui;

import com.botmaker.core.BodyBlock;

/**
 * Information about moving an existing block to a new position.
 * @param blockId The ID of the block being moved
 * @param targetBody The BodyBlock where the block should be moved to
 * @param insertionIndex The index where the block should be inserted
 */
public record MoveBlockInfo(String blockId, BodyBlock targetBody, int insertionIndex) {
}

=================================================================================
FILE: ./src/main/java/com/botmaker/ui/ProjectSelectionScreen.java
=================================================================================

package com.botmaker.ui;

import com.botmaker.project.ProjectCreator;
import com.botmaker.project.ProjectInfo;
import com.botmaker.project.ProjectManager;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.Scene;
import javafx.scene.control.*;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.HBox;
import javafx.scene.layout.VBox;
import javafx.stage.Stage;

import java.time.format.DateTimeFormatter;
import java.util.List;
import java.util.Optional;
import java.util.function.BiConsumer;
import java.util.function.Consumer;

/**
 * Project selection screen shown on startup with project creation capability
 */
public class ProjectSelectionScreen {

    private final ProjectManager projectManager;
    private final ProjectCreator projectCreator;

    // Changed to BiConsumer to pass (ProjectName, ShouldClearCache)
    private final BiConsumer<String, Boolean> onProjectSelected;

    private final Stage stage;
    private ListView<ProjectInfo> projectListView;

    // New Checkbox
    private CheckBox clearCacheCheckbox;

    public ProjectSelectionScreen(Stage stage, BiConsumer<String, Boolean> onProjectSelected) {
        this.stage = stage;
        this.projectManager = new ProjectManager();
        this.projectCreator = new ProjectCreator();
        this.onProjectSelected = onProjectSelected;
    }

    public Scene createScene() {
        BorderPane root = new BorderPane();
        root.setPadding(new Insets(20));

        // Header
        Label titleLabel = new Label("Select a Project");
        titleLabel.setStyle("-fx-font-size: 24px; -fx-font-weight: bold;");
        VBox header = new VBox(10, titleLabel);
        header.setAlignment(Pos.CENTER);
        header.setPadding(new Insets(0, 0, 20, 0));

        // Project list
        projectListView = new ListView<>();
        projectListView.setPrefHeight(400);

        projectListView.setCellFactory(lv -> new ListCell<>() {
            @Override
            protected void updateItem(ProjectInfo project, boolean empty) {
                super.updateItem(project, empty);
                if (empty || project == null) {
                    setText(null);
                    setGraphic(null);
                } else {
                    VBox box = new VBox(5);
                    Label nameLabel = new Label(project.getName());
                    nameLabel.setStyle("-fx-font-size: 16px; -fx-font-weight: bold;");

                    Label pathLabel = new Label(project.getProjectPath().toString());
                    pathLabel.setStyle("-fx-font-size: 11px; -fx-text-fill: gray;");

                    Label dateLabel = new Label("Last modified: " +
                            project.getLastModified().format(DateTimeFormatter.ofPattern("MMM dd, yyyy HH:mm")));
                    dateLabel.setStyle("-fx-font-size: 11px; -fx-text-fill: gray;");

                    box.getChildren().addAll(nameLabel, pathLabel, dateLabel);
                    setGraphic(box);
                }
            }
        });

        refreshProjectList();

        if (!projectListView.getItems().isEmpty()) {
            projectListView.getSelectionModel().select(0);
        }

        // Controls Area
        Button openButton = new Button("Open Project");
        openButton.setPrefWidth(150);
        openButton.setDefaultButton(true);
        openButton.setOnAction(e -> openSelectedProject());

        Button createButton = new Button("Create New Project");
        createButton.setPrefWidth(150);
        createButton.setOnAction(e -> showCreateProjectDialog());

        // CLEAR CACHE CHECKBOX
        clearCacheCheckbox = new CheckBox("Clear Language Server Cache (Fix startup freeze)");
        clearCacheCheckbox.setStyle("-fx-text-fill: #666; -fx-font-size: 11px;");
        clearCacheCheckbox.setTooltip(new Tooltip("Check this if the application hangs on loading."));

        projectListView.setOnMouseClicked(e -> {
            if (e.getClickCount() == 2) {
                openSelectedProject();
            }
        });

        HBox buttonBox = new HBox(10, openButton, createButton);
        buttonBox.setAlignment(Pos.CENTER);

        VBox footer = new VBox(15, clearCacheCheckbox, buttonBox);
        footer.setAlignment(Pos.CENTER);
        footer.setPadding(new Insets(20, 0, 0, 0));

        VBox center = new VBox(10, projectListView, footer);
        root.setTop(header);
        root.setCenter(center);

        Scene scene = new Scene(root, 600, 550); // Increased height slightly
        scene.getStylesheets().add(getClass().getResource("/com/botmaker/styles.css").toExternalForm());

        return scene;
    }

    private void openSelectedProject() {
        ProjectInfo selected = projectListView.getSelectionModel().getSelectedItem();
        if (selected != null) {
            onProjectSelected.accept(selected.getName(), clearCacheCheckbox.isSelected());
        }
    }

    // ... rest of file (refreshProjectList, showCreateProjectDialog, etc) remains the same ...

    private void refreshProjectList() {
        List<ProjectInfo> projects = projectManager.listProjects();
        projectListView.getItems().clear();
        projectListView.getItems().addAll(projects);
    }

    private void showCreateProjectDialog() {
        Dialog<String> dialog = new Dialog<>();
        dialog.setTitle("Create New Project");
        dialog.setHeaderText("Enter project name");

        ButtonType createButtonType = new ButtonType("Create", ButtonBar.ButtonData.OK_DONE);
        dialog.getDialogPane().getButtonTypes().addAll(createButtonType, ButtonType.CANCEL);

        VBox content = new VBox(10);
        content.setPadding(new Insets(20));

        TextField projectNameField = new TextField();
        projectNameField.setPromptText("ProjectName");

        Label instructionLabel = new Label("Project name must:");
        instructionLabel.setStyle("-fx-font-size: 11px; -fx-text-fill: gray;");

        Label rule1 = new Label("• Start with an uppercase letter");
        rule1.setStyle("-fx-font-size: 10px; -fx-text-fill: gray;");

        Label rule2 = new Label("• Contain only letters and numbers");
        rule2.setStyle("-fx-font-size: 10px; -fx-text-fill: gray;");

        Label rule3 = new Label("• Be between 2-50 characters");
        rule3.setStyle("-fx-font-size: 10px; -fx-text-fill: gray;");

        Label exampleLabel = new Label("Example: MyFirstProject");
        exampleLabel.setStyle("-fx-font-size: 10px; -fx-font-style: italic; -fx-text-fill: gray;");

        content.getChildren().addAll(
                new Label("Project Name:"),
                projectNameField,
                instructionLabel,
                rule1,
                rule2,
                rule3,
                exampleLabel
        );

        dialog.getDialogPane().setContent(content);

        Button createButton = (Button) dialog.getDialogPane().lookupButton(createButtonType);
        createButton.setDisable(true);

        projectNameField.textProperty().addListener((observable, oldValue, newValue) -> {
            boolean isValid = isValidProjectName(newValue);
            createButton.setDisable(!isValid);
            if (newValue.isEmpty()) projectNameField.setStyle("");
            else if (isValid) projectNameField.setStyle("-fx-border-color: green; -fx-border-width: 2px;");
            else projectNameField.setStyle("-fx-border-color: red; -fx-border-width: 2px;");
        });

        javafx.application.Platform.runLater(projectNameField::requestFocus);

        dialog.setResultConverter(dialogButton -> {
            if (dialogButton == createButtonType) return projectNameField.getText();
            return null;
        });

        Optional<String> result = dialog.showAndWait();
        result.ifPresent(this::createProject);
    }

    private boolean isValidProjectName(String name) {
        if (name == null || name.trim().isEmpty()) return false;
        if (!name.matches("^[A-Z][a-zA-Z0-9]*$")) return false;
        if (name.length() < 2 || name.length() > 50) return false;
        if (projectCreator.projectExists(name)) return false;
        return true;
    }

    private void createProject(String projectName) {
        try {
            projectCreator.createProject(projectName);
            refreshProjectList();
            for (ProjectInfo project : projectListView.getItems()) {
                if (project.getName().equals(projectName)) {
                    projectListView.getSelectionModel().select(project);
                    break;
                }
            }
        } catch (Exception e) {
            Alert errorAlert = new Alert(Alert.AlertType.ERROR);
            errorAlert.setTitle("Error");
            errorAlert.setHeaderText("Failed to create project");
            errorAlert.setContentText(e.getMessage());
            errorAlert.showAndWait();
        }
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/ui/UIManager.java
=================================================================================

package com.botmaker.ui;

import com.botmaker.core.CodeBlock;
import com.botmaker.events.CoreApplicationEvents;
import com.botmaker.events.EventBus;
import com.botmaker.lsp.CompletionContext;
import com.botmaker.services.CodeEditorService;
import com.botmaker.ui.AddableBlock.BlockCategory;
import com.botmaker.validation.DiagnosticsManager;
import com.botmaker.validation.ErrorTranslator;
import javafx.application.Platform;
import javafx.geometry.Insets;
import javafx.geometry.Orientation;
import javafx.scene.Node;
import javafx.scene.Scene;
import javafx.scene.control.*;
import javafx.scene.layout.*;
import javafx.stage.Stage;
import org.eclipse.lsp4j.Diagnostic;
import org.eclipse.lsp4j.DiagnosticSeverity;

import java.util.*;
import java.util.function.Consumer;
import java.util.stream.Collectors;

public class UIManager {

    private final BlockDragAndDropManager dragAndDropManager;
    private final EventBus eventBus;
    private final CodeEditorService codeEditorService;
    private final DiagnosticsManager diagnosticsManager;
    private final Stage primaryStage;

    private VBox blocksContainer;
    private Label statusLabel;
    private TextArea outputArea;
    private ListView<Diagnostic> errorListView;
    private TabPane bottomTabPane;
    private Tab terminalTab;
    private ScrollPane scrollPane;
    private MenuBarManager menuBarManager;
    private Consumer<Void> onSelectProject;

    // Controls
    private Button debugButton;
    private Button runButton;
    private Button unifiedStopButton; // UNIFIED BUTTON
    private Button stepOverButton;
    private Button continueButton;
    private Button undoButton;
    private Button redoButton;

    // Application State Tracking
    private enum AppState { IDLE, RUNNING, DEBUGGING }
    private AppState currentAppState = AppState.IDLE;

    public UIManager(BlockDragAndDropManager dragAndDropManager,
                     EventBus eventBus,
                     CodeEditorService codeEditorService,
                     DiagnosticsManager diagnosticsManager,
                     Stage primaryStage) {
        this.dragAndDropManager = dragAndDropManager;
        this.eventBus = eventBus;
        this.codeEditorService = codeEditorService;
        this.diagnosticsManager = diagnosticsManager;
        this.primaryStage = primaryStage;

        setupEventHandlers();
    }

    private void setupEventHandlers() {
        eventBus.subscribe(CoreApplicationEvents.UIBlocksUpdatedEvent.class, this::handleBlocksUpdate, true);
        eventBus.subscribe(CoreApplicationEvents.OutputAppendedEvent.class, event -> {
            // Protect the UI Component from holding too much text
            if (outputArea.getText().length() > 10_000) {
                // If too long, cut the top half
                String current = outputArea.getText();
                outputArea.setText("[...Old Output Trimmed...]\n" + current.substring(current.length() - 5000) + event.getText());
                outputArea.positionCaret(outputArea.getLength());
            } else {
                outputArea.appendText(event.getText());
            }
        }, true);

        eventBus.subscribe(CoreApplicationEvents.OutputClearedEvent.class, event -> outputArea.clear(), true);
        eventBus.subscribe(CoreApplicationEvents.OutputSetEvent.class, event -> outputArea.setText(event.getText()), true);
        eventBus.subscribe(CoreApplicationEvents.StatusMessageEvent.class, event -> statusLabel.setText(event.getMessage()), true);

        eventBus.subscribe(CoreApplicationEvents.DiagnosticsUpdatedEvent.class, event -> {
            diagnosticsManager.processDiagnostics(event.getDiagnostics());
            updateErrors(diagnosticsManager.getDiagnostics());
            statusLabel.setText(diagnosticsManager.getErrorSummary());
        }, true);


        // State Management Handlers
        eventBus.subscribe(CoreApplicationEvents.ProgramStartedEvent.class, e -> setAppState(AppState.RUNNING), true);
        eventBus.subscribe(CoreApplicationEvents.ProgramStoppedEvent.class, e -> setAppState(AppState.IDLE), true);
        eventBus.subscribe(CoreApplicationEvents.DebugSessionStartedEvent.class, e -> setAppState(AppState.DEBUGGING), true);
        eventBus.subscribe(CoreApplicationEvents.DebugSessionFinishedEvent.class, e -> setAppState(AppState.IDLE), true);

        // Debugging specific controls
        eventBus.subscribe(CoreApplicationEvents.DebugSessionPausedEvent.class, e -> updateDebugControls(true), true);
        eventBus.subscribe(CoreApplicationEvents.DebugSessionResumedEvent.class, e -> updateDebugControls(false), true);

        eventBus.subscribe(CoreApplicationEvents.HistoryStateChangedEvent.class, event -> {
            Platform.runLater(() -> {
                if (undoButton != null) undoButton.setDisable(!event.canUndo());
                if (redoButton != null) redoButton.setDisable(!event.canRedo());
            });
        }, true);
    }

    private void setAppState(AppState state) {
        this.currentAppState = state;
        updateToolbarState();
    }

    private void updateToolbarState() {
        boolean isBusy = (currentAppState != AppState.IDLE);

        runButton.setDisable(isBusy);
        debugButton.setDisable(isBusy);
        unifiedStopButton.setDisable(!isBusy); // Enable only when busy

        if (currentAppState == AppState.DEBUGGING) {
            unifiedStopButton.setText("Stop Debugging ⏹");
            unifiedStopButton.setStyle("-fx-background-color: #E74C3C; -fx-text-fill: white;");
            bottomTabPane.getSelectionModel().select(terminalTab);
        } else if (currentAppState == AppState.RUNNING) {
            unifiedStopButton.setText("Stop Run ⏹");
            unifiedStopButton.setStyle("-fx-background-color: #E74C3C; -fx-text-fill: white;");
            bottomTabPane.getSelectionModel().select(terminalTab);

            // Disable debug specific buttons during run
            stepOverButton.setDisable(true);
            continueButton.setDisable(true);
        } else {
            // Idle
            unifiedStopButton.setText("Stop ⏹");
            unifiedStopButton.setStyle(""); // Reset style
            stepOverButton.setDisable(true);
            continueButton.setDisable(true);
        }
    }

    private void updateDebugControls(boolean isPaused) {
        // Only relevant if we are actually debugging
        if (currentAppState == AppState.DEBUGGING) {
            stepOverButton.setDisable(!isPaused);
            continueButton.setDisable(!isPaused);
        }
    }

    private void handleBlocksUpdate(CoreApplicationEvents.UIBlocksUpdatedEvent event) {
        blocksContainer.getChildren().clear();
        if (event.getRootBlock() != null) {
            CompletionContext context = codeEditorService.createCompletionContext();
            Node rootNode = event.getRootBlock().getUINode(context);

            rootNode.addEventHandler(BlockEvent.BreakpointToggleEvent.TOGGLE_BREAKPOINT, e -> {
                eventBus.publish(new CoreApplicationEvents.BreakpointToggledEvent(e.getBlock(), e.isEnabled()));
            });

            blocksContainer.getChildren().add(rootNode);
        }
    }

    public Scene createScene() {
        menuBarManager = new MenuBarManager(primaryStage);
        menuBarManager.setEventBus(eventBus);
        menuBarManager.setOnSelectProject(v -> { if (onSelectProject != null) onSelectProject.accept(null); });

        blocksContainer = new VBox(10);
        blocksContainer.getStyleClass().add("blocks-canvas");

        scrollPane = new ScrollPane(blocksContainer);
        scrollPane.setFitToWidth(true);
        scrollPane.getStyleClass().add("code-scroll-pane");

        Accordion paletteAccordion = createCategorizedPalette();
        VBox paletteContainer = new VBox(paletteAccordion);
        paletteContainer.setPrefWidth(220);
        paletteContainer.getStyleClass().add("palette-sidebar");

        statusLabel = new Label("Ready");
        statusLabel.setId("status-label");

        outputArea = new TextArea();
        outputArea.setEditable(false);
        outputArea.getStyleClass().add("console-area");

        errorListView = new ListView<>();
        configureErrorList(errorListView);

        bottomTabPane = new TabPane();
        terminalTab = new Tab("Terminal", outputArea);
        terminalTab.setClosable(false);
        Tab errorsTab = new Tab("Errors", errorListView);
        errorsTab.setClosable(false);
        bottomTabPane.getTabs().addAll(terminalTab, errorsTab);

        HBox toolBar = createToolBar();

        SplitPane verticalSplit = new SplitPane();
        verticalSplit.setOrientation(Orientation.VERTICAL);
        verticalSplit.getItems().addAll(scrollPane, bottomTabPane);
        verticalSplit.setDividerPositions(0.75);
        VBox.setVgrow(verticalSplit, Priority.ALWAYS);

        BorderPane mainLayout = new BorderPane();
        mainLayout.setTop(toolBar);
        mainLayout.setLeft(paletteContainer);
        mainLayout.setCenter(verticalSplit);
        mainLayout.setBottom(statusLabel);

        VBox root = new VBox(menuBarManager.getMenuBar(), mainLayout);
        VBox.setVgrow(mainLayout, Priority.ALWAYS);
        root.getStyleClass().add("light-theme");

        Scene scene = new Scene(root, 1000, 700);
        scene.getStylesheets().add(getClass().getResource("/com/botmaker/styles.css").toExternalForm());

        return scene;
    }

    private HBox createToolBar() {
        undoButton = new Button("Undo");
        undoButton.setDisable(true);
        undoButton.setOnAction(e -> eventBus.publish(new CoreApplicationEvents.UndoRequestedEvent()));

        redoButton = new Button("Redo");
        redoButton.setDisable(true);
        redoButton.setOnAction(e -> eventBus.publish(new CoreApplicationEvents.RedoRequestedEvent()));

        Region spacer1 = new Region();
        HBox.setHgrow(spacer1, Priority.ALWAYS);

        Button compileButton = new Button("Compile");
        compileButton.getStyleClass().add("toolbar-btn");
        compileButton.setOnAction(e -> eventBus.publish(new CoreApplicationEvents.CompilationRequestedEvent()));

        runButton = new Button("Run ▶");
        runButton.getStyleClass().addAll("toolbar-btn", "btn-run");
        runButton.setOnAction(e -> eventBus.publish(new CoreApplicationEvents.ExecutionRequestedEvent()));

        debugButton = new Button("Debug 🐞");
        debugButton.getStyleClass().addAll("toolbar-btn", "btn-debug");
        debugButton.setOnAction(e -> eventBus.publish(new CoreApplicationEvents.DebugStartRequestedEvent()));

        // UNIFIED STOP BUTTON
        unifiedStopButton = new Button("Stop ⏹");
        unifiedStopButton.getStyleClass().addAll("toolbar-btn", "btn-stop");
        unifiedStopButton.setDisable(true);
        unifiedStopButton.setOnAction(e -> {
            if (currentAppState == AppState.RUNNING) {
                eventBus.publish(new CoreApplicationEvents.StopRunRequestedEvent());
            } else if (currentAppState == AppState.DEBUGGING) {
                eventBus.publish(new CoreApplicationEvents.DebugStopRequestedEvent());
            }
        });

        Region spacer2 = new Region();
        HBox.setHgrow(spacer2, Priority.ALWAYS);

        stepOverButton = new Button("Step ⤵");
        stepOverButton.setDisable(true);
        stepOverButton.setOnAction(e -> eventBus.publish(new CoreApplicationEvents.DebugStepOverRequestedEvent()));

        continueButton = new Button("Continue ⏩");
        continueButton.setDisable(true);
        continueButton.setOnAction(e -> eventBus.publish(new CoreApplicationEvents.DebugContinueRequestedEvent()));

        HBox toolbar = new HBox(10,
                undoButton, redoButton,
                spacer1,
                compileButton, runButton, debugButton, unifiedStopButton,
                spacer2,
                stepOverButton, continueButton
        );
        toolbar.setPadding(new Insets(10));
        toolbar.getStyleClass().add("main-toolbar");
        return toolbar;
    }

    // ... (Helper methods createCategorizedPalette, configureErrorList, updateErrors match previous implementation)

    private Accordion createCategorizedPalette() {
        Accordion accordion = new Accordion();
        Map<BlockCategory, List<AddableBlock>> grouped = Arrays.stream(AddableBlock.values())
                .collect(Collectors.groupingBy(AddableBlock::getCategory));

        BlockCategory[] order = {
                BlockCategory.OUTPUT, BlockCategory.INPUT, BlockCategory.VARIABLES,
                BlockCategory.FLOW, BlockCategory.LOOPS, BlockCategory.CONTROL, BlockCategory.UTILITY
        };

        for (BlockCategory category : order) {
            List<AddableBlock> blocks = grouped.get(category);
            if (blocks == null) continue;

            VBox content = new VBox(8);
            content.setPadding(new Insets(10));

            for (AddableBlock blockType : blocks) {
                Label blockLabel = new Label(blockType.getDisplayName());
                blockLabel.setMaxWidth(Double.MAX_VALUE);
                blockLabel.getStyleClass().addAll("palette-item", "palette-" + category.name().toLowerCase());
                dragAndDropManager.makeDraggable(blockLabel, blockType);
                content.getChildren().add(blockLabel);
            }

            TitledPane pane = new TitledPane(category.getLabel(), content);
            pane.getStyleClass().add("palette-pane");
            accordion.getPanes().add(pane);
        }
        if (!accordion.getPanes().isEmpty()) accordion.setExpandedPane(accordion.getPanes().get(0));
        return accordion;
    }

    private void configureErrorList(ListView<Diagnostic> lv) {
        lv.setPlaceholder(new Label("No errors to display."));
        lv.setCellFactory(list -> new ListCell<>() {
            @Override
            protected void updateItem(Diagnostic diagnostic, boolean empty) {
                super.updateItem(diagnostic, empty);
                getStyleClass().removeAll("error-cell", "warning-cell");
                if (empty || diagnostic == null) {
                    setText(null);
                    setOnMouseClicked(null);
                } else {
                    String message = ErrorTranslator.getShortSummary(diagnostic);
                    int line = diagnostic.getRange().getStart().getLine() + 1;
                    setText(String.format("Line %d: %s", line, message));
                    if (diagnostic.getSeverity() == DiagnosticSeverity.Error) getStyleClass().add("error-cell");
                    else if (diagnostic.getSeverity() == DiagnosticSeverity.Warning) getStyleClass().add("warning-cell");

                    setOnMouseClicked(event -> {
                        if (event.getClickCount() >= 1) {
                            diagnosticsManager.findBlockForDiagnostic(diagnostic).ifPresent(block -> {
                                Node uiNode = block.getUINode();
                                if (uiNode != null) uiNode.requestFocus();
                            });
                        }
                    });
                }
            }
        });
    }

    private void updateErrors(List<Diagnostic> diagnostics) {
        if (diagnostics == null) errorListView.getItems().clear();
        else errorListView.getItems().setAll(diagnostics);
        if (diagnostics != null && !diagnostics.isEmpty()) bottomTabPane.getSelectionModel().select(1);
    }

    public void setOnSelectProject(Consumer<Void> callback) { this.onSelectProject = callback; }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/util/BlockLookupHelper.java
=================================================================================

package com.botmaker.util;

import com.botmaker.core.BodyBlock;
import com.botmaker.core.BlockWithChildren;
import com.botmaker.core.CodeBlock;
import com.botmaker.core.StatementBlock;

import java.util.Map;

/**
 * Helper class for looking up blocks in the block tree.
 */
public class BlockLookupHelper {

    /**
     * Finds a block by its ID in the node-to-block map.
     * @param blockId The ID of the block to find
     * @param nodeToBlockMap The map of AST nodes to CodeBlocks
     * @return The StatementBlock if found, null otherwise
     */
    public static StatementBlock findBlockById(String blockId, Map<?, CodeBlock> nodeToBlockMap) {
        if (blockId == null || nodeToBlockMap == null) {
            return null;
        }

        // Search through all blocks in the map
        for (CodeBlock block : nodeToBlockMap.values()) {
            if (block.getId().equals(blockId) && block instanceof StatementBlock) {
                return (StatementBlock) block;
            }
        }

        return null;
    }

    /**
     * Finds the BodyBlock that contains the given statement block.
     * @param targetBlock The statement block to find the parent for
     * @param nodeToBlockMap The map of AST nodes to CodeBlocks
     * @return The BodyBlock containing the statement, null if not found
     */
    public static BodyBlock findParentBody(StatementBlock targetBlock, Map<?, CodeBlock> nodeToBlockMap) {
        if (targetBlock == null || nodeToBlockMap == null) {
            return null;
        }

        // Search through all blocks to find which BodyBlock contains the target
        for (CodeBlock block : nodeToBlockMap.values()) {
            if (block instanceof BodyBlock) {
                BodyBlock bodyBlock = (BodyBlock) block;
                if (bodyBlock.getStatements().contains(targetBlock)) {
                    return bodyBlock;
                }
            }

            // Also check nested structures
            if (block instanceof BlockWithChildren) {
                BodyBlock found = findParentBodyInChildren(targetBlock, (BlockWithChildren) block);
                if (found != null) {
                    return found;
                }
            }
        }

        return null;
    }

    /**
     * Recursively searches for the parent body in a block's children.
     */
    private static BodyBlock findParentBodyInChildren(StatementBlock targetBlock, BlockWithChildren parent) {
        for (CodeBlock child : parent.getChildren()) {
            if (child instanceof BodyBlock) {
                BodyBlock bodyBlock = (BodyBlock) child;
                if (bodyBlock.getStatements().contains(targetBlock)) {
                    return bodyBlock;
                }
            }

            if (child instanceof BlockWithChildren) {
                BodyBlock found = findParentBodyInChildren(targetBlock, (BlockWithChildren) child);
                if (found != null) {
                    return found;
                }
            }
        }

        return null;
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/util/DefaultNames.java
=================================================================================

package com.botmaker.util;

/**
 * Provides sensible default names for auto-generated elements
 */
public class DefaultNames {

    // Variable names by type
    public static final String DEFAULT_INT = "number";
    public static final String DEFAULT_DOUBLE = "decimal";
    public static final String DEFAULT_BOOLEAN = "flag";
    public static final String DEFAULT_STRING = "text";
    public static final String DEFAULT_VARIABLE = "variable";

    // Method to get default name by type
    public static String forType(String typeName) {
        if (typeName == null) return DEFAULT_VARIABLE;

        switch (typeName.toLowerCase()) {
            case "int":
            case "long":
            case "short":
            case "byte":
                return DEFAULT_INT;
            case "double":
            case "float":
                return DEFAULT_DOUBLE;
            case "boolean":
                return DEFAULT_BOOLEAN;
            case "string":
                return DEFAULT_STRING;
            default:
                return DEFAULT_VARIABLE;
        }
    }

    private DefaultNames() {} // Prevent instantiation
}

=================================================================================
FILE: ./src/main/java/com/botmaker/util/TypeManager.java
=================================================================================

package com.botmaker.util;

import org.eclipse.jdt.core.dom.AST;
import org.eclipse.jdt.core.dom.PrimitiveType;
import org.eclipse.jdt.core.dom.Type;

import java.util.List;

public class TypeManager {

    private static final List<String> FUNDAMENTAL_TYPES = List.of(
            "int", "double", "boolean", "String", "long", "float", "char"
    );

    public static List<String> getFundamentalTypeNames() {
        return FUNDAMENTAL_TYPES;
    }

    /**
     * Creates a JDT AST Type node from a string representation.
     * Handles arrays (e.g., "int[]", "String[][]").
     */
    public static Type createTypeNode(AST ast, String typeName) {
        // count array dimensions
        int dimensions = 0;
        String baseName = typeName;

        while (baseName.endsWith("[]")) {
            dimensions++;
            baseName = baseName.substring(0, baseName.length() - 2);
        }

        Type baseType;
        switch (baseName) {
            case "int": baseType = ast.newPrimitiveType(PrimitiveType.INT); break;
            case "double": baseType = ast.newPrimitiveType(PrimitiveType.DOUBLE); break;
            case "boolean": baseType = ast.newPrimitiveType(PrimitiveType.BOOLEAN); break;
            case "char": baseType = ast.newPrimitiveType(PrimitiveType.CHAR); break;
            case "long": baseType = ast.newPrimitiveType(PrimitiveType.LONG); break;
            case "float": baseType = ast.newPrimitiveType(PrimitiveType.FLOAT); break;
            case "short": baseType = ast.newPrimitiveType(PrimitiveType.SHORT); break;
            case "byte": baseType = ast.newPrimitiveType(PrimitiveType.BYTE); break;
            default: baseType = ast.newSimpleType(ast.newName(baseName)); break;
        }

        if (dimensions > 0) {
            return ast.newArrayType(baseType, dimensions);
        } else {
            return baseType;
        }
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/validation/DiagnosticsManager.java
=================================================================================

package com.botmaker.validation;

import com.botmaker.core.CodeBlock;
import javafx.application.Platform;
import org.eclipse.jdt.core.dom.ASTNode;
import org.eclipse.lsp4j.Diagnostic;
import org.eclipse.lsp4j.DiagnosticSeverity;
import org.eclipse.lsp4j.PublishDiagnosticsParams;

import java.util.*;

public class DiagnosticsManager {

    private Map<ASTNode, CodeBlock> nodeToBlockMap;
    private String sourceCode;
    private final Set<CodeBlock> blocksWithErrors = new HashSet<>();
    private List<Diagnostic> lastDiagnostics = new ArrayList<>();

    // NEW: Track line numbers to blocks for fallback matching
    private Map<Integer, Set<CodeBlock>> lineToBlocksMap = new HashMap<>();

    public List<Diagnostic> getDiagnostics() {
        return lastDiagnostics;
    }

    public boolean hasErrors() {
        if (lastDiagnostics == null || lastDiagnostics.isEmpty()) {
            return false;
        }
        return lastDiagnostics.stream().anyMatch(d -> {
            DiagnosticSeverity severity = d.getSeverity();
            return severity == null || severity == DiagnosticSeverity.Error;
        });
    }

    public void updateSource(Map<ASTNode, CodeBlock> nodeToBlockMap, String sourceCode) {
        this.nodeToBlockMap = nodeToBlockMap;
        this.sourceCode = sourceCode;

        // Build line-to-block mapping for fallback
        buildLineToBlockMap();
    }

    /**
     * Builds a map from line numbers to blocks for fallback matching
     * when AST node matching fails.
     */
    private void buildLineToBlockMap() {
        lineToBlocksMap.clear();

        if (nodeToBlockMap == null || sourceCode == null) {
            return;
        }

        for (Map.Entry<ASTNode, CodeBlock> entry : nodeToBlockMap.entrySet()) {
            ASTNode node = entry.getKey();
            CodeBlock block = entry.getValue();

            // Calculate which lines this node spans
            int startLine = getLineNumber(node.getStartPosition());
            int endLine = getLineNumber(node.getStartPosition() + node.getLength());

            // Add block to all lines it spans
            for (int line = startLine; line <= endLine; line++) {
                lineToBlocksMap.computeIfAbsent(line, k -> new HashSet<>()).add(block);
            }
        }
    }

    public void processDiagnostics(List<Diagnostic> diagnostics) {
        this.lastDiagnostics = diagnostics;

        // Clear previous errors
        for (CodeBlock block : blocksWithErrors) {
            block.clearError();
        }
        blocksWithErrors.clear();

        if (nodeToBlockMap == null) return;

        // Process new diagnostics
        for (Diagnostic diagnostic : diagnostics) {
            // Only show errors, not warnings (unless you want warnings too)
            if (diagnostic.getSeverity() != DiagnosticSeverity.Error) {
                continue;
            }

            Optional<CodeBlock> blockOpt = findBlockForDiagnostic(diagnostic);

            if (blockOpt.isPresent()) {
                CodeBlock block = blockOpt.get();

                // Use translated error message
                String userFriendlyMessage = ErrorTranslator.getShortSummary(diagnostic);
                String suggestion = ErrorTranslator.getSuggestion(diagnostic);

                block.setError(userFriendlyMessage + "\n" + suggestion);
                blocksWithErrors.add(block);
            } else {
                // Log unmapped diagnostics for debugging
                System.err.println("Warning: Could not map diagnostic to block: " +
                        diagnostic.getMessage() + " at line " +
                        (diagnostic.getRange().getStart().getLine() + 1));
            }
        }
    }

    /**
     * Finds the code block responsible for a diagnostic.
     * Uses multiple strategies for better matching.
     */
    public Optional<CodeBlock> findBlockForDiagnostic(Diagnostic diagnostic) {
        // Strategy 1: Precise AST node matching (best)
        Optional<CodeBlock> block = findBlockByASTNode(diagnostic);
        if (block.isPresent()) {
            return block;
        }

        // Strategy 2: Line-based fallback (good for edge cases)
        block = findBlockByLine(diagnostic);
        if (block.isPresent()) {
            return block;
        }

        // Strategy 3: Parent node search (for nested expressions)
        return findBlockByParentNode(diagnostic);
    }

    /**
     * Strategy 1: Find block by matching AST node ranges
     */
    private Optional<CodeBlock> findBlockByASTNode(Diagnostic diagnostic) {
        int startOffset = getOffsetFromPosition(diagnostic.getRange().getStart());
        int endOffset = getOffsetFromPosition(diagnostic.getRange().getEnd());

        // Find the most specific (smallest) block that contains the diagnostic range
        ASTNode bestNode = null;
        int bestLength = Integer.MAX_VALUE;

        for (ASTNode node : nodeToBlockMap.keySet()) {
            int nodeStart = node.getStartPosition();
            int nodeEnd = nodeStart + node.getLength();

            // Check if node contains the diagnostic range
            if (nodeStart <= startOffset && nodeEnd >= endOffset) {
                int nodeLength = node.getLength();

                // Prefer the smallest containing node
                if (nodeLength < bestLength) {
                    bestNode = node;
                    bestLength = nodeLength;
                }
            }
        }

        return Optional.ofNullable(bestNode).map(nodeToBlockMap::get);
    }

    /**
     * Strategy 2: Find block by line number (fallback)
     */
    private Optional<CodeBlock> findBlockByLine(Diagnostic diagnostic) {
        int line = diagnostic.getRange().getStart().getLine();

        Set<CodeBlock> blocksOnLine = lineToBlocksMap.get(line);
        if (blocksOnLine == null || blocksOnLine.isEmpty()) {
            return Optional.empty();
        }

        // If multiple blocks on same line, prefer the first one
        // (Could be improved with more sophisticated heuristics)
        return blocksOnLine.stream().findFirst();
    }

    /**
     * Strategy 3: Find block by searching parent nodes
     */
    private Optional<CodeBlock> findBlockByParentNode(Diagnostic diagnostic) {
        int startOffset = getOffsetFromPosition(diagnostic.getRange().getStart());

        // Find any node that contains the start position
        for (ASTNode node : nodeToBlockMap.keySet()) {
            int nodeStart = node.getStartPosition();
            int nodeEnd = nodeStart + node.getLength();

            if (nodeStart <= startOffset && nodeEnd >= startOffset) {
                return Optional.of(nodeToBlockMap.get(node));
            }
        }

        return Optional.empty();
    }

    /**
     * Converts LSP position to source code offset
     */
    private int getOffsetFromPosition(org.eclipse.lsp4j.Position pos) {
        int line = pos.getLine();
        int character = pos.getCharacter();
        int offset = 0;
        int currentLine = 0;

        if (sourceCode == null) return 0;

        while (currentLine < line && offset < sourceCode.length()) {
            if (sourceCode.charAt(offset) == '\n') {
                currentLine++;
            }
            offset++;
        }

        return offset + character;
    }

    /**
     * Gets line number from character offset
     */
    private int getLineNumber(int offset) {
        if (sourceCode == null || offset < 0) return 0;

        int line = 0;
        for (int i = 0; i < Math.min(offset, sourceCode.length()); i++) {
            if (sourceCode.charAt(i) == '\n') {
                line++;
            }
        }
        return line;
    }

    /**
     * Get all blocks that have errors (useful for UI highlighting)
     */
    public Set<CodeBlock> getBlocksWithErrors() {
        return Collections.unmodifiableSet(blocksWithErrors);
    }

    /**
     * Check if a specific block has errors
     */
    public boolean hasError(CodeBlock block) {
        return blocksWithErrors.contains(block);
    }

    /**
     * Get diagnostics for a specific block
     */
    public List<Diagnostic> getDiagnosticsForBlock(CodeBlock block) {
        if (lastDiagnostics == null || nodeToBlockMap == null) {
            return Collections.emptyList();
        }

        List<Diagnostic> blockDiagnostics = new ArrayList<>();

        for (Diagnostic diagnostic : lastDiagnostics) {
            Optional<CodeBlock> diagBlock = findBlockForDiagnostic(diagnostic);
            if (diagBlock.isPresent() && diagBlock.get() == block) {
                blockDiagnostics.add(diagnostic);
            }
        }

        return blockDiagnostics;
    }

    /**
     * Get a summary of all errors (useful for status bar)
     */
    public String getErrorSummary() {
        if (!hasErrors()) {
            return "✅ No errors";
        }

        long errorCount = lastDiagnostics.stream()
                .filter(d -> d.getSeverity() == DiagnosticSeverity.Error)
                .count();

        long warningCount = lastDiagnostics.stream()
                .filter(d -> d.getSeverity() == DiagnosticSeverity.Warning)
                .count();

        StringBuilder summary = new StringBuilder();
        if (errorCount > 0) {
            summary.append(String.format("❌ %d error%s", errorCount, errorCount == 1 ? "" : "s"));
        }
        if (warningCount > 0) {
            if (summary.length() > 0) summary.append(", ");
            summary.append(String.format("⚠️ %d warning%s", warningCount, warningCount == 1 ? "" : "s"));
        }

        return summary.toString();
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/validation/ErrorTranslator.java
=================================================================================

package com.botmaker.validation;

import org.eclipse.lsp4j.Diagnostic;
import org.eclipse.lsp4j.DiagnosticSeverity;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class ErrorTranslator {

    private static final Map<Integer, ErrorInfo> ERROR_MAPPINGS = new HashMap<>();
    private static final Pattern ERROR_CODE_PATTERN = Pattern.compile("\\b(\\d{7,})\\b");

    static class ErrorInfo {
        String userMessage;
        String suggestion;
        DiagnosticSeverity severity;

        ErrorInfo(String userMessage, String suggestion, DiagnosticSeverity severity) {
            this.userMessage = userMessage;
            this.suggestion = suggestion;
            this.severity = severity;
        }

        ErrorInfo(String userMessage, String suggestion) {
            this(userMessage, suggestion, DiagnosticSeverity.Error);
        }
    }

    static {
        // PRIORITY 1: Critical Errors (Must Handle)

        // 16777233 - TypeMismatch
        ERROR_MAPPINGS.put(16777233, new ErrorInfo(
                "Wrong type used: You're trying to use a {0} where a {1} is expected",
                "Check that you're using the right type of value (number, text, true/false, etc.)"
        ));

        // 570425394 - UndefinedName (Variable doesn't exist)
        ERROR_MAPPINGS.put(570425394, new ErrorInfo(
                "Variable or name '{0}' doesn't exist",
                "Did you forget to create this variable? Check for typos in the name."
        ));

        // 536870963 - UninitializedLocalVariable
        ERROR_MAPPINGS.put(536870963, new ErrorInfo(
                "Variable '{0}' is used before being given a value",
                "Set a value to this variable before using it."
        ));

        // 536870967 - RedefinedLocal (Duplicate variable)
        ERROR_MAPPINGS.put(536870967, new ErrorInfo(
                "A variable named '{0}' already exists",
                "Choose a different name or remove the duplicate variable."
        ));

        // 67108979 - ParameterMismatch
        ERROR_MAPPINGS.put(67108979, new ErrorInfo(
                "Wrong number of parameters: Expected {0} but got {1}",
                "Check how many inputs this function needs."
        ));

        // 603979884 - ShouldReturnValue
        ERROR_MAPPINGS.put(603979884, new ErrorInfo(
                "This function must return a value",
                "Add a return statement with a value at the end of the function."
        ));

        // PRIORITY 2: Type System Errors

        // 16777218 - UndefinedType
        ERROR_MAPPINGS.put(16777218, new ErrorInfo(
                "Type '{0}' cannot be found",
                "This type doesn't exist. Check for typos or missing imports."
        ));

        // 67108964 - UndefinedMethod
        ERROR_MAPPINGS.put(67108964, new ErrorInfo(
                "Method '{0}' doesn't exist",
                "Check the spelling of the method name or if it's available."
        ));

        // 33554502 - UndefinedField
        ERROR_MAPPINGS.put(33554502, new ErrorInfo(
                "Field '{0}' doesn't exist",
                "This field is not defined. Check the name and spelling."
        ));

        // PRIORITY 3: Syntax Errors (If user can edit code)

        // 1610612960 - MissingSemiColon
        ERROR_MAPPINGS.put(1610612960, new ErrorInfo(
                "Missing semicolon (;) at the end of the line",
                "Add a semicolon (;) at the end of this statement."
        ));

        // 1610612995 - UnterminatedString
        ERROR_MAPPINGS.put(1610612995, new ErrorInfo(
                "Text is missing a closing quote",
                "Add a closing quote (\") at the end of the text."
        ));

        // 1610612941 - ParsingErrorNoSuggestion
        ERROR_MAPPINGS.put(1610612941, new ErrorInfo(
                "Syntax error: The code structure is incorrect",
                "Check for missing brackets, parentheses, or other syntax issues."
        ));

        // 1610612956 - UnmatchedBracket
        ERROR_MAPPINGS.put(1610612956, new ErrorInfo(
                "Unmatched bracket - missing opening or closing bracket",
                "Check that all { } brackets are properly paired."
        ));

        // PRIORITY 4: Flow Control

        // 536870908 - InvalidBreak
        ERROR_MAPPINGS.put(536870908, new ErrorInfo(
                "'break' can only be used inside a loop or switch",
                "Move this break statement inside a loop block."
        ));

        // 536870909 - InvalidContinue
        ERROR_MAPPINGS.put(536870909, new ErrorInfo(
                "'continue' can only be used inside a loop",
                "Move this continue statement inside a loop block."
        ));

        // 536870161 - CodeCannotBeReached
        ERROR_MAPPINGS.put(536870161, new ErrorInfo(
                "This code will never run (unreachable code)",
                "Remove this code or fix the logic that prevents it from running.",
                DiagnosticSeverity.Warning
        ));

        // PRIORITY 5: Warnings

        // 536870973 - LocalVariableIsNeverUsed
        ERROR_MAPPINGS.put(536870973, new ErrorInfo(
                "Variable '{0}' is created but never used",
                "Remove this variable or use it somewhere in your code.",
                DiagnosticSeverity.Warning
        ));

        // 536870974 - ArgumentIsNeverUsed
        ERROR_MAPPINGS.put(536870974, new ErrorInfo(
                "Parameter '{0}' is never used",
                "Remove this parameter or use it in the function.",
                DiagnosticSeverity.Warning
        ));

        // 536871185 - AssignmentHasNoEffect
        ERROR_MAPPINGS.put(536871185, new ErrorInfo(
                "This assignment does nothing",
                "You're assigning a variable to itself. Remove this line or fix the logic.",
                DiagnosticSeverity.Warning
        ));
    }

    /**
     * Extracts the JDT error code from a diagnostic message
     */
    private static Integer extractErrorCode(String message) {
        Matcher matcher = ERROR_CODE_PATTERN.matcher(message);
        if (matcher.find()) {
            try {
                return Integer.parseInt(matcher.group(1));
            } catch (NumberFormatException e) {
                return null;
            }
        }
        return null;
    }

    /**
     * Translates diagnostics to user-friendly messages
     */
    public static String translate(List<Diagnostic> diagnostics) {
        if (diagnostics == null || diagnostics.isEmpty()) {
            return "✅ No errors found. Your code looks good!";
        }

        StringBuilder result = new StringBuilder();
        int errorCount = 0;
        int warningCount = 0;

        for (Diagnostic diagnostic : diagnostics) {
            if (diagnostic.getSeverity() == DiagnosticSeverity.Error) {
                errorCount++;
            } else if (diagnostic.getSeverity() == DiagnosticSeverity.Warning) {
                warningCount++;
            }
        }

        if (errorCount > 0) {
            result.append(String.format("❌ Found %d error%s:\n\n", errorCount, errorCount == 1 ? "" : "s"));
        }
        if (warningCount > 0) {
            result.append(String.format("⚠️  Found %d warning%s:\n\n", warningCount, warningCount == 1 ? "" : "s"));
        }

        for (Diagnostic diagnostic : diagnostics) {
            String icon = diagnostic.getSeverity() == DiagnosticSeverity.Error ? "❌" : "⚠️";
            int lineNumber = diagnostic.getRange().getStart().getLine() + 1;

            String translated = translateSingleDiagnostic(diagnostic);
            result.append(String.format("%s Line %d: %s\n\n", icon, lineNumber, translated));
        }

        return result.toString().trim();
    }

    /**
     * Translates a single diagnostic to a user-friendly message
     */
    public static String translateSingleDiagnostic(Diagnostic diagnostic) {
        String originalMessage = diagnostic.getMessage();

        // Try to extract error code
        Integer errorCode = extractErrorCode(originalMessage);

        if (errorCode != null && ERROR_MAPPINGS.containsKey(errorCode)) {
            ErrorInfo info = ERROR_MAPPINGS.get(errorCode);

            // Try to extract variable/type names from the original message
            String enrichedMessage = enrichMessage(info.userMessage, originalMessage);

            return String.format("%s\n   💡 %s", enrichedMessage, info.suggestion);
        }

        // Fallback: Try pattern matching for common error messages (backward compatibility)
        return translateByPattern(originalMessage);
    }

    /**
     * Enriches the user message with context from the original error message
     */
    private static String enrichMessage(String template, String originalMessage) {
        // Extract quoted strings (variable names, type names, etc.)
        Pattern quotedPattern = Pattern.compile("'([^']+)'|\"([^\"]+)\"");
        Matcher matcher = quotedPattern.matcher(originalMessage);

        int index = 0;
        String result = template;
        while (matcher.find() && result.contains("{" + index + "}")) {
            String value = matcher.group(1) != null ? matcher.group(1) : matcher.group(2);
            result = result.replace("{" + index + "}", "'" + value + "'");
            index++;
        }

        // Remove unreplaced placeholders
        result = result.replaceAll("\\{\\d+\\}", "the value");

        return result;
    }

    /**
     * Fallback pattern-based translation (for backward compatibility)
     */
    private static String translateByPattern(String message) {
        if (message.contains("cannot be resolved to a type")) {
            return "A type or class could not be found.\n   💡 Check for typos or if the type exists.";
        }
        if (message.contains("cannot be resolved")) {
            return "A variable, method, or name could not be found.\n   💡 Check for typos or if it was declared.";
        }
        if (message.contains("Syntax error, insert")) {
            try {
                String suggestion = message.split("insert \"")[1].split("\" to")[0];
                return String.format("Syntax error: Something is missing.\n   💡 Try adding '%s'", suggestion);
            } catch (Exception e) {
                return "Syntax error: Something is missing in the code structure.\n   💡 Check for missing semicolons, brackets, or parentheses.";
            }
        }
        if (message.contains("incompatible types") || message.contains("Type mismatch")) {
            return "Wrong type used: You're using a value of the wrong type.\n   💡 Make sure you're using the right kind of value (number, text, etc.)";
        }
        if (message.contains("might not have been initialized")) {
            return "Variable used before being set.\n   💡 Give this variable a value before using it.";
        }
        if (message.contains("is not a statement")) {
            return "This line is not a valid statement.\n   💡 It might be an incomplete expression or command.";
        }
        if (message.contains("Duplicate local variable")) {
            return "A variable with this name already exists.\n   💡 Choose a different name for this variable.";
        }

        // Return original message if no translation found
        return message;
    }

    /**
     * Get a short summary for UI display (e.g., tooltip)
     */
    public static String getShortSummary(Diagnostic diagnostic) {
        String originalMessage = diagnostic.getMessage();
        Integer errorCode = extractErrorCode(originalMessage);

        if (errorCode != null && ERROR_MAPPINGS.containsKey(errorCode)) {
            ErrorInfo info = ERROR_MAPPINGS.get(errorCode);
            return enrichMessage(info.userMessage, originalMessage);
        }

        // Fallback: Return first line of original message
        return originalMessage.split("\n")[0];
    }

    /**
     * Get just the suggestion part
     */
    public static String getSuggestion(Diagnostic diagnostic) {
        String originalMessage = diagnostic.getMessage();
        Integer errorCode = extractErrorCode(originalMessage);

        if (errorCode != null && ERROR_MAPPINGS.containsKey(errorCode)) {
            return ERROR_MAPPINGS.get(errorCode).suggestion;
        }

        return "Check your code for issues.";
    }
}


=================================================================================
FILE: ./src/main/java/com/botmaker/validation/TypeValidator.java
=================================================================================

package com.botmaker.validation;

import org.eclipse.jdt.core.dom.*;

import java.util.*;

/**
 * Simple, user-friendly type validation for non-coders.
 * Prevents common mistakes without technical jargon.
 */
public class TypeValidator {

    // Variables that should be hidden from users (system/special variables)
    private static final Set<String> HIDDEN_VARIABLES = Set.of(
            "args",      // Command line arguments array
            "this",      // Current object reference
            "super",     // Parent class reference
            "scanner"    // System scanner object
    );

    /**
     * Check if a variable should be visible to users in autocomplete
     */
    public static boolean isUserVariable(String variableName) {
        if (variableName == null) return false;

        // Hide system variables
        if (HIDDEN_VARIABLES.contains(variableName)) {
            return false;
        }

        // Hide variables starting with underscore (convention for internal)
        if (variableName.startsWith("_")) {
            return false;
        }

        return true;
    }

    /**
     * Get a user-friendly type name (no technical jargon)
     */
    public static String getFriendlyTypeName(ITypeBinding typeBinding) {
        if (typeBinding == null) return "unknown";

        String typeName = typeBinding.getName();

        // Handle arrays
        if (typeBinding.isArray()) {
            ITypeBinding elementType = typeBinding.getElementType();
            return "list of " + getFriendlyTypeName(elementType);
        }

        // Handle common types with friendly names
        switch (typeName) {
            case "int":
            case "Integer":
            case "long":
            case "Long":
            case "short":
            case "Short":
            case "byte":
            case "Byte":
                return "number (whole)";

            case "double":
            case "Double":
            case "float":
            case "Float":
                return "number (decimal)";

            case "boolean":
            case "Boolean":
                return "true/false";

            case "String":
                return "text";

            case "char":
            case "Character":
                return "character";

            default:
                // For collections, extract simple name
                if (typeName.contains("<")) {
                    return "collection";
                }
                return typeName;
        }
    }

    /**
     * Check if two types are compatible for assignment
     */
    public static boolean areTypesCompatible(ITypeBinding targetType, ITypeBinding sourceType) {
        if (targetType == null || sourceType == null) return true; // Can't check, allow

        // Same type - always OK
        if (targetType.isEqualTo(sourceType)) return true;

        // Handle numeric widening (safe conversions)
        if (isNumericWideningAllowed(targetType, sourceType)) return true;

        // Check if source is subtype of target (inheritance)
        if (sourceType.isAssignmentCompatible(targetType)) return true;

        return false;
    }

    /**
     * Check if numeric widening conversion is allowed (safe)
     */
    private static boolean isNumericWideningAllowed(ITypeBinding target, ITypeBinding source) {
        String targetName = target.getQualifiedName();
        String sourceName = source.getQualifiedName();

        // Widening conversions that don't lose data
        Map<String, Set<String>> wideningMap = Map.of(
                "int", Set.of("byte", "short"),
                "long", Set.of("byte", "short", "int"),
                "float", Set.of("byte", "short", "int", "long"),
                "double", Set.of("byte", "short", "int", "long", "float")
        );

        Set<String> allowedSources = wideningMap.get(targetName);
        return allowedSources != null && allowedSources.contains(sourceName);
    }

    /**
     * Get a user-friendly error message for type mismatch
     */
    public static String getTypeMismatchMessage(ITypeBinding expected, ITypeBinding actual) {
        String expectedName = getFriendlyTypeName(expected);
        String actualName = getFriendlyTypeName(actual);

        return String.format(
                "Type mismatch: You're using %s but %s is needed here.",
                actualName,
                expectedName
        );
    }

    /**
     * Check if an expression can be used as a boolean (in if/while conditions)
     */
    public static boolean isBooleanExpression(Expression expr) {
        if (expr == null) return false;

        ITypeBinding typeBinding = expr.resolveTypeBinding();
        if (typeBinding == null) return true; // Can't check, allow

        return typeBinding.getName().equals("boolean") ||
                typeBinding.getName().equals("Boolean");
    }

    /**
     * Check if an expression is numeric
     */
    public static boolean isNumericExpression(Expression expr) {
        if (expr == null) return false;

        ITypeBinding typeBinding = expr.resolveTypeBinding();
        if (typeBinding == null) return true; // Can't check, allow

        String name = typeBinding.getName();
        return name.equals("int") || name.equals("Integer") ||
                name.equals("long") || name.equals("Long") ||
                name.equals("float") || name.equals("Float") ||
                name.equals("double") || name.equals("Double") ||
                name.equals("byte") || name.equals("Byte") ||
                name.equals("short") || name.equals("Short");
    }

    /**
     * Check if an expression is a collection (List, array, etc.)
     */
    public static boolean isCollectionExpression(Expression expr) {
        if (expr == null) return false;

        ITypeBinding typeBinding = expr.resolveTypeBinding();
        if (typeBinding == null) return false;

        return typeBinding.isArray() ||
                typeBinding.getName().contains("List") ||
                typeBinding.getName().contains("Collection") ||
                typeBinding.getName().contains("Set");
    }

    /**
     * Suggest appropriate variable name based on type
     */
    public static String suggestVariableName(ITypeBinding typeBinding) {
        if (typeBinding == null) return "value";

        String typeName = typeBinding.getName();

        if (typeBinding.isArray()) {
            return "items";
        }

        switch (typeName) {
            case "int":
            case "Integer":
            case "long":
            case "Long":
                return "number";

            case "double":
            case "Double":
            case "float":
            case "Float":
                return "decimal";

            case "boolean":
            case "Boolean":
                return "flag";

            case "String":
                return "text";

            case "char":
            case "Character":
                return "letter";

            default:
                if (typeName.contains("List")) return "list";
                if (typeName.contains("Map")) return "dictionary";
                if (typeName.contains("Set")) return "collection";
                return "value";
        }
    }
}

