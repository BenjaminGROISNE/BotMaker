=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\Main.java
=================================================================================

package com.botmaker;

import com.botmaker.config.ApplicationConfig;
import com.botmaker.di.DependencyContainer;
import com.botmaker.init.AppDependencyConfigurator;
import com.botmaker.init.AppServiceInitializer;
import com.botmaker.project.LibraryManager;
import com.botmaker.project.ProjectConfig;
import com.botmaker.services.CodeEditorService;
import com.botmaker.services.LanguageServerService;
import com.botmaker.ui.ProjectSelectionScreen;
import com.botmaker.ui.UIManager;
import javafx.application.Application;
import javafx.application.Platform;
import javafx.scene.control.Alert;
import javafx.stage.Stage;

import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class Main extends Application {

    private DependencyContainer container;
    private LanguageServerService languageServerService;

    @Override
    public void start(Stage primaryStage) {
        String lastProject = ProjectConfig.getLastOpened();

        // Check if last project exists and auto-load
        if (lastProject != null && projectExists(lastProject)) {
            System.out.println("Auto-loading last project: " + lastProject);
            openProject(primaryStage, lastProject, false);
        } else {
            showProjectSelection(primaryStage);
        }
    }

    private void showProjectSelection(Stage primaryStage) {
        ProjectSelectionScreen selectionScreen = new ProjectSelectionScreen(
                primaryStage,
                (projectName, clearCache) -> openProject(primaryStage, projectName, clearCache)
        );

        primaryStage.setScene(selectionScreen.createScene());
        primaryStage.setTitle("BotMaker - Select Project");
        primaryStage.show();
    }

    private void openProject(Stage primaryStage, String projectName, boolean clearCache) {
        try {
            // 0. Verify Library Integrity
            Path projectPath = Paths.get("projects", projectName);
            LibraryManager libManager = new LibraryManager();
            boolean repaired = libManager.verifyAndRepair(projectPath);

            if (repaired) {
                System.out.println("Project libraries were repaired/updated.");
            }

            ProjectConfig.updateLastOpened(projectName);
            ApplicationConfig config = ApplicationConfig.forProject(projectName);

            // 1. Configure Container
            container = new DependencyContainer();
            AppDependencyConfigurator.configure(container, config, primaryStage);

            // 2. Handle Cache Flag
            if (clearCache) {
                container.resolve(LanguageServerService.class).setShouldClearCache(true);
            }

            // 3. Initialize Services & Wiring
            AppServiceInitializer.initialize(container);

            // 4. Keep reference for shutdown
            this.languageServerService = container.resolve(LanguageServerService.class);

            // 5. Setup UI
            UIManager uiManager = container.resolve(UIManager.class);
            uiManager.setOnSelectProject(v -> shutdownAndShowSelector(primaryStage));

            primaryStage.setScene(uiManager.createScene());
            primaryStage.setTitle("BotMaker Blocks - " + projectName);

            // 6. Load Code
            container.resolve(CodeEditorService.class).loadInitialCode();

            primaryStage.setOnCloseRequest(e -> {
                e.consume();
                performShutdown();
            });

            primaryStage.show();

        } catch (Exception e) {
            e.printStackTrace();
            showErrorDialog("Error opening project: " + e.getMessage());
            showProjectSelection(primaryStage);
        }
    }

    private void shutdownAndShowSelector(Stage primaryStage) {
        // Non-terminal shutdown (just stop LSP, keep JVM alive)
        if (languageServerService != null) {
            languageServerService.shutdown();
            languageServerService = null;
        }
        showProjectSelection(primaryStage);
    }

    private void performShutdown() {
        new Thread(() -> {
            try {
                if (languageServerService != null) {
                    System.out.println("Shutting down Language Server...");
                    languageServerService.shutdown();
                }
            } catch (Exception ex) {
                System.err.println("Error during shutdown: " + ex.getMessage());
            } finally {
                Platform.runLater(() -> {
                    Platform.exit();
                    System.exit(0);
                });
            }
        }).start();
    }

    private boolean projectExists(String projectName) {
        return Files.exists(Paths.get("projects", projectName)) &&
                Files.exists(Paths.get("projects", projectName, "build.gradle"));
    }

    private void showErrorDialog(String message) {
        Alert alert = new Alert(Alert.AlertType.ERROR);
        alert.setTitle("Error");
        alert.setHeaderText("Failed to open project");
        alert.setContentText(message);
        alert.showAndWait();
    }

    public static void main(String[] args) {
        launch(args);
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\blocks\AssignmentBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractStatementBlock;
import com.botmaker.core.ExpressionBlock;
import com.botmaker.lsp.CompletionContext;
import com.botmaker.ui.components.BlockUIComponents;
import com.botmaker.ui.components.SelectorComponents;
import javafx.geometry.Pos;
import javafx.scene.Node;
import javafx.scene.control.Button;
import javafx.scene.control.ComboBox;
import javafx.scene.layout.HBox;
import org.eclipse.jdt.core.dom.*;

public class AssignmentBlock extends AbstractStatementBlock {

    private ExpressionBlock leftHandSide;
    private ExpressionBlock rightHandSide;
    private String operator;

    private static final String[] OPERATOR_NAMES = {
            "set to", "add", "subtract", "multiply by", "divide by", "increment", "decrement"
    };

    private static final String[] OPERATOR_SYMBOLS = {
            "=", "+=", "-=", "*=", "/=", "++", "--"
    };

    public AssignmentBlock(String id, ExpressionStatement astNode) {
        super(id, astNode);
        initializeOperator(astNode);
    }

    private void initializeOperator(ExpressionStatement astNode) {
        if (astNode.getExpression() instanceof Assignment) {
            this.operator = ((Assignment) astNode.getExpression()).getOperator().toString();
        } else if (astNode.getExpression() instanceof PostfixExpression) {
            this.operator = ((PostfixExpression) astNode.getExpression()).getOperator().toString();
        } else if (astNode.getExpression() instanceof PrefixExpression) {
            this.operator = ((PrefixExpression) astNode.getExpression()).getOperator().toString();
        } else {
            this.operator = "=";
        }
    }

    public void setLeftHandSide(ExpressionBlock leftHandSide) { this.leftHandSide = leftHandSide; }
    public void setRightHandSide(ExpressionBlock rightHandSide) { this.rightHandSide = rightHandSide; }

    @Override
    protected Node createUINode(CompletionContext context) {
        HBox container = new HBox(5);
        container.setAlignment(Pos.CENTER_LEFT);
        container.getStyleClass().add("assignment-block");

        // Left hand side
        if (leftHandSide != null) {
            container.getChildren().add(leftHandSide.getUINode(context));
        }

        // Operator selector via Component Factory
        ComboBox<String> operatorSelector = SelectorComponents.createOperatorSelector(
                OPERATOR_NAMES,
                OPERATOR_SYMBOLS,
                operator,
                newOperator -> {
                    this.operator = newOperator;
                    if (this.astNode instanceof ExpressionStatement) {
                        Expression expr = ((ExpressionStatement) this.astNode).getExpression();
                        context.codeEditor().updateAssignmentOperator(expr, newOperator);
                    }
                }
        );
        container.getChildren().add(operatorSelector);

        // Right hand side (only for non-increment/decrement)
        if (!operator.equals("++") && !operator.equals("--")) {
            if (rightHandSide != null) {
                container.getChildren().add(rightHandSide.getUINode(context));
            }

            // FIX: Use e.getSource() to avoid uninitialized variable reference
            Button addButton = createAddButton(e -> showExpressionMenu((Button) e.getSource(), context));
            container.getChildren().add(addButton);
        }

        // Spacer and Delete button
        container.getChildren().addAll(
                BlockUIComponents.createSpacer(),
                createDeleteButton(context)
        );

        return container;
    }

    private void showExpressionMenu(Button button, CompletionContext context) {
        String targetType = "any";
        if (leftHandSide != null && leftHandSide.getAstNode() != null) {
            Expression lhsExpr = (org.eclipse.jdt.core.dom.Expression) leftHandSide.getAstNode();
            org.eclipse.jdt.core.dom.ITypeBinding binding = lhsExpr.resolveTypeBinding();
            if (binding != null) {
                targetType = com.botmaker.util.TypeManager.determineUiType(binding.getName());
            }
        }

        org.eclipse.jdt.core.dom.Expression toReplace = null;
        if (rightHandSide != null) {
            toReplace = (org.eclipse.jdt.core.dom.Expression) rightHandSide.getAstNode();
        }

        // Use helper from AbstractStatementBlock
        showExpressionMenuAndReplace(button, context, targetType, toReplace);
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\blocks\BinaryExpressionBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractExpressionBlock;
import com.botmaker.core.ExpressionBlock;
import com.botmaker.lsp.CompletionContext;
import com.botmaker.ui.components.BlockUIComponents;
import javafx.geometry.Pos;
import javafx.scene.Node;
import javafx.scene.control.Button;
import javafx.scene.control.ComboBox;
import javafx.scene.control.Label;
import javafx.scene.layout.HBox;
import org.eclipse.jdt.core.dom.ITypeBinding;
import org.eclipse.jdt.core.dom.InfixExpression;
import org.eclipse.jdt.core.dom.Expression;

public class BinaryExpressionBlock extends AbstractExpressionBlock {

    private ExpressionBlock leftOperand;
    private ExpressionBlock rightOperand;
    private String operator;
    private final ITypeBinding returnType;

    private static final String[] MATH_OPERATOR_NAMES = { "plus", "minus", "times", "divided by", "modulo" };
    private static final String[] MATH_OPERATOR_SYMBOLS = { "+", "-", "*", "/", "%" };

    public BinaryExpressionBlock(String id, InfixExpression astNode) {
        super(id, astNode);
        this.operator = astNode.getOperator().toString();
        this.returnType = astNode.resolveTypeBinding();
    }

    public void setLeftOperand(ExpressionBlock leftOperand) { this.leftOperand = leftOperand; }
    public void setRightOperand(ExpressionBlock rightOperand) { this.rightOperand = rightOperand; }

    @Override
    protected Node createUINode(CompletionContext context) {
        HBox container = new HBox(5);
        container.setAlignment(Pos.CENTER_LEFT);
        container.getStyleClass().add("binary-expression-block");

        HBox expressionBox = new HBox(5);
        expressionBox.setAlignment(Pos.CENTER_LEFT);

        // Left operand + Change Button
        if (leftOperand != null) {
            expressionBox.getChildren().add(leftOperand.getUINode(context));
            Button changeLeft = BlockUIComponents.createChangeButton(e ->
                    showExpressionMenuAndReplace((Button)e.getSource(), context, "number", (Expression) leftOperand.getAstNode())
            );
            changeLeft.setStyle("-fx-font-size: 8px; -fx-padding: 1px 3px;");
            expressionBox.getChildren().add(changeLeft);
        }

        // Operator Selector
        if (isMathOperator(operator)) {
            ComboBox<String> selector = createOperatorSelector(
                    MATH_OPERATOR_NAMES,
                    MATH_OPERATOR_SYMBOLS,
                    operator,
                    newOp -> {
                        this.operator = newOp;
                        // Call the code editor to update the AST
                        context.codeEditor().updateBinaryOperator((InfixExpression) this.astNode, newOp);
                    }
            );
            selector.getStyleClass().add("math-operator-selector");
            expressionBox.getChildren().add(selector);
        } else {
            expressionBox.getChildren().add(createOperatorLabel(operator));
        }

        // Right operand + Change Button
        if (rightOperand != null) {
            expressionBox.getChildren().add(rightOperand.getUINode(context));
            Button changeRight = BlockUIComponents.createChangeButton(e ->
                    showExpressionMenuAndReplace((Button)e.getSource(), context, "number", (Expression) rightOperand.getAstNode())
            );
            changeRight.setStyle("-fx-font-size: 8px; -fx-padding: 1px 3px;");
            expressionBox.getChildren().add(changeRight);
        }

        container.getChildren().add(expressionBox);

        // Type indicator
        String typeName = (returnType != null) ? returnType.getName() : "unknown";
        Label typeLabel = new Label("→ " + typeName);
        typeLabel.setStyle("-fx-font-style: italic; -fx-text-fill: #999; -fx-font-size: 10px;");
        container.getChildren().add(typeLabel);

        return container;
    }

    private boolean isMathOperator(String op) {
        for (String mathOp : MATH_OPERATOR_SYMBOLS) {
            if (mathOp.equals(op)) return true;
        }
        return false;
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\blocks\BooleanLiteralBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractExpressionBlock;
import com.botmaker.lsp.CompletionContext;
import javafx.geometry.Pos;
import javafx.scene.Node;
import javafx.scene.control.ComboBox;
import javafx.scene.control.Label;
import javafx.scene.layout.StackPane;
import org.eclipse.jdt.core.dom.BooleanLiteral;
import org.eclipse.jdt.core.dom.Expression;

/**
 * Block for true/false values with improved UI (Toggle Switch style)
 */
public class BooleanLiteralBlock extends AbstractExpressionBlock {

    private boolean value;

    public BooleanLiteralBlock(String id, BooleanLiteral astNode) {
        super(id, astNode);
        this.value = astNode.booleanValue();
    }

    public boolean getValue() {
        return value;
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        StackPane root = new StackPane();
        root.getStyleClass().add("boolean-literal-block");

        // Define colors
        String trueColor = "#2ecc71"; // Emerald Green
        String falseColor = "#e74c3c"; // Alizarin Red
        String currentColor = value ? trueColor : falseColor;

        // 1. The invisible functional dropdown
        ComboBox<String> booleanSelector = new ComboBox<>();
        booleanSelector.getItems().addAll("true", "false");
        booleanSelector.setValue(value ? "true" : "false");

        // Make the combo box fill the area but be invisible
        // We use opacity 0 so the user can still click it, but sees the label behind it
        booleanSelector.setStyle("-fx-opacity: 0; -fx-cursor: hand;");
        booleanSelector.setMaxSize(Double.MAX_VALUE, Double.MAX_VALUE);

        // 2. The visible label (pill shape)
        Label displayLabel = new Label(value ? "TRUE" : "FALSE");
        displayLabel.setStyle(
                "-fx-text-fill: white; " +
                        "-fx-font-weight: bold; " +
                        "-fx-font-size: 11px; " +
                        "-fx-font-family: 'Segoe UI', sans-serif;" +
                        "-fx-padding: 3 10 3 10;" +
                        "-fx-background-color: " + currentColor + ";" +
                        "-fx-background-radius: 12;" // Pill shape
        );

        // Center the label
        StackPane.setAlignment(displayLabel, Pos.CENTER);

        // Handle value change
        booleanSelector.setOnAction(e -> {
            String selected = booleanSelector.getValue();
            boolean newValue = "true".equals(selected);

            if (newValue != value) {
                this.value = newValue;
                // Update logic
                context.codeEditor().replaceLiteralValue(
                        (Expression) this.astNode,
                        String.valueOf(newValue)
                );
                // Immediate UI feedback (before full rebuild)
                displayLabel.setText(newValue ? "TRUE" : "FALSE");
                displayLabel.setStyle(displayLabel.getStyle().replace(currentColor, newValue ? trueColor : falseColor));
            }
        });

        root.getChildren().addAll(displayLabel, booleanSelector);

        // Force specific size to look neat
        root.setMinWidth(60);
        root.setMaxHeight(24);

        return root;
    }

    @Override
    public String getDetails() {
        return "Boolean: " + value;
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\blocks\BreakBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractStatementBlock;
import com.botmaker.lsp.CompletionContext;
import javafx.scene.Node;
import javafx.scene.layout.HBox;
import org.eclipse.jdt.core.dom.BreakStatement;

public class BreakBlock extends AbstractStatementBlock {

    public BreakBlock(String id, BreakStatement astNode) {
        super(id, astNode);
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        HBox container = createStandardHeader(context, createKeywordLabel("break"));
        container.getStyleClass().add("break-block");
        return container;
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\blocks\ClassBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractCodeBlock;
import com.botmaker.core.BlockWithChildren;
import com.botmaker.core.CodeBlock;
import com.botmaker.lsp.CompletionContext;
import com.botmaker.ui.BlockDragAndDropManager;
import javafx.geometry.Insets;
import javafx.scene.Node;
import javafx.scene.control.Label;
import javafx.scene.layout.Region;
import javafx.scene.layout.VBox;
import org.eclipse.jdt.core.dom.TypeDeclaration;

import java.util.ArrayList;
import java.util.List;

public class ClassBlock extends AbstractCodeBlock implements BlockWithChildren {

    private final String className;
    // FIX: Must accept generic CodeBlock to support Enums
    private final List<CodeBlock> bodyDeclarations = new ArrayList<>();
    private final BlockDragAndDropManager dragAndDropManager;

    public ClassBlock(String id, TypeDeclaration astNode, BlockDragAndDropManager manager) {
        super(id, astNode);
        this.className = astNode.getName().getIdentifier();
        this.dragAndDropManager = manager;
    }

    public void addBodyDeclaration(CodeBlock block) {
        bodyDeclarations.add(block);
    }

    @Override
    public List<CodeBlock> getChildren() {
        return new ArrayList<>(bodyDeclarations);
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        VBox container = new VBox(10);
        container.getStyleClass().add("class-block");
        container.setPadding(new Insets(15));

        container.setStyle(
                "-fx-background-color: linear-gradient(to bottom, #ecf0f1 0%, #bdc3c7 100%);" +
                        "-fx-border-color: #34495e;" +
                        "-fx-border-width: 3px;" +
                        "-fx-border-radius: 10px;" +
                        "-fx-background-radius: 10px;"
        );

        Label header = new Label("Class: " + className);
        header.setStyle("-fx-font-size: 20px; -fx-font-weight: bold; -fx-text-fill: #2c3e50; -fx-padding: 0 0 15 0;");
        container.getChildren().add(header);

        // Top separator
        container.getChildren().add(createClassMemberSeparator(context, 0));

        // FIX: Ensure this loop adds the UI Node of every child (Method OR Enum)
        for (int i = 0; i < bodyDeclarations.size(); i++) {
            CodeBlock block = bodyDeclarations.get(i);
            container.getChildren().add(block.getUINode(context));
            container.getChildren().add(createClassMemberSeparator(context, i + 1));
        }

        return container;
    }

    private Region createClassMemberSeparator(CompletionContext context, int insertIndex) {
        Region separator = new Region();
        separator.setMinHeight(30);
        separator.setMaxHeight(30);
        separator.getStyleClass().add("method-separator");

        separator.setStyle(
                "-fx-background-color: rgba(52, 73, 94, 0.15);" +
                        "-fx-border-color: rgba(52, 73, 94, 0.4);" +
                        "-fx-border-width: 2px 0 2px 0;" +
                        "-fx-border-style: dashed;" +
                        "-fx-cursor: hand;"
        );

        context.dragAndDropManager().addClassMemberDropHandlers(
                separator,
                this,
                insertIndex
        );

        separator.setOnMouseEntered(e -> separator.setStyle("-fx-background-color: rgba(142, 68, 173, 0.3); -fx-border-color: #8E44AD; -fx-border-width: 3px 0 3px 0; -fx-border-style: solid;"));
        separator.setOnMouseExited(e -> separator.setStyle("-fx-background-color: rgba(52, 73, 94, 0.15); -fx-border-color: rgba(52, 73, 94, 0.4); -fx-border-width: 2px 0 2px 0; -fx-border-style: dashed;"));

        return separator;
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\blocks\CommentBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractStatementBlock;
import com.botmaker.lsp.CompletionContext;
import com.botmaker.ui.components.BlockUIComponents;
import com.botmaker.ui.components.TextFieldComponents;
import javafx.geometry.Pos;
import javafx.scene.Node;
import javafx.scene.control.Label;
import javafx.scene.control.TextField;
import javafx.scene.layout.HBox;
import org.eclipse.jdt.core.dom.Comment;

public class CommentBlock extends AbstractStatementBlock {

    private String commentText;

    public CommentBlock(String id, Comment astNode, String commentText) {
        super(id, astNode);
        this.commentText = commentText;
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        HBox container = new HBox(5);
        container.setAlignment(Pos.CENTER_LEFT);
        container.getStyleClass().add("comment-block");

        // Label
        Label commentLabel = new Label("Comment:");
        commentLabel.getStyleClass().add("comment-indicator");

        // TextField using component factory
        TextField commentField = TextFieldComponents.createCommentField(
                commentText,
                "Write your note here...",
                newText -> {
                    if (!newText.equals(commentText)) {
                        this.commentText = newText;
                        javafx.application.Platform.runLater(() -> {
                            context.codeEditor().updateComment((Comment) this.astNode, this.commentText);
                        });
                        container.requestFocus();
                    }
                }
        );

        container.getChildren().addAll(
                commentLabel,
                commentField,
                BlockUIComponents.createSpacer(),
                createDeleteButton(context)
        );

        return container;
    }

    @Override
    public String getDetails() {
        return "Comment: " + (commentText != null ? commentText : "");
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\blocks\ComparisonExpressionBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractExpressionBlock;
import com.botmaker.core.ExpressionBlock;
import com.botmaker.lsp.CompletionContext;
import javafx.geometry.Pos;
import javafx.scene.Node;
import javafx.scene.control.ComboBox;
import javafx.scene.layout.HBox;
import org.eclipse.jdt.core.dom.ITypeBinding;
import org.eclipse.jdt.core.dom.InfixExpression;

public class ComparisonExpressionBlock extends AbstractExpressionBlock {

    private ExpressionBlock leftOperand;
    private ExpressionBlock rightOperand;
    private String operator;
    private final ITypeBinding returnType;

    // Operator display names (user-friendly)
    private static final String[] OPERATOR_NAMES = {
            "less than",                    // <
            "less than or equal",           // <=
            "greater than",                 // >
            "greater than or equal",        // >=
            "equal to",                     // ==
            "not equal to"                  // !=
    };

    // Corresponding Java operators
    private static final String[] OPERATOR_SYMBOLS = {
            "<", "<=", ">", ">=", "==", "!="
    };

    public ComparisonExpressionBlock(String id, InfixExpression astNode) {
        super(id, astNode);
        this.operator = astNode.getOperator().toString();
        this.returnType = astNode.resolveTypeBinding();
    }

    public ExpressionBlock getLeftOperand() {
        return leftOperand;
    }

    public void setLeftOperand(ExpressionBlock leftOperand) {
        this.leftOperand = leftOperand;
    }

    public ExpressionBlock getRightOperand() {
        return rightOperand;
    }

    public void setRightOperand(ExpressionBlock rightOperand) {
        this.rightOperand = rightOperand;
    }

    public String getOperator() {
        return operator;
    }

    public ITypeBinding getReturnType() {
        return returnType;
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        HBox container = new HBox(5);
        container.setAlignment(Pos.CENTER_LEFT);
        container.getStyleClass().add("comparison-expression-block");

        // Left operand
        if (leftOperand != null) {
            container.getChildren().add(leftOperand.getUINode(context));
        }

        // Operator selector - shows user-friendly names
        ComboBox<String> operatorSelector = new ComboBox<>();
        operatorSelector.getItems().addAll(OPERATOR_NAMES);
        operatorSelector.getStyleClass().add("comparison-operator-selector");

        // Set current operator
        String currentName = getOperatorDisplayName(operator);
        operatorSelector.setValue(currentName);

        // Handle operator change
        operatorSelector.setOnAction(e -> {
            String selectedName = operatorSelector.getValue();
            String newOperator = getOperatorSymbol(selectedName);
            if (newOperator != null && !newOperator.equals(operator)) {
                this.operator = newOperator;
                // Trigger code regeneration with new operator
                System.out.println("Comparison operator changed to: " + newOperator);
            }
        });

        container.getChildren().add(operatorSelector);

        // Right operand
        if (rightOperand != null) {
            container.getChildren().add(rightOperand.getUINode(context));
        }

        return container;
    }

    /**
     * Convert operator symbol to display name
     */
    private String getOperatorDisplayName(String symbol) {
        for (int i = 0; i < OPERATOR_SYMBOLS.length; i++) {
            if (OPERATOR_SYMBOLS[i].equals(symbol)) {
                return OPERATOR_NAMES[i];
            }
        }
        return "equal to"; // default
    }

    /**
     * Convert display name to operator symbol
     */
    private String getOperatorSymbol(String displayName) {
        for (int i = 0; i < OPERATOR_NAMES.length; i++) {
            if (OPERATOR_NAMES[i].equals(displayName)) {
                return OPERATOR_SYMBOLS[i];
            }
        }
        return "=="; // default
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\blocks\ContinueBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractStatementBlock;
import com.botmaker.lsp.CompletionContext;
import javafx.scene.Node;
import javafx.scene.layout.HBox;
import org.eclipse.jdt.core.dom.ContinueStatement;

public class ContinueBlock extends AbstractStatementBlock {

    public ContinueBlock(String id, ContinueStatement astNode) {
        super(id, astNode);
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        HBox container = createStandardHeader(context, createKeywordLabel("continue"));
        container.getStyleClass().add("continue-block");
        return container;
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\blocks\DeclareEnumBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractStatementBlock;
import com.botmaker.lsp.CompletionContext;
import com.botmaker.ui.components.BlockUIComponents;
import com.botmaker.ui.components.TextFieldComponents;
import javafx.geometry.Pos;
import javafx.scene.Node;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.control.TextField;
import javafx.scene.layout.HBox;
import javafx.scene.layout.VBox;
import org.eclipse.jdt.core.dom.*;

import java.util.ArrayList;
import java.util.List;

public class DeclareEnumBlock extends AbstractStatementBlock {

    private final String enumName;
    private final List<String> constants;
    private final EnumDeclaration enumDeclaration;
    private final boolean isStatement;

    // Constructor 1: Inside a Method (Wrapped in TypeDeclarationStatement)
    public DeclareEnumBlock(String id, TypeDeclarationStatement astNode) {
        super(id, astNode);
        if (astNode.getDeclaration() instanceof EnumDeclaration) {
            this.enumDeclaration = (EnumDeclaration) astNode.getDeclaration();
            this.isStatement = true;
        } else {
            throw new IllegalArgumentException("Statement is not an EnumDeclaration");
        }
        this.enumName = enumDeclaration.getName().getIdentifier();
        this.constants = extractConstants(enumDeclaration);
    }

    // Constructor 2: Inside a Class (Raw EnumDeclaration)
    public DeclareEnumBlock(String id, EnumDeclaration astNode) {
        super(id, astNode);
        this.enumDeclaration = astNode;
        this.isStatement = false;
        this.enumName = astNode.getName().getIdentifier();
        this.constants = extractConstants(astNode);
    }

    private List<String> extractConstants(EnumDeclaration decl) {
        List<String> list = new ArrayList<>();
        if (decl.enumConstants() != null) {
            for (Object obj : decl.enumConstants()) {
                if (obj instanceof EnumConstantDeclaration) {
                    list.add(((EnumConstantDeclaration) obj).getName().getIdentifier());
                }
            }
        }
        return list;
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        VBox container = new VBox(5);
        container.getStyleClass().add("enum-block");
        // Explicit styling to ensure visibility
        container.setStyle("-fx-background-color: #e67e22; -fx-background-radius: 8; -fx-padding: 8; -fx-effect: dropshadow(three-pass-box, rgba(0,0,0,0.2), 5, 0, 0, 2);");

        // --- Header ---
        HBox headerContent = new HBox(8);
        headerContent.setAlignment(Pos.CENTER_LEFT);

        Label label = BlockUIComponents.createKeywordLabel("Enum");
        label.setStyle("-fx-text-fill: white; -fx-font-weight: bold;");

        TextField nameField = TextFieldComponents.createVariableNameField(enumName, newName -> {
            if (!newName.equals(enumName) && !newName.isEmpty()) {
                context.codeEditor().renameEnum(enumDeclaration, newName);
            }
        });

        Button addConstantBtn = new Button("+ Add Value");
        addConstantBtn.getStyleClass().add("expression-add-button");
        addConstantBtn.setOnAction(e -> context.codeEditor().addEnumConstant(enumDeclaration, "NEW_VALUE"));

        headerContent.getChildren().addAll(label, nameField, addConstantBtn);

        // Delete Logic: Differentiate between Statement (Method) and Declaration (Class)
        Runnable deleteAction = () -> {
            if (isStatement) {
                // Inside method: cast astNode to Statement
                context.codeEditor().deleteStatement((Statement) this.astNode);
            } else {
                // Inside class: remove the declaration
                context.codeEditor().deleteEnumFromClass(enumDeclaration);
            }
        };

        // Create the full header row (Content + Spacer + Delete Button)
        HBox headerRow = BlockUIComponents.createHeaderRow(deleteAction, headerContent);
        container.getChildren().add(headerRow);

        // --- Constants List ---
        if (!constants.isEmpty()) {
            VBox constantsBox = new VBox(4);
            constantsBox.setStyle("-fx-padding: 5 0 5 20;");

            for (int i = 0; i < constants.size(); i++) {
                String constant = constants.get(i);
                final int index = i;

                HBox row = new HBox(5);
                row.setAlignment(Pos.CENTER_LEFT);

                TextField constField = new TextField(constant);
                constField.getStyleClass().add("variable-name-field");
                constField.setPrefWidth(120);
                constField.setStyle("-fx-background-color: rgba(255,255,255,0.9); -fx-text-fill: #333; -fx-background-radius: 4;");

                constField.focusedProperty().addListener((obs, oldVal, newVal) -> {
                    if (!newVal) {
                        String val = constField.getText();
                        if (!val.equals(constant) && !val.isEmpty()) {
                            context.codeEditor().renameEnumConstant(enumDeclaration, index, val);
                        }
                    }
                });

                Button deleteBtn = new Button("×");
                deleteBtn.setStyle("-fx-background-color: transparent; -fx-text-fill: white; -fx-font-weight: bold; -fx-cursor: hand; -fx-font-size: 14px;");
                deleteBtn.setOnAction(e -> context.codeEditor().deleteEnumConstant(enumDeclaration, index));

                row.getChildren().addAll(constField, deleteBtn);
                constantsBox.getChildren().add(row);
            }
            container.getChildren().add(constantsBox);
        }

        return container;
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\blocks\DoWhileBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractStatementBlock;
import com.botmaker.core.BodyBlock;
import com.botmaker.core.BlockWithChildren;
import com.botmaker.core.CodeBlock;
import com.botmaker.core.ExpressionBlock;
import com.botmaker.lsp.CompletionContext;
import com.botmaker.ui.BlockDragAndDropManager;
import javafx.scene.Node;
import javafx.scene.layout.HBox;
import javafx.scene.layout.VBox;
import org.eclipse.jdt.core.dom.DoStatement;

import java.util.ArrayList;
import java.util.List;

public class DoWhileBlock extends AbstractStatementBlock implements BlockWithChildren {

    private ExpressionBlock condition;
    private BodyBlock body;

    public DoWhileBlock(String id, DoStatement astNode, BlockDragAndDropManager dragAndDropManager) {
        super(id, astNode);
    }

    public void setCondition(ExpressionBlock condition) { this.condition = condition; }
    public void setBody(BodyBlock body) { this.body = body; }

    @Override
    public List<CodeBlock> getChildren() {
        List<CodeBlock> children = new ArrayList<>();
        if (body != null) children.add(body);
        if (condition != null) children.add(condition);
        return children;
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        VBox mainContainer = new VBox(5);
        mainContainer.getStyleClass().add("do-while-block");

        // 1. Header: "do" + Delete Button
        mainContainer.getChildren().add(createStandardHeader(context, createKeywordLabel("do")));

        // 2. Body
        VBox bodyNode = createIndentedBody(body, context, "do-while-body");
        if (bodyNode != null) mainContainer.getChildren().add(bodyNode);

        // 3. Footer: "while [condition]"
        // Note: Do-While footer doesn't typically have a delete button itself, as it's part of the block
        HBox whileCondition = createSentence(
                createKeywordLabel("while"),
                condition != null ? condition.getUINode(context) : createExpressionDropZone(context)
        );
        whileCondition.getStyleClass().add("do-while-condition");

        mainContainer.getChildren().add(whileCondition);

        return mainContainer;
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\blocks\ForBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractStatementBlock;
import com.botmaker.core.BodyBlock;
import com.botmaker.core.BlockWithChildren;
import com.botmaker.core.CodeBlock;
import com.botmaker.core.ExpressionBlock;
import com.botmaker.lsp.CompletionContext;
import com.botmaker.ui.BlockDragAndDropManager;
import javafx.scene.Node;
import javafx.scene.layout.VBox;
import org.eclipse.jdt.core.dom.EnhancedForStatement;

import java.util.ArrayList;
import java.util.List;

public class ForBlock extends AbstractStatementBlock implements BlockWithChildren {

    private ExpressionBlock variable;
    private ExpressionBlock collection;
    private BodyBlock body;

    public ForBlock(String id, EnhancedForStatement astNode, BlockDragAndDropManager dragAndDropManager) {
        super(id, astNode);
    }

    public void setVariable(ExpressionBlock variable) { this.variable = variable; }
    public void setCollection(ExpressionBlock collection) { this.collection = collection; }
    public void setBody(BodyBlock body) { this.body = body; }

    @Override
    public List<CodeBlock> getChildren() {
        List<CodeBlock> children = new ArrayList<>();
        if (variable != null) children.add(variable);
        if (collection != null) children.add(collection);
        if (body != null) children.add(body);
        return children;
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        // Header: "for each [var] in [collection]"
        Node headerContent = createSentence(
                createKeywordLabel("for each"),
                variable != null ? variable.getUINode(context) : createExpressionDropZone(context),
                createKeywordLabel("in"),
                collection != null ? collection.getUINode(context) : createExpressionDropZone(context)
        );
        headerContent.getStyleClass().add("for-header");

        VBox mainContainer = new VBox(5);
        mainContainer.getStyleClass().add("for-block");
        mainContainer.getChildren().add(createStandardHeader(context, headerContent));

        // Body
        VBox bodyNode = createIndentedBody(body, context, "for-body");
        if (bodyNode != null) mainContainer.getChildren().add(bodyNode);

        return mainContainer;
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\blocks\IdentifierBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractExpressionBlock;
import com.botmaker.lsp.CompletionContext;
import com.botmaker.util.TypeManager;
import javafx.application.Platform;
import javafx.scene.Cursor;
import javafx.scene.Node;
import javafx.scene.control.ContextMenu;
import javafx.scene.control.MenuItem;
import javafx.scene.control.Tooltip;
import javafx.scene.layout.HBox;
import javafx.scene.text.Text;
import org.eclipse.jdt.core.dom.*;
import org.eclipse.lsp4j.*;

import java.util.List;
import java.util.stream.Collectors;

public class IdentifierBlock extends AbstractExpressionBlock {
    private final String identifier;
    private boolean isUnedited = false;
    private static final String UNEDITED_STYLE_CLASS = "unedited-identifier";

    public IdentifierBlock(String id, SimpleName astNode) {
        this(id, astNode, false);
    }

    public IdentifierBlock(String id, SimpleName astNode, boolean markAsUnedited) {
        super(id, astNode);
        this.identifier = astNode.getIdentifier();
        this.isUnedited = markAsUnedited;
    }

    public String getIdentifier() { return identifier; }
    public boolean isUnedited() { return isUnedited; }

    public void markAsEdited() {
        this.isUnedited = false;
        if (uiNode != null) {
            uiNode.getStyleClass().remove(UNEDITED_STYLE_CLASS);
        }
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        Text text = new Text(this.identifier);
        HBox container = new HBox(text);
        container.setAlignment(javafx.geometry.Pos.CENTER_LEFT);
        container.getStyleClass().add("identifier-block");

        if (isUnedited) container.getStyleClass().add(UNEDITED_STYLE_CLASS);

        container.setCursor(Cursor.HAND);
        String tooltipText = isUnedited ? "⚠️ Default variable name - Click to choose" : "Click to change variable";
        Tooltip.install(container, new Tooltip(tooltipText));

        container.setOnMouseClicked(e -> {
            if (e.getClickCount() == 1) requestSuggestions(container, context);
        });

        return container;
    }

    private void requestSuggestions(Node uiNode, CompletionContext context) {
        try {
            Position pos = getPositionFromOffset(context.sourceCode(), this.astNode.getStartPosition());
            CompletionParams params = new CompletionParams(new TextDocumentIdentifier(context.docUri()), pos);

            String expectedType = determineExpectedType();
            System.out.println("[Debug] Suggestion Context -> Expected Type: " + expectedType);

            context.server().getTextDocumentService().completion(params).thenAccept(result -> {
                if (result == null || (result.isLeft() && result.getLeft().isEmpty()) ||
                        (result.isRight() && result.getRight().getItems().isEmpty())) {
                    return;
                }

                List<CompletionItem> items = result.isLeft() ? result.getLeft() : result.getRight().getItems();

                Platform.runLater(() -> {
                    ContextMenu menu = new ContextMenu();
                    menu.setStyle("-fx-control-inner-background: white;");

                    List<CompletionItem> filteredItems = items.stream()
                            .filter(item -> item.getKind() == CompletionItemKind.Variable || item.getKind() == CompletionItemKind.Field)
                            .filter(item -> TypeManager.isUserVariable(item.getLabel()))
                            .filter(item -> {
                                String typeInfo = item.getDetail();
                                if (typeInfo == null || typeInfo.isBlank()) {
                                    if (item.getLabel().contains(" : ")) {
                                        String[] parts = item.getLabel().split(" : ");
                                        if (parts.length > 1) typeInfo = parts[1].trim();
                                    }
                                }
                                // Checks validity using TypeManager (now handles SWITCH_COMPATIBLE)
                                return TypeManager.isCompatible(typeInfo, expectedType);
                            })
                            .collect(Collectors.toList());

                    if (filteredItems.isEmpty()) {
                        MenuItem noVars = new MenuItem("(No compatible variables found)");
                        noVars.setDisable(true);
                        noVars.setStyle("-fx-text-fill: #999;");
                        menu.getItems().add(noVars);
                    } else {
                        for (CompletionItem item : filteredItems) {
                            String label = item.getLabel();
                            String detail = item.getDetail();
                            if (detail == null && label.contains(" : ")) {
                                detail = label.split(" : ")[1].trim();
                            }

                            String display = label;
                            if (!label.contains(":") && detail != null && !detail.isEmpty()) {
                                display += " (" + getSimpleTypeName(detail) + ")";
                            }

                            MenuItem mi = new MenuItem(display);
                            mi.setStyle("-fx-text-fill: black;");
                            mi.setOnAction(event -> {
                                applySuggestion(item, context);
                                markAsEdited();
                            });
                            menu.getItems().add(mi);
                        }
                    }
                    menu.show(uiNode, javafx.geometry.Side.BOTTOM, 0, 0);
                });
            });
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * Walks up the AST skipping parentheses to find the true semantic parent.
     */
    private String determineExpectedType() {
        if (this.astNode == null) return TypeManager.UI_TYPE_ANY;

        ASTNode child = this.astNode;
        ASTNode parent = this.astNode.getParent();

        while (parent instanceof ParenthesizedExpression) {
            child = parent;
            parent = parent.getParent();
        }

        if (parent == null) return TypeManager.UI_TYPE_ANY;

        // NEW: Switch Statement Expression Context
        if (parent instanceof SwitchStatement) {
            if (((SwitchStatement) parent).getExpression() == child) {
                return TypeManager.UI_TYPE_SWITCH_COMPATIBLE;
            }
        }

        // 2. Boolean Contexts
        if (parent instanceof IfStatement) {
            if (((IfStatement) parent).getExpression() == child) return TypeManager.UI_TYPE_BOOLEAN;
        }
        if (parent instanceof WhileStatement) {
            if (((WhileStatement) parent).getExpression() == child) return TypeManager.UI_TYPE_BOOLEAN;
        }
        if (parent instanceof DoStatement) {
            if (((DoStatement) parent).getExpression() == child) return TypeManager.UI_TYPE_BOOLEAN;
        }

        // 3. Unary Contexts
        if (parent instanceof PrefixExpression) {
            PrefixExpression.Operator op = ((PrefixExpression) parent).getOperator();
            if (op == PrefixExpression.Operator.NOT) return TypeManager.UI_TYPE_BOOLEAN;
            return TypeManager.UI_TYPE_NUMBER;
        }
        if (parent instanceof PostfixExpression) return TypeManager.UI_TYPE_NUMBER;

        // 4. Binary Contexts
        if (parent instanceof InfixExpression) {
            InfixExpression infix = (InfixExpression) parent;
            InfixExpression.Operator op = infix.getOperator();
            if (op == InfixExpression.Operator.CONDITIONAL_AND || op == InfixExpression.Operator.CONDITIONAL_OR) {
                return TypeManager.UI_TYPE_BOOLEAN;
            }
            return TypeManager.UI_TYPE_NUMBER;
        }

        // 5. Assignment
        if (parent instanceof Assignment) {
            Assignment assignment = (Assignment) parent;
            if (assignment.getRightHandSide() == child) {
                Expression lhs = assignment.getLeftHandSide();
                ITypeBinding binding = lhs.resolveTypeBinding();
                if (binding != null) {
                    return TypeManager.determineUiType(binding.getName());
                }
            }
        }

        // 6. Variable Declaration
        if (parent instanceof VariableDeclarationFragment) {
            VariableDeclarationFragment frag = (VariableDeclarationFragment) parent;
            if (frag.getInitializer() == child) {
                ASTNode grandParent = frag.getParent();
                if (grandParent instanceof VariableDeclarationStatement) {
                    Type type = ((VariableDeclarationStatement) grandParent).getType();
                    return TypeManager.determineUiType(type.toString());
                }
            }
        }

        return TypeManager.UI_TYPE_ANY;
    }

    private String getSimpleTypeName(String detail) {
        if (detail == null) return "";
        if (TypeManager.isCompatible(detail, TypeManager.UI_TYPE_NUMBER)) return "number";
        if (TypeManager.isCompatible(detail, TypeManager.UI_TYPE_BOOLEAN)) return "bool";
        return detail;
    }

    private void applySuggestion(CompletionItem item, CompletionContext context) {
        try {
            String insertText = item.getInsertText() != null ? item.getInsertText() : item.getLabel();
            if (insertText.contains(" : ")) {
                insertText = insertText.split(" : ")[0];
            }
            context.codeEditor().replaceSimpleName((SimpleName) this.astNode, insertText);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private Position getPositionFromOffset(String code, int offset) {
        int line = 0;
        int lastNewline = -1;
        for (int i = 0; i < offset; i++) {
            if (code.charAt(i) == '\n') {
                line++;
                lastNewline = i;
            }
        }
        int character = offset - lastNewline - 1;
        return new Position(line, character);
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\blocks\IfBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractStatementBlock;
import com.botmaker.core.BodyBlock;
import com.botmaker.core.ExpressionBlock;
import com.botmaker.core.StatementBlock;
import com.botmaker.lsp.CompletionContext;
import com.botmaker.ui.components.BlockUIComponents;
import javafx.geometry.Pos;
import javafx.scene.Node;
import javafx.scene.control.Button;
import javafx.scene.layout.HBox;
import javafx.scene.layout.VBox;
import org.eclipse.jdt.core.dom.CompilationUnit;
import org.eclipse.jdt.core.dom.IfStatement;

public class IfBlock extends AbstractStatementBlock {

    private ExpressionBlock condition;
    private BodyBlock thenBody;
    private StatementBlock elseStatement;

    public IfBlock(String id, IfStatement astNode) {
        super(id, astNode);
    }

    public void setCondition(ExpressionBlock condition) { this.condition = condition; }
    public void setThenBody(BodyBlock thenBody) { this.thenBody = thenBody; }
    public void setElseStatement(StatementBlock elseStatement) { this.elseStatement = elseStatement; }

    @Override
    protected Node createUINode(CompletionContext context) {
        VBox container = new VBox(5);
        container.getStyleClass().add("if-block");

        // 1. Header: "If [condition] [+]"
        Button addButton = createAddButton(e ->
                showExpressionMenuAndReplace((Button)e.getSource(), context, "boolean",
                        condition != null ? (org.eclipse.jdt.core.dom.Expression) condition.getAstNode() : null)
        );

        Node headerContent = createSentence(
                createKeywordLabel("If"),
                getOrDropZone(condition, context),
                addButton
        );

        container.getChildren().add(createStandardHeader(context, headerContent));

        // 2. Then Body
        if (thenBody != null) {
            VBox thenNode = createIndentedBody(thenBody, context, "if-body");
            container.getChildren().add(thenNode);
        }

        // 3. Else / Else If Logic
        if (elseStatement != null) {
            if (elseStatement instanceof BodyBlock) {
                // Regular Else
                VBox elseContainer = new VBox(5);

                HBox elseHeader = createSentence(
                        createKeywordLabel("Else"),
                        BlockUIComponents.createAddButton(e -> context.codeEditor().convertElseToElseIf((IfStatement) this.astNode)),
                        BlockUIComponents.createSpacer(),
                        BlockUIComponents.createDeleteButton(() -> context.codeEditor().deleteElseFromIfStatement((IfStatement) this.astNode))
                );

                VBox elseBodyNode = createIndentedBody((BodyBlock) elseStatement, context, "if-body");
                elseContainer.getChildren().addAll(elseHeader, elseBodyNode);
                container.getChildren().add(elseContainer);
            } else {
                // Else If (Recursive IfBlock)
                HBox elseIfContainer = new HBox(5);
                elseIfContainer.setAlignment(Pos.CENTER_LEFT);
                elseIfContainer.getChildren().add(createKeywordLabel("Else"));

                Node elseNode = elseStatement.getUINode(context);
                HBox.setHgrow(elseNode, javafx.scene.layout.Priority.ALWAYS);
                elseIfContainer.getChildren().add(elseNode);

                container.getChildren().add(elseIfContainer);
            }
        } else {
            // Add Else Button
            Button addElseButton = createAddButton(e -> context.codeEditor().addElseToIfStatement((IfStatement) this.astNode));
            container.getChildren().add(addElseButton);
        }

        return container;
    }

    @Override
    public int getBreakpointLine(CompilationUnit cu) {
        if (condition != null) return condition.getBreakpointLine(cu);
        return super.getBreakpointLine(cu);
    }

    @Override
    public com.botmaker.core.CodeBlock getHighlightTarget() {
        return condition != null ? condition : this;
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\blocks\LibraryBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractCodeBlock;
import com.botmaker.core.BlockWithChildren;
import com.botmaker.core.CodeBlock;
import com.botmaker.lsp.CompletionContext;
import javafx.geometry.Insets;
import javafx.scene.Node;
import javafx.scene.control.Label;
import javafx.scene.layout.VBox;
import org.eclipse.jdt.core.dom.TypeDeclaration;

import java.util.ArrayList;
import java.util.List;

public class LibraryBlock extends AbstractCodeBlock implements BlockWithChildren {

    private final String className;
    private final List<MethodDeclarationBlock> methods = new ArrayList<>();

    public LibraryBlock(String id, TypeDeclaration astNode) {
        super(id, astNode);
        this.className = astNode.getName().getIdentifier();
    }

    public void addMethod(MethodDeclarationBlock method) {
        methods.add(method);
    }

    @Override
    public List<CodeBlock> getChildren() {
        return new ArrayList<>(methods);
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        VBox container = new VBox(10);
        container.getStyleClass().add("library-block");
        container.setPadding(new Insets(10));
        // Ensure background is set so white text (if any) is visible,
        // OR enforce text color to be dark.
        container.setStyle("-fx-background-color: #f4f6f9;");

        Label header = new Label("Library: " + className);
        // Using specific styling instead of generic main-block-header which might be designed for dark backgrounds
        header.setStyle("-fx-font-size: 18px; -fx-font-weight: bold; -fx-text-fill: #2c3e50; -fx-padding: 0 0 10 0;");

        container.getChildren().add(header);

        for (MethodDeclarationBlock method : methods) {
            container.getChildren().add(method.getUINode(context));
        }

        return container;
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\blocks\ListBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractExpressionBlock;
import com.botmaker.core.ExpressionBlock;
import com.botmaker.lsp.CompletionContext;
import com.botmaker.util.TypeManager;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.Node;
import javafx.scene.control.Button;
import javafx.scene.control.ContextMenu;
import javafx.scene.control.Label;
import javafx.scene.control.MenuItem;
import javafx.scene.layout.HBox;
import javafx.scene.layout.VBox;
import org.eclipse.jdt.core.dom.*;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * Visual block for lists.
 * Supports:
 * 1. Array Initializers: {1, 2, 3}
 * 2. List Factories: Arrays.asList(1, 2, 3) or List.of(1, 2, 3)
 */
public class ListBlock extends AbstractExpressionBlock {

    private final List<ExpressionBlock> elements = new ArrayList<>();
    private final boolean isFixedArray; // True if it's a {}, False if it's Arrays.asList

    public ListBlock(String id, ASTNode astNode) {
        super(id, astNode);
        this.isFixedArray = (astNode instanceof ArrayInitializer);
    }

    public void addElement(ExpressionBlock element) {
        this.elements.add(element);
    }

    public List<ExpressionBlock> getElements() {
        return elements;
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        // ... (Container and Style setup remains same)
        VBox container = new VBox(5);
        container.setAlignment(Pos.TOP_LEFT);
        container.getStyleClass().add("list-block");

        boolean isNested = (this.astNode.getParent() instanceof ArrayInitializer) ||
                (this.astNode.getParent() instanceof MethodInvocation);

        if (isNested) {
            container.setStyle("-fx-background-color: rgba(255,255,255,0.08); -fx-background-radius: 6; -fx-border-color: rgba(255,255,255,0.15); -fx-border-width: 1;");
            container.setPadding(new Insets(4, 6, 4, 6));
        } else {
            container.setPadding(new Insets(6, 10, 6, 10));
        }

        // --- Header Row ---
        HBox headerRow = new HBox(8);
        headerRow.setAlignment(Pos.CENTER_LEFT);

        // Calculate logic
        String itemType = determineItemType();
        // If itemType is "list", we are holding sub-lists.
        // If itemType is "boolean"/"number", we are holding values.

        String typeLabel = isFixedArray ? "Array" : "List";

        // Debug label helpful for verification:
        // Label listLabel = new Label(typeLabel + "<" + itemType + "> (" + elements.size() + ")");
        Label listLabel = new Label(typeLabel + " (" + elements.size() + ")");
        listLabel.getStyleClass().add("list-label");

        if (!isFixedArray) {
            listLabel.setStyle("-fx-text-fill: #aaddff;");
        }

        Button addButton = new Button("+");
        addButton.getStyleClass().add("expression-add-button");
        addButton.setStyle("-fx-font-size: 10px; -fx-padding: 2px 8px;");

        addButton.setOnAction(e -> showAddElementMenu(addButton, context, elements.size(), itemType));

        headerRow.getChildren().addAll(listLabel, addButton);
        container.getChildren().add(headerRow);

        // --- Elements ---
        if (elements.isEmpty()) {
            Label emptyLabel = new Label(" (empty) ");
            emptyLabel.setStyle("-fx-font-style: italic; -fx-text-fill: rgba(255,255,255,0.4); -fx-font-size: 10px;");
            container.getChildren().add(emptyLabel);
        } else {
            VBox elementsContainer = new VBox(3);
            elementsContainer.setPadding(new Insets(2, 0, 0, 12));

            for (int i = 0; i < elements.size(); i++) {
                // Pass itemType down so row knows what it contains
                HBox elementRow = createElementRow(i, elements.get(i), context, itemType);
                elementsContainer.getChildren().add(elementRow);
            }
            container.getChildren().add(elementsContainer);
        }

        return container;
    }

    /**
     * Determines the UI type of items inside this list (e.g., "number", "text", "boolean", "list").
     */
    /**
     * Logic to determine what kind of items this specific ListBlock should contain.
     * It walks up the AST to find the Variable Declaration, calculates total nesting depth,
     * calculates current depth, and decides if we need "list" or a leaf type.
     */
    private String determineItemType() {
        ASTNode current = this.astNode;
        ASTNode rootDefinition = null;
        int currentDepth = 0;

        // 1. Walk up to find the root definition and count current depth
        while (current != null) {
            // If we hit another Arrays.asList, we are one level deeper
            if (current instanceof MethodInvocation) {
                MethodInvocation mi = (MethodInvocation) current;
                if ("asList".equals(mi.getName().getIdentifier())) {
                    // If we aren't the starting node, increment depth
                    if (current != this.astNode) {
                        currentDepth++;
                    }
                }
            }

            // Found declaration: ArrayList<ArrayList<Boolean>> x = ...
            if (current instanceof VariableDeclarationFragment) {
                rootDefinition = current;
                break;
            }
            // Found declaration in standard usage
            if (current instanceof VariableDeclarationStatement) {
                rootDefinition = current;
                break;
            }
            // Found usage inside new ArrayList<>(...)
            if (current instanceof ClassInstanceCreation) {
                rootDefinition = current;
                break;
            }

            current = current.getParent();
        }

        // 2. Analyze the root type
        String rootTypeStr = "any";

        if (rootDefinition instanceof VariableDeclarationStatement) {
            rootTypeStr = ((VariableDeclarationStatement) rootDefinition).getType().toString();
        } else if (rootDefinition instanceof VariableDeclarationFragment) {
            ASTNode parent = rootDefinition.getParent();
            if (parent instanceof VariableDeclarationStatement) {
                rootTypeStr = ((VariableDeclarationStatement) parent).getType().toString();
            }
        } else if (rootDefinition instanceof ClassInstanceCreation) {
            rootTypeStr = ((ClassInstanceCreation) rootDefinition).getType().toString();
        }

        // 3. Calculate Dimensions
        // e.g. ArrayList<ArrayList<Boolean>> -> genericDepth = 2, leafType = "Boolean"
        int genericDepth = TypeManager.getListNestingLevel(rootTypeStr);
        String leafType = TypeManager.getLeafType(rootTypeStr); // e.g. "Boolean"


        // 4. Determine UI Type based on depth comparison
        // If genericDepth is 2 (List of List of Bool)
        // currentDepth 0 (Root) -> needs "list" (to make depth 1)
        // currentDepth 1 (Middle) -> needs leafType ("Boolean")

        // Note: The depth calculation depends on how the AST creates the structure.
        // Arrays.asList( Arrays.asList ( ... ) )
        // Root list is depth 0.

        int remainingLevels = genericDepth - 1 - currentDepth;

        if (remainingLevels > 0) {
            return "list";
        } else {
            return TypeManager.determineUiType(leafType);
        }
    }

    private HBox createElementRow(int index, ExpressionBlock element, CompletionContext context, String itemType) {
        HBox row = new HBox(6);
        row.setAlignment(Pos.CENTER_LEFT);

        Label indexLabel = new Label(String.valueOf(index));
        indexLabel.setStyle("-fx-font-family: monospace; -fx-text-fill: #666; -fx-font-size: 9px; -fx-min-width: 10px;");

        Node elementNode = element.getUINode(context);
        if (element instanceof ListBlock) {
            HBox.setHgrow(elementNode, javafx.scene.layout.Priority.ALWAYS);
        }

        Button changeButton = new Button("↻");
        changeButton.getStyleClass().add("icon-button");
        changeButton.setStyle("-fx-font-size: 8px; -fx-padding: 1px 4px; -fx-opacity: 0.3;");
        changeButton.setOnAction(e -> showChangeElementMenu(changeButton, context, index, itemType));

        Button deleteButton = new Button("✕");
        deleteButton.getStyleClass().add("icon-button");
        deleteButton.setStyle("-fx-font-size: 8px; -fx-padding: 1px 4px; -fx-text-fill: #ff5555; -fx-opacity: 0.3;");
        deleteButton.setOnAction(e -> deleteElement(index, context));

        row.setOnMouseEntered(e -> {
            changeButton.setStyle("-fx-font-size: 8px; -fx-padding: 1px 4px; -fx-opacity: 1.0;");
            deleteButton.setStyle("-fx-font-size: 8px; -fx-padding: 1px 4px; -fx-text-fill: #ff5555; -fx-opacity: 1.0;");
        });
        row.setOnMouseExited(e -> {
            changeButton.setStyle("-fx-font-size: 8px; -fx-padding: 1px 4px; -fx-opacity: 0.3;");
            deleteButton.setStyle("-fx-font-size: 8px; -fx-padding: 1px 4px; -fx-text-fill: #ff5555; -fx-opacity: 0.3;");
        });

        row.getChildren().addAll(indexLabel, elementNode, changeButton, deleteButton);
        return row;
    }

    private void showAddElementMenu(Button button, CompletionContext context, int insertIndex, String targetType) {
        ContextMenu menu = new ContextMenu();

        // Use getForType to filter the options
        for (com.botmaker.ui.AddableExpression type : com.botmaker.ui.AddableExpression.getForType(targetType)) {
            MenuItem menuItem = new MenuItem(type.getDisplayName());
            menuItem.setOnAction(e -> {
                context.codeEditor().addElementToList(this.astNode, type, insertIndex);
            });
            menu.getItems().add(menuItem);
        }
        menu.show(button, javafx.geometry.Side.BOTTOM, 0, 0);
    }

    private void showChangeElementMenu(Button button, CompletionContext context, int elementIndex, String targetType) {
        ContextMenu menu = new ContextMenu();

        // Use getForType to filter the options
        for (com.botmaker.ui.AddableExpression type : com.botmaker.ui.AddableExpression.getForType(targetType)) {
            MenuItem menuItem = new MenuItem(type.getDisplayName());
            menuItem.setOnAction(e -> {
                if (elementIndex < elements.size()) {
                    ExpressionBlock oldElement = elements.get(elementIndex);
                    context.codeEditor().replaceExpression(
                            (Expression) oldElement.getAstNode(),
                            type
                    );
                }
            });
            menu.getItems().add(menuItem);
        }
        menu.show(button, javafx.geometry.Side.BOTTOM, 0, 0);
    }

    private void deleteElement(int index, CompletionContext context) {
        if (index >= 0 && index < elements.size()) {
            context.codeEditor().deleteElementFromList(this.astNode, index);
        }
    }

    @Override
    public String getDetails() {
        return (isFixedArray ? "Array" : "List") + " (" + elements.size() + " items)";
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\blocks\LiteralBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractExpressionBlock;
import com.botmaker.lsp.CompletionContext;
import javafx.scene.Cursor;
import javafx.scene.Node;
import javafx.scene.control.TextField;
import javafx.scene.control.TextFormatter;
import javafx.scene.layout.HBox;
import org.eclipse.jdt.core.dom.Expression;
import org.eclipse.jdt.core.dom.MethodInvocation;

import java.math.BigDecimal;
import java.util.function.UnaryOperator;

public class LiteralBlock<T> extends AbstractExpressionBlock {
    private final T value;

    public LiteralBlock(String id, Expression astNode, T value) {
        super(id, astNode);
        this.value = value;
    }

    public T getValue() {
        return value;
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        String initialText = (value instanceof String) ? (String) value : String.valueOf(value);
        TextField textField = new TextField(initialText);

        if (initialText.isEmpty() && value instanceof String) {
            textField.setPromptText("Type a value...");
        }

        textField.setCursor(Cursor.TEXT);
        textField.getStyleClass().add("literal-text-field");

        // --- INPUT VALIDATION FILTER ---
        UnaryOperator<TextFormatter.Change> filter = createInputFilter();
        if (filter != null) {
            textField.setTextFormatter(new TextFormatter<>(filter));
        }

        // --- FOCUS LISTENER (Commit changes) ---
        textField.focusedProperty().addListener((obs, oldVal, newVal) -> {
            if (!newVal) { // Focus Lost
                String newText = textField.getText();
                String oldText = (value instanceof String) ? (String) value : String.valueOf(value);

                // Handle empty numbers / intermediate states gracefully
                if (isNumberType() && !isValidFinalNumber(newText)) {
                    textField.setText(oldText); // Revert invalid state
                    return;
                }

                // NEW: Normalize the number (Add 'f' for Float, 'L' for Long)
                String textToSave = normalizeNumberSuffix(newText);

                // Update UI to match saved text (e.g., show "3.5f" if user typed "3.5")
                if (!textToSave.equals(newText)) {
                    textField.setText(textToSave);
                }

                if (!textToSave.equals(oldText)) {
                    if (this.astNode instanceof MethodInvocation) {
                        MethodInvocation mi = (MethodInvocation) this.astNode;
                        context.codeEditor().addStringArgumentToMethodInvocation(mi, textToSave);
                    } else {
                        context.codeEditor().replaceLiteralValue((Expression) this.astNode, textToSave);
                    }
                }
            }
        });

        HBox container = new HBox(textField);
        container.setAlignment(javafx.geometry.Pos.CENTER_LEFT);
        container.getStyleClass().add("literal-block");
        return container;
    }

    /**
     * Automatically appends required Java suffixes (f, L) if missing.
     */
    private String normalizeNumberSuffix(String text) {
        if (value instanceof Float) {
            if (!text.toLowerCase().endsWith("f")) {
                return text + "f";
            }
        } else if (value instanceof Long) {
            if (!text.toLowerCase().endsWith("l")) {
                return text + "L"; // Use Uppercase L to avoid confusion with 1
            }
        }
        return text;
    }

    /**
     * Creates a filter based on the type of the value stored in this block.
     */
    private UnaryOperator<TextFormatter.Change> createInputFilter() {
        return change -> {
            String newText = change.getControlNewText();

            if (newText.isEmpty()) return change;

            // 1. INTEGER Types (Byte, Short, Integer, Long)
            if (value instanceof Integer || value instanceof Short || value instanceof Byte || value instanceof Long) {
                // Allow digits, minus, and L suffix for Longs
                String regex = (value instanceof Long) ? "-?[0-9]*[lL]?" : "-?[0-9]*";

                if (newText.matches(regex)) {
                    if (isWithinRange(newText, value.getClass())) {
                        return change;
                    }
                }
                return null;
            }

            // 2. FLOATING POINT Types (Float, Double)
            else if (value instanceof Double || value instanceof Float) {
                // Allow digits, dot, minus, and f/d suffixes
                if (newText.matches("-?[0-9]*\\.?[0-9]*[dDfF]?")) {
                    if (isWithinRange(newText, value.getClass())) {
                        return change;
                    }
                }
                return null;
            }

            // 3. STRING
            else if (value instanceof String) {
                String input = change.getText();
                if (input.contains("\"") || input.contains("\n") || input.contains("\r")) {
                    return null;
                }
                return change;
            }

            return change;
        };
    }

    /**
     * Checks if the text value fits within the MIN/MAX bounds of the target type.
     */
    private boolean isWithinRange(String text, Class<?> type) {
        // Allow intermediate states
        if (text.equals("-") || text.equals(".") || text.equals("-.")) return true;

        // Strip suffixes for parsing check
        String cleanText = text.replaceAll("[dDfFlL]$", "");
        if (cleanText.isEmpty()) return true;

        try {
            if (type == Byte.class) {
                long val = Long.parseLong(cleanText);
                return val >= Byte.MIN_VALUE && val <= Byte.MAX_VALUE;
            }
            if (type == Short.class) {
                long val = Long.parseLong(cleanText);
                return val >= Short.MIN_VALUE && val <= Short.MAX_VALUE;
            }
            if (type == Integer.class) {
                long val = Long.parseLong(cleanText);
                return val >= Integer.MIN_VALUE && val <= Integer.MAX_VALUE;
            }
            if (type == Long.class) {
                Long.parseLong(cleanText);
                return true;
            }
            if (type == Float.class) {
                double val = Double.parseDouble(cleanText);
                // Float.MAX_VALUE is huge, mostly we check for Infinity overflow
                return !Double.isInfinite(val);
            }
            if (type == Double.class) {
                BigDecimal val = new BigDecimal(cleanText);
                // Check if it fits in a double
                return !Double.isInfinite(val.doubleValue());
            }
        } catch (NumberFormatException e) {
            return false;
        }

        return true;
    }

    private boolean isValidFinalNumber(String text) {
        if (text.equals("-") || text.equals(".") || text.equals("-.")) return false;
        if (text.endsWith(".")) return false;
        return true;
    }

    private boolean isNumberType() {
        return value instanceof Number;
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\blocks\MainBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.lsp.CompletionContext;
import com.botmaker.ui.BlockDragAndDropManager;
import javafx.scene.Node;
import javafx.scene.control.Label;
import javafx.scene.layout.VBox;
import org.eclipse.jdt.core.dom.MethodDeclaration;

/**
 * MainBlock is just a MethodDeclarationBlock that detects if it's the "main" method
 * and adjusts its UI styling accordingly.
 */
public class MainBlock extends MethodDeclarationBlock {

    private final boolean isMainMethod;

    public MainBlock(String id, MethodDeclaration astNode, BlockDragAndDropManager manager) {
        super(id, astNode, manager);
        this.isMainMethod = "main".equals(astNode.getName().getIdentifier()) &&
                org.eclipse.jdt.core.dom.Modifier.isStatic(astNode.getModifiers());
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        Node standardUI = super.createUINode(context);

        if (isMainMethod) {
            // Apply special styling for main method
            VBox wrapper = new VBox(standardUI);
            wrapper.getStyleClass().add("main-method-highlight");
            wrapper.setStyle("-fx-background-color: #e8f4f8; -fx-border-color: #3498db; -fx-border-width: 2; -fx-border-radius: 8; -fx-padding: 5;");

            Label mainBadge = new Label("⭐ Program Entry Point");
            mainBadge.setStyle("-fx-font-size: 10px; -fx-text-fill: #3498db; -fx-font-weight: bold;");
            wrapper.getChildren().add(0, mainBadge);

            return wrapper;
        }

        return standardUI;
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\blocks\MethodDeclarationBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractStatementBlock;
import com.botmaker.core.BlockWithChildren;
import com.botmaker.core.BodyBlock;
import com.botmaker.core.CodeBlock;
import com.botmaker.lsp.CompletionContext;
import com.botmaker.ui.BlockDragAndDropManager;
import com.botmaker.util.DefaultNames;
import com.botmaker.util.TypeManager;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.Node;
import javafx.scene.control.*;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Priority;
import javafx.scene.layout.Region;
import javafx.scene.layout.VBox;
import org.eclipse.jdt.core.dom.MethodDeclaration;
import org.eclipse.jdt.core.dom.Modifier;
import org.eclipse.jdt.core.dom.SingleVariableDeclaration;

import java.util.Collections;
import java.util.List;

public class MethodDeclarationBlock extends AbstractStatementBlock implements BlockWithChildren {

    private final String methodName;
    private final String returnType;
    private BodyBlock body;

    public MethodDeclarationBlock(String id, MethodDeclaration astNode, BlockDragAndDropManager manager) {
        super(id, astNode);
        this.methodName = astNode.getName().getIdentifier();
        if (astNode.getReturnType2() != null) {
            this.returnType = astNode.getReturnType2().toString();
        } else {
            this.returnType = "void";
        }
    }

    public void setBody(BodyBlock body) {
        this.body = body;
    }

    @Override
    public List<CodeBlock> getChildren() {
        return body != null ? Collections.singletonList(body) : Collections.emptyList();
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        VBox container = new VBox(0); // 0 spacing, handled by padding
        container.getStyleClass().add("method-block");
        // CSS: .method-block { -fx-background-color: transparent; }

        // --- HEADER SECTION ---
        VBox headerBox = new VBox(5);
        headerBox.getStyleClass().add("method-header");
        // We will do inline styles here for immediate results, but moving to CSS is better
        // A nice purple/indigo for functions
        headerBox.setStyle(
                "-fx-background-color: #8E44AD; " +
                        "-fx-background-radius: 8 8 0 0; " +
                        "-fx-padding: 8 10 8 10;"
        );

        // Row 1: "Function [Name] returns [Type]"
        HBox topRow = new HBox(8);
        topRow.setAlignment(Pos.CENTER_LEFT);

        Label funcLabel = new Label("Function");
        funcLabel.setStyle("-fx-text-fill: rgba(255,255,255,0.8); -fx-font-weight: bold; -fx-font-size: 10px; -fx-text-transform: uppercase;");

        Label nameLabel = new Label(methodName);
        nameLabel.setStyle("-fx-text-fill: white; -fx-font-family: 'Segoe UI', sans-serif; -fx-font-weight: bold; -fx-font-size: 14px;");

        Region spacer = new Region();
        HBox.setHgrow(spacer, Priority.ALWAYS);

        Label returnsLabel = new Label("returns");
        returnsLabel.setStyle("-fx-text-fill: rgba(255,255,255,0.7); -fx-font-style: italic; -fx-font-size: 11px;");



        ComboBox<String> typeSelector = new ComboBox<>();
        typeSelector.getItems().add("void");
        typeSelector.getItems().addAll(TypeManager.getFundamentalTypeNames());
        typeSelector.setValue(returnType);
        typeSelector.setStyle("-fx-font-size: 11px; -fx-background-color: rgba(255,255,255,0.2); -fx-text-fill: white; -fx-background-radius: 4;");
        // Force the text inside combo to be visible (JavaFX Combobox styling can be tricky)
        typeSelector.setButtonCell(new ListCell<String>() {
            @Override
            protected void updateItem(String item, boolean empty) {
                super.updateItem(item, empty);
                if(empty || item == null) { setText(null); }
                else {
                    setText(item);
                    setStyle("-fx-text-fill: white;"); // Make selected text white
                }
            }
        });

        typeSelector.setOnAction(e -> {
            String selected = typeSelector.getValue();
            if (!selected.equals(returnType)) {
                context.codeEditor().setMethodReturnType((MethodDeclaration) this.astNode, selected);
            }
        });

        Button deleteBtn = new Button("×");
        deleteBtn.setStyle("-fx-background-color: transparent; -fx-text-fill: #E74C3C; -fx-font-size: 16px; -fx-padding: 0; -fx-cursor: hand;");
        deleteBtn.setOnAction(e -> {
            context.codeEditor().deleteMethod((MethodDeclaration) this.astNode);
        });
        deleteBtn.setOnMouseEntered(e -> deleteBtn.setStyle("-fx-background-color: #E74C3C; -fx-text-fill: white; -fx-font-size: 16px; -fx-padding: 2 6 2 6; -fx-cursor: hand; -fx-background-radius: 4;"));
        deleteBtn.setOnMouseExited(e -> deleteBtn.setStyle("-fx-background-color: transparent; -fx-text-fill: #E74C3C; -fx-font-size: 16px; -fx-padding: 0; -fx-cursor: hand;"));


        topRow.getChildren().addAll(funcLabel, nameLabel, spacer, returnsLabel, typeSelector, deleteBtn);

        // Row 2: Parameters
        HBox paramRow = new HBox(6);
        paramRow.setAlignment(Pos.CENTER_LEFT);

        Label paramsLabel = new Label("Inputs:");
        paramsLabel.setStyle("-fx-text-fill: rgba(255,255,255,0.7); -fx-font-size: 11px;");
        paramRow.getChildren().add(paramsLabel);

        MethodDeclaration md = (MethodDeclaration) this.astNode;
        List<?> params = md.parameters();

        for (int i = 0; i < params.size(); i++) {
            SingleVariableDeclaration param = (SingleVariableDeclaration) params.get(i);
            Node paramNode = createParamNode(param, i, context);
            paramRow.getChildren().add(paramNode);
        }

        MenuButton addParamBtn = new MenuButton("+");
        addParamBtn.setStyle("-fx-font-size: 10px; -fx-padding: 2 6 2 6; -fx-background-color: rgba(255,255,255,0.2); -fx-text-fill: white; -fx-background-radius: 10;");

        for (String type : TypeManager.getFundamentalTypeNames()) {
            MenuItem item = new MenuItem(type);
            item.setOnAction(e -> {
                String defaultName = DefaultNames.forType(type);
                context.codeEditor().addParameterToMethod(
                        (MethodDeclaration) this.astNode, type, defaultName
                );
            });
            addParamBtn.getItems().add(item);
        }
        paramRow.getChildren().add(addParamBtn);

        headerBox.getChildren().addAll(topRow, paramRow);
        container.getChildren().add(headerBox);

        // --- BODY ---
        VBox bodyWrapper = new VBox();
        // Add a left border to visually connect header to body
        bodyWrapper.setStyle("-fx-border-color: #8E44AD; -fx-border-width: 0 0 0 4; -fx-background-color: rgba(142, 68, 173, 0.05);");

        if (body != null) {
            Node bodyNode = body.getUINode(context);
            VBox.setVgrow(bodyNode, Priority.ALWAYS);
            bodyWrapper.getChildren().add(bodyNode);
        }
        container.getChildren().add(bodyWrapper);

        return container;
    }

    private Node createParamNode(SingleVariableDeclaration param, int index, CompletionContext context) {
        HBox box = new HBox(4);
        box.setAlignment(Pos.CENTER_LEFT);
        // Pill style: Semi-transparent white background
        box.setStyle("-fx-background-color: rgba(255,255,255,0.9); -fx-background-radius: 12; -fx-padding: 3 8 3 8;");

        Label typeLabel = new Label(param.getType().toString());
        typeLabel.setStyle("-fx-text-fill: #8E44AD; -fx-font-weight: bold; -fx-font-size: 11px;");

        String currentName = param.getName().getIdentifier();
        TextField nameField = new TextField(currentName);

        // Make the TextField look like a label unless clicked
        nameField.setStyle(
                "-fx-background-color: transparent; " +
                        "-fx-padding: 0; " +
                        "-fx-font-size: 11px; " +
                        "-fx-text-fill: #333;"
        );
        nameField.setPrefWidth(Math.max(30, currentName.length() * 7));

        // When focused, add a subtle underline or border
        nameField.focusedProperty().addListener((obs, oldVal, newVal) -> {
            if (newVal) {
                nameField.setStyle("-fx-background-color: white; -fx-padding: 0; -fx-font-size: 11px; -fx-text-fill: black; -fx-border-color: #8E44AD; -fx-border-width: 0 0 1 0;");
            } else {
                // Lost focus - save and revert style
                nameField.setStyle("-fx-background-color: transparent; -fx-padding: 0; -fx-font-size: 11px; -fx-text-fill: #333;");
                String val = nameField.getText().trim();
                if (!val.isEmpty() && !val.equals(currentName)) {
                    context.codeEditor().renameMethodParameter((MethodDeclaration) this.astNode, index, val);
                } else {
                    nameField.setText(currentName);
                }
            }
        });

        nameField.setOnAction(e -> box.requestFocus()); // Commit on Enter

        MethodDeclaration md = (MethodDeclaration) this.astNode;
        boolean isMainMethod = "main".equals(md.getName().getIdentifier()) &&
                Modifier.isStatic(md.getModifiers()) &&
                Modifier.isPublic(md.getModifiers());

        if (!isMainMethod) {
            Button deleteBtn = new Button("×");
            deleteBtn.setStyle("-fx-background-color: transparent; -fx-text-fill: #E74C3C; -fx-font-size: 16px; -fx-padding: 0; -fx-cursor: hand;");
            deleteBtn.setOnAction(e -> {
                context.codeEditor().deleteMethod((MethodDeclaration) this.astNode);
            });
            deleteBtn.setOnMouseEntered(e -> deleteBtn.setStyle("-fx-background-color: #E74C3C; -fx-text-fill: white; -fx-font-size: 16px; -fx-padding: 2 6 2 6; -fx-cursor: hand; -fx-background-radius: 4;"));
            deleteBtn.setOnMouseExited(e -> deleteBtn.setStyle("-fx-background-color: transparent; -fx-text-fill: #E74C3C; -fx-font-size: 16px; -fx-padding: 0; -fx-cursor: hand;"));

            box.getChildren().add(deleteBtn);
        }
        box.getChildren().addAll(typeLabel, nameField);
        return box;
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\blocks\MethodInvocationBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractExpressionBlock;
import com.botmaker.core.ExpressionBlock;
import com.botmaker.core.StatementBlock;
import com.botmaker.lsp.CompletionContext;
import com.botmaker.project.ProjectFile;
import com.botmaker.ui.AddableExpression;
import javafx.geometry.Pos;
import javafx.scene.Node;
import javafx.scene.control.*;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Priority;
import javafx.scene.layout.Region;
import org.eclipse.jdt.core.dom.*;

import java.util.ArrayList;
import java.util.List;

public class MethodInvocationBlock extends AbstractExpressionBlock implements StatementBlock {

    private String scopeName;
    private String methodName;
    private final List<ExpressionBlock> arguments = new ArrayList<>();
    private boolean isStatementContext = false;

    public MethodInvocationBlock(String id, ASTNode astNode) {
        super(id, resolveExpressionNode(astNode));

        if (astNode instanceof ExpressionStatement) {
            this.isStatementContext = true;
        }

        MethodInvocation mi = (MethodInvocation) this.astNode;
        this.methodName = mi.getName().getIdentifier();
        if (mi.getExpression() != null) {
            this.scopeName = mi.getExpression().toString();
        } else {
            this.scopeName = ""; // Local
        }
    }

    private static MethodInvocation resolveExpressionNode(ASTNode node) {
        if (node instanceof ExpressionStatement) {
            return (MethodInvocation) ((ExpressionStatement) node).getExpression();
        }
        return (MethodInvocation) node;
    }

    public void addArgument(ExpressionBlock arg) {
        arguments.add(arg);
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        HBox container = new HBox(6);
        container.setAlignment(Pos.CENTER_LEFT);
        container.getStyleClass().add("method-call-block");

        if (!isStatementContext) {
            container.setStyle("-fx-background-color: #34495E; -fx-background-radius: 12; -fx-padding: 3 8 3 8;");
        } else {
            container.setStyle("-fx-background-color: #34495E; -fx-background-radius: 4; -fx-padding: 5 10 5 10;");
        }

        Label callLabel = new Label("Call");
        callLabel.setStyle("-fx-text-fill: #aaa; -fx-font-weight: bold; -fx-font-size: 10px;");

        // --- Prepare Data ---
        String currentFileClass = "";
        if (context.applicationState() != null && context.applicationState().getActiveFile() != null) {
            currentFileClass = context.applicationState().getActiveFile().getClassName();
        }

        // --- File Selector ---
        ComboBox<String> fileSelector = new ComboBox<>();
        if (context.applicationState() != null) {
            for (ProjectFile file : context.applicationState().getAllFiles()) {
                fileSelector.getItems().add(file.getClassName());
            }
        }

        String displayValue = scopeName.isEmpty() ? currentFileClass : scopeName;
        if (!fileSelector.getItems().contains(displayValue)) {
            fileSelector.getItems().add(0, displayValue);
        }
        fileSelector.setValue(displayValue);
        fileSelector.setStyle("-fx-font-size: 11px; -fx-pref-width: 100px;");

        // --- Method Selector ---
        ComboBox<String> methodSelector = new ComboBox<>();
        methodSelector.setValue(methodName);
        methodSelector.setEditable(false);
        methodSelector.setStyle("-fx-font-size: 11px; -fx-pref-width: 120px; -fx-font-weight: bold;");

        final String finalCurrentFileClass = currentFileClass;

        // --- Logic to populate methods ---
        Runnable populateMethodList = () -> {
            String selectedFile = fileSelector.getValue();
            methodSelector.getItems().clear();

            ProjectFile targetFile = findProjectFile(context, selectedFile);

            if (targetFile != null) {
                ensureAstParsed(targetFile);

                if (targetFile.getAst() != null && !targetFile.getAst().types().isEmpty()) {
                    TypeDeclaration type = (TypeDeclaration) targetFile.getAst().types().get(0);
                    boolean isLocal = selectedFile.equals(finalCurrentFileClass);

                    for (MethodDeclaration md : type.getMethods()) {
                        int mods = md.getModifiers();
                        boolean isStatic = Modifier.isStatic(mods);
                        boolean isPublic = Modifier.isPublic(mods);

                        if (isLocal || (isPublic && isStatic)) {
                            methodSelector.getItems().add(md.getName().getIdentifier());
                        }
                    }
                }

                // NEW: Auto-select if only one option
                if (methodSelector.getItems().size() == 1) {
                    methodSelector.getSelectionModel().select(0);
                }
            }
        };

        // Listener: Update Code on Method Selection
        methodSelector.setOnAction(e -> {
            String newMethodName = methodSelector.getValue();
            if (newMethodName == null) return;

            String newScopeDisplay = fileSelector.getValue();
            String newScopeAST = newScopeDisplay.equals(finalCurrentFileClass) ? "" : newScopeDisplay;

            // FIXED: Always sync arguments when method changes, even if name is same
            // (in case signature was updated in the other file)
            List<String> paramTypes = findParameterTypes(context, newScopeDisplay, newMethodName);

            context.codeEditor().updateMethodInvocation(
                    (MethodInvocation) this.astNode,
                    newScopeAST,
                    newMethodName,
                    paramTypes
            );
        });

        fileSelector.setOnAction(e -> {
            populateMethodList.run();
            methodSelector.show();
        });

        populateMethodList.run();

        container.getChildren().addAll(callLabel, fileSelector, new Label("."), methodSelector);

        // Calculate expected parameter count and mismatch status FIRST
        int expectedParamCount = findParameterTypes(context, displayValue, methodName).size();
        boolean hasMismatch = arguments.size() != expectedParamCount;

        // NEW: Add a "Sync Arguments" button to fix mismatches
        Button syncBtn = new Button("⟳");
        if (hasMismatch) {
            syncBtn.setStyle("-fx-font-size: 10px; -fx-padding: 2 4 2 4; -fx-background-color: #FFA500; -fx-text-fill: white; -fx-font-weight: bold;");
            syncBtn.setTooltip(new Tooltip("⚠ Arguments don't match! Click to sync with function signature"));
        } else {
            syncBtn.setStyle("-fx-font-size: 10px; -fx-padding: 2 4 2 4; -fx-background-color: rgba(255,255,255,0.2); -fx-text-fill: #90EE90;");
            syncBtn.setTooltip(new Tooltip("Arguments match signature ✓"));
        }
        syncBtn.setOnAction(e -> {
            String currentScope = fileSelector.getValue();
            String currentMethod = methodSelector.getValue();
            String scopeForAST = currentScope.equals(finalCurrentFileClass) ? "" : currentScope;

            List<String> paramTypes = findParameterTypes(context, currentScope, currentMethod);

            context.codeEditor().updateMethodInvocation(
                    (MethodInvocation) this.astNode,
                    scopeForAST,
                    currentMethod,
                    paramTypes
            );
        });
        container.getChildren().add(syncBtn);

        // --- Arguments UI ---
        Label argsLabel = new Label("(");
        argsLabel.setStyle("-fx-text-fill: white;");
        container.getChildren().add(argsLabel);

        // Fetch parameter names for display labels
        List<String> paramNames = findParameterNames(context, displayValue, methodName);

        for (int i = 0; i < arguments.size(); i++) {
            ExpressionBlock arg = arguments.get(i);
            HBox argBox = new HBox(2);
            argBox.setAlignment(Pos.CENTER_LEFT);
            argBox.setStyle("-fx-background-color: rgba(255,255,255,0.1); -fx-background-radius: 4; -fx-padding: 2;");

            // Parameter Name Label
            if (i < paramNames.size()) {
                Label paramNameLabel = new Label(paramNames.get(i) + ":");
                paramNameLabel.setStyle("-fx-text-fill: #aaa; -fx-font-size: 9px; -fx-padding: 0 4 0 2;");
                argBox.getChildren().add(paramNameLabel);
            }

            argBox.getChildren().add(arg.getUINode(context));

            // FIXED: Only show delete button if we have more arguments than expected
            // OR if we're within expected range (always allow manual deletion)
            Button delBtn = new Button("×");
            delBtn.setStyle("-fx-background-color: transparent; -fx-text-fill: #E74C3C; -fx-font-size: 10px; -fx-padding: 0 0 0 2; -fx-cursor: hand;");
            int index = i;
            delBtn.setOnAction(e -> {
                // Use generic list deletion
                context.codeEditor().deleteElementFromList(this.astNode, index);
            });
            argBox.getChildren().add(delBtn);

            container.getChildren().add(argBox);
        }

        // FIXED: Only show "+" button if we have fewer arguments than expected parameters
        if (arguments.size() < expectedParamCount) {
            MenuButton addArgBtn = new MenuButton("+");
            addArgBtn.setStyle("-fx-font-size: 9px; -fx-padding: 2 4 2 4;");

            // IMPROVED: Show appropriate expression types based on next parameter type
            String nextParamType = getParameterTypeAt(context, displayValue, methodName, arguments.size());
            List<AddableExpression> availableTypes = AddableExpression.getForType(nextParamType);

            for (AddableExpression type : availableTypes) {
                MenuItem item = new MenuItem(type.getDisplayName());
                item.setOnAction(e -> {
                    context.codeEditor().addArgumentToMethodInvocation(
                            (MethodInvocation) this.astNode,
                            type
                    );
                });
                addArgBtn.getItems().add(item);
            }
            container.getChildren().add(addArgBtn);
        } else if (arguments.size() > expectedParamCount) {
            // Visual indicator that there are too many arguments
            Label warningLabel = new Label("⚠ Too many");
            warningLabel.setStyle("-fx-text-fill: #FFA500; -fx-font-size: 9px; -fx-font-weight: bold;");
            warningLabel.setTooltip(new Tooltip(String.format("Expected %d argument(s), got %d", expectedParamCount, arguments.size())));
            container.getChildren().add(warningLabel);
        } else if (arguments.size() < expectedParamCount) {
            // Visual indicator that arguments are missing
            Label missingLabel = new Label(String.format("⚠ Need %d more", expectedParamCount - arguments.size()));
            missingLabel.setStyle("-fx-text-fill: #FF6B6B; -fx-font-size: 9px; -fx-font-weight: bold;");
            missingLabel.setTooltip(new Tooltip(String.format("Expected %d argument(s), got %d", expectedParamCount, arguments.size())));
            container.getChildren().add(missingLabel);
        }

        Label closeParen = new Label(")");
        closeParen.setStyle("-fx-text-fill: white;");
        container.getChildren().add(closeParen);

        if (isStatementContext) {
            Region spacer = new Region();
            HBox.setHgrow(spacer, Priority.ALWAYS);
            Button deleteButton = new Button("X");
            deleteButton.setOnAction(e -> context.codeEditor().deleteStatement((Statement) this.astNode.getParent()));
            container.getChildren().addAll(spacer, deleteButton);
        }

        return container;
    }

    // --- Helpers ---

    private ProjectFile findProjectFile(CompletionContext context, String className) {
        if (context.applicationState() == null) return null;
        for (ProjectFile file : context.applicationState().getAllFiles()) {
            if (file.getClassName().equals(className)) {
                return file;
            }
        }
        return null;
    }

    private void ensureAstParsed(ProjectFile file) {
        if (file.getAst() == null) {
            try {
                ASTParser parser = ASTParser.newParser(AST.getJLSLatest());
                parser.setSource(file.getContent().toCharArray());
                parser.setKind(ASTParser.K_COMPILATION_UNIT);
                CompilationUnit cu = (CompilationUnit) parser.createAST(null);
                file.setAst(cu);
            } catch (Exception ignored) {}
        }
    }

    private List<String> findParameterTypes(CompletionContext context, String className, String methodName) {
        List<String> types = new ArrayList<>();
        ProjectFile targetFile = findProjectFile(context, className);

        if (targetFile != null) {
            ensureAstParsed(targetFile);
            if (targetFile.getAst() != null && !targetFile.getAst().types().isEmpty()) {
                TypeDeclaration type = (TypeDeclaration) targetFile.getAst().types().get(0);
                for (MethodDeclaration md : type.getMethods()) {
                    if (md.getName().getIdentifier().equals(methodName)) {
                        for (Object p : md.parameters()) {
                            SingleVariableDeclaration param = (SingleVariableDeclaration) p;
                            types.add(param.getType().toString());
                        }
                        return types;
                    }
                }
            }
        }
        return types;
    }

    // NEW: Helper to get parameter names for UI labels
    private List<String> findParameterNames(CompletionContext context, String className, String methodName) {
        List<String> names = new ArrayList<>();
        ProjectFile targetFile = findProjectFile(context, className);

        if (targetFile != null) {
            ensureAstParsed(targetFile);
            if (targetFile.getAst() != null && !targetFile.getAst().types().isEmpty()) {
                TypeDeclaration type = (TypeDeclaration) targetFile.getAst().types().get(0);
                for (MethodDeclaration md : type.getMethods()) {
                    if (md.getName().getIdentifier().equals(methodName)) {
                        for (Object p : md.parameters()) {
                            SingleVariableDeclaration param = (SingleVariableDeclaration) p;
                            names.add(param.getName().getIdentifier());
                        }
                        return names;
                    }
                }
            }
        }
        return names;
    }

    // NEW: Helper to get the UI type for a specific parameter position
    private String getParameterTypeAt(CompletionContext context, String className, String methodName, int index) {
        List<String> types = findParameterTypes(context, className, methodName);
        if (index >= 0 && index < types.size()) {
            return com.botmaker.util.TypeManager.determineUiType(types.get(index));
        }
        return "any"; // Fallback
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\blocks\PrintBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractStatementBlock;
import com.botmaker.core.ExpressionBlock;
import com.botmaker.lsp.CompletionContext;
import javafx.scene.Node;
import javafx.scene.control.Button;
import javafx.scene.layout.HBox;
import javafx.scene.text.Text;
import org.eclipse.jdt.core.dom.ExpressionStatement;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

public class PrintBlock extends AbstractStatementBlock {

    private final List<ExpressionBlock> arguments = new ArrayList<>();

    public PrintBlock(String id, ExpressionStatement astNode) {
        super(id, astNode);
    }

    public void addArgument(ExpressionBlock argument) { this.arguments.add(argument); }

    @Override
    protected Node createUINode(CompletionContext context) {
        HBox content = createSentence();
        content.getChildren().add(new Text("Print:"));

        if (arguments.isEmpty()) {
            content.getChildren().add(createExpressionDropZone(context));
        } else {
            for (ExpressionBlock arg : arguments) {
                content.getChildren().add(arg.getUINode(context));
            }
        }

        // Add Button
        Button addButton = createAddButton(e -> {
            // Logic handles one argument for now in standard print blocks
            org.eclipse.jdt.core.dom.Expression toReplace = !arguments.isEmpty() ?
                    (org.eclipse.jdt.core.dom.Expression) arguments.get(0).getAstNode() : null;
            showExpressionMenuAndReplace((Button)e.getSource(), context, "any", toReplace);
        });

        content.getChildren().add(addButton);

        Node container = createStandardHeader(context, content);
        container.getStyleClass().add("print-block");
        return container;
    }

    @Override
    public String getDetails() {
        String argsString = arguments.stream().map(ExpressionBlock::getDetails).collect(Collectors.joining(", "));
        return "Print Statement: " + argsString;
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\blocks\ReadInputBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractStatementBlock;
import com.botmaker.core.ExpressionBlock;
import com.botmaker.lsp.CompletionContext;
import javafx.scene.Node;
import javafx.scene.control.Label;
import org.eclipse.jdt.core.dom.VariableDeclarationStatement;

import static com.botmaker.ui.components.BlockUIComponents.createTypeLabel;

public class ReadInputBlock extends AbstractStatementBlock {

    private ExpressionBlock variableName;
    private String inputType;

    public ReadInputBlock(String id, VariableDeclarationStatement astNode, String inputType) {
        super(id, astNode);
        this.inputType = inputType;
    }

    public void setVariableName(ExpressionBlock variableName) { this.variableName = variableName; }

    @Override
    protected Node createUINode(CompletionContext context) {
        Node varNode = variableName != null ? variableName.getUINode(context) : null;

        Label scannerLabel = new Label("scanner." + inputType + "()");
        scannerLabel.getStyleClass().add("method-call-label");

        Node content = createSentence(
                createTypeLabel(getTypeDisplayName()),
                varNode,
                createKeywordLabel("="),
                scannerLabel
        );

        Node container = createStandardHeader(context, content);
        container.getStyleClass().add("read-input-block");
        return container;
    }


    private String getTypeDisplayName() {
        switch (inputType) {
            case "nextLine": return "String";
            case "nextInt": return "int";
            case "nextDouble": return "double";
            case "nextBoolean": return "boolean";
            default: return "var";
        }
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\blocks\ReturnBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractStatementBlock;
import com.botmaker.core.ExpressionBlock;
import com.botmaker.lsp.CompletionContext;
import com.botmaker.ui.components.BlockUIComponents;
import javafx.scene.Node;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import org.eclipse.jdt.core.dom.ASTNode;
import org.eclipse.jdt.core.dom.MethodDeclaration;
import org.eclipse.jdt.core.dom.ReturnStatement;

import static com.botmaker.ui.components.BlockUIComponents.createChangeButton;

public class ReturnBlock extends AbstractStatementBlock {

    private ExpressionBlock expression;

    public ReturnBlock(String id, ReturnStatement astNode) {
        super(id, astNode);
    }

    public void setExpression(ExpressionBlock expression) {
        this.expression = expression;
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        // Determine parent method return type
        String methodReturnType = findParentMethodReturnType();
        boolean isVoid = "void".equals(methodReturnType);

        Node content;

        if (expression != null) {
            Button changeBtn = createChangeButton(e ->
                    showExpressionMenuAndReplace((Button)e.getSource(), context, methodReturnType, (org.eclipse.jdt.core.dom.Expression)expression.getAstNode())
            );

            content = createSentence(
                    createKeywordLabel("return"),
                    expression.getUINode(context),
                    changeBtn
            );
        } else if (!isVoid) {
            Button addButton = createAddButton(e ->
                    BlockUIComponents.createExpressionTypeMenu(methodReturnType, type ->
                            context.codeEditor().setReturnExpression((ReturnStatement) this.astNode, type)
                    ).show((Button)e.getSource(), javafx.geometry.Side.BOTTOM, 0, 0)
            );

            content = createSentence(
                    createKeywordLabel("return"),
                    addButton
            );
        } else {
            Label voidLabel = new Label("(void)");
            voidLabel.setStyle("-fx-text-fill: #aaa; -fx-font-size: 10px; -fx-font-style: italic;");

            content = createSentence(
                    createKeywordLabel("return"),
                    voidLabel
            );
        }

        Node container = createStandardHeader(context, content);
        container.getStyleClass().add("return-block");

        return container;
    }

    private String findParentMethodReturnType() {
        ASTNode current = this.astNode.getParent();
        while (current != null) {
            if (current instanceof MethodDeclaration) {
                MethodDeclaration md = (MethodDeclaration) current;
                if (md.getReturnType2() != null) {
                    return md.getReturnType2().toString();
                }
                return "void";
            }
            current = current.getParent();
        }
        return "void";
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\blocks\SwitchBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractStatementBlock;
import com.botmaker.core.BodyBlock;
import com.botmaker.core.BlockWithChildren;
import com.botmaker.core.CodeBlock;
import com.botmaker.core.ExpressionBlock;
import com.botmaker.lsp.CompletionContext;
import com.botmaker.ui.BlockDragAndDropManager;
import com.botmaker.ui.components.BlockUIComponents;
import com.botmaker.util.TypeManager;
import javafx.geometry.Insets;
import javafx.scene.Node;
import javafx.scene.control.Button;
import javafx.scene.layout.HBox;
import javafx.scene.layout.VBox;
import org.eclipse.jdt.core.dom.*;

import java.util.ArrayList;
import java.util.List;

public class SwitchBlock extends AbstractStatementBlock implements BlockWithChildren {

    private ExpressionBlock expression;
    private final List<SwitchCaseBlock> cases = new ArrayList<>();
    private final BlockDragAndDropManager dragAndDropManager;

    public SwitchBlock(String id, SwitchStatement astNode, BlockDragAndDropManager dragAndDropManager) {
        super(id, astNode);
        this.dragAndDropManager = dragAndDropManager;
    }

    public void setExpression(ExpressionBlock expression) { this.expression = expression; }
    public void addCase(SwitchCaseBlock caseBlock) { this.cases.add(caseBlock); }

    @Override
    public List<CodeBlock> getChildren() {
        List<CodeBlock> children = new ArrayList<>();
        if (expression != null) children.add(expression);
        children.addAll(cases);
        return children;
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        // Header
        // FIX: Use UI_TYPE_SWITCH_COMPATIBLE to filter allowed types for the Switch expression
        Button changeSwitchExprBtn = BlockUIComponents.createChangeButton(e ->
                showExpressionMenuAndReplace((Button)e.getSource(), context, TypeManager.UI_TYPE_SWITCH_COMPATIBLE,
                        expression != null ? (Expression) expression.getAstNode() : null)
        );

        Node headerContent = createSentence(
                createKeywordLabel("switch"),
                getOrDropZone(expression, context),
                changeSwitchExprBtn
        );
        headerContent.getStyleClass().add("switch-header");

        // Main container
        VBox mainContainer = new VBox(5);
        mainContainer.getStyleClass().add("switch-block");
        mainContainer.getChildren().add(createStandardHeader(context, headerContent));

        // Cases Container
        VBox casesContainer = new VBox(5);
        casesContainer.getStyleClass().add("switch-cases");
        casesContainer.setPadding(new Insets(5, 0, 0, 20));

        for (int i = 0; i < cases.size(); i++) {
            SwitchCaseBlock caseBlock = cases.get(i);
            // Pass index context to control button visibility
            casesContainer.getChildren().add(caseBlock.createUINode(context, i, cases.size()));
        }

        mainContainer.getChildren().add(casesContainer);

        // Add Case Button at the bottom
        Button addCaseButton = new Button("+ Add Case");
        addCaseButton.getStyleClass().add("add-case-button");
        addCaseButton.setOnAction(e -> context.codeEditor().addCaseToSwitch((SwitchStatement) this.astNode));

        mainContainer.getChildren().add(addCaseButton);

        return mainContainer;
    }

    // Inner Static Class for Cases
    public static class SwitchCaseBlock extends AbstractStatementBlock implements BlockWithChildren {
        private ExpressionBlock caseExpression;
        private BodyBlock body;
        private final BlockDragAndDropManager dragAndDropManager;

        public SwitchCaseBlock(String id, SwitchCase astNode, BlockDragAndDropManager dragAndDropManager) {
            super(id, astNode);
            this.dragAndDropManager = dragAndDropManager;
        }

        public void setCaseExpression(ExpressionBlock caseExpression) { this.caseExpression = caseExpression; }
        public void setBody(BodyBlock body) { this.body = body; }
        public boolean isDefault() { return caseExpression == null; }

        @Override
        public List<CodeBlock> getChildren() {
            List<CodeBlock> children = new ArrayList<>();
            if (caseExpression != null) children.add(caseExpression);
            if (body != null) children.add(body);
            return children;
        }

        @Override
        protected Node createUINode(CompletionContext context) {
            // Use the overloaded version below
            return createUINode(context, -1, -1);
        }

        // Special render method that knows position
        public Node createUINode(CompletionContext context, int index, int totalCases) {
            HBox caseHeader = new HBox(5);

            // Case Label & Expression
            if (isDefault()) {
                caseHeader.getChildren().add(createKeywordLabel("default:"));
            } else {
                // 1. Determine Expected Type from Parent Switch
                String targetType = "any";
                if (this.astNode.getParent() instanceof SwitchStatement) {
                    SwitchStatement parent = (SwitchStatement) this.astNode.getParent();
                    Expression switchExpr = parent.getExpression();
                    if (switchExpr != null) {
                        ITypeBinding binding = switchExpr.resolveTypeBinding();
                        if (binding != null) {
                            targetType = TypeManager.determineUiType(binding.getName());
                        }
                    }
                }

                // 2. Create Change Button
                String finalTargetType = targetType;
                Button changeBtn = BlockUIComponents.createChangeButton(e ->
                        showExpressionMenuAndReplace((Button)e.getSource(), context, finalTargetType,
                                caseExpression != null ? (Expression) caseExpression.getAstNode() : null)
                );

                caseHeader.getChildren().addAll(
                        createKeywordLabel("case"),
                        getOrDropZone(caseExpression, context),
                        changeBtn,
                        createKeywordLabel(":")
                );
            }

            // Move Buttons
            if (index >= 0) {
                Button upBtn = new Button("▲");
                upBtn.setStyle("-fx-font-size: 9px; -fx-padding: 2 4 2 4;");
                upBtn.setDisable(index == 0);
                upBtn.setOnAction(e -> context.codeEditor().moveSwitchCase((SwitchCase) this.astNode, true));

                Button downBtn = new Button("▼");
                downBtn.setStyle("-fx-font-size: 9px; -fx-padding: 2 4 2 4;");
                downBtn.setDisable(index == totalCases - 1);
                downBtn.setOnAction(e -> context.codeEditor().moveSwitchCase((SwitchCase) this.astNode, false));

                caseHeader.getChildren().addAll(BlockUIComponents.createSpacer(), upBtn, downBtn);
            }

            // Delete Button
            caseHeader.getChildren().add(createDeleteButton(context));

            VBox container = new VBox(5);
            container.getStyleClass().add("switch-case-block");
            container.getChildren().add(caseHeader);

            VBox bodyNode = createIndentedBody(body, context, "switch-case-body");
            if (bodyNode != null) container.getChildren().add(bodyNode);

            return container;
        }
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\blocks\VariableDeclarationBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractStatementBlock;
import com.botmaker.core.ExpressionBlock;
import com.botmaker.lsp.CompletionContext;
import com.botmaker.ui.components.BlockUIComponents;
import com.botmaker.ui.components.TextFieldComponents;
import com.botmaker.util.TypeManager;
import javafx.geometry.Pos;
import javafx.scene.Cursor;
import javafx.scene.Node;
import javafx.scene.control.*;
import javafx.scene.layout.HBox;
import org.eclipse.jdt.core.dom.Type;
import org.eclipse.jdt.core.dom.VariableDeclarationFragment;
import org.eclipse.jdt.core.dom.VariableDeclarationStatement;

import static com.botmaker.ui.components.BlockUIComponents.createTypeLabel;

public class VariableDeclarationBlock extends AbstractStatementBlock {

    private final String variableName;
    private final Type variableType;
    private ExpressionBlock initializer;

    public VariableDeclarationBlock(String id, VariableDeclarationStatement astNode) {
        super(id, astNode);
        VariableDeclarationFragment fragment = (VariableDeclarationFragment) astNode.fragments().get(0);
        this.variableName = fragment.getName().getIdentifier();
        this.variableType = astNode.getType();
        this.initializer = null;
    }

    public void setInitializer(ExpressionBlock initializer) { this.initializer = initializer; }

    @Override
    protected Node createUINode(CompletionContext context) {
        // 1. Type Label with Menu
        Label typeLabel = createTypeLabel(getDisplayTypeName(variableType));
        typeLabel.setCursor(Cursor.HAND);
        Tooltip.install(typeLabel, new Tooltip("Click to change type (ArrayList/Base)"));
        typeLabel.setOnMouseClicked(e -> showTypeMenu(typeLabel, context));

        // 2. Name Field
        TextField nameField = TextFieldComponents.createVariableNameField(variableName, newName -> {
            VariableDeclarationFragment fragment = (VariableDeclarationFragment) ((VariableDeclarationStatement) this.astNode).fragments().get(0);
            if (!newName.equals(variableName) && !newName.isEmpty()) {
                context.codeEditor().replaceSimpleName(fragment.getName(), newName);
            }
        });

        // 3. Initializer Logic
        Node initNode;
        if (initializer != null) {
            // FIX: Restored original priority logic
            if (initializer instanceof ListBlock) {
                // Render ListBlock directly (it handles its own layout)
                initNode = initializer.getUINode(context);
            } else if (initializer.getAstNode() instanceof org.eclipse.jdt.core.dom.ArrayInitializer) {
                // Fallback for other array initializers (add bracket styling)
                initNode = createListDisplay(context);
            } else {
                // Standard expression
                initNode = initializer.getUINode(context);
            }
        } else {
            initNode = createExpressionDropZone(context);
        }

        // 4. Add Button
        String uiTargetType = TypeManager.determineUiType(variableType.toString());
        Button addButton = createAddButton(e ->
                showExpressionMenuAndReplace((Button)e.getSource(), context, uiTargetType,
                        initializer != null ? (org.eclipse.jdt.core.dom.Expression)initializer.getAstNode() : null)
        );

        Node content = createSentence(
                typeLabel,
                nameField,
                createKeywordLabel("="),
                initNode,
                addButton
        );

        HBox container = createStandardHeader(context, content);
        container.getStyleClass().add("variable-declaration-block");

        return container;
    }

    private void showTypeMenu(Node anchor, CompletionContext context) {
        ContextMenu menu = new ContextMenu();
        String currentStr = variableType.toString();
        boolean isArrayListType = isArrayList(variableType);
        boolean isArray = variableType.isArrayType();
        final String baseType = extractBaseType(currentStr, isArrayListType, isArray);

        // Toggle ArrayList
        MenuItem toggleList = new MenuItem(isArrayListType ? "Convert to Single Value" : "Convert to ArrayList");
        toggleList.setStyle("-fx-font-weight: bold;");
        toggleList.setOnAction(e -> {
            String newType = isArrayListType ? baseType : "ArrayList<" + TypeManager.toWrapperType(baseType) + ">";
            context.codeEditor().replaceVariableType((VariableDeclarationStatement) this.astNode, newType);
        });
        menu.getItems().add(toggleList);

        // Nested List Option
        if (isArrayListType) {
            MenuItem makeNested = new MenuItem("Make ArrayList of ArrayLists");
            makeNested.setOnAction(e -> {
                String newType = "ArrayList<ArrayList<" + TypeManager.toWrapperType(baseType) + ">>";
                context.codeEditor().replaceVariableType((VariableDeclarationStatement) this.astNode, newType);
            });
            menu.getItems().add(makeNested);
        }

        menu.getItems().add(new SeparatorMenuItem());

        // Change Base Type
        Menu changeBaseMenu = new Menu("Change Base Type");
        for (String type : TypeManager.getFundamentalTypeNames()) {
            MenuItem item = new MenuItem(type);
            item.setOnAction(e -> {
                String newType = isArrayListType ? "ArrayList<" + TypeManager.toWrapperType(type) + ">" : type;
                context.codeEditor().replaceVariableType((VariableDeclarationStatement) this.astNode, newType);
            });
            changeBaseMenu.getItems().add(item);
        }
        menu.getItems().add(changeBaseMenu);
        menu.show(anchor, javafx.geometry.Side.BOTTOM, 0, 0);
    }

    private String extractBaseType(String currentStr, boolean isArrayListType, boolean isArray) {
        if (isArrayListType && currentStr.contains("<")) {
            return currentStr.substring(currentStr.indexOf("<") + 1, currentStr.lastIndexOf(">"));
        } else if (isArray) {
            return currentStr.replace("[]", "");
        }
        return currentStr;
    }

    private HBox createListDisplay(CompletionContext context) {
        HBox listBox = new HBox(3);
        listBox.setAlignment(Pos.CENTER_LEFT);
        listBox.getStyleClass().add("inline-list-display");

        Label open = new Label("["); open.setStyle("-fx-font-weight: bold; -fx-font-size: 14px;");
        Label close = new Label("]"); close.setStyle("-fx-font-weight: bold; -fx-font-size: 14px;");

        listBox.getChildren().addAll(open, initializer.getUINode(context), close);
        return listBox;
    }

    private String getDisplayTypeName(Type type) {
        String typeName = type.toString();
        if (isArrayList(type)) return typeName;
        if (typeName.endsWith("[]")) return typeName.replace("[]", " list");
        return typeName;
    }

    private boolean isArrayList(Type type) {
        return type.toString().startsWith("ArrayList");
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\blocks\WaitBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractStatementBlock;
import com.botmaker.core.ExpressionBlock;
import com.botmaker.lsp.CompletionContext;
import javafx.scene.Node;
import org.eclipse.jdt.core.dom.Statement;

public class WaitBlock extends AbstractStatementBlock {

    private ExpressionBlock duration;

    public WaitBlock(String id, Statement astNode) {
        super(id, astNode);
    }

    public void setDuration(ExpressionBlock duration) {
        this.duration = duration;
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        Node content = createSentence(
                createKeywordLabel("Wait"),
                getOrDropZone(duration, context),
                createKeywordLabel("ms")
        );

        Node container = createStandardHeader(context, content);
        container.getStyleClass().add("wait-block");

        return container;
    }

    @Override
    public String getDetails() {
        return "Wait: " + (duration != null ? duration.getDetails() : "...");
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\blocks\WhileBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractStatementBlock;
import com.botmaker.core.BodyBlock;
import com.botmaker.core.BlockWithChildren;
import com.botmaker.core.CodeBlock;
import com.botmaker.core.ExpressionBlock;
import com.botmaker.lsp.CompletionContext;
import com.botmaker.ui.BlockDragAndDropManager;
import javafx.scene.Node;
import javafx.scene.control.Button;
import javafx.scene.layout.VBox;
import org.eclipse.jdt.core.dom.WhileStatement;
import java.util.ArrayList;
import java.util.List;

public class WhileBlock extends AbstractStatementBlock implements BlockWithChildren {

    private ExpressionBlock condition;
    private BodyBlock body;

    public WhileBlock(String id, WhileStatement astNode, BlockDragAndDropManager dragAndDropManager) {
        super(id, astNode);
    }

    public void setCondition(ExpressionBlock condition) { this.condition = condition; }
    public void setBody(BodyBlock body) { this.body = body; }

    @Override
    public List<CodeBlock> getChildren() {
        List<CodeBlock> children = new ArrayList<>();
        if (condition != null) children.add(condition);
        if (body != null) children.add(body);
        return children;
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        // 1. Create the Header Row: "while [condition] [+]"
        Button addButton = createAddButton(e ->
                showExpressionMenuAndReplace((Button)e.getSource(), context, "boolean",
                        condition != null ? (org.eclipse.jdt.core.dom.Expression) condition.getAstNode() : null)
        );

        Node headerContent = createSentence(
                createKeywordLabel("while"),
                getOrDropZone(condition, context),
                addButton
        );
        headerContent.getStyleClass().add("while-header");

        // 2. Create the Indented Body
        VBox bodyNode = createIndentedBody(body, context, "while-body");

        // 3. Assemble: Header + Body
        VBox mainContainer = new VBox(5);
        mainContainer.getStyleClass().add("while-block");

        // Use standard header wrapper for the top row (handles spacer & delete button)
        mainContainer.getChildren().add(createStandardHeader(context, headerContent));

        if (bodyNode != null) {
            mainContainer.getChildren().add(bodyNode);
        }

        return mainContainer;
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\config\ApplicationConfig.java
=================================================================================

package com.botmaker.config;

import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Locale;

public class ApplicationConfig {

    // ... [Existing Fields remain same] ...
    private final Path jdtServerPath;
    private final Path projectPath;
    private final Path workspaceDataPath;
    private final Path sourceFilePath;
    private final Path compiledOutputPath;
    private final String mainClassName;
    private final String javaHome;
    private final String javaExecutable;
    private final String javacExecutable;
    private final int initialWidth;
    private final int initialHeight;
    private final boolean enableEventLogging;

    private ApplicationConfig(Builder builder) {
        this.jdtServerPath = builder.jdtServerPath;
        this.projectPath = builder.projectPath;
        this.workspaceDataPath = builder.workspaceDataPath;
        this.sourceFilePath = builder.sourceFilePath;
        this.compiledOutputPath = builder.compiledOutputPath;
        this.mainClassName = builder.mainClassName;
        this.javaHome = builder.javaHome;
        this.javaExecutable = builder.javaExecutable;
        this.javacExecutable = builder.javacExecutable;
        this.initialWidth = builder.initialWidth;
        this.initialHeight = builder.initialHeight;
        this.enableEventLogging = builder.enableEventLogging;
    }

    // ... [Getters remain same] ...
    public Path getJdtServerPath() { return jdtServerPath; }
    public Path getProjectPath() { return projectPath; }
    public Path getWorkspaceDataPath() { return workspaceDataPath; }
    public Path getSourceFilePath() { return sourceFilePath; }
    public Path getCompiledOutputPath() { return compiledOutputPath; }
    public String getMainClassName() { return mainClassName; }
    public String getJavaHome() { return javaHome; }
    public String getJavaExecutable() { return javaExecutable; }
    public String getJavacExecutable() { return javacExecutable; }
    public int getInitialWidth() { return initialWidth; }
    public int getInitialHeight() { return initialHeight; }
    public boolean isEnableEventLogging() { return enableEventLogging; }

    public static ApplicationConfig forProject(String projectName) {
        String javaHome = System.getProperty("java.home");
        String packageName = projectName.toLowerCase();
        String mainClassName = projectName;

        // --- FIX: OS Detection for Executables ---
        boolean isWindows = System.getProperty("os.name").toLowerCase(Locale.ROOT).contains("win");
        String javaBin = isWindows ? "java.exe" : "java";
        String javacBin = isWindows ? "javac.exe" : "javac";

        return new Builder()
                .jdtServerPath(Paths.get("tools", "jdt-language-server")) // Use varargs for separator safety
                .projectPath(Paths.get("projects", projectName))
                .workspaceDataPath(Paths.get(System.getProperty("user.home"), ".jdtls-workspace", projectName))
                .sourceFilePath(Paths.get("projects", projectName, "src", "main", "java", "com", packageName, mainClassName + ".java"))
                .compiledOutputPath(Paths.get("projects", projectName, "build", "classes", "java", "main"))
                .mainClassName("com." + packageName + "." + mainClassName)
                .javaHome(javaHome)
                .javaExecutable(Paths.get(javaHome, "bin", javaBin).toString())
                .javacExecutable(Paths.get(javaHome, "bin", javacBin).toString())
                .initialWidth(600)
                .initialHeight(800)
                .enableEventLogging(false)
                .build();
    }

    // ... [Builder Class remains same] ...
    public static class Builder {
        private Path jdtServerPath;
        private Path projectPath;
        private Path workspaceDataPath;
        private Path sourceFilePath;
        private Path compiledOutputPath;
        private String mainClassName;
        private String javaHome;
        private String javaExecutable;
        private String javacExecutable;
        private int initialWidth = 600;
        private int initialHeight = 800;
        private boolean enableEventLogging = false;

        public Builder jdtServerPath(Path jdtServerPath) { this.jdtServerPath = jdtServerPath; return this; }
        public Builder projectPath(Path projectPath) { this.projectPath = projectPath; return this; }
        public Builder workspaceDataPath(Path workspaceDataPath) { this.workspaceDataPath = workspaceDataPath; return this; }
        public Builder sourceFilePath(Path sourceFilePath) { this.sourceFilePath = sourceFilePath; return this; }
        public Builder compiledOutputPath(Path compiledOutputPath) { this.compiledOutputPath = compiledOutputPath; return this; }
        public Builder mainClassName(String mainClassName) { this.mainClassName = mainClassName; return this; }
        public Builder javaHome(String javaHome) { this.javaHome = javaHome; return this; }
        public Builder javaExecutable(String javaExecutable) { this.javaExecutable = javaExecutable; return this; }
        public Builder javacExecutable(String javacExecutable) { this.javacExecutable = javacExecutable; return this; }
        public Builder initialWidth(int initialWidth) { this.initialWidth = initialWidth; return this; }
        public Builder initialHeight(int initialHeight) { this.initialHeight = initialHeight; return this; }
        public Builder enableEventLogging(boolean enableEventLogging) { this.enableEventLogging = enableEventLogging; return this; }

        public ApplicationConfig build() {
            if (jdtServerPath == null) throw new IllegalStateException("jdtServerPath is required");
            if (projectPath == null) throw new IllegalStateException("projectPath is required");
            if (mainClassName == null) throw new IllegalStateException("mainClassName is required");
            return new ApplicationConfig(this);
        }
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\config\Constants.java
=================================================================================

package com.botmaker.config;

/**
 * Application-wide constants
 */
public class Constants {

    // Debugger Configuration
    public static final int DEBUGGER_MAX_CONNECT_RETRIES = 10;
    public static final int DEBUGGER_RETRY_DELAY_MS = 250;
    public static final int DEBUGGER_SHUTDOWN_TIMEOUT_SECONDS = 2;
    public static final int DEBUGGER_EXIT_DELAY_MS = 500;

    // Thread Sleep Times
    public static final int SHORT_SLEEP_MS = 500;

    // JVM Options
    public static final String JVM_MAX_HEAP = "-Xmx1G";
    public static final String JVM_ENTITY_SIZE_LIMIT = "-Djdk.xml.maxGeneralEntitySizeLimit=0";
    public static final String JVM_TOTAL_ENTITY_SIZE_LIMIT = "-Djdk.xml.totalEntitySizeLimit=0";

    // LSP Configuration
    public static final String LSP_DETECT_VM_DISABLED = "-DDetectVMInstallationsJob.disabled=true";
    public static final String LSP_FILE_ENCODING = "-Dfile.encoding=UTF-8";
    public static final String LSP_LOG_DISABLE = "-Xlog:disable";
    public static final String LSP_DEPENDENCY_COLLECTOR = "-Daether.dependencyCollector.impl=bf";

    // Debug Flags (disable for production)
    public static final boolean LSP_LOG_PROTOCOL = true;
    public static final String LSP_LOG_LEVEL = "ALL";

    private Constants() {} // Prevent instantiation
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\core\AbstractCodeBlock.java
=================================================================================

package com.botmaker.core;

import com.botmaker.lsp.CompletionContext;
import javafx.beans.binding.Bindings;
import javafx.geometry.Insets;
import javafx.scene.Node;
import javafx.scene.control.ContextMenu;
import javafx.scene.control.MenuItem;
import javafx.scene.control.Tooltip;
import javafx.scene.layout.Pane;
import javafx.scene.layout.Region;
import javafx.scene.paint.Color;
import javafx.scene.shape.Circle;
import org.eclipse.jdt.core.dom.ASTNode;
import org.eclipse.jdt.core.dom.CompilationUnit;

public abstract class AbstractCodeBlock implements CodeBlock {
    protected final String id;
    protected final ASTNode astNode;

    protected Node uiNode;
    private javafx.scene.control.Tooltip errorTooltip;

    // Breakpoint State
    protected boolean isBreakpoint = false;
    private Circle breakpointCircle;

    // Constants
    private static final double GUTTER_PADDING = 12.0; // Space reserved on the left
    private static final double CIRCLE_RADIUS = 4.0;

    public AbstractCodeBlock(String id, ASTNode astNode) {
        this.id = id;
        this.astNode = astNode;
    }

    @Override
    public String getId() { return id; }

    @Override
    public ASTNode getAstNode() { return astNode; }

    @Override
    public Node getUINode(CompletionContext context) {
        if (uiNode == null) {
            // 1. Create the standard UI
            this.uiNode = createUINode(context);

            // 2. Inject the visual Gutter (Padding + Circle)
            if (uiNode instanceof Region) {
                Region region = (Region) uiNode;

                // Add left padding to make room for the circle
                Insets existing = region.getPadding();
                region.setPadding(new Insets(
                        existing.getTop(),
                        existing.getRight(),
                        existing.getBottom(),
                        existing.getLeft() + GUTTER_PADDING
                ));

                // If the UI node allows children (Pane), add the floating circle
                if (uiNode instanceof Pane) {
                    Pane pane = (Pane) uiNode;

                    breakpointCircle = new Circle(CIRCLE_RADIUS, Color.RED);
                    breakpointCircle.setManaged(false); // Don't affect flow layout
                    breakpointCircle.setVisible(false); // Hidden by default

                    // Position: Center vertically, placed inside the left padding
                    // x = (Padding / 2) roughly centers it in the gutter
                    breakpointCircle.setLayoutX(GUTTER_PADDING / 2 + existing.getLeft());
                    breakpointCircle.centerYProperty().bind(pane.heightProperty().divide(2));

                    pane.getChildren().add(breakpointCircle);
                }
            }

            // 3. Setup Interaction
            setupBreakpointInteraction();

            // 4. Discovery Tooltip
            Tooltip tip = new Tooltip("Right-click to toggle breakpoint");
            Tooltip.install(uiNode, tip);
        }

        updateBreakpointVisuals();
        return uiNode;
    }

    private void setupBreakpointInteraction() {
        if (uiNode == null) return;

        ContextMenu contextMenu = new ContextMenu();
        MenuItem toggleBpItem = new MenuItem("Toggle Breakpoint");
        toggleBpItem.setOnAction(ev -> toggleBreakpoint());
        contextMenu.getItems().add(toggleBpItem);

        uiNode.setOnContextMenuRequested(e -> {
            toggleBpItem.setText(isBreakpoint ? "Remove Breakpoint 🔴" : "Add Breakpoint ⚪");
            contextMenu.show(uiNode, e.getScreenX(), e.getScreenY());
            e.consume();
        });
    }

    @Override
    public Node getUINode() { return uiNode; }

    @Override
    public void highlight() {
        if (uiNode != null && !uiNode.getStyleClass().contains("highlighted")) {
            uiNode.getStyleClass().add("highlighted");
        }
    }

    @Override
    public void unhighlight() {
        if (uiNode != null) {
            uiNode.getStyleClass().remove("highlighted");
        }
    }

    @Override
    public void setError(String message) {
        if (uiNode != null) {
            if (!uiNode.getStyleClass().contains("error-block")) {
                uiNode.getStyleClass().add("error-block");
            }
            if (errorTooltip == null) {
                errorTooltip = new Tooltip(message);
                Tooltip.install(uiNode, errorTooltip);
            } else {
                errorTooltip.setText(message);
            }
        }
    }

    @Override
    public void clearError() {
        if (uiNode != null) {
            uiNode.getStyleClass().remove("error-block");
            if (errorTooltip != null) {
                Tooltip.uninstall(uiNode, errorTooltip);
                errorTooltip = null;
            }
        }
    }

    @Override
    public int getBreakpointLine(CompilationUnit cu) {
        if (cu == null || astNode == null) return -1;
        return cu.getLineNumber(astNode.getStartPosition());
    }

    @Override
    public CodeBlock getHighlightTarget() { return this; }

    @Override
    public String getDetails() {
        return this.getClass().getSimpleName() + " (ID: " + this.getId() + ")";
    }

    @Override
    public boolean isBreakpoint() { return isBreakpoint; }

    @Override
    public void setBreakpoint(boolean enabled) {
        this.isBreakpoint = enabled;
        updateBreakpointVisuals();
    }

    @Override
    public void toggleBreakpoint() {
        setBreakpoint(!isBreakpoint);
        if (uiNode != null) {
            uiNode.fireEvent(new com.botmaker.ui.BlockEvent.BreakpointToggleEvent(this, isBreakpoint));
        }
    }

    private void updateBreakpointVisuals() {
        // Update the circle visibility
        if (breakpointCircle != null) {
            breakpointCircle.setVisible(isBreakpoint);
        }

        // Optional: Keep the red border as secondary reinforcement, or remove if circle is enough
        if (uiNode != null) {
            String style = uiNode.getStyle();
            String borderStyle = "-fx-border-color: #e74c3c; -fx-border-width: 0 0 0 2; -fx-border-style: solid;";

            if (isBreakpoint) {
                if (!style.contains("-fx-border-color: #e74c3c")) {
                    uiNode.setStyle(style + borderStyle);
                }
            } else {
                uiNode.setStyle(style.replace(borderStyle, ""));
            }
        }
    }

    protected Node createExpressionDropZone(CompletionContext context) {
        Region dropZone = new Region();
        context.dragAndDropManager().addExpressionDropHandlers(dropZone);
        return dropZone;
    }

    protected abstract Node createUINode(CompletionContext context);
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\core\AbstractExpressionBlock.java
=================================================================================

package com.botmaker.core;

import com.botmaker.lsp.CompletionContext;
import com.botmaker.ui.components.BlockUIComponents;
import com.botmaker.ui.components.SelectorComponents;
import javafx.scene.control.Button;
import javafx.scene.control.ComboBox;
import javafx.scene.control.Label;
import org.eclipse.jdt.core.dom.ASTNode;
import org.eclipse.jdt.core.dom.Expression;

import java.util.function.Consumer;

public abstract class AbstractExpressionBlock extends AbstractCodeBlock implements ExpressionBlock {
    public AbstractExpressionBlock(String id, ASTNode astNode) {
        super(id, astNode);
    }

    // --- HELPER METHODS ---

    protected Label createKeywordLabel(String text) {
        return BlockUIComponents.createKeywordLabel(text);
    }

    protected Label createOperatorLabel(String text) {
        return BlockUIComponents.createOperatorLabel(text);
    }

    protected ComboBox<String> createOperatorSelector(String[] names, String[] symbols, String currentSymbol, Consumer<String> onSymbolChange) {
        return SelectorComponents.createOperatorSelector(names, symbols, currentSymbol, onSymbolChange);
    }

    /**
     * Helper to show the expression type menu and replace the current expression node upon selection.
     */
    protected void showExpressionMenuAndReplace(Button button, CompletionContext context, String targetType, Expression toReplace) {
        BlockUIComponents.createExpressionTypeMenu(targetType, type -> {
            if (toReplace != null) {
                context.codeEditor().replaceExpression(toReplace, type);
            }
        }).show(button, javafx.geometry.Side.BOTTOM, 0, 0);
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\core\AbstractStatementBlock.java
=================================================================================

package com.botmaker.core;

import com.botmaker.lsp.CompletionContext;
import com.botmaker.ui.components.BlockUIComponents;
import com.botmaker.ui.components.LayoutComponents;
import com.botmaker.ui.components.PlaceholderComponents;
import javafx.scene.Node;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.layout.HBox;
import org.eclipse.jdt.core.dom.ASTNode;
import org.eclipse.jdt.core.dom.Expression;
import org.eclipse.jdt.core.dom.Statement;

import java.util.function.Consumer;

public abstract class AbstractStatementBlock extends AbstractCodeBlock implements StatementBlock {
    public AbstractStatementBlock(String id, ASTNode astNode) {
        super(id, astNode);
    }

    // --- HELPER METHODS ---

    protected Button createDeleteButton(CompletionContext context) {
        return BlockUIComponents.createDeleteButton(() ->
                context.codeEditor().deleteStatement((Statement) this.astNode)
        );
    }

    protected Label createKeywordLabel(String text) {
        return BlockUIComponents.createKeywordLabel(text);
    }

    protected HBox createStandardHeader(CompletionContext context, Node... content) {
        HBox container = BlockUIComponents.createHeaderRow(
                () -> context.codeEditor().deleteStatement((Statement) this.astNode),
                content
        );
        // Apply default styles that might be overridden by specific blocks
        container.getStyleClass().add("statement-block-header");
        return container;
    }

    protected Button createAddButton(javafx.event.EventHandler<javafx.event.ActionEvent> handler) {
        return BlockUIComponents.createAddButton(handler);
    }

    /**
     * Creates an indented body VBox for nested statements.
     */
    protected javafx.scene.layout.VBox createIndentedBody(com.botmaker.core.BodyBlock body, CompletionContext context, String styleClass) {
        Node bodyNode = (body != null) ? body.getUINode(context) : null;
        return LayoutComponents.createIndentedBody(bodyNode, styleClass);
    }

    /**
     * Helper to render an expression or a drop zone if null.
     */
    protected Node getOrDropZone(com.botmaker.core.ExpressionBlock expr, CompletionContext context) {
        return PlaceholderComponents.createExpressionOrDropZone(
                expr,
                context,
                () -> createExpressionDropZone(context) // Defined in AbstractCodeBlock
        );
    }

    /**
     * Helper to create a sentence row (e.g. for loops).
     */
    protected javafx.scene.layout.HBox createSentence(Node... nodes) {
        return LayoutComponents.createSentenceRow(nodes);
    }

    protected void showExpressionMenuAndReplace(Button button, CompletionContext context, String targetType, Expression toReplace) {
        BlockUIComponents.createExpressionTypeMenu(targetType, type -> {
            if (toReplace != null) {
                context.codeEditor().replaceExpression(toReplace, type);
            } else if (this instanceof com.botmaker.blocks.ReturnBlock) {
                // Special case for ReturnBlock which might accept null
                // Handled by specific implementations usually, but good for generic replacement
            }
        }).show(button, javafx.geometry.Side.BOTTOM, 0, 0);
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\core\BlockWithChildren.java
=================================================================================

package com.botmaker.core;

import java.util.List;

public interface BlockWithChildren {
    List<CodeBlock> getChildren();
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\core\BodyBlock.java
=================================================================================

package com.botmaker.core;

import com.botmaker.core.AbstractStatementBlock;
import com.botmaker.lsp.CompletionContext;
import com.botmaker.ui.BlockDragAndDropManager;
import javafx.scene.Cursor;
import javafx.scene.Node;
import javafx.scene.layout.Priority;
import javafx.scene.layout.VBox;
import org.eclipse.jdt.core.dom.Block;
import org.eclipse.jdt.core.dom.Statement; // Changed from Block

import java.util.ArrayList;
import java.util.List;

public class BodyBlock extends AbstractStatementBlock implements BlockWithChildren {
    private final List<StatementBlock> statements = new ArrayList<>();
    private final BlockDragAndDropManager dragAndDropManager;

    // FIX: Changed parameter from Block to Statement to allow SwitchCase
    public BodyBlock(String id, Statement astNode, BlockDragAndDropManager dragAndDropManager) {
        super(id, astNode);
        this.dragAndDropManager = dragAndDropManager;
    }

    public void addStatement(StatementBlock statement) {
        statements.add(statement);
    }

    public List<StatementBlock> getStatements() {
        return new ArrayList<>(statements);
    }

    public void removeStatement(StatementBlock statement) {
        statements.remove(statement);
    }

    public void insertStatement(int index, StatementBlock statement) {
        if (index < 0 || index > statements.size()) {
            throw new IndexOutOfBoundsException("Index: " + index + ", Size: " + statements.size());
        }
        statements.add(index, statement);
    }

    @Override
    public List<CodeBlock> getChildren() {
        return new ArrayList<>(statements);
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        VBox container = new VBox();
        container.getStyleClass().add("body-block");
        VBox.setVgrow(container, Priority.ALWAYS);

        if (statements.isEmpty()) {
            javafx.scene.control.Label placeholder = new javafx.scene.control.Label("Drag block here");
            placeholder.getStyleClass().add("empty-body-placeholder");
            placeholder.setMouseTransparent(true);
            container.getChildren().add(placeholder);
            container.setAlignment(javafx.geometry.Pos.CENTER);
            container.setMinHeight(30);
            dragAndDropManager.addEmptyBodyDropHandlers(container, this);
        } else {
            container.getChildren().add(createSeparatorWithHandlers(this, 0));

            for (int i = 0; i < statements.size(); i++) {
                StatementBlock statement = statements.get(i);
                Node statementNode = statement.getUINode(context);
                makeStatementDraggable(statementNode, statement);
                container.getChildren().add(statementNode);
                container.getChildren().add(createSeparatorWithHandlers(this, i + 1));
            }
        }
        return container;
    }

    private void makeStatementDraggable(Node statementNode, StatementBlock statement) {
        statementNode.setOnMouseEntered(e -> statementNode.setCursor(Cursor.OPEN_HAND));
        statementNode.setOnMouseExited(e -> statementNode.setCursor(Cursor.DEFAULT));
        dragAndDropManager.makeBlockMovable(statementNode, statement, this);
    }

    private Node createSeparatorWithHandlers(BodyBlock targetBody, int insertionIndex) {
        javafx.scene.layout.Region separator = dragAndDropManager.createSeparator();
        separator.getStyleClass().add("body-block-separator");
        StatementBlock adjacentBlock = (insertionIndex < statements.size()) ? statements.get(insertionIndex) : null;
        dragAndDropManager.addSeparatorDragHandlers(separator, targetBody, insertionIndex, adjacentBlock);
        return separator;
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\core\CodeBlock.java
=================================================================================

package com.botmaker.core;

import com.botmaker.lsp.CompletionContext;
import javafx.scene.Node;
import org.eclipse.jdt.core.dom.ASTNode;
import org.eclipse.jdt.core.dom.CompilationUnit;

public interface CodeBlock {
    String getId();
    ASTNode getAstNode();
    Node getUINode(CompletionContext context);
    Node getUINode();

    // Visual State
    void highlight();
    void unhighlight();
    void setError(String message);
    void clearError();

    // Breakpoint Logic
    void setBreakpoint(boolean enabled);
    boolean isBreakpoint();
    void toggleBreakpoint();

    // Debugging
    int getBreakpointLine(CompilationUnit cu);
    CodeBlock getHighlightTarget();
    String getDetails();
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\core\ExpressionBlock.java
=================================================================================

package com.botmaker.core;

/**
 * A block that represents a value that can be evaluated.
 * Examples: a literal "hello", a variable `x`, a calculation `2 + 2`.
 */
public interface ExpressionBlock extends CodeBlock {
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\core\StatementBlock.java
=================================================================================

package com.botmaker.core;

/**
 * A block that represents a complete action or step in execution.
 * Examples: a variable declaration, an if-statement, a method call.
 */
public interface StatementBlock extends CodeBlock {
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\di\DependencyContainer.java
=================================================================================

package com.botmaker.di;

import java.util.HashMap;
import java.util.Map;
import java.util.function.Supplier;

/**
 * Simple dependency injection container.
 * Manages service lifecycle and provides dependency resolution.
 * Phase 3: Fixed ConcurrentModificationException
 */
public class DependencyContainer {

    private final Map<Class<?>, Object> singletons = new HashMap<>();
    private final Map<Class<?>, Supplier<?>> factories = new HashMap<>();

    /**
     * Register a singleton instance
     */
    public <T> void registerSingleton(Class<T> type, T instance) {
        if (instance == null) {
            throw new IllegalArgumentException("Instance cannot be null");
        }
        singletons.put(type, instance);
    }

    /**
     * Register a factory for creating instances
     */
    public <T> void registerFactory(Class<T> type, Supplier<T> factory) {
        if (factory == null) {
            throw new IllegalArgumentException("Factory cannot be null");
        }
        factories.put(type, factory);
    }

    /**
     * Register a lazy singleton using a factory
     * The instance will be created on first access and cached
     */
    public <T> void registerLazySingleton(Class<T> type, Supplier<T> factory) {
        if (factory == null) {
            throw new IllegalArgumentException("Factory cannot be null");
        }
        factories.put(type, factory);
    }

    /**
     * Resolve a dependency
     */
    @SuppressWarnings("unchecked")
    public <T> T resolve(Class<T> type) {
        // Check if we have a singleton instance
        Object instance = singletons.get(type);
        if (instance != null) {
            return (T) instance;
        }

        // Check if we have a factory
        Supplier<?> factory = factories.get(type);
        if (factory != null) {
            // PHASE 3 FIX: Create instance first, then cache it
            // This avoids ConcurrentModificationException
            T newInstance = (T) factory.get();

            // Cache the instance for future use
            singletons.put(type, newInstance);

            // Remove the factory since we don't need it anymore
            // (optional - keeps memory clean)
            factories.remove(type);

            return newInstance;
        }

        throw new IllegalStateException("No registration found for type: " + type.getName());
    }

    /**
     * Check if a type is registered
     */
    public boolean isRegistered(Class<?> type) {
        return singletons.containsKey(type) || factories.containsKey(type);
    }

    /**
     * Remove a registration
     */
    public void unregister(Class<?> type) {
        singletons.remove(type);
        factories.remove(type);
    }

    /**
     * Clear all registrations
     */
    public void clear() {
        singletons.clear();
        factories.clear();
    }

    /**
     * Get count of registered types
     */
    public int getRegistrationCount() {
        return singletons.size() + factories.size();
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\events\AbstractApplicationEvent.java
=================================================================================

package com.botmaker.events;

/**
 * Abstract base class for events that provides common functionality
 */
public abstract class AbstractApplicationEvent implements ApplicationEvent {
    private final long timestamp;
    private final String source;

    protected AbstractApplicationEvent() {
        this(null);
    }

    protected AbstractApplicationEvent(String source) {
        this.timestamp = System.currentTimeMillis();
        this.source = source != null ? source : getClass().getSimpleName();
    }

    @Override
    public long getTimestamp() {
        return timestamp;
    }

    @Override
    public String getSource() {
        return source;
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\events\ApplicationEvent.java
=================================================================================

package com.botmaker.events;

/**
 * Base interface for all application events.
 * Events represent things that have happened in the application.
 */
public interface ApplicationEvent {
    /**
     * Timestamp when the event was created
     */
    long getTimestamp();

    /**
     * Optional source identifier for debugging
     */
    default String getSource() {
        return getClass().getSimpleName();
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\events\CoreApplicationEvents.java
=================================================================================

package com.botmaker.events;

import com.botmaker.core.AbstractCodeBlock;
import com.botmaker.core.CodeBlock;
import org.eclipse.lsp4j.Diagnostic;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

public class CoreApplicationEvents {



    public static class CodeUpdatedEvent extends AbstractApplicationEvent {
        private final String newCode;
        private final String previousCode;
        public CodeUpdatedEvent(String newCode, String previousCode) {
            this.newCode = newCode;
            this.previousCode = previousCode;
        }
        public String getNewCode() { return newCode; }
        public String getPreviousCode() { return previousCode; }
    }

    public static class DiagnosticsUpdatedEvent extends AbstractApplicationEvent {
        private final List<Diagnostic> diagnostics;
        public DiagnosticsUpdatedEvent(List<Diagnostic> diagnostics) {
            this.diagnostics = diagnostics != null ? List.copyOf(diagnostics) : Collections.emptyList();
        }
        public List<Diagnostic> getDiagnostics() { return diagnostics; }
    }

    public static class UIRefreshRequestedEvent extends AbstractApplicationEvent {
        private final String code;
        public UIRefreshRequestedEvent(String code) { this.code = code; }
        public String getCode() { return code; }
    }

    public static class BlockHighlightEvent extends AbstractApplicationEvent {
        private final CodeBlock block;
        public BlockHighlightEvent(CodeBlock block) { this.block = block; }
        public CodeBlock getBlock() { return block; }
    }



    public static class UIBlocksUpdatedEvent extends AbstractApplicationEvent {
        private final AbstractCodeBlock rootBlock;

        public UIBlocksUpdatedEvent(AbstractCodeBlock rootBlock) {
            super("CodeEditorService");
            this.rootBlock = rootBlock;
        }

        public AbstractCodeBlock getRootBlock() { return rootBlock; }
    }

    public static class CompilationRequestedEvent extends AbstractApplicationEvent {}
    public static class ExecutionRequestedEvent extends AbstractApplicationEvent {}
    public static class DebugStartRequestedEvent extends AbstractApplicationEvent {}

    public static class DebugSessionStartedEvent extends AbstractApplicationEvent {}
    public static class DebugSessionResumedEvent extends AbstractApplicationEvent {}
    public static class DebugSessionFinishedEvent extends AbstractApplicationEvent {}

    public static class DebugSessionPausedEvent extends AbstractApplicationEvent {
        private final int lineNumber;
        private final CodeBlock block;
        public DebugSessionPausedEvent(int lineNumber, CodeBlock block) {
            this.lineNumber = lineNumber;
            this.block = block;
        }
        public int getLineNumber() { return lineNumber; }
        public CodeBlock getBlock() { return block; }
    }

    public static class StatusMessageEvent extends AbstractApplicationEvent {
        private final String message;
        public StatusMessageEvent(String message) { this.message = message; }
        public String getMessage() { return message; }
    }

    // Inside CoreApplicationEvents class


    public static class OutputAppendedEvent extends AbstractApplicationEvent {
        private final String text;
        public OutputAppendedEvent(String text) { this.text = text; }
        public String getText() { return text; }
    }

    public static class OutputClearedEvent extends AbstractApplicationEvent {}
    public static class OutputSetEvent extends AbstractApplicationEvent {
        private final String text;
        public OutputSetEvent(String text) { this.text = text; }
        public String getText() { return text; }
    }

    public static class UndoRequestedEvent extends AbstractApplicationEvent {
        public UndoRequestedEvent() { super("User"); }
    }

    public static class RedoRequestedEvent extends AbstractApplicationEvent {
        public RedoRequestedEvent() { super("User"); }
    }

    /**
     * Fired whenever the history stack changes (to enable/disable UI buttons)
     */
    public static class HistoryStateChangedEvent extends AbstractApplicationEvent {
        private final boolean canUndo;
        private final boolean canRedo;

        public HistoryStateChangedEvent(boolean canUndo, boolean canRedo) {
            this.canUndo = canUndo;
            this.canRedo = canRedo;
        }

        public boolean canUndo() { return canUndo; }
        public boolean canRedo() { return canRedo; }
    }


    // ADD THESE EVENT CLASSES TO CoreApplicationEvents.java:

    /**
     * Fired when a user requests to stop the currently running program
     */
    public static class StopRunRequestedEvent extends AbstractApplicationEvent {
        public StopRunRequestedEvent() {
            super("User");
        }
    }

    /**
     * Fired when a program starts executing (not debugging)
     */
    public static class ProgramStartedEvent extends AbstractApplicationEvent {
        public ProgramStartedEvent() {
            super("ExecutionService");
        }
    }

    /**
     * Fired when a program stops executing (completed or terminated)
     */
    public static class ProgramStoppedEvent extends AbstractApplicationEvent {
        public ProgramStoppedEvent() {
            super("ExecutionService");
        }
    }
    /**
     * Fired when a user wants to step over the current line
     */
    public static class DebugStepOverRequestedEvent extends AbstractApplicationEvent {
        public DebugStepOverRequestedEvent() {
            super("User");
        }
    }

    public static class DebugStopRequestedEvent extends AbstractApplicationEvent {
        public DebugStopRequestedEvent() {
            super("User");
        }
    }

    /**
     * Fired when a user wants to continue execution until the next breakpoint
     */
    public static class DebugContinueRequestedEvent extends AbstractApplicationEvent {
        public DebugContinueRequestedEvent() {
            super("User");
        }
    }

    /**
     * Fired when a user toggles a breakpoint on a block
     */
    public static class BreakpointToggledEvent extends AbstractApplicationEvent {
        private final CodeBlock block;
        private final boolean isEnabled;

        public BreakpointToggledEvent(CodeBlock block, boolean isEnabled) {
            super("User");
            this.block = block;
            this.isEnabled = isEnabled;
        }

        public CodeBlock getBlock() { return block; }
        public boolean isEnabled() { return isEnabled; }
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\events\EventBus.java
=================================================================================

package com.botmaker.events;

import javafx.application.Platform;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.function.Consumer;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * Central event bus for application-wide event communication.
 * Thread-safe and supports both synchronous and asynchronous event delivery.
 */
public class EventBus {
    private static final Logger LOGGER = Logger.getLogger(EventBus.class.getName());

    private final Map<Class<? extends ApplicationEvent>, List<EventHandler<?>>> handlers;
    // NEW: List for listeners that want to receive EVERY event (like the Event Log)
    private final List<Consumer<ApplicationEvent>> globalListeners;
    private final boolean enableLogging;

    public EventBus() {
        this(false);
    }

    public EventBus(boolean enableLogging) {
        this.handlers = new ConcurrentHashMap<>();
        this.globalListeners = new CopyOnWriteArrayList<>(); // NEW
        this.enableLogging = enableLogging;
    }

    /**
     * Subscribe to events of a specific type
     */
    public <T extends ApplicationEvent> void subscribe(Class<T> eventType, Consumer<T> handler) {
        subscribe(eventType, handler, false);
    }

    /**
     * Subscribe to events with option to run on JavaFX thread
     */
    public <T extends ApplicationEvent> void subscribe(
            Class<T> eventType,
            Consumer<T> handler,
            boolean runOnFxThread) {

        handlers.computeIfAbsent(eventType, k -> new CopyOnWriteArrayList<>())
                .add(new EventHandler<>(handler, runOnFxThread));

        if (enableLogging) {
            LOGGER.info("Subscribed to " + eventType.getSimpleName());
        }
    }

    /**
     * NEW: Subscribe to ALL events passing through the bus.
     * Useful for logging and debugging consoles.
     */
    public void subscribeAll(Consumer<ApplicationEvent> listener) {
        globalListeners.add(listener);
    }

    /**
     * Publish an event to all subscribers
     */
    public void publish(ApplicationEvent event) {
        if (event == null) {
            return;
        }

        if (enableLogging) {
            LOGGER.info("Publishing: " + event.getSource());
        }

        // 1. Notify specific handlers
        Class<? extends ApplicationEvent> eventType = event.getClass();
        List<EventHandler<?>> eventHandlers = handlers.get(eventType);

        if (eventHandlers != null && !eventHandlers.isEmpty()) {
            for (EventHandler<?> handler : eventHandlers) {
                try {
                    handler.handle(event);
                } catch (Exception e) {
                    LOGGER.log(Level.SEVERE, "Error handling event: " + eventType.getSimpleName(), e);
                }
            }
        } else if (enableLogging) {
            LOGGER.warning("No specific handlers for event: " + eventType.getSimpleName());
        }

        // 2. NEW: Notify global listeners
        for (Consumer<ApplicationEvent> globalListener : globalListeners) {
            try {
                globalListener.accept(event);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }

    /**
     * Unsubscribe a specific handler from an event type
     */
    public <T extends ApplicationEvent> void unsubscribe(Class<T> eventType, Consumer<T> handler) {
        List<EventHandler<?>> eventHandlers = handlers.get(eventType);
        if (eventHandlers != null) {
            eventHandlers.removeIf(h -> h.getHandler() == handler);
        }
    }

    /**
     * Clear all handlers for a specific event type
     */
    public void clearHandlers(Class<? extends ApplicationEvent> eventType) {
        handlers.remove(eventType);
    }

    /**
     * Clear all handlers
     */
    public void clearAllHandlers() {
        handlers.clear();
        globalListeners.clear(); // NEW
    }

    public int getHandlerCount(Class<? extends ApplicationEvent> eventType) {
        List<EventHandler<?>> eventHandlers = handlers.get(eventType);
        return eventHandlers != null ? eventHandlers.size() : 0;
    }

    private static class EventHandler<T extends ApplicationEvent> {
        private final Consumer<T> handler;
        private final boolean runOnFxThread;

        EventHandler(Consumer<T> handler, boolean runOnFxThread) {
            this.handler = handler;
            this.runOnFxThread = runOnFxThread;
        }

        @SuppressWarnings("unchecked")
        void handle(ApplicationEvent event) {
            if (runOnFxThread && !Platform.isFxApplicationThread()) {
                Platform.runLater(() -> handler.accept((T) event));
            } else {
                handler.accept((T) event);
            }
        }

        Consumer<T> getHandler() {
            return handler;
        }
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\init\AppDependencyConfigurator.java
=================================================================================

package com.botmaker.init;

import com.botmaker.config.ApplicationConfig;
import com.botmaker.di.DependencyContainer;
import com.botmaker.events.EventBus;
import com.botmaker.parser.AstRewriter;
import com.botmaker.parser.BlockFactory;
import com.botmaker.parser.NodeCreator;
import com.botmaker.runtime.CodeExecutionService;
import com.botmaker.services.*;
import com.botmaker.state.ApplicationState;
import com.botmaker.ui.BlockDragAndDropManager;
import com.botmaker.ui.UIManager;
import com.botmaker.validation.DiagnosticsManager;
import javafx.stage.Stage;

public class AppDependencyConfigurator {

    public static void configure(DependencyContainer container, ApplicationConfig config, Stage primaryStage) {
        // Core Config & State
        container.registerSingleton(ApplicationConfig.class, config);
        container.registerSingleton(ApplicationState.class, new ApplicationState());
        container.registerSingleton(EventBus.class, new EventBus(config.isEnableEventLogging()));

        // Parsing & AST
        container.registerSingleton(BlockFactory.class, new BlockFactory());
        container.registerSingleton(NodeCreator.class, new NodeCreator());
        container.registerLazySingleton(AstRewriter.class, () ->
                new AstRewriter(container.resolve(NodeCreator.class)));

        // UI Helpers & Validation
        container.registerSingleton(DiagnosticsManager.class, new DiagnosticsManager());
        container.registerSingleton(BlockDragAndDropManager.class, new BlockDragAndDropManager(null));

        // Services
        registerServices(container);

        // UI Manager (Requires Stage)
        container.registerLazySingleton(UIManager.class, () -> {
            return new UIManager(
                    container.resolve(BlockDragAndDropManager.class),
                    container.resolve(EventBus.class),
                    container.resolve(CodeEditorService.class),
                    container.resolve(DiagnosticsManager.class),
                    primaryStage,
                    // New Dependencies:
                    container.resolve(ApplicationConfig.class),
                    container.resolve(ApplicationState.class)
            );
        });
    }

    private static void registerServices(DependencyContainer container) {
        container.registerLazySingleton(LanguageServerService.class, () ->
                new LanguageServerService(
                        container.resolve(ApplicationConfig.class),
                        container.resolve(ApplicationState.class),
                        container.resolve(EventBus.class),
                        container.resolve(DiagnosticsManager.class)
                )
        );

        container.registerLazySingleton(CodeExecutionService.class, () -> {
            EventBus eventBus = container.resolve(EventBus.class);
            return new CodeExecutionService(
                    text -> eventBus.publish(new com.botmaker.events.CoreApplicationEvents.OutputAppendedEvent(text)),
                    () -> eventBus.publish(new com.botmaker.events.CoreApplicationEvents.OutputClearedEvent()),
                    text -> eventBus.publish(new com.botmaker.events.CoreApplicationEvents.OutputSetEvent(text)),
                    msg -> eventBus.publish(new com.botmaker.events.CoreApplicationEvents.StatusMessageEvent(msg)),
                    container.resolve(DiagnosticsManager.class),
                    container.resolve(ApplicationConfig.class),
                    container.resolve(ApplicationState.class) // <--- ADD THIS
            );
        });

        container.registerLazySingleton(CodeEditorService.class, () ->
                new CodeEditorService(
                        container.resolve(ApplicationConfig.class),
                        container.resolve(ApplicationState.class),
                        container.resolve(EventBus.class),
                        container.resolve(BlockFactory.class),
                        container.resolve(AstRewriter.class),
                        container.resolve(BlockDragAndDropManager.class),
                        container.resolve(LanguageServerService.class),
                        container.resolve(DiagnosticsManager.class)
                )
        );

        container.registerLazySingleton(ExecutionService.class, () ->
                new ExecutionService(
                        container.resolve(ApplicationConfig.class),
                        container.resolve(ApplicationState.class),
                        container.resolve(EventBus.class),
                        container.resolve(CodeExecutionService.class),
                        container.resolve(DiagnosticsManager.class)
                )
        );

        container.registerLazySingleton(DebuggingService.class, () ->
                new DebuggingService(
                        container.resolve(ApplicationState.class),
                        container.resolve(EventBus.class),
                        container.resolve(CodeExecutionService.class),
                        container.resolve(BlockFactory.class),
                        container.resolve(ApplicationConfig.class)
                )
        );
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\init\AppServiceInitializer.java
=================================================================================

package com.botmaker.init;

import com.botmaker.blocks.ClassBlock;
import com.botmaker.core.BodyBlock;
import com.botmaker.core.StatementBlock;
import com.botmaker.di.DependencyContainer;
import com.botmaker.services.*;
import com.botmaker.state.ApplicationState;
import com.botmaker.ui.AddableBlock;
import com.botmaker.ui.BlockDragAndDropManager;
import com.botmaker.ui.UIManager;
import com.botmaker.util.BlockLookupHelper;
import org.eclipse.jdt.core.dom.TypeDeclaration;

public class AppServiceInitializer {

    public static void initialize(DependencyContainer container) throws Exception {
        // 1. Initialize Language Server
        LanguageServerService lss = container.resolve(LanguageServerService.class);
        lss.initialize();

        // 2. Resolve Services needed for wiring
        CodeEditorService codeEditorService = container.resolve(CodeEditorService.class);
        ApplicationState state = container.resolve(ApplicationState.class);
        BlockDragAndDropManager dragAndDropManager = container.resolve(BlockDragAndDropManager.class);

        // 3. Wire up Drag and Drop Logic
        setupDragAndDropCallbacks(dragAndDropManager, codeEditorService, state);

        // 4. Ensure other services are instantiated
        container.resolve(ExecutionService.class);
        container.resolve(DebuggingService.class);
        container.resolve(UIManager.class);
    }

    private static void setupDragAndDropCallbacks(BlockDragAndDropManager manager,
                                                  CodeEditorService editorService,
                                                  ApplicationState state) {
        // Handle adding new blocks
// ... inside setupDragAndDropCallbacks ...
        manager.setCallback(dropInfo -> {
            // Check if dropping into a CLASS
            if (dropInfo.targetClass() != null) {
                if (dropInfo.type() == AddableBlock.METHOD_DECLARATION) {
                    editorService.getCodeEditor().addMethodToClass(
                            (TypeDeclaration) dropInfo.targetClass().getAstNode(),
                            "newMethod", "void", dropInfo.insertionIndex()
                    );
                }
                else if (dropInfo.type() == AddableBlock.DECLARE_ENUM) {
                    editorService.getCodeEditor().addEnumToClass(
                            (TypeDeclaration) dropInfo.targetClass().getAstNode(),
                            "NewEnum", dropInfo.insertionIndex()
                    );
                }
            }
            // Check if dropping into a BODY (Method)
            else if (dropInfo.targetBody() != null) {
                editorService.getCodeEditor().addStatement(
                        dropInfo.targetBody(), dropInfo.type(), dropInfo.insertionIndex()
                );
            }
        });

        // Handle moving existing blocks
        manager.setMoveCallback(moveInfo -> {
            StatementBlock blockToMove = BlockLookupHelper.findBlockById(
                    moveInfo.blockId(),
                    state.getNodeToBlockMap()
            );

            if (blockToMove != null) {
                BodyBlock sourceBody = BlockLookupHelper.findParentBody(
                        blockToMove,
                        state.getNodeToBlockMap()
                );

                if (sourceBody != null) {
                    editorService.getCodeEditor().moveStatement(
                            blockToMove,
                            sourceBody,
                            moveInfo.targetBody(),
                            moveInfo.insertionIndex()
                    );
                }
            }
        });
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\library\Main.java
=================================================================================

package com.botmaker.library;

import org.bytedeco.javacpp.Loader;
import org.bytedeco.opencv.opencv_java;


public class Main {

    static{
        Loader.load(opencv_java.class);
    }

    public static void main(String[] args) {
        try {
            //testLiveCapture();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\library\capture\CaptureTest.java
=================================================================================

package com.botmaker.library.capture;


import com.botmaker.library.opencv.*;
import com.sun.jna.platform.win32.WinDef;
import com.sun.jna.platform.win32.WinDef.HWND;
import org.opencv.core.Mat;
import org.opencv.core.Scalar;

import javax.imageio.ImageIO;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import java.util.List;
import java.util.Scanner;

import static com.botmaker.library.capture.ScreenCapture.bufferedImageToMat;
import static com.botmaker.library.capture.ScreenCapture.matToBufferedImage;


public class CaptureTest {

    public static void main(String[] args){
        try {
            testPostLeftClick();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public static void testLiveCapture() throws InterruptedException {
        User32.INSTANCE.SetProcessDPIAware();

        System.out.println("You have 5 seconds to bring the window you want to capture to the foreground...");
        Thread.sleep(5000);

        HWND selectedWindow = User32.INSTANCE.GetForegroundWindow();

        if (selectedWindow == null) {
            System.out.println("Could not get the foreground window.");
            return;
        }

        byte[] windowText = new byte[512];
        User32.INSTANCE.GetWindowTextA(selectedWindow.getPointer(), windowText, 512);
        String windowTitle = new String(windowText).trim();

        System.out.println("Capturing window: " + windowTitle);


        BufferedImage firstCapture = ScreenCapture.capture(selectedWindow);
        try {
            ImageIO.write(firstCapture, "png", new File("capture.png"));
            System.out.println("Saved the first capture to capture.png");
        } catch (IOException e) {
            e.printStackTrace();
        }

        ImageDisplay display = new ImageDisplay();
        display.showImage(firstCapture);

        while (true) {
            BufferedImage screenshot = ScreenCapture.capture(selectedWindow);
            display.showImage(screenshot);
            Thread.sleep(100); // Capture roughly 10 times per second
        }
    }

    public static void testCreateTemplateAndFind() throws IOException, InterruptedException {
        System.out.println("Press 'C' to capture the first corner of the rectangle.");
        waitForCKey();
        Point p1 = getMousePosition();
        System.out.println("First corner captured at: " + p1);

        System.out.println("Press 'C' again to capture the second corner.");
        waitForCKey();
        Point p2 = getMousePosition();
        System.out.println("Second corner captured at: " + p2);

        Rectangle rect = new Rectangle(p1);
        rect.add(p2);

        BufferedImage desktop = ScreenCapture.captureDesktop();
        if (desktop == null) {
            System.err.println("Failed to capture desktop.");
            return;
        }

        BufferedImage templateImage = desktop.getSubimage(rect.x, rect.y, rect.width, rect.height);

        Template backgroundTemplate = new Template(bufferedImageToMat(desktop), "background");
        Template template = new Template(bufferedImageToMat(templateImage), "template");

        MatchResult result = OpencvManager.findBestMatch(template, backgroundTemplate, MatType.COLOR);

        if (result != null) {
            System.out.println("Match found at: " + result.rectLocation);
            System.out.println("Confidence: " + result.getScore());

            // Draw the rectangle on the background image
            Mat drawnImage = OpencvManager.drawMatch(backgroundTemplate.mat, result, new Scalar(0, 255, 0));

            // Convert the Mat back to a BufferedImage
            BufferedImage resultImage = matToBufferedImage(drawnImage);

            // Display the result
            ImageDisplay display = new ImageDisplay();
            display.showImage(resultImage);
        } else {
            System.out.println("No match found.");
        }
    }

    private static void waitForCKey() throws InterruptedException {
        // Wait for key release first to avoid capturing a held-down key
        while ((User32.INSTANCE.GetAsyncKeyState('C') & 0x8000) != 0) {
            Thread.sleep(10);
        }
        // Now wait for a fresh key press
        while ((User32.INSTANCE.GetAsyncKeyState('C') & 0x8000) == 0) {
            Thread.sleep(10);
        }
        System.out.println("... 'C' key pressed!");
    }

    private static Point getMousePosition() {
        WinDef.POINT p = new WinDef.POINT();
        User32.INSTANCE.GetCursorPos(p);
        return new Point(p.x, p.y);
    }

    public static void testCaptureChildWindow() throws InterruptedException {
        System.out.println("You have 5 seconds to bring the window you want to capture to the foreground...");
        Thread.sleep(5000);

        HWND foregroundWindow = User32.INSTANCE.GetForegroundWindow();
        byte[] windowText = new byte[512];
        User32.INSTANCE.GetWindowTextA(foregroundWindow.getPointer(), windowText, 512);
        String windowTitle = new String(windowText).trim();

        List<WindowInfo> childWindows = WindowFinder.getChildWindows(foregroundWindow);

        System.out.println("Available windows to capture:");
        System.out.println("0: " + windowTitle + " (Parent)");
        for (int i = 0; i < childWindows.size(); i++) {
            System.out.println((i + 1) + ": " + childWindows.get(i).getTitle());
        }

        System.out.print("Enter the number of the window to capture: ");
        Scanner scanner = new Scanner(System.in);
        int choice = scanner.nextInt();

        HWND selectedWindow;
        if (choice == 0) {
            selectedWindow = foregroundWindow;
        } else if (choice > 0 && choice <= childWindows.size()) {
            selectedWindow = childWindows.get(choice - 1).getHWnd();
        } else {
            System.out.println("Invalid choice.");
            return;
        }
        BufferedImage image = ScreenCapture.capture(selectedWindow);
        try {
            ImageIO.write(image, "png", new File("capture.png"));
            System.out.println("Saved the first capture to capture.png");
        } catch (IOException e) {
            e.printStackTrace();
        }

        ImageDisplay display = new ImageDisplay();
        while (true) {
            BufferedImage screenshot = ScreenCapture.capture(selectedWindow);
            display.showImage(screenshot);
        }
    }

    public static void testPostLeftClick() throws InterruptedException {
        System.out.println("You have 5 seconds to bring the window you want to click on (using PostMessage) to the foreground...");
        Thread.sleep(5000);

        HWND selectedWindow = User32.INSTANCE.GetForegroundWindow();

        if (selectedWindow == null) {
            System.out.println("Could not get the foreground window.");
            return;
        }

        byte[] windowText = new byte[512];
        User32.INSTANCE.GetWindowTextA(selectedWindow.getPointer(), windowText, 512);
        String windowTitle = new String(windowText).trim();

        System.out.println("Move your mouse to the desired click location within the window and press 'C'.");
        waitForCKey();
        Point mousePos = getMousePosition();

        WinDef.RECT windowRect = new WinDef.RECT();
        User32.INSTANCE.GetWindowRect(selectedWindow.getPointer(), windowRect);

        int relativeX = mousePos.x - windowRect.left;
        int relativeY = mousePos.y - windowRect.top;

        System.out.println("Clicking on window (PostMessage): " + windowTitle + " at relative coordinates (" + relativeX + ", " + relativeY + ") in 3 seconds...");
        Thread.sleep(3000);
        Clicker.postLeftClick(selectedWindow, relativeX, relativeY);
        System.out.println("Clicked!");
    }

    public static void testClickOnVirtualScreen() throws InterruptedException {

        System.out.println("Place le curseur, appuie sur 'C'");
        waitForCKey();
        Point p = getMousePosition();          // GetCursorPos → virt-desktop
        Clicker.postLeftClickScreen(p.x, p.y);
        System.out.println("Click envoyé à ("+p.x+", "+p.y+")");

    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\library\capture\Clicker.java
=================================================================================

package com.botmaker.library.capture;

import com.sun.jna.platform.win32.WinDef;
import com.sun.jna.platform.win32.WinDef.HWND;
import com.sun.jna.platform.win32.WinDef.LPARAM;
import com.sun.jna.platform.win32.WinDef.POINT;
import com.sun.jna.platform.win32.WinDef.WPARAM;

public final class Clicker {

    private static LPARAM makeLParam(int x, int y) {
        return new LPARAM((y << 16) | (x & 0xFFFF));
    }



    public static void postLeftClickScreen(int xAbs, int yAbs) {

        // 1️⃣ quelle fenêtre est sous ce pixel ?
        POINT.ByValue ptScreen = new POINT.ByValue();
        ptScreen.x = xAbs;
        ptScreen.y = yAbs;

        HWND hWnd = User32.INSTANCE.WindowFromPoint(ptScreen);
        if (hWnd == null) {
            return;
        }

        POINT ptClient = new POINT();
        ptClient.x = xAbs;
        ptClient.y = yAbs;
        User32.INSTANCE.ScreenToClient(hWnd, ptClient);

        // 3️⃣ réutiliser le helper qui marche
        postLeftClick(hWnd, ptClient.x, ptClient.y);
    }


    /** Posts a left click at (x,y) given in *client* coords of hWnd. */
    public static void postLeftClick(HWND hWnd, int x, int y) {

        /* 1️⃣ client → screen */
        POINT ptScreen = new POINT();
        ptScreen.x = x;
        ptScreen.y = y;
        User32.INSTANCE.ClientToScreen(hWnd, ptScreen);

        /* 2️⃣ window really under that point (child or same) */
        HWND hTarget = User32.INSTANCE.WindowFromPoint(ptScreen);
        if (hTarget == null) {
            hTarget = hWnd;
        }

        /* 3️⃣ screen → client of that target */
        POINT ptClient = new POINT();
        ptClient.x = ptScreen.x;
        ptClient.y = ptScreen.y;
        User32.INSTANCE.ScreenToClient(hTarget, ptClient);

        /* 4️⃣ pack & shoot the messages */
        LPARAM lParam = makeLParam(ptClient.x, ptClient.y);
        WPARAM wDown  = new WPARAM(User32.MK_LBUTTON);

        User32.INSTANCE.PostMessage(hTarget, User32.WM_LBUTTONDOWN, wDown, lParam);
        User32.INSTANCE.PostMessage(hTarget, User32.WM_LBUTTONUP,   new WPARAM(0), lParam);
    }

    private Clicker() {}  // utility class
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\library\capture\GDI32.java
=================================================================================

package com.botmaker.library.capture;

import com.sun.jna.Native;
import com.sun.jna.Pointer;
import com.sun.jna.platform.win32.WinDef.HBITMAP;
import com.sun.jna.platform.win32.WinDef.HDC;
import com.sun.jna.platform.win32.WinGDI;
import com.sun.jna.platform.win32.WinNT.HANDLE;
import com.sun.jna.win32.StdCallLibrary;


public interface GDI32 extends StdCallLibrary {
    GDI32 INSTANCE = Native.load("gdi32", GDI32.class);

    int SRCCOPY = 0x00CC0020;

    boolean BitBlt(HDC hdcDest, int nXDest, int nYDest, int nWidth, int nHeight, HDC hdcSrc, int nXSrc, int nYSrc, int dwRop);
    HDC CreateCompatibleDC(HDC hdc);
    HBITMAP CreateCompatibleBitmap(HDC hdc, int nWidth, int nHeight);
    Pointer SelectObject(HDC hdc, Pointer h);
    boolean DeleteDC(HDC hdc);
    boolean DeleteObject(HBITMAP ho);
    int GetObject(HANDLE h, int c, WinGDI.BITMAP lp);
    int GetDIBits(HDC hdc, HBITMAP hbm, int uStartScan, int cScanLines, int[] lpvBits, WinGDI.BITMAPINFO lpbi, int uUsage);
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\library\capture\ImageDisplay.java
=================================================================================

package com.botmaker.library.capture;

import javax.swing.*;
import java.awt.image.BufferedImage;

public class ImageDisplay {
    private final JFrame frame;
    private final JLabel imageLabel;

    public ImageDisplay() {
        frame = new JFrame("Live Capture");
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        imageLabel = new JLabel();
        frame.getContentPane().add(imageLabel);
        frame.setResizable(false);
    }

    public void showImage(BufferedImage image) {
        if (image == null) {
            return;
        }
        imageLabel.setIcon(new ImageIcon(image));
        if (!frame.isVisible()) {
            frame.pack();
            frame.setVisible(true);
        }
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\library\capture\ScreenCapture.java
=================================================================================

package com.botmaker.library.capture;

import com.sun.jna.platform.win32.WinDef.*;
import com.sun.jna.platform.win32.WinGDI;
import org.opencv.core.CvType;
import org.opencv.core.Mat;

import java.awt.*;
import java.awt.image.BufferedImage;
import java.awt.image.DataBufferByte;
import java.awt.image.DataBufferInt;


public class ScreenCapture {


    static Mat bufferedImageToMat(BufferedImage bi) {

        BufferedImage convertedImg = new BufferedImage(bi.getWidth(), bi.getHeight(), BufferedImage.TYPE_3BYTE_BGR);

        convertedImg.getGraphics().drawImage(bi, 0, 0, null);

        Mat mat = new Mat(convertedImg.getHeight(), convertedImg.getWidth(), CvType.CV_8UC3);
        byte[] data = ((DataBufferByte) convertedImg.getRaster().getDataBuffer()).getData();
        mat.put(0, 0, data);
        return mat;
    }

    static BufferedImage matToBufferedImage(Mat mat) {
        int type = BufferedImage.TYPE_BYTE_GRAY;
        if (mat.channels() > 1) {
            type = BufferedImage.TYPE_3BYTE_BGR;
        }
        int bufferSize = mat.channels() * mat.cols() * mat.rows();
        byte[] b = new byte[bufferSize];
        mat.get(0, 0, b);
        BufferedImage image = new BufferedImage(mat.cols(), mat.rows(), type);
        final byte[] targetPixels = ((DataBufferByte) image.getRaster().getDataBuffer()).getData();
        System.arraycopy(b, 0, targetPixels, 0, b.length);
        return image;
    }

    public static BufferedImage capture(HWND hWnd) {
        // Get screen dimensions for fullscreen check
        Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
        RECT screenRect = new RECT();
        screenRect.left = 0;
        screenRect.top = 0;
        screenRect.right = (int) screenSize.getWidth();
        screenRect.bottom = (int) screenSize.getHeight();

        // Get window dimensions
        RECT windowRect = new RECT();
        User32.INSTANCE.GetWindowRect(hWnd.getPointer(), windowRect);

        BufferedImage image;

        // Check if the window is fullscreen. If so, Robot is more reliable.
        if (windowRect.toString().equals(screenRect.toString()) && User32.INSTANCE.GetForegroundWindow().equals(hWnd)) {
            image = captureWithRobot(hWnd, windowRect);
        } else {
            // For windowed mode, GDI is faster, with a fallback to Robot.
            image = captureWithGDI(hWnd);
            // Fallback for black, invalid, or frozen (stale) images.
            if (image == null || image.getWidth() == 0 || image.getHeight() == 0 || isBlack(image)) {
                image = captureWithRobot(hWnd, windowRect);
            }
        }
        return image;
    }

    private static BufferedImage captureWithGDI(HWND hWnd) {
        HDC hdcWindow = User32.INSTANCE.GetDC(hWnd);
        HDC hdcMemDC = GDI32.INSTANCE.CreateCompatibleDC(hdcWindow);

        RECT bounds = new RECT();
        User32.INSTANCE.GetClientRect(hWnd, bounds);

        int width = bounds.right - bounds.left;
        int height = bounds.bottom - bounds.top;

        if (width <= 0 || height <= 0) {
            User32.INSTANCE.ReleaseDC(hWnd, hdcWindow);
            GDI32.INSTANCE.DeleteDC(hdcMemDC);
            return null;
        }

        HBITMAP hBitmap = GDI32.INSTANCE.CreateCompatibleBitmap(hdcWindow, width, height);
        GDI32.INSTANCE.SelectObject(hdcMemDC, hBitmap.getPointer());

        User32.INSTANCE.PrintWindow(hWnd, hdcMemDC, 2); // 2 = PW_CLIENTONLY

        WinGDI.BITMAPINFO bmi = new WinGDI.BITMAPINFO();
        bmi.bmiHeader.biWidth = width;
        bmi.bmiHeader.biHeight = -height; // Top-down image
        bmi.bmiHeader.biPlanes = 1;
        bmi.bmiHeader.biBitCount = 32;
        bmi.bmiHeader.biCompression = WinGDI.BI_RGB;

        BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);
        GDI32.INSTANCE.GetDIBits(hdcWindow, hBitmap, 0, height, ((DataBufferInt) image.getRaster().getDataBuffer()).getData(), bmi, WinGDI.DIB_RGB_COLORS);

        GDI32.INSTANCE.DeleteObject(hBitmap);
        GDI32.INSTANCE.DeleteDC(hdcMemDC);
        User32.INSTANCE.ReleaseDC(hWnd, hdcWindow);

        return image;
    }

    private static BufferedImage captureWithRobot(HWND hWnd, RECT bounds) {
        int width = bounds.right - bounds.left;
        int height = bounds.bottom - bounds.top;
        if (width <= 0 || height <= 0) {
            // Before failing, try to get the bounds again, as the window might have been minimized.
            User32.INSTANCE.GetWindowRect(hWnd.getPointer(), bounds);
            width = bounds.right - bounds.left;
            height = bounds.bottom - bounds.top;
            if (width <= 0 || height <= 0) {
                return null;
            }
        }
        try {
            return new Robot().createScreenCapture(new Rectangle(bounds.left, bounds.top, width, height));
        } catch (AWTException e) {
            e.printStackTrace();
            return null;
        }
    }

    private static boolean isBlack(BufferedImage image) {
        int width = image.getWidth();
        int height = image.getHeight();
        // Check a few pixels to see if they are black. A small sample is enough.
        for (int i = 0; i < 10; i++) {
            int x = (int) (Math.random() * width);
            int y = (int) (Math.random() * height);
            if ((image.getRGB(x, y) & 0x00FFFFFF) != 0) {
                return false; // Found a non-black pixel
            }
        }
        return true;
    }

    public static BufferedImage captureDesktop() {
        try {
            return new Robot().createScreenCapture(new Rectangle(Toolkit.getDefaultToolkit().getScreenSize()));
        } catch (AWTException e) {
            e.printStackTrace();
            return null;
        }
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\library\capture\User32.java
=================================================================================

package com.botmaker.library.capture;

import com.sun.jna.Native;
import com.sun.jna.Pointer;
import com.sun.jna.win32.W32APIOptions;
import com.sun.jna.platform.win32.WinDef.*;
import com.sun.jna.win32.StdCallLibrary;

public interface User32 extends StdCallLibrary {

    /* 🔸  KEY FIX: use DEFAULT_OPTIONS so "PostMessage" → "PostMessageW" */
    User32 INSTANCE = Native.load(
            "user32",
            User32.class,
            W32APIOptions.DEFAULT_OPTIONS);

    /* ---------  window enumeration  --------- */

    interface WNDENUMPROC extends StdCallCallback {
        boolean callback(Pointer hWnd, Pointer arg);
    }

    boolean EnumWindows(WNDENUMPROC lpEnumFunc, Pointer arg);
    boolean EnumChildWindows(HWND parent, WNDENUMPROC lpEnumFunc, Pointer arg);

    /* ---------  text / geometry  --------- */

    int  GetWindowTextA(Pointer hWnd, byte[] lpString, int nMax);
    Pointer FindWindowA(String lpClass, String lpName);
    boolean GetWindowRect(Pointer hWnd, RECT rect);
    boolean GetClientRect(HWND hWnd, RECT rect);

    /* ---------  DC / painting  --------- */

    HDC GetDC(HWND hWnd);
    int ReleaseDC(HWND hWnd, HDC hDC);
    boolean PrintWindow(HWND hWnd, HDC hdcBlt, int flags);

    /* ---------  DPI / focus / mouse pos  --------- */

    boolean SetProcessDPIAware();
    HWND    GetForegroundWindow();
    boolean SetForegroundWindow(HWND hWnd);
    boolean GetCursorPos(POINT pt);
    short   GetAsyncKeyState(int vKey);

    /* ---------  coordinate helpers  --------- */

    boolean ClientToScreen(HWND hWnd, POINT pt);
    boolean ScreenToClient(HWND hWnd, POINT pt);

    /* ---------  hit-testing  --------- */
    HWND WindowFromPoint(POINT pt);
    HWND WindowFromPoint(POINT.ByValue pt);   // ← ByValue !
    int  CWP_ALL = 0x0000;
    HWND ChildWindowFromPointEx(HWND parent, POINT pt, int flags);

    /* ---------  messaging  --------- */

    boolean PostMessage(HWND hWnd, int msg, WPARAM wp, LPARAM lp);
    LRESULT SendMessage(HWND hWnd, int msg, WPARAM wp, LPARAM lp);

    /* ---- NEW DESKTOP / METRICS ------------------------------------------- */

    HWND GetDesktopWindow();                // top level “Progman/WorkerW” window
    int  GetSystemMetrics(int index);       // screen size, virtual-desktop origin

    int SM_XVIRTUALSCREEN = 76;   // left   of bounding rect (can be negative)
    int SM_YVIRTUALSCREEN = 77;   // top    of bounding rect
    int SM_CXVIRTUALSCREEN = 78;  // width  of bounding rect
    int SM_CYVIRTUALSCREEN = 79;  // height of bounding rect

    HWND GetAncestor(HWND hWnd, int gaFlags);     // GA_ROOT = 2, GA_ROOTOWNER = 3
    boolean ShowWindow(HWND hWnd, int nCmdShow);  // SW_RESTORE = 9
    /* ---------  mouse constants  --------- */

    int WM_LBUTTONDOWN = 0x0201;
    int WM_LBUTTONUP   = 0x0202;
    int MK_LBUTTON     = 0x0001;
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\library\capture\WindowFinder.java
=================================================================================

package com.botmaker.library.capture;

import com.sun.jna.Pointer;
import com.sun.jna.platform.win32.WinDef.HWND;

import java.util.ArrayList;
import java.util.List;

public class WindowFinder {

    public static HWND findWindow(String title) {
        return new HWND(User32.INSTANCE.FindWindowA(null, title));
    }

    public static List<WindowInfo> getChildWindows(HWND parent) {
        List<WindowInfo> windows = new ArrayList<>();
        User32.INSTANCE.EnumChildWindows(parent, (hWnd, p) -> {
            byte[] windowText = new byte[512];
            User32.INSTANCE.GetWindowTextA(hWnd, windowText, 512);
            String title = new String(windowText).trim();
            if (!title.isEmpty()) {
                windows.add(new WindowInfo(new HWND(hWnd), title));
            }
            return true;
        }, null);
        return windows;
    }

    public static List<WindowInfo> getAllWindows() {
        List<WindowInfo> windows = new ArrayList<>();
        User32.INSTANCE.EnumWindows((hWnd, p) -> {
            byte[] windowText = new byte[512];
            User32.INSTANCE.GetWindowTextA(hWnd, windowText, 512);
            String title = new String(windowText).trim();
            if (!title.isEmpty()) {
                windows.add(new WindowInfo(new HWND(hWnd), title));
            }
            return true;
        }, null);
        return windows;
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\library\capture\WindowInfo.java
=================================================================================

package com.botmaker.library.capture;

import com.sun.jna.platform.win32.WinDef.HWND;
import com.sun.jna.platform.win32.WinDef.RECT;

public class WindowInfo {

    private final HWND hWnd;
    private final String title;

    public WindowInfo(HWND hWnd, String title) {
        this.hWnd = hWnd;
        this.title = title;
    }

    public HWND getHWnd() {
        return hWnd;
    }

    public String getTitle() {
        return title;
    }

    public RECT getWindowRect() {
        RECT rect = new RECT();
        User32.INSTANCE.GetWindowRect(hWnd.getPointer(), rect);
        return rect;
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\library\emulator\AdbHelper.java
=================================================================================

package com.botmaker.library.emulator;

import com.android.ddmlib.*;

import java.io.IOException;

public class AdbHelper {

    private static AndroidDebugBridge adb;

    public static void initAdb() {
        if (adb == null) {
            AndroidDebugBridge.init(false);
            adb = AndroidDebugBridge.createBridge();
        }
    }

    public static void terminateAdb() {
        if (adb != null) {
            AndroidDebugBridge.terminate();
            adb = null;
        }
    }

    public static IDevice connect(String adbHost, int adbPort) throws Exception {
        String serial = adbHost + ":" + adbPort;

        // First, check if the device is already connected
        for (IDevice device : adb.getDevices()) {
            if (device.getSerialNumber().equals(serial)) {
                return device;
            }
        }

        // If not, try to connect to it via adb command
        System.out.println("Attempting to connect to ADB device: " + serial);
        ProcessBuilder pb = new ProcessBuilder("adb", "connect", serial);
        Process process = pb.start();
        process.waitFor(); // Wait for the adb connect command to finish

        long startTime = System.currentTimeMillis();
        long timeout = 30 * 1000; // 30 seconds timeout

        while (System.currentTimeMillis() - startTime < timeout) {
            for (IDevice device : adb.getDevices()) {
                if (device.getSerialNumber().equals(serial)) {
                    System.out.println("Successfully connected to ADB device: " + serial);
                    return device;
                }
            }
            Thread.sleep(1000); // Wait for 1 second before retrying
        }
        System.out.println("Failed to connect to ADB device: " + serial + " after timeout.");
        return null;
    }

    public static boolean isPackageInstalled(IDevice device, String packageName) throws TimeoutException, AdbCommandRejectedException, ShellCommandUnresponsiveException, IOException {
        CollectingOutputReceiver receiver = new CollectingOutputReceiver();
        device.executeShellCommand("pm list packages " + packageName, receiver);
        return receiver.getOutput().contains(packageName);
    }

    public static void launchGame(IDevice device, String packageName, String activityName) throws AdbCommandRejectedException, TimeoutException, ShellCommandUnresponsiveException, IOException {
        device.executeShellCommand("am start -n " + packageName + "/" + activityName, new CollectingOutputReceiver());
    }

    public static void waitForBootComplete(IDevice dev, long timeoutMs)
            throws TimeoutException, AdbCommandRejectedException, IOException, InterruptedException {

        long deadline = System.currentTimeMillis() + timeoutMs;


        while (dev.getState() != IDevice.DeviceState.ONLINE) {
            if (System.currentTimeMillis() > deadline) {
                throw new TimeoutException("Device never came online");
            }
            Thread.sleep(1_000);
        }


        while (true) {
            String boot = dev.getProperty("sys.boot_completed");            // shortcut wrapper
            String anim = dev.getProperty("init.svc.bootanim");             // may be null on -no-boot-anim
            if ("1".equals(boot) && (anim == null || "stopped".equals(anim))) {
                return;                                                     // fully booted
            }
            if (System.currentTimeMillis() > deadline) {
                throw new TimeoutException("Device did not finish booting");
            }
            Thread.sleep(1_000);
        }
    }


}



=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\library\emulator\BlueStacksConfig.java
=================================================================================

package com.botmaker.library.emulator;

import java.io.BufferedReader;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.HashMap;
import java.util.Map;

public class BlueStacksConfig {

    private final Map<String, String> properties = new HashMap<>();

    public BlueStacksConfig(Path filePath) throws IOException {
        try (BufferedReader reader = Files.newBufferedReader(filePath)) {
            String line;
            while ((line = reader.readLine()) != null) {
                String[] parts = line.split("=");
                if (parts.length == 2) {
                    properties.put(parts[0].trim(), parts[1].trim().replace("\"", ""));
                }
            }
        }
    }


    public String getProperty(String key) {
        return properties.get(key);
    }

    public String getAdbPort(String instanceName) {
        return getProperty("bst.instance." + instanceName + ".adb_port");
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\library\emulator\BlueStacksEmulator.java
=================================================================================

package com.botmaker.library.emulator;

import com.android.ddmlib.CollectingOutputReceiver;

import com.botmaker.library.inspector.RegistryInspector;

import java.io.IOException;
import java.nio.file.Path;
import java.nio.file.Paths;

public class BlueStacksEmulator extends Emulator {

    private static final String EMULATOR_NAME = "BlueStacks";
    private static final String BLUESTACKS_EXE = "HD-Player.exe";
    private static final String BLUESTACKS_CONF = "bluestacks.conf";

    private static final int MAX_SCREENSHOT_RETRIES = 5;
    private static final long SCREENSHOT_RETRY_DELAY_MS = 2000; // 2 seconds

    private final BlueStacksInstance instance;

    public BlueStacksEmulator(BlueStacksInstance instance) {
        super(EMULATOR_NAME, Paths.get(RegistryInspector.getBlueStacksInstallPath()));
        if (installPath == null) {
            throw new IllegalStateException("BlueStacks installation path not found.");
        }
        this.instance = instance;
    }

    @Override
    public void start() throws IOException {
        Path bluestacksExePath = installPath.resolve(BLUESTACKS_EXE);
        ProcessBuilder pb = new ProcessBuilder(bluestacksExePath.toString(), "--instance", instance.getInstanceName());
        pb.start();
    }

    @Override
    public void connect() throws Exception {
        String userDefinedDir = RegistryInspector.getBlueStacksUserDefinedDir();
        if (userDefinedDir == null) {
            throw new IllegalStateException("BlueStacks UserDefinedDir not found.");
        }
        BlueStacksConfig config = new BlueStacksConfig(Paths.get(userDefinedDir).resolve(BLUESTACKS_CONF));
        String adbPort = config.getAdbPort(instance.getInstanceName());
        if (adbPort == null) {
            throw new IllegalStateException("ADB port not found in bluestacks.conf for instance: " + instance.getInstanceName());
        }

        this.device = AdbHelper.connect("127.0.0.1", Integer.parseInt(adbPort));
        if (this.device == null) {
            throw new IllegalStateException("Failed to connect to BlueStacks ADB for instance: " + instance.getInstanceName());
        }
        AdbHelper.waitForBootComplete(this.device,120_000);
    }

    @Override
    public String getMainWindowTitle() {
        // This might need to be more dynamic, but for now, a common title
        return "BlueStacks App Player";
    }

    @Override
    public void takeScreenshot(Path outputPath) throws Exception {
        if (device == null) {
            throw new IllegalStateException("Emulator not connected.");
        }

        String devicePath = "/sdcard/screenshot.png";
        CollectingOutputReceiver receiver = new CollectingOutputReceiver();

        // Take screenshot on device
        device.executeShellCommand("screencap -p " + devicePath, receiver);

        // Pull the file from device
        device.pullFile(devicePath, outputPath.toString());

        // Delete the temporary file on device
        device.executeShellCommand("rm " + devicePath, receiver);
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\library\emulator\BlueStacksInstance.java
=================================================================================

package com.botmaker.library.emulator;

import com.fasterxml.jackson.annotation.JsonProperty;

public class BlueStacksInstance {
    @JsonProperty("ID")
    private int id;
    @JsonProperty("Name")
    private String name;
    @JsonProperty("IsFolder")
    private boolean isFolder;
    @JsonProperty("ParentFolder")
    private int parentFolder;
    @JsonProperty("IsOpen")
    private boolean isOpen;
    @JsonProperty("IsVisible")
    private boolean isVisible;
    @JsonProperty("InstanceName")
    private String instanceName;

    // Getters and Setters
    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public boolean isFolder() {
        return isFolder;
    }

    public void setFolder(boolean folder) {
        isFolder = folder;
    }

    public int getParentFolder() {
        return parentFolder;
    }

    public void setParentFolder(int parentFolder) {
        this.parentFolder = parentFolder;
    }

    public boolean isOpen() {
        return isOpen;
    }

    public void setOpen(boolean open) {
        isOpen = open;
    }

    public boolean isVisible() {
        return isVisible;
    }

    public void setVisible(boolean visible) {
        isVisible = visible;
    }

    public String getInstanceName() {
        return instanceName;
    }

    public void setInstanceName(String instanceName) {
        this.instanceName = instanceName;
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\library\emulator\BlueStacksInstanceManager.java
=================================================================================

package com.botmaker.library.emulator;



import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;

import java.io.IOException;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.List;

public class BlueStacksInstanceManager {

    public static List<BlueStacksInstance> getInstances(Path mimMetaDataPath) throws IOException {
        ObjectMapper mapper = new ObjectMapper();
        List<BlueStacksInstance> instances = new ArrayList<>();

        JsonNode rootNode = mapper.readTree(mimMetaDataPath.toFile());
        JsonNode organizationNode = rootNode.get("Organization");

        if (organizationNode != null && organizationNode.isArray()) {
            for (JsonNode node : organizationNode) {
                instances.add(mapper.treeToValue(node, BlueStacksInstance.class));
            }
        }
        return instances;
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\library\emulator\Emulator.java
=================================================================================

package com.botmaker.library.emulator;

import com.android.ddmlib.IDevice;

import java.nio.file.Path;

public abstract class Emulator {

    protected final String name;
    protected final Path installPath;
    protected IDevice device;

    public Emulator(String name, Path installPath) {
        this.name = name;
        this.installPath = installPath;
    }

    public abstract void start() throws Exception;
    public abstract void connect() throws Exception;

    public boolean isGameInstalled(String packageName) throws Exception {
        if (device == null) {
            throw new IllegalStateException("Emulator not connected.");
        }
        return AdbHelper.isPackageInstalled(device, packageName);
    }

    public void launchGame(String packageName, String gameActivity) throws Exception {
        if (device == null) {
            throw new IllegalStateException("Emulator not connected.");
        }
        AdbHelper.launchGame(device, packageName, gameActivity);
    }

    public String getName() {
        return name;
    }

    public Path getInstallPath() {
        return installPath;
    }

    public IDevice getDevice() {
        return device;
    }

    public abstract String getMainWindowTitle();
    public abstract void takeScreenshot(Path outputPath) throws Exception;
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\library\emulator\EmulatorTest.java
=================================================================================

package com.botmaker.library.emulator;



import com.botmaker.library.inspector.RegistryInspector;

import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.List;

public class EmulatorTest {

    public static void main(String[] args) {
        AdbHelper.initAdb(); // Initialize ADB once
        try {
            String bluestacksInstallPathStr = RegistryInspector.getBlueStacksInstallPath();
            if (bluestacksInstallPathStr == null) {
                System.out.println("BlueStacks not found.");
                return;
            }
            Path bluestacksInstallPath = Paths.get(bluestacksInstallPathStr);
            System.out.println("BlueStacks Install Path: " + bluestacksInstallPath);

            String bluestacksDataDirStr = RegistryInspector.getBlueStacksDataDir();
            if (bluestacksDataDirStr == null) {
                System.out.println("BlueStacks Data Directory not found.");
                return;
            }
            Path bluestacksDataDir = Paths.get(bluestacksDataDirStr);
            System.out.println("BlueStacks Data Directory: " + bluestacksDataDir);

            Path mimMetaDataPath = bluestacksDataDir.resolve("UserData").resolve("MimMetaData.json");
            if (!mimMetaDataPath.toFile().exists()) {
                System.out.println("MimMetaData.json not found at: " + mimMetaDataPath);
                return;
            }

            List<BlueStacksInstance> instances = BlueStacksInstanceManager.getInstances(mimMetaDataPath);
            if (instances.isEmpty()) {
                System.out.println("No BlueStacks instances found.");
                return;
            }

            System.out.println("Found BlueStacks Instances:");
            for (BlueStacksInstance instance : instances) {
                System.out.println("  ID: " + instance.getId() + ", Name: " + instance.getName() + ", InstanceName: " + instance.getInstanceName());

                BlueStacksEmulator emulator = new BlueStacksEmulator(instance);
                System.out.println("  Attempting to start emulator: " + emulator.getName() + " (" + emulator.getInstallPath() + ")");
                emulator.start();
                System.out.println("  Emulator started. Attempting to connect to ADB...");
                emulator.connect();

                if (emulator.getDevice() != null) {
                    System.out.println("  Connected to ADB device: " + emulator.getDevice().getSerialNumber());


                    String gamePackage = "com.supercell.clashofclans"; // Replace with your game's package name
                    if (emulator.isGameInstalled(gamePackage)) {
                        System.out.println("  Game " + gamePackage + " is installed.");
                        String gameActivity = "com.supercell.titan.GameApp"; // Replace with your game's main activity
                        emulator.launchGame(gamePackage, gameActivity);
                        System.out.println("  Game launched.");
                    } else {
                        System.out.println("  Game " + gamePackage + " is NOT installed.");
                    }

                    System.out.println("  Main Window Title: " + emulator.getMainWindowTitle());

                    // Take a screenshot
                    Path screenshotPath = Paths.get("screenshot_" + instance.getInstanceName() + ".png");
                    emulator.takeScreenshot(screenshotPath);
                    System.out.println("  Screenshot saved to: " + screenshotPath.toAbsolutePath());

                } else {
                    System.out.println("  Failed to connect to ADB for this instance.");
                }
                System.out.println("----------------------------------------");
            }



        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            AdbHelper.terminateAdb(); // Terminate ADB when done
        }
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\library\inspector\RegistryInspector.java
=================================================================================

package com.botmaker.library.inspector;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class RegistryInspector {

    public static String getLDPlayerInstallPath() {
        return getRegistryValue("HKEY_LOCAL_MACHINE\\SOFTWARE\\XuanZhi\\LDPlayer9", "InstallDir");
    }

    public static String getBlueStacksInstallPath() {
        String path = getRegistryValue("HKEY_LOCAL_MACHINE\\SOFTWARE\\BlueStacks_nxt", "InstallDir");
        if (path == null) {
            path = getRegistryValue("HKEY_LOCAL_MACHINE\\SOFTWARE\\BlueStacks_msi", "InstallDir");
        }
        return path;
    }

    public static String getBlueStacksDataDir() {
        String path = getRegistryValue("HKEY_LOCAL_MACHINE\\SOFTWARE\\BlueStacks_nxt", "DataDir");
        if (path == null) {
            path = getRegistryValue("HKEY_LOCAL_MACHINE\\SOFTWARE\\BlueStacks_msi", "DataDir");
        }
        return path;
    }

    public static String getBlueStacksUserDefinedDir() {
        String path = getRegistryValue("HKEY_LOCAL_MACHINE\\SOFTWARE\\BlueStacks_nxt", "UserDefinedDir");
        if (path == null) {
            path = getRegistryValue("HKEY_LOCAL_MACHINE\\SOFTWARE\\BlueStacks_msi", "UserDefinedDir");
        }
        return path;
    }

    private static String getRegistryValue(String key, String valueName) {
        try {
            ProcessBuilder pb = new ProcessBuilder("reg", "query", key, "/v", valueName);
            Process process = pb.start();
            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
            String line;
            while ((line = reader.readLine()) != null) {
                if (line.trim().startsWith(valueName)) {
                    String[] parts = line.trim().split("    ");
                    if (parts.length > 1) {
                        return parts[parts.length - 1];
                    }
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
        return null;
    }

    public static void main(String[] args) {
        System.out.println("Checking for LDPlayer...");
        String ldPlayerPath = getLDPlayerInstallPath();
        if (ldPlayerPath != null) {
            System.out.println("LDPlayer is installed at: " + ldPlayerPath);
        } else {
            System.out.println("LDPlayer is not installed.");
        }

        System.out.println("\nChecking for BlueStacks...");
        String blueStacksPath = getBlueStacksInstallPath();
        if (blueStacksPath != null) {
            System.out.println("BlueStacks is installed at: " + blueStacksPath);
        } else {
            System.out.println("BlueStacks is not installed.");
        }
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\library\interaction\GameInteractor.java
=================================================================================

package com.botmaker.library.interaction;


import com.botmaker.library.capture.Clicker;
import com.botmaker.library.capture.ScreenCapture;
import com.botmaker.library.capture.WindowInfo;
import com.botmaker.library.emulator.Emulator;
import com.botmaker.library.opencv.MatType;
import com.botmaker.library.opencv.MatchResult;
import com.botmaker.library.opencv.OpencvManager;
import com.botmaker.library.opencv.Template;

import java.awt.image.BufferedImage;
import java.io.File;
import java.util.logging.Logger;

public class GameInteractor{

    private static final Logger LOGGER = Logger.getLogger(GameInteractor.class.getName());

    private final GameType gameType;
    private final Emulator emulator;
    private final WindowInfo gameWindow;

    public GameInteractor(GameType gameType, Emulator emulator, WindowInfo gameWindow) {
        this.gameType = gameType;
        this.emulator = emulator;
        this.gameWindow = gameWindow;
    }

    public Template getBackground() {
        try {
            BufferedImage screenshot = null;
            if (gameType == GameType.EMULATOR && emulator != null) {
                File tempFile = File.createTempFile("screenshot", ".png");
                tempFile.deleteOnExit(); // Ensure cleanup even if the program crashes later
                emulator.takeScreenshot(tempFile.toPath());
                screenshot = javax.imageio.ImageIO.read(tempFile);
                tempFile.delete(); // Clean up the temporary file immediately
            } else if (gameType == GameType.WINDOW && gameWindow != null) {
                screenshot = ScreenCapture.capture(gameWindow.getHWnd());
            } else if (gameType == GameType.SCREEN) {
                screenshot = ScreenCapture.captureDesktop();
            }

            if (screenshot != null) {
                return new Template(OpencvManager.bufferedImageToMat(screenshot), "screenshot");
            }
            return null;
        } catch (Exception e) {
            LOGGER.severe("Failed to get background screenshot: " + e.getMessage());
            e.printStackTrace(); // Also print stack trace for easier debugging
            return null; // Return null on any exception
        }
    }


    public MatchResult findTemplateInGame(Template template, MatType matType, double confidenceThreshold) throws Exception {
        Template background = getBackground();
        if (background != null) {
            return OpencvManager.findBestMatch(template, background, matType, confidenceThreshold);
        }
        return MatchResult.noMatch();
    }


    public void click(int x, int y) throws Exception {
        LOGGER.info("Clicking at: (" + x + ", " + y + ")");
        if (gameType == GameType.EMULATOR && emulator != null) {
            if (emulator.getDevice() == null) {
                LOGGER.severe("Emulator device not connected. Cannot perform click.");
                return;
            }
            emulator.getDevice().executeShellCommand("input tap " + x + " " + y, null);
        } else if (gameType == GameType.WINDOW && gameWindow != null) {
            Clicker.postLeftClick(gameWindow.getHWnd(), x, y);
        } else if (gameType == GameType.SCREEN) {
            Clicker.postLeftClickScreen(x, y);
        } else {
            LOGGER.warning("Cannot perform click. Game type not supported or game not initialized.");
        }
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\library\interaction\GameType.java
=================================================================================

package com.botmaker.library.interaction;

public enum GameType {
    WINDOW,
    EMULATOR,
    SCREEN
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\library\opencv\MatchResult.java
=================================================================================

package com.botmaker.library.opencv;

import org.opencv.core.Rect;


public class MatchResult {
    public Rect rectLocation;
    public double score;
    public double confidenceThreshold;
    public String winningTemplateId;
    public String winningBackgroundId;
    // --- START OF MODIFICATION ---
    public final MatType matType;

    public MatchResult(Rect rect, double score, double threshold, String winningTemplateId, String winningBackgroundId, MatType matType) {
        this.rectLocation = rect;
        this.score = score;
        this.confidenceThreshold = threshold;
        this.winningTemplateId = winningTemplateId;
        this.winningBackgroundId = winningBackgroundId;
        this.matType = matType;
    }

    private MatchResult() {
        this.rectLocation = new Rect();
        this.score = 0;
        this.confidenceThreshold = 0;
        this.winningTemplateId = null;
        this.winningBackgroundId = null;
        this.matType = null;
    }

    public static MatchResult noMatch() {
        return new MatchResult();
    }

    public String getTemplateId() {
        return winningTemplateId;
    }
    public String getBackgroundId() {
        return winningBackgroundId;
    }

    public double getScore(){
        return score;
    }

    public Boolean isMatch(){
        if (winningTemplateId == null) {
            return false;
        }
        return score>=confidenceThreshold;
    }

    @Override
    public String toString() {
        if (winningTemplateId == null) {
            return "MatchResult [No Match]";
        }
        // --- START OF MODIFICATION ---
        return String.format("MatchResult [Template: %s, Background: %s, Score: %.4f, Location: %s, Threshold: %.4f, MatType: %s, IsSignificant: %b]",
                winningTemplateId != null ? winningTemplateId : "N/A",
                winningBackgroundId != null ? winningBackgroundId : "N/A",
                score,
                rectLocation != null ? rectLocation.toString() : "N/A",
                confidenceThreshold,
                matType,
                isMatch());
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\library\opencv\MatType.java
=================================================================================

package com.botmaker.library.opencv;

public enum MatType {COLOR, GRAY}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\library\opencv\OpencvManager.java
=================================================================================

package com.botmaker.library.opencv;


import org.opencv.core.*;
import org.opencv.imgproc.Imgproc;

import java.awt.image.BufferedImage;
import java.awt.image.DataBufferByte;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;

import static org.opencv.imgcodecs.Imgcodecs.imread;
import static org.opencv.imgproc.Imgproc.*;



public class OpencvManager {
    private static final double DEFAULT_CONFIDENCE_THRESHOLD = 0.8;

    public static Mat bufferedImageToMat(BufferedImage image) {

        BufferedImage convertedImg = new BufferedImage(image.getWidth(), image.getHeight(), BufferedImage.TYPE_3BYTE_BGR);

        convertedImg.getGraphics().drawImage(image, 0, 0, null);

        Mat mat = new Mat(image.getHeight(), image.getWidth(), CvType.CV_8UC3);

        byte[] pixels = ((DataBufferByte) convertedImg.getRaster().getDataBuffer()).getData();

        mat.put(0, 0, pixels);
        return mat;
    }

    public static Template loadTemplate(String path) {
        Mat mat = imread(path);
        if (mat.empty()) {
            System.err.println("Error: Could not load template from path: " + path);
            return null;
        }
        return new Template(mat, path);
    }

    public OpencvManager() {

    }

    static public Boolean isRGBA(Mat mat){
        return mat.channels() == 4;
    }

    static public Boolean isRGB(Mat mat){
        return mat.channels() == 3;
    }
    static public Boolean isGray(Mat mat){
        return mat.channels() == 1;
    }

    static void convertToBGR(Mat mat){
        if(isGray(mat)){
            cvtColor(mat, mat, COLOR_GRAY2RGB);
        }
        else if(isRGBA(mat)){
            cvtColor(mat, mat, COLOR_RGBA2RGB);
        }
    }

    static void convertToGray(Mat mat){
        if(isRGB(mat)){
            cvtColor(mat, mat, COLOR_RGB2GRAY);
        }
        else if(isRGBA(mat)){
            cvtColor(mat, mat, COLOR_RGBA2GRAY);
        }
    }
    public static Mat drawMatch(Mat image, MatchResult match, Scalar color) {
        Mat drawnImage = image.clone();
        Imgproc.rectangle(drawnImage, match.rectLocation, color, 2);
        return drawnImage;
    }
    static public MatchResult findBestMatch(Template template, Template backgroundTemplate,MatType convertType){
        return findBestMatch(template,backgroundTemplate,convertType,DEFAULT_CONFIDENCE_THRESHOLD);
    }

    static public void convertTo(Mat mat, MatType convertType){
        if(convertType == MatType.COLOR){
            convertToBGR(mat);
        }
        else if(convertType == MatType.GRAY){
            convertToGray(mat);
        }
    }

    static public void convertTo(Template template, MatType convertType){
        convertTo(template.mat,convertType);
    }



    private static Core.MinMaxLocResult performMatch(Mat templateMat, Mat backgroundMat) {
        if (backgroundMat.width() < templateMat.width() || backgroundMat.height() < templateMat.height()) {
            System.err.println("Error: Template dimensions are larger than the background image.");
            return null;
        }

        int resultCols = backgroundMat.cols() - templateMat.cols() + 1;
        int resultRows = backgroundMat.rows() - templateMat.rows() + 1;
        Mat resultMat = new Mat(resultRows, resultCols, CvType.CV_32FC1);

        Imgproc.matchTemplate(backgroundMat, templateMat, resultMat, Imgproc.TM_CCOEFF_NORMED);
        return Core.minMaxLoc(resultMat);
    }

    static public MatchResult findBestMatch(Template template, Template backgroundTemplate, MatType convertType, double confidenceThreshold){

        Template localTemplate = template.clone();
        Template localBackground = backgroundTemplate.clone();

        convertTo(localTemplate,convertType);
        convertTo(localBackground,convertType);

        if (localBackground.width() < localTemplate.width() || localBackground.height() < localTemplate.height()) {
            System.err.println("Error: Template dimensions are larger than the background image.");
            return null;
        }

        int resultCols = localBackground.cols() - localTemplate.cols() + 1;
        int resultRows = localBackground.rows() - localTemplate.rows() + 1;
        Mat resultMat = new Mat(resultRows, resultCols, CvType.CV_32FC1);

        matchTemplate(localBackground.mat,localTemplate.mat,resultMat,TM_CCOEFF_NORMED);
        Core.MinMaxLocResult mmr = Core.minMaxLoc(resultMat);
        // performMatch()
        double bestScore = mmr.maxVal;
        if (bestScore >= confidenceThreshold) {
            // If it is, create and return the MatchResult object.
            Point bestLocation = mmr.maxLoc;
            Rect rect = new Rect(bestLocation, localTemplate.size());
            // --- START OF MODIFICATION ---
            return new MatchResult(rect, bestScore, confidenceThreshold, template.id, backgroundTemplate.id, convertType);
            // --- END OF MODIFICATION ---
        }
        // --- START OF MODIFICATION ---
        return new MatchResult(null, bestScore, confidenceThreshold, template.id, backgroundTemplate.id, convertType);
        // --- END OF MODIFICATION ---
    }


    public static List<MatchResult> findMultipleMatches(Template template, Template backgroundTemplate, MatType convertType){
        return findMultipleMatches(template,backgroundTemplate,convertType,DEFAULT_CONFIDENCE_THRESHOLD, 0.5);
    }

    public static List<MatchResult> findMultipleMatches(Template template, Template backgroundTemplate, MatType convertType, double confidenceThreshold) {
        // Overload with a default overlap threshold
        return findMultipleMatches(template, backgroundTemplate, convertType, confidenceThreshold, 0.5);
    }
    public static List<MatchResult> findMultipleMatches(Template template, Template backgroundTemplate, MatType convertType, double confidenceThreshold, double overlapThreshold) {
        if (template.empty() || backgroundTemplate.empty() || backgroundTemplate.width() < template.width() || backgroundTemplate.height() < template.height()) {
            System.err.println("Error: Invalid input images for findMultipleMatches.");
            return new ArrayList<>(); // Return an empty list on error
        }

        Template localTemplate = template.clone();
        Template localBackground = backgroundTemplate.clone();

        convertTo(localTemplate,convertType);
        convertTo(localBackground,convertType);

        int resultCols = localBackground.cols() - localTemplate.cols() + 1;
        int resultRows = localBackground.rows() - localTemplate.rows() + 1;
        Mat resultMat = new Mat(resultRows, resultCols, CvType.CV_32FC1);
        Imgproc.matchTemplate(localBackground.mat, localTemplate.mat, resultMat, Imgproc.TM_CCOEFF_NORMED);

        List<MatchResult> candidates = new ArrayList<>();
        for (int y = 0; y < resultMat.rows(); y++) {
            for (int x = 0; x < resultMat.cols(); x++) {
                if (resultMat.get(y, x)[0] >= confidenceThreshold) {
                    Point matchLoc = new Point(x, y);
                    Rect rect = new Rect(matchLoc, localTemplate.size());
                    // --- START OF MODIFICATION ---
                    candidates.add(new MatchResult(rect, resultMat.get(y, x)[0], confidenceThreshold, template.id, backgroundTemplate.id, convertType));
                    // --- END OF MODIFICATION ---
                }
            }
        }

        System.out.printf("Found %d raw matches above the threshold of %.2f.%n", candidates.size(), confidenceThreshold);
        if (candidates.isEmpty()) {
            return candidates;
        }

        // Non-Maximal Suppression
        candidates.sort(Comparator.comparing(MatchResult::getScore).reversed());
        List<MatchResult> winners = new ArrayList<>();

        while(!candidates.isEmpty()) {
            MatchResult champion = candidates.getFirst();
            winners.add(champion);
            candidates.removeIf(competitor -> {
                double iou = calculateIntersectionOverUnion(champion.rectLocation, competitor.rectLocation);
                return iou > overlapThreshold;
            });
        }
        System.out.printf("Returning %d non-overlapping matches.%n", winners.size());
        return winners;
    }

    private static double calculateIntersectionOverUnion(Rect r1, Rect r2) {
        int xA = Math.max(r1.x, r2.x);
        int yA = Math.max(r1.y, r2.y);
        int xB = Math.min(r1.x + r1.width, r2.x + r2.width);
        int yB = Math.min(r1.y + r1.height, r2.y + r2.height);

        int intersectionArea = Math.max(0, xB - xA) * Math.max(0, yB - yA);

        int r1Area = r1.width * r1.height;
        int r2Area = r2.width * r2.height;

        double unionArea = (double) r1Area + r2Area - intersectionArea;

        return intersectionArea / unionArea;
    }
    public static List<MatchResult> findBestMatchPerTemplate(List<Template> allTemplates, Template backgroundTemplate, MatType convertType){
        return findBestMatchPerTemplate(allTemplates,backgroundTemplate,convertType,DEFAULT_CONFIDENCE_THRESHOLD);
    }
    public static List<MatchResult> findBestMatchPerTemplate(List<Template> allTemplates, Template backgroundTemplate, MatType convertType, double confidenceThreshold){
        return allTemplates
                .parallelStream()
                .map(template -> findBestMatch(template,backgroundTemplate,convertType,confidenceThreshold))
                .filter(Objects::nonNull)
                .collect(Collectors.toList());
    }

    public static MatchResult findOneTemplate(List<Template> allTemplates, Template backgroundTemplate,MatType convertType){
        return findOneTemplate(allTemplates,backgroundTemplate,convertType,DEFAULT_CONFIDENCE_THRESHOLD);
    }
    public static MatchResult findOneTemplate(List<Template> allTemplates, Template backgroundTemplate,MatType convertType, double confidenceThreshold){
        return allTemplates
                .parallelStream()
                .map(template -> findBestMatch(template, backgroundTemplate, convertType, confidenceThreshold))
                .filter(Objects::nonNull)
                .findAny()
                .orElse(null);
    }


    public static MatchResult findBestOneTemplate(List<Template> allTemplates, Template backgroundTemplate,MatType convertType) {
        return findBestOneTemplate(allTemplates,backgroundTemplate,convertType,DEFAULT_CONFIDENCE_THRESHOLD);
    }

    public static MatchResult findBestOneTemplate(List<Template> allTemplates, Template backgroundTemplate,MatType convertType, double confidenceThreshold){
        return findBestMatchPerTemplate(allTemplates,backgroundTemplate,convertType,confidenceThreshold)
                .stream()
                .max(Comparator.comparing(MatchResult::getScore))
                .orElse(null);
    }

    public static List<MatchResult> findAllMatches(List<Template> allTemplates, Template backgroundTemplate,MatType convertType, double confidenceThreshold){
        return allTemplates
                .parallelStream()
                .flatMap(template ->
                        Objects.requireNonNull(findMultipleMatches(template, backgroundTemplate, convertType, confidenceThreshold)).stream()
                )
                .collect(Collectors.toList());
    }

    public static List<MatchResult> findAllMatches(List<Template> allTemplates, List<Template> allBackgrounds,MatType convertType, double confidenceThreshold){
        return allBackgrounds
                .parallelStream()
                .flatMap(background -> findAllMatches(allTemplates, background, convertType, confidenceThreshold).stream())
                .collect(Collectors.toList());
    }


    public static MatchResult findBestInBackgrounds(
            Template template,
            List<Template> allBackgrounds, // Changed to List<Mat> for clarity
            MatType matType,
            double confidenceThreshold)
    {
        return allBackgrounds
                .parallelStream()
                .map(backgroundMat -> findBestMatch(template, backgroundMat, matType, confidenceThreshold))
                .filter(Objects::nonNull)
                .max(Comparator.comparing(MatchResult::getScore))
                .orElse(null);
    }


    public static List<MatchResult> findBestPerBackground(
            Template template,
            List<Template> allBackgrounds, // Changed to List<Mat>
            MatType matType,
            double confidenceThreshold)
    {
        // This implementation is already correct for its stated goal.
        return allBackgrounds
                .parallelStream()
                .map(backgroundMat -> findBestMatch(template, backgroundMat, matType, confidenceThreshold))
                .filter(Objects::nonNull)
                .collect(Collectors.toList());
    }


    //Competitive Matches

    private static boolean hasConflictWith(MatchResult wantedMatch,
                                           Template badTemplate,
                                           Template backgroundTemplate,
                                           MatType matType,
                                           double confidenceThreshold) {

        // If the wanted match wasn't even found, there can't be a conflict.
        if (wantedMatch == null || wantedMatch.rectLocation == null) {
            return false;
        }

        MatchResult badMatch = findBestMatch(badTemplate, backgroundTemplate, matType, confidenceThreshold);

        // If the bad template wasn't found or the matches don't intersect, there's no conflict.
        if (badMatch == null || badMatch.rectLocation == null || !intersects(wantedMatch.rectLocation, badMatch.rectLocation)) {
            return false;
        }

        // A conflict only exists if the bad match is found at the same location with an equal or higher score.
        if (badMatch.getScore() >= wantedMatch.getScore()) {
            System.out.printf(
                    "Conflict found: Wanted '%s' (Score: %.4f) was challenged by '%s' (Score: %.4f) at the same location.%n",
                    wantedMatch.winningTemplateId, wantedMatch.getScore(), badMatch.winningTemplateId, badMatch.getScore()
            );
            return true;
        }

        return false;
    }


    public static List<MatchResult> findCompetitiveMatches(
            List<Template> allTemplates,
            Template background,
            MatType matType,
            double confidenceThreshold)
    {
        List<MatchResult> candidates = findAllMatches(allTemplates, background, matType, confidenceThreshold);
        candidates.sort(Comparator.comparing(MatchResult::getScore).reversed());
        List<MatchResult> winners = new ArrayList<>();
        while (!candidates.isEmpty()) {
            MatchResult champion = candidates.getFirst();
            winners.add(champion);
            candidates.removeIf(competitor ->
                    intersects(champion.rectLocation, competitor.rectLocation)
            );
        }
        return winners;
    }

    public static MatchResult findWantedTemplate(
            Template wantedTemplate,
            Template backgroundTemplate,
            Template badTemplate,
            MatType matType,
            double confidenceThreshold) {
        MatchResult wantedMatch = findBestMatch(wantedTemplate, backgroundTemplate, matType, confidenceThreshold);
        if (wantedMatch == null) {
            return null;
        }
        // Step 2: Delegate the conflict check to our new helper function.
        if (hasConflictWith(wantedMatch, badTemplate, backgroundTemplate, matType, confidenceThreshold)) {
            return null; // A conflict was found, so the match is invalid.
        }

        // No conflict, the match is valid.
        return wantedMatch;
    }

    public static MatchResult findWantedTemplate(
            Template wantedTemplate,
            Template backgroundTemplate,
            List<Template> allBadTemplates,
            MatType matType,
            double confidenceThreshold)
    {
        MatchResult wantedMatch = findBestMatch(wantedTemplate, backgroundTemplate, matType, confidenceThreshold);
        if (wantedMatch == null) {
            return null;
        }

        // Step 2: Use a parallel stream to see if ANY bad template causes a conflict.
        // The lambda becomes a simple and clean call to our helper function.
        boolean hasAnyConflict = allBadTemplates
                .parallelStream()
                .anyMatch(badTemplate -> hasConflictWith(wantedMatch, badTemplate, backgroundTemplate, matType, confidenceThreshold));

        // Step 3: Return the result.
        if (hasAnyConflict) {
            return null; // At least one conflict was found, so the match is invalid.
        } else {
            return wantedMatch; // No conflicts found, the match is valid.
        }
    }

    public static List<MatchResult> findEachWantedTemplate(
            List<Template> allWantedTemplates,
            Template backgroundTemplate,
            Template badTemplate,
            MatType matType,
            double confidenceThreshold)
    {
        Template localBackground = backgroundTemplate.clone();
        Template localBadTemplate = badTemplate.clone();

        return allWantedTemplates
                .parallelStream()
                .map(wantedTemplate ->
                        findWantedTemplate(wantedTemplate.clone(), localBackground, localBadTemplate, matType, confidenceThreshold)
                )
                .filter(Objects::nonNull)
                .collect(Collectors.toList());

    }

    public static List<MatchResult> findEachWantedTemplate(
            List<Template> allWantedTemplates,
            Template backgroundTemplate,
            List<Template> allBadTemplates,
            MatType matType,
            double confidenceThreshold)
    {
        return allWantedTemplates
                .parallelStream()
                .map(wantedTemplate -> {
                    Template localWanted = wantedTemplate.clone();
                    return findWantedTemplate(localWanted, backgroundTemplate, allBadTemplates, matType, confidenceThreshold);
                })
                .filter(Objects::nonNull)
                .collect(Collectors.toList());
    }



    private static boolean intersects(Rect r1, Rect r2) {
        return r1.x < r2.x + r2.width &&
                r1.x + r1.width > r2.x &&
                r1.y < r2.y + r2.height &&
                r1.y + r1.height > r2.y;
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\library\opencv\OpencvTest.java
=================================================================================

package com.botmaker.library.opencv;


import com.botmaker.library.capture.ScreenCapture;
import org.bytedeco.javacpp.Loader;
import org.bytedeco.opencv.opencv_java;
import org.opencv.core.Mat;
import org.opencv.core.Rect;
import org.opencv.imgcodecs.Imgcodecs;

import javax.imageio.ImageIO;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Random;
import java.util.concurrent.TimeUnit;


public class OpencvTest {
    static{
        Loader.load(opencv_java.class);
    }
    private static final String BACKGROUNDS_DIR = "images/backgrounds";
    private static final String TEMPLATES_DIR = "images/templates";

    public static void main(String[] args) throws IOException, InterruptedException {
        // 1. Record screen and save backgrounds
        recordScreenAndSave(10, 2);

        // 2. Extract templates from backgrounds
        extractTemplatesFromBackgrounds(3);

        // 3. Benchmark OpenCV functions
        benchmarkOpenCVFunctions();
    }

    public static void recordScreenAndSave(int screenshotCount, int intervalSeconds) throws InterruptedException, IOException {
        File backgroundsDir = new File(BACKGROUNDS_DIR);
        if (!backgroundsDir.exists()) {
            backgroundsDir.mkdirs();
        }

        for (int i = 0; i < screenshotCount; i++) {
            BufferedImage screenshot = ScreenCapture.captureDesktop();
            if (screenshot != null) {
                File outputFile = new File(BACKGROUNDS_DIR + "/background_" + i + ".png");
                ImageIO.write(screenshot, "png", outputFile);
                System.out.println("Saved background image: " + outputFile.getAbsolutePath());
            }
            TimeUnit.SECONDS.sleep(intervalSeconds);
        }
    }

    public static void extractTemplatesFromBackgrounds(int templatesPerBackground) throws IOException {
        File templatesDir = new File(TEMPLATES_DIR);
        if (!templatesDir.exists()) {
            templatesDir.mkdirs();
        }

        File backgroundsDir = new File(BACKGROUNDS_DIR);
        File[] backgroundFiles = backgroundsDir.listFiles((dir, name) -> name.toLowerCase().endsWith(".png"));

        if (backgroundFiles == null) {
            System.out.println("No background images found in " + BACKGROUNDS_DIR);
            return;
        }

        Random random = new Random();
        int templateCount = 0;
        for (File backgroundFile : backgroundFiles) {
            BufferedImage backgroundImage = ImageIO.read(backgroundFile);
            for (int i = 0; i < templatesPerBackground; i++) {
                // Random size between 5% and 20% of the background dimensions
                double scale = 0.05 + (0.15 * random.nextDouble());
                int templateWidth = (int) (backgroundImage.getWidth() * scale);
                int templateHeight = (int) (backgroundImage.getHeight() * scale);

                int x = random.nextInt(backgroundImage.getWidth() - templateWidth);
                int y = random.nextInt(backgroundImage.getHeight() - templateHeight);
                BufferedImage templateImage = backgroundImage.getSubimage(x, y, templateWidth, templateHeight);

                File outputFile = new File(TEMPLATES_DIR + "/template_" + templateCount++ + ".png");
                ImageIO.write(templateImage, "png", outputFile);
                System.out.println("Saved template image: " + outputFile.getAbsolutePath());
            }
        }
    }

    public static void benchmarkOpenCVFunctions() {
        File backgroundsDir = new File(BACKGROUNDS_DIR);
        File[] backgroundFiles = backgroundsDir.listFiles((dir, name) -> name.toLowerCase().endsWith(".png"));
        File templatesDir = new File(TEMPLATES_DIR);
        File[] templateFiles = templatesDir.listFiles((dir, name) -> name.toLowerCase().endsWith(".png"));

        if (backgroundFiles == null || templateFiles == null) {
            System.out.println("No background or template images found.");
            return;
        }

        List<Template> backgroundTemplates = new ArrayList<>();
        for (File file : backgroundFiles) {
            backgroundTemplates.add(new Template(file.getAbsolutePath()));
        }

        List<Template> templates = new ArrayList<>();
        for (File file : templateFiles) {
            templates.add(new Template(file.getAbsolutePath()));
        }

        System.out.println("--- Benchmarking Results ---");

        // --- Benchmarking findBestMatch ---
        long totalTimeBestMatch = 0;
        int bestMatchCount = 0;
        for (Template background : backgroundTemplates) {
            for (Template template : templates) {
                long startTime = System.nanoTime();
                MatchResult result = OpencvManager.findBestMatch(template, background, MatType.COLOR);
                long endTime = System.nanoTime();
                totalTimeBestMatch += (endTime - startTime);
                bestMatchCount++;
                if (result != null) {
                    System.out.printf("findBestMatch: Found %s in %s with score %.4f%n",
                            new File(template.id).getName(), new File(background.id).getName(), result.getScore());
                }
            }
        }
        System.out.println("findBestMatch average time: " + (totalTimeBestMatch / bestMatchCount) / 1_000_000.0 + " ms");


        long totalTimeMultipleMatches = 0;
        int multipleMatchesCount = 0;
        for (Template background : backgroundTemplates) {
            for (Template template : templates) {
                long startTime = System.nanoTime();
                List<MatchResult> results = OpencvManager.findMultipleMatches(template, background, MatType.COLOR);
                long endTime = System.nanoTime();
                totalTimeMultipleMatches += (endTime - startTime);
                multipleMatchesCount++;
                if (results != null && !results.isEmpty()) {
                    for (MatchResult result : results) {
                        System.out.printf("findMultipleMatches: Found %s in %s with score %.4f%n",
                                new File(template.id).getName(), new File(background.id).getName(), result.getScore());
                    }
                }
            }
        }
        System.out.println("findMultipleMatches average time: " + (totalTimeMultipleMatches / multipleMatchesCount) / 1_000_000.0 + " ms");

         long totalTimeBestMatchPerTemplate = 0;
        int bestMatchPerTemplateCount = 0;
        for (Template background : backgroundTemplates) {
            long startTime = System.nanoTime();
            List<MatchResult> results = OpencvManager.findBestMatchPerTemplate(templates, background, MatType.COLOR);
            long endTime = System.nanoTime();
            totalTimeBestMatchPerTemplate += (endTime - startTime);
            bestMatchPerTemplateCount++;
            if (results != null && !results.isEmpty()) {
                for (MatchResult result : results) {
                    System.out.printf("findBestMatchPerTemplate: Found match in %s with score %.4f%n",
                            new File(background.id).getName(), result.getScore());
                }
            }
        }
        System.out.println("findBestMatchPerTemplate average time: " + (totalTimeBestMatchPerTemplate / bestMatchPerTemplateCount) / 1_000_000.0 + " ms");
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\library\opencv\Template.java
=================================================================================

package com.botmaker.library.opencv;


import org.opencv.core.Mat;
import org.opencv.core.Size;
import org.opencv.imgcodecs.Imgcodecs;

public class Template {
    public final Mat mat;
    public final String id;

    public Template(Mat mat, String id) {
        this.mat = mat;
        this.id = id;
    }

    public Template(String filePath) {
        this(Imgcodecs.imread(filePath), filePath);
    }

    public int rows(){
        return mat.rows();
    }
    public int cols(){
        return mat.cols();
    }
    public int channels(){
        return mat.channels();
    }
    public int type(){
        return mat.type();
    }

    public int width(){
        return mat.width();
    }
    public int height(){
        return mat.height();
    }

    public Size size(){
        return mat.size();
    }
    public boolean empty(){
        return mat.empty();
    }
    public Template clone(){
        return new Template(mat.clone(),id);
    }

    @Override
    public String toString() {
        return "Template[id='" + id + "', width=" + width() + ", height=" + height() + "]";
    }

}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\lsp\CompletionContext.java
=================================================================================

package com.botmaker.lsp;

import com.botmaker.parser.CodeEditor;
import com.botmaker.state.ApplicationState; // Import State
import com.botmaker.ui.BlockDragAndDropManager;
import org.eclipse.lsp4j.services.LanguageServer;

public record CompletionContext(
        CodeEditor codeEditor,
        LanguageServer server,
        String docUri,
        String sourceCode,
        long docVersion,
        BlockDragAndDropManager dragAndDropManager,
        ApplicationState applicationState // Added field
) {
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\lsp\JdtLanguageServerLauncher.java
=================================================================================

package com.botmaker.lsp;

import com.botmaker.config.Constants;
import org.eclipse.lsp4j.jsonrpc.Launcher;
import org.eclipse.lsp4j.launch.LSPLauncher;
import org.eclipse.lsp4j.services.LanguageClient;
import org.eclipse.lsp4j.services.LanguageServer;
import org.eclipse.lsp4j.*;

import java.io.*;
import java.nio.file.*;
import java.util.*;
import java.util.concurrent.CompletableFuture;
import java.util.function.Consumer;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.stream.Stream;

public class JdtLanguageServerLauncher {

    private final Process process;
    private final LanguageServer server;

    public JdtLanguageServerLauncher(
            Path jdtlsPath,
            Path projectPath,
            Path workspaceData,
            Consumer<PublishDiagnosticsParams> diagnosticsConsumer) throws Exception {

        System.out.println("Initializing JDT LS...");

        // Suppress LSP4J internal logging
        Logger.getLogger("org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint").setLevel(Level.SEVERE);
        Logger.getLogger("org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer").setLevel(Level.SEVERE);

        // Locate launcher jar
        Path launcherJar = Files.list(jdtlsPath.resolve("plugins"))
                .filter(p -> p.getFileName().toString().startsWith("org.eclipse.equinox.launcher_"))
                .findFirst()
                .orElseThrow(() -> new RuntimeException("Launcher JAR not found at: " + jdtlsPath.resolve("plugins")));

        String javaExecutable = Paths.get(System.getProperty("java.home"), "bin", "java").toString();
        if (System.getProperty("os.name").toLowerCase().contains("win")) {
            if (!javaExecutable.endsWith(".exe")) javaExecutable += ".exe";
        }

        Path projectDir = projectPath.toAbsolutePath().normalize();
        Files.createDirectories(workspaceData);

        String osName = System.getProperty("os.name").toLowerCase();
        String configDirName;
        if (osName.contains("win")) {
            configDirName = "config_win";
        } else if (osName.contains("mac")) {
            configDirName = "config_mac";
        } else {
            configDirName = "config_linux";
        }

        Path configPath = jdtlsPath.resolve(configDirName);

        List<String> command = new ArrayList<>(Arrays.asList(
                javaExecutable,
                Constants.JVM_ENTITY_SIZE_LIMIT,
                Constants.JVM_TOTAL_ENTITY_SIZE_LIMIT,
                "--add-modules=ALL-SYSTEM",
                "--add-opens", "java.base/java.util=ALL-UNNAMED",
                "--add-opens", "java.base/java.lang=ALL-UNNAMED",
                "--add-opens", "java.base/sun.nio.fs=ALL-UNNAMED",
                "-Declipse.application=org.eclipse.jdt.ls.core.id1",
                "-Dosgi.bundles.defaultStartLevel=4",
                "-Declipse.product=org.eclipse.jdt.ls.core.product",
                Constants.LSP_DETECT_VM_DISABLED,
                Constants.LSP_FILE_ENCODING,
                Constants.LSP_LOG_DISABLE,
                Constants.JVM_MAX_HEAP,
                Constants.LSP_DEPENDENCY_COLLECTOR,
                "--enable-native-access=javafx.graphics"
        ));

        if (Constants.LSP_LOG_PROTOCOL) {
            command.add("-Dlog.protocol=true");
            command.add("-Dlog.level=" + Constants.LSP_LOG_LEVEL);
        }

        command.addAll(Arrays.asList(
                "-jar", launcherJar.toString(),
                "-configuration", configPath.toString(),
                "-data", workspaceData.toAbsolutePath().normalize().toString()
        ));

        ProcessBuilder pb = new ProcessBuilder(command);
        pb.redirectErrorStream(false); // Keep stderr separate
        process = pb.start();

        // Consume stderr
        new Thread(() -> {
            try (BufferedReader br = new BufferedReader(new InputStreamReader(process.getErrorStream()))) {
                String line;
                while ((line = br.readLine()) != null) {
                    // Uncomment to debug JDT internal errors
                    // System.out.println("[JDT LS STDERR] " + line);
                }
            } catch (IOException ignored) {}
        }, "JDT-LS-Stderr-Gobbler").start();

        Launcher<LanguageServer> launcher = LSPLauncher.createClientLauncher(
                new SimpleLanguageClient(diagnosticsConsumer),
                process.getInputStream(),
                process.getOutputStream()
        );

        launcher.startListening();
        server = launcher.getRemoteProxy();

        InitializeParams init = new InitializeParams();
        init.setProcessId((int) ProcessHandle.current().pid());

        ClientCapabilities capabilities = new ClientCapabilities();
        WorkspaceClientCapabilities workspaceCaps = new WorkspaceClientCapabilities();
        workspaceCaps.setDidChangeConfiguration(new DidChangeConfigurationCapabilities(true));
        workspaceCaps.setWorkspaceFolders(true);
        capabilities.setWorkspace(workspaceCaps);

        TextDocumentClientCapabilities textDocCaps = new TextDocumentClientCapabilities();
        capabilities.setTextDocument(textDocCaps);
        init.setCapabilities(capabilities);

        WorkspaceFolder folder = new WorkspaceFolder(projectDir.toUri().toString());
        init.setWorkspaceFolders(List.of(folder));
        init.setRootUri(folder.getUri());

        try {
            // --- FIX: INCREASED TIMEOUT TO 60 SECONDS ---
            server.initialize(init).get(60, java.util.concurrent.TimeUnit.SECONDS);
            server.initialized(new InitializedParams());
            System.out.println("JDT LS Initialized successfully.");
        } catch (Exception e) {
            e.printStackTrace();
            System.err.println("JDT LS failed to initialize within timeout.");
        }
    }

    public LanguageServer getServer() { return server; }

    public void stop() {
        if (server != null) {
            try { server.shutdown().get(); } catch (Exception ignored) {}
            server.exit();
        }
        if (process != null) process.destroy();
    }

    public static void cleanupWorkspace(Path workspaceData) {
        if (!Files.exists(workspaceData)) return;
        try (Stream<Path> walk = Files.walk(workspaceData)) {
            walk.sorted(Comparator.reverseOrder())
                    .map(Path::toFile)
                    .forEach(File::delete);
        } catch (IOException e) {}
    }

    static class SimpleLanguageClient implements LanguageClient {
        private final Consumer<PublishDiagnosticsParams> diagnosticsConsumer;
        public SimpleLanguageClient(Consumer<PublishDiagnosticsParams> diagnosticsConsumer) { this.diagnosticsConsumer = diagnosticsConsumer; }
        @Override public void telemetryEvent(Object o) { }
        @Override public void publishDiagnostics(PublishDiagnosticsParams diagnostics) { if (diagnosticsConsumer != null) diagnosticsConsumer.accept(diagnostics); }
        @Override public void showMessage(MessageParams messageParams) { System.out.println("[LSP] " + messageParams.getMessage()); }
        @Override public CompletableFuture<MessageActionItem> showMessageRequest(ShowMessageRequestParams showMessageRequestParams) { return CompletableFuture.completedFuture(null); }
        @Override public void logMessage(MessageParams messageParams) { System.out.println("[LSP Log] " + messageParams.getMessage()); }
        @Override public CompletableFuture<Void> registerCapability(RegistrationParams params) { return CompletableFuture.completedFuture(null); }
        @Override public CompletableFuture<Void> unregisterCapability(UnregistrationParams params) { return CompletableFuture.completedFuture(null); }
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\parser\AstRewriter.java
=================================================================================

package com.botmaker.parser;

import com.botmaker.core.BodyBlock;
import com.botmaker.core.StatementBlock;
import com.botmaker.ui.AddableBlock;
import com.botmaker.ui.AddableExpression;
import com.botmaker.util.TypeManager;
import org.eclipse.jdt.core.dom.*;
import org.eclipse.jdt.core.dom.rewrite.*;
import org.eclipse.jface.text.Document;
import org.eclipse.jface.text.IDocument;
import org.eclipse.text.edits.TextEdit;

import java.util.ArrayList;
import java.util.List;

public class AstRewriter {

    private final NodeCreator nodeCreator;

    public AstRewriter(NodeCreator nodeCreator) {
        this.nodeCreator = nodeCreator;
    }

    // ... [Existing methods: moveStatement, addStatement, replaceExpression, replaceLiteral, etc.] ...
    public String moveStatement(CompilationUnit cu, String originalCode, StatementBlock blockToMove, BodyBlock sourceBody, BodyBlock targetBody, int targetIndex) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);
        Statement statement = (Statement) blockToMove.getAstNode();
        ListRewrite sourceListRewrite = getListRewriteForBody(rewriter, sourceBody);
        ListRewrite targetListRewrite = getListRewriteForBody(rewriter, targetBody);
        if (sourceListRewrite == targetListRewrite || sourceBody == targetBody) {}
        Statement copiedStatement = (Statement) ASTNode.copySubtree(ast, statement);
        sourceListRewrite.remove(statement, null);
        insertIntoList(targetListRewrite, targetBody, copiedStatement, targetIndex);
        return applyRewrite(rewriter, originalCode);
    }



    public String addStatement(CompilationUnit cu, String originalCode, BodyBlock targetBody, AddableBlock type, int index) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);
        Statement newStatement;
        if (type == AddableBlock.COMMENT) {
            newStatement = (Statement) rewriter.createStringPlaceholder("// Comment", ASTNode.EMPTY_STATEMENT);
        } else {
            newStatement = nodeCreator.createDefaultStatement(ast, type, cu, rewriter);
        }
        if (newStatement == null) return originalCode;
        ListRewrite listRewrite = getListRewriteForBody(rewriter, targetBody);
        insertIntoList(listRewrite, targetBody, newStatement, index);
        return applyRewrite(rewriter, originalCode);
    }

    public String replaceExpression(CompilationUnit cu, String originalCode, Expression toReplace, AddableExpression type) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);
        Expression newExpression = nodeCreator.createDefaultExpression(ast, type, cu, rewriter);
        if (newExpression == null) return originalCode;
        rewriter.replace(toReplace, newExpression, null);
        return applyRewrite(rewriter, originalCode);
    }

    public String replaceLiteral(CompilationUnit cu, String originalCode, Expression toReplace, String newLiteralValue) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);
        Expression newExpression;
        if (toReplace instanceof StringLiteral) {
            StringLiteral newString = ast.newStringLiteral();
            newString.setLiteralValue(newLiteralValue);
            newExpression = newString;
        } else if (toReplace instanceof NumberLiteral) {
            newExpression = ast.newNumberLiteral(newLiteralValue);
        } else if (toReplace instanceof BooleanLiteral) {
            newExpression = ast.newBooleanLiteral(Boolean.parseBoolean(newLiteralValue));
        } else {
            return originalCode;
        }
        rewriter.replace(toReplace, newExpression, null);
        return applyRewrite(rewriter, originalCode);
    }

    // --- NEW: Infix Operator Replacement ---
    public String replaceInfixOperator(CompilationUnit cu, String originalCode, InfixExpression infix, InfixExpression.Operator newOp) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);
        rewriter.set(infix, InfixExpression.OPERATOR_PROPERTY, newOp, null);
        return applyRewrite(rewriter, originalCode);
    }

    // In AstRewriter.java

    public String addMethodToClass(CompilationUnit cu, String originalCode, TypeDeclaration typeDecl,
                                   String methodName, String returnType, int index) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);

        // Create new method
        MethodDeclaration newMethod = ast.newMethodDeclaration();
        newMethod.setName(ast.newSimpleName(methodName));

        // Set modifiers: public static
        newMethod.modifiers().add(ast.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD));
        newMethod.modifiers().add(ast.newModifier(Modifier.ModifierKeyword.STATIC_KEYWORD));

        // Set return type
        if ("void".equals(returnType)) {
            newMethod.setReturnType2(ast.newPrimitiveType(PrimitiveType.VOID));
        } else {
            newMethod.setReturnType2(TypeManager.createTypeNode(ast, returnType));
        }

        // Create empty body
        Block body = ast.newBlock();
        newMethod.setBody(body);

        // Insert into class
        ListRewrite listRewrite = rewriter.getListRewrite(typeDecl, TypeDeclaration.BODY_DECLARATIONS_PROPERTY);
        listRewrite.insertAt(newMethod, index, null);

        return applyRewrite(rewriter, originalCode);
    }

    public String deleteMethodFromClass(CompilationUnit cu, String originalCode, MethodDeclaration method) {
        ASTRewrite rewriter = ASTRewrite.create(cu.getAST());
        rewriter.remove(method, null);
        return applyRewrite(rewriter, originalCode);
    }

    public String updateComment(String originalCode, Comment commentNode, String newText) {
        try {
            IDocument document = new Document(originalCode);
            String replacement = newText.contains("\n") ? "/* " + newText + " */" : "// " + newText;
            document.replace(commentNode.getStartPosition(), commentNode.getLength(), replacement);
            return document.get();
        } catch (Exception e) { return originalCode; }
    }

    public String deleteComment(String originalCode, Comment commentNode) {
        try {
            IDocument document = new Document(originalCode);
            document.replace(commentNode.getStartPosition(), commentNode.getLength(), "");
            return document.get();
        } catch (Exception e) { return originalCode; }
    }

    public String addArgumentToMethodInvocation(CompilationUnit cu, String originalCode, MethodInvocation mi, AddableExpression type) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);
        ListRewrite listRewrite = rewriter.getListRewrite(mi, MethodInvocation.ARGUMENTS_PROPERTY);
        Expression newArg = nodeCreator.createDefaultExpression(ast, type, cu, rewriter);
        if (newArg != null) listRewrite.insertLast(newArg, null);
        return applyRewrite(rewriter, originalCode);
    }

    public String addArgumentToMethodInvocation(CompilationUnit cu, String originalCode, MethodInvocation mi, Expression newArgument) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);
        ListRewrite listRewrite = rewriter.getListRewrite(mi, MethodInvocation.ARGUMENTS_PROPERTY);
        listRewrite.insertLast(newArgument, null);
        return applyRewrite(rewriter, originalCode);
    }

    public String replaceSimpleName(CompilationUnit cu, String originalCode, SimpleName toReplace, String newName) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);
        rewriter.replace(toReplace, ast.newSimpleName(newName), null);
        return applyRewrite(rewriter, originalCode);
    }

    public String deleteNode(CompilationUnit cu, String originalCode, ASTNode toDelete) {
        ASTRewrite rewriter = ASTRewrite.create(cu.getAST());
        rewriter.remove(toDelete, null);
        return applyRewrite(rewriter, originalCode);
    }

    public String replaceVariableType(CompilationUnit cu, String originalCode, VariableDeclarationStatement varDecl, String newTypeName) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);
        if (newTypeName.contains("ArrayList")) {
            ImportManager.addImport(cu, rewriter, "java.util.ArrayList");
            ImportManager.addImport(cu, rewriter, "java.util.List");
        }
        Type newType = TypeManager.createTypeNode(ast, newTypeName);
        rewriter.replace(varDecl.getType(), newType, null);
        if (!varDecl.fragments().isEmpty()) {
            VariableDeclarationFragment fragment = (VariableDeclarationFragment) varDecl.fragments().get(0);
            Expression currentInitializer = fragment.getInitializer();
            Expression newInitializer = null;
            List<Expression> valuesToPreserve = new ArrayList<>();
            String oldLeaf = TypeManager.getLeafType(varDecl.getType().toString());
            String newLeaf = TypeManager.getLeafType(newTypeName);
            if (oldLeaf.equals(newLeaf) && currentInitializer != null) collectLeafValues(currentInitializer, valuesToPreserve);

            if (newTypeName.startsWith("ArrayList<")) {
                newInitializer = nodeCreator.createRecursiveListInitializer(ast, newTypeName, cu, rewriter, valuesToPreserve);
            } else if (newTypeName.endsWith("[]")) {
                ArrayCreation creation = ast.newArrayCreation();
                creation.setType((ArrayType) TypeManager.createTypeNode(ast, newTypeName));
                ArrayInitializer ai = ast.newArrayInitializer();
                if (!valuesToPreserve.isEmpty()) {
                    for(Expression val : valuesToPreserve) ai.expressions().add(ASTNode.copySubtree(ast, val));
                }
                creation.setInitializer(ai);
                newInitializer = creation;
            } else {
                newInitializer = !valuesToPreserve.isEmpty() ? (Expression) ASTNode.copySubtree(ast, valuesToPreserve.get(0)) : nodeCreator.createDefaultInitializer(ast, newTypeName);
            }
            if (newInitializer != null) rewriter.replace(currentInitializer, newInitializer, null);
        }
        return applyRewrite(rewriter, originalCode);
    }

    public String addElementToList(CompilationUnit cu, String originalCode, ASTNode listNode, AddableExpression type, int insertIndex) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);
        Expression newElement = nodeCreator.createDefaultExpression(ast, type, cu, rewriter);
        if (newElement == null) return originalCode;
        if (listNode instanceof ArrayInitializer) {
            rewriter.getListRewrite(listNode, ArrayInitializer.EXPRESSIONS_PROPERTY).insertAt(newElement, insertIndex, null);
        } else if (listNode instanceof MethodInvocation) {
            rewriter.getListRewrite(listNode, MethodInvocation.ARGUMENTS_PROPERTY).insertAt(newElement, insertIndex, null);
        } else if (listNode instanceof ClassInstanceCreation) {
            ClassInstanceCreation cic = (ClassInstanceCreation) listNode;
            if (!cic.arguments().isEmpty() && cic.arguments().get(0) instanceof MethodInvocation) {
                MethodInvocation mi = (MethodInvocation) cic.arguments().get(0);
                rewriter.getListRewrite(mi, MethodInvocation.ARGUMENTS_PROPERTY).insertAt(newElement, insertIndex, null);
            }
        }
        return applyRewrite(rewriter, originalCode);
    }

    public String deleteElementFromList(CompilationUnit cu, String originalCode, ASTNode listNode, int elementIndex) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);
        List<?> expressions;
        ChildListPropertyDescriptor property;
        ASTNode targetNode = listNode;
        if (listNode instanceof ClassInstanceCreation) {
            ClassInstanceCreation cic = (ClassInstanceCreation) listNode;
            if (!cic.arguments().isEmpty() && cic.arguments().get(0) instanceof MethodInvocation) {
                MethodInvocation mi = (MethodInvocation) cic.arguments().get(0);
                targetNode = mi;
                expressions = mi.arguments();
                property = MethodInvocation.ARGUMENTS_PROPERTY;
            } else return originalCode;
        } else if (listNode instanceof ArrayInitializer) {
            expressions = ((ArrayInitializer) listNode).expressions();
            property = ArrayInitializer.EXPRESSIONS_PROPERTY;
        } else if (listNode instanceof MethodInvocation) {
            expressions = ((MethodInvocation) listNode).arguments();
            property = MethodInvocation.ARGUMENTS_PROPERTY;
        } else return originalCode;
        if (elementIndex >= 0 && elementIndex < expressions.size()) {
            rewriter.getListRewrite(targetNode, property).remove((ASTNode) expressions.get(elementIndex), null);
        }
        return applyRewrite(rewriter, originalCode);
    }

    public String convertElseToElseIf(CompilationUnit cu, String originalCode, IfStatement ifStatement) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);
        Statement elseStatement = ifStatement.getElseStatement();
        if (elseStatement != null && elseStatement.getNodeType() == ASTNode.BLOCK) {
            IfStatement newElseIf = ast.newIfStatement();
            newElseIf.setExpression(ast.newBooleanLiteral(true));
            newElseIf.setThenStatement((Block) ASTNode.copySubtree(ast, elseStatement));
            rewriter.replace(elseStatement, newElseIf, null);
        }
        return applyRewrite(rewriter, originalCode);
    }

    public String addElseToIfStatement(CompilationUnit cu, String originalCode, IfStatement ifStatement) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);
        if (ifStatement.getElseStatement() == null) rewriter.set(ifStatement, IfStatement.ELSE_STATEMENT_PROPERTY, ast.newBlock(), null);
        return applyRewrite(rewriter, originalCode);
    }

    public String deleteElseFromIfStatement(CompilationUnit cu, String originalCode, IfStatement ifStatement) {
        ASTRewrite rewriter = ASTRewrite.create(cu.getAST());
        if (ifStatement.getElseStatement() != null) rewriter.remove(ifStatement.getElseStatement(), null);
        return applyRewrite(rewriter, originalCode);
    }

    public String replaceAssignmentOperator(CompilationUnit cu, String originalCode, Assignment assignment, Assignment.Operator newOp) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);
        Assignment newAssignment = ast.newAssignment();
        newAssignment.setLeftHandSide((Expression) ASTNode.copySubtree(ast, assignment.getLeftHandSide()));
        newAssignment.setRightHandSide((Expression) ASTNode.copySubtree(ast, assignment.getRightHandSide()));
        newAssignment.setOperator(newOp);
        rewriter.replace(assignment, newAssignment, null);
        return applyRewrite(rewriter, originalCode);
    }

    public String replacePrefixOperator(CompilationUnit cu, String originalCode, PrefixExpression prefix, PrefixExpression.Operator newOp) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);
        PrefixExpression newPrefix = ast.newPrefixExpression();
        newPrefix.setOperand((Expression) ASTNode.copySubtree(ast, prefix.getOperand()));
        newPrefix.setOperator(newOp);
        rewriter.replace(prefix, newPrefix, null);
        return applyRewrite(rewriter, originalCode);
    }

    public String replacePostfixOperator(CompilationUnit cu, String originalCode, PostfixExpression postfix, PostfixExpression.Operator newOp) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);
        PostfixExpression newPostfix = ast.newPostfixExpression();
        newPostfix.setOperand((Expression) ASTNode.copySubtree(ast, postfix.getOperand()));
        newPostfix.setOperator(newOp);
        rewriter.replace(postfix, newPostfix, null);
        return applyRewrite(rewriter, originalCode);
    }

    public String updateMethodInvocation(CompilationUnit cu, String originalCode, MethodInvocation mi, String newScope, String newMethodName, List<String> newParamTypes) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);
        if (newScope == null || newScope.isEmpty() || newScope.equals("Local")) {
            if (mi.getExpression() != null) rewriter.remove(mi.getExpression(), null);
        } else {
            SimpleName newScopeNode = ast.newSimpleName(newScope);
            if (mi.getExpression() == null) rewriter.set(mi, MethodInvocation.EXPRESSION_PROPERTY, newScopeNode, null);
            else rewriter.replace(mi.getExpression(), newScopeNode, null);
        }
        if (!mi.getName().getIdentifier().equals(newMethodName)) rewriter.replace(mi.getName(), ast.newSimpleName(newMethodName), null);
        ListRewrite argsRewrite = rewriter.getListRewrite(mi, MethodInvocation.ARGUMENTS_PROPERTY);
        List<?> currentArgs = mi.arguments();
        int targetCount = newParamTypes.size();
        int currentCount = currentArgs.size();
        if (currentCount > targetCount) {
            for (int i = currentCount - 1; i >= targetCount; i--) argsRewrite.remove((ASTNode) currentArgs.get(i), null);
        } else if (currentCount < targetCount) {
            for (int i = currentCount; i < targetCount; i++) {
                String typeName = newParamTypes.get(i);
                Expression defaultExpr = nodeCreator.createDefaultInitializer(ast, typeName);
                argsRewrite.insertLast(defaultExpr, null);
            }
        }
        return applyRewrite(rewriter, originalCode);
    }

    public String renameMethodParameter(CompilationUnit cu, String originalCode, MethodDeclaration method, int index, String newName) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);
        List<?> params = method.parameters();
        if (index >= 0 && index < params.size()) {
            SingleVariableDeclaration param = (SingleVariableDeclaration) params.get(index);
            SimpleName newNameNode = ast.newSimpleName(newName);
            rewriter.replace(param.getName(), newNameNode, null);
        }
        return applyRewrite(rewriter, originalCode);
    }

    public String setMethodReturnType(CompilationUnit cu, String originalCode, MethodDeclaration method, String newTypeName) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);
        Type newType;
        if ("void".equals(newTypeName)) newType = ast.newPrimitiveType(PrimitiveType.VOID);
        else newType = TypeManager.createTypeNode(ast, newTypeName);
        rewriter.replace(method.getReturnType2(), newType, null);
        return applyRewrite(rewriter, originalCode);
    }

    public String addParameterToMethod(CompilationUnit cu, String originalCode, MethodDeclaration method, String typeName, String paramName) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);
        ListRewrite listRewrite = rewriter.getListRewrite(method, MethodDeclaration.PARAMETERS_PROPERTY);
        SingleVariableDeclaration newParam = ast.newSingleVariableDeclaration();
        newParam.setType(TypeManager.createTypeNode(ast, typeName));
        newParam.setName(ast.newSimpleName(paramName));
        listRewrite.insertLast(newParam, null);
        return applyRewrite(rewriter, originalCode);
    }

    public String deleteParameterFromMethod(CompilationUnit cu, String originalCode, MethodDeclaration method, int index) {
        ASTRewrite rewriter = ASTRewrite.create(cu.getAST());
        ListRewrite listRewrite = rewriter.getListRewrite(method, MethodDeclaration.PARAMETERS_PROPERTY);
        List<?> params = method.parameters();
        if (index >= 0 && index < params.size()) listRewrite.remove((ASTNode) params.get(index), null);
        return applyRewrite(rewriter, originalCode);
    }

    public String setReturnExpression(CompilationUnit cu, String originalCode, ReturnStatement returnStmt, AddableExpression type) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);
        Expression newExpr = nodeCreator.createDefaultExpression(ast, type, cu, rewriter);
        if (newExpr == null) return originalCode;
        if (returnStmt.getExpression() == null) rewriter.set(returnStmt, ReturnStatement.EXPRESSION_PROPERTY, newExpr, null);
        else rewriter.replace(returnStmt.getExpression(), newExpr, null);
        return applyRewrite(rewriter, originalCode);
    }

    public String addEnumToClass(CompilationUnit cu, String originalCode, TypeDeclaration typeDecl, String enumName, int index) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);

        EnumDeclaration newEnum = ast.newEnumDeclaration();
        newEnum.setName(ast.newSimpleName(enumName));
        newEnum.modifiers().add(ast.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD));

        // Add default values
        EnumConstantDeclaration const1 = ast.newEnumConstantDeclaration();
        const1.setName(ast.newSimpleName("OPTION_A"));
        newEnum.enumConstants().add(const1);

        ListRewrite listRewrite = rewriter.getListRewrite(typeDecl, TypeDeclaration.BODY_DECLARATIONS_PROPERTY);
        listRewrite.insertAt(newEnum, index, null);

        return applyRewrite(rewriter, originalCode);
    }

    public String deleteEnumFromClass(CompilationUnit cu, String originalCode, EnumDeclaration enumDecl) {
        ASTRewrite rewriter = ASTRewrite.create(cu.getAST());
        rewriter.remove(enumDecl, null);
        return applyRewrite(rewriter, originalCode);
    }

    public String renameEnum(CompilationUnit cu, String originalCode, EnumDeclaration enumNode, String newName) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);
        rewriter.replace(enumNode.getName(), ast.newSimpleName(newName), null);
        return applyRewrite(rewriter, originalCode);
    }

    public String addEnumConstant(CompilationUnit cu, String originalCode, EnumDeclaration enumNode, String constantName) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);
        ListRewrite listRewrite = rewriter.getListRewrite(enumNode, EnumDeclaration.ENUM_CONSTANTS_PROPERTY);

        EnumConstantDeclaration newConst = ast.newEnumConstantDeclaration();
        newConst.setName(ast.newSimpleName(constantName));

        listRewrite.insertLast(newConst, null);
        return applyRewrite(rewriter, originalCode);
    }

    public String deleteEnumConstant(CompilationUnit cu, String originalCode, EnumDeclaration enumNode, int index) {
        ASTRewrite rewriter = ASTRewrite.create(cu.getAST());
        ListRewrite listRewrite = rewriter.getListRewrite(enumNode, EnumDeclaration.ENUM_CONSTANTS_PROPERTY);
        List<?> constants = enumNode.enumConstants();

        if (index >= 0 && index < constants.size()) {
            listRewrite.remove((ASTNode) constants.get(index), null);
        }
        return applyRewrite(rewriter, originalCode);
    }

    public String renameEnumConstant(CompilationUnit cu, String originalCode, EnumDeclaration enumNode, int index, String newName) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);
        List<?> constants = enumNode.enumConstants();

        if (index >= 0 && index < constants.size()) {
            EnumConstantDeclaration constDecl = (EnumConstantDeclaration) constants.get(index);
            rewriter.replace(constDecl.getName(), ast.newSimpleName(newName), null);
        }
        return applyRewrite(rewriter, originalCode);
    }

    public String addCaseToSwitch(CompilationUnit cu, String originalCode, SwitchStatement switchStmt) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);
        ListRewrite listRewrite = rewriter.getListRewrite(switchStmt, SwitchStatement.STATEMENTS_PROPERTY);
        SwitchCase newCase = ast.newSwitchCase();
        int count = 0;
        for(Object o : switchStmt.statements()) { if(o instanceof SwitchCase) count++; }
        try { newCase.expressions().add(ast.newNumberLiteral(String.valueOf(count))); } catch(Exception ignored) {}
        listRewrite.insertLast(newCase, null);
        listRewrite.insertLast(ast.newBreakStatement(), null);
        return applyRewrite(rewriter, originalCode);
    }

    public String moveSwitchCase(CompilationUnit cu, String originalCode, SwitchCase caseNode, boolean moveUp) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);
        SwitchStatement parent = (SwitchStatement) caseNode.getParent();
        List<Statement> statements = parent.statements();
        List<List<Statement>> chunks = new ArrayList<>();
        List<Statement> currentChunk = null;
        for (Statement stmt : statements) {
            if (stmt instanceof SwitchCase) {
                if (currentChunk != null) chunks.add(currentChunk);
                currentChunk = new ArrayList<>();
            }
            if (currentChunk != null) currentChunk.add(stmt);
        }
        if (currentChunk != null) chunks.add(currentChunk);
        int targetIndex = -1;
        for (int i = 0; i < chunks.size(); i++) {
            if (!chunks.get(i).isEmpty() && chunks.get(i).get(0) == caseNode) {
                targetIndex = i;
                break;
            }
        }
        if (targetIndex == -1) return originalCode;
        int neighborIndex = moveUp ? targetIndex - 1 : targetIndex + 1;
        if (neighborIndex < 0 || neighborIndex >= chunks.size()) return originalCode;
        List<Statement> targetChunk = chunks.get(targetIndex);
        List<Statement> neighborChunk = chunks.get(neighborIndex);
        ListRewrite listRewrite = rewriter.getListRewrite(parent, SwitchStatement.STATEMENTS_PROPERTY);
        if (moveUp) {
            ASTNode insertPoint = neighborChunk.get(0);
            for (Statement stmt : targetChunk) {
                ASTNode moveTarget = rewriter.createMoveTarget(stmt);
                listRewrite.insertBefore(moveTarget, insertPoint, null);
            }
        } else {
            ASTNode insertPoint = targetChunk.get(0);
            for (Statement stmt : neighborChunk) {
                ASTNode moveTarget = rewriter.createMoveTarget(stmt);
                listRewrite.insertBefore(moveTarget, insertPoint, null);
            }
        }
        return applyRewrite(rewriter, originalCode);
    }

    private ListRewrite getListRewriteForBody(ASTRewrite rewriter, BodyBlock body) {
        ASTNode node = body.getAstNode();
        if (node instanceof Block) {
            return rewriter.getListRewrite(node, Block.STATEMENTS_PROPERTY);
        } else if (node instanceof SwitchCase) {
            return rewriter.getListRewrite(node.getParent(), SwitchStatement.STATEMENTS_PROPERTY);
        }
        throw new IllegalArgumentException("Unsupported body node type: " + node.getClass());
    }

    private void insertIntoList(ListRewrite listRewrite, BodyBlock body, Statement newStatement, int relativeIndex) {
        ASTNode node = body.getAstNode();
        if (node instanceof Block) {
            listRewrite.insertAt(newStatement, relativeIndex, null);
        } else if (node instanceof SwitchCase) {
            SwitchCase caseNode = (SwitchCase) node;
            SwitchStatement parent = (SwitchStatement) caseNode.getParent();
            List<?> allStatements = parent.statements();
            int caseIndex = allStatements.indexOf(caseNode);
            int absoluteIndex = caseIndex + 1 + relativeIndex;
            listRewrite.insertAt(newStatement, absoluteIndex, null);
        }
    }

    private String applyRewrite(ASTRewrite rewriter, String originalCode) {
        IDocument document = new Document(originalCode);
        try {
            TextEdit edits = rewriter.rewriteAST(document, null);
            edits.apply(document);
            return document.get();
        } catch (Exception e) { e.printStackTrace(); return originalCode; }
    }

    private void collectLeafValues(Expression expr, List<Expression> accumulator) {
        if (expr == null) return;
        boolean isContainer = false;
        if (expr instanceof ClassInstanceCreation) {
            ClassInstanceCreation cic = (ClassInstanceCreation) expr;
            if (cic.getType().toString().startsWith("ArrayList") && !cic.arguments().isEmpty()) {
                isContainer = true;
                collectLeafValues((Expression) cic.arguments().get(0), accumulator);
            }
        } else if (expr instanceof MethodInvocation) {
            MethodInvocation mi = (MethodInvocation) expr;
            String name = mi.getName().getIdentifier();
            if (name.equals("asList") || name.equals("of")) {
                isContainer = true;
                for (Object arg : mi.arguments()) collectLeafValues((Expression) arg, accumulator);
            }
        } else if (expr instanceof ArrayInitializer) {
            isContainer = true;
            for (Object e : ((ArrayInitializer) expr).expressions()) collectLeafValues((Expression) e, accumulator);
        } else if (expr instanceof ArrayCreation) {
            isContainer = true;
            if (((ArrayCreation) expr).getInitializer() != null) collectLeafValues(((ArrayCreation) expr).getInitializer(), accumulator);
        }
        if (!isContainer) accumulator.add(expr);
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\parser\BlockFactory.java
=================================================================================

package com.botmaker.parser;

import com.botmaker.blocks.*;
import com.botmaker.core.*;
import com.botmaker.ui.BlockDragAndDropManager;
import com.botmaker.util.BlockIdPrefix;
import org.eclipse.jdt.core.dom.*;

import java.util.*;

public class BlockFactory {

    private CompilationUnit ast;
    private String currentSourceCode;
    private List<Comment> allComments;
    private boolean markNewIdentifiersAsUnedited = false;
    private BlockParser blockParser;

    public AbstractCodeBlock convert(String javaCode, Map<ASTNode, CodeBlock> nodeToBlockMap, BlockDragAndDropManager manager) {
        this.currentSourceCode = javaCode;
        this.blockParser = new BlockParser(this, manager, markNewIdentifiersAsUnedited);

        try {
            ASTParser parser = ASTParser.newParser(AST.getJLSLatest());
            parser.setSource(javaCode.toCharArray());
            parser.setKind(ASTParser.K_COMPILATION_UNIT);
            parser.setResolveBindings(true);
            parser.setUnitName("Unit.java");
            parser.setEnvironment(null, null, null, true);
            this.ast = (CompilationUnit) parser.createAST(null);

            this.allComments = new ArrayList<>();
            for (Object obj : ast.getCommentList()) {
                if (obj instanceof Comment && !(obj instanceof Javadoc)) allComments.add((Comment) obj);
            }

            if (ast.types().isEmpty()) return null;

            AbstractTypeDeclaration rootNode = (AbstractTypeDeclaration) ast.types().get(0);

            // --- CASE A: Standard Class File ---
            if (rootNode instanceof TypeDeclaration) {
                TypeDeclaration typeDecl = (TypeDeclaration) rootNode;

                ClassBlock classBlock = new ClassBlock(
                        BlockIdPrefix.generate(BlockIdPrefix.CLASS, typeDecl),
                        typeDecl,
                        manager
                );
                nodeToBlockMap.put(typeDecl, classBlock);

                // Iterate over ALL body declarations (Methods AND Inner Enums)
                for (Object obj : typeDecl.bodyDeclarations()) {

                    // 1. Handle Methods
                    if (obj instanceof MethodDeclaration) {
                        MethodDeclaration method = (MethodDeclaration) obj;
                        MethodDeclarationBlock methodBlock;

                        if (isMainMethod(method)) {
                            methodBlock = new MainBlock(
                                    BlockIdPrefix.generate(BlockIdPrefix.METHOD, method),
                                    method,
                                    manager
                            );
                        } else {
                            methodBlock = new MethodDeclarationBlock(
                                    BlockIdPrefix.generate(BlockIdPrefix.METHOD, method),
                                    method,
                                    manager
                            );
                        }

                        nodeToBlockMap.put(method, methodBlock);

                        if (method.getBody() != null) {
                            methodBlock.setBody(parseBodyBlock(method.getBody(), nodeToBlockMap, manager));
                        }

                        classBlock.addBodyDeclaration(methodBlock);
                    }

                    // 2. Handle Inner Enums (FIX: Ensure this logic exists here)
                    else if (obj instanceof EnumDeclaration) {
                        EnumDeclaration enumDecl = (EnumDeclaration) obj;
                        DeclareEnumBlock enumBlock = new DeclareEnumBlock(
                                BlockIdPrefix.generate(BlockIdPrefix.ENUM, enumDecl),
                                enumDecl // Uses the Constructor for Class Members
                        );
                        nodeToBlockMap.put(enumDecl, enumBlock);
                        classBlock.addBodyDeclaration(enumBlock);
                    }
                }

                return classBlock;
            }
            return null;

        } catch (Exception e) {
            System.err.println("Critical error in BlockFactory.convert: " + e.getMessage());
            e.printStackTrace();
            return null;
        } finally {
            setMarkNewIdentifiersAsUnedited(false);
        }
    }

    // ... (rest of the file remains exactly the same as provided: isMainMethod, parseBodyBlock, etc.)
    private boolean isMainMethod(MethodDeclaration method) {
        if (!"main".equals(method.getName().getIdentifier())) return false;
        if (!Modifier.isStatic(method.getModifiers())) return false;
        if (!Modifier.isPublic(method.getModifiers())) return false;
        if (method.parameters().size() != 1) return false;
        return true;
    }

    public void setMarkNewIdentifiersAsUnedited(boolean mark) { this.markNewIdentifiersAsUnedited = mark; }

    public BodyBlock parseBodyBlock(Block astBlock, Map<ASTNode, CodeBlock> nodeToBlockMap, BlockDragAndDropManager manager) {
        BodyBlock bodyBlock = new BodyBlock(BlockIdPrefix.generate(BlockIdPrefix.BODY, astBlock), astBlock, manager);
        nodeToBlockMap.put(astBlock, bodyBlock);

        List<CodeBlock> allChildren = new ArrayList<>();
        for (Object statementObj : astBlock.statements()) {
            blockParser.parseStatement((Statement) statementObj, nodeToBlockMap).ifPresent(allChildren::add);
        }

        // Comment merging logic
        int blockStart = astBlock.getStartPosition() + 1;
        int blockEnd = astBlock.getStartPosition() + astBlock.getLength() - 1;

        for (Comment comment : allComments) {
            int cPos = comment.getStartPosition();
            if (cPos > blockStart && cPos < blockEnd) {
                boolean isInsideChild = false;
                for (Object stmtObj : astBlock.statements()) {
                    Statement s = (Statement) stmtObj;
                    if (cPos >= s.getStartPosition() && cPos <= s.getStartPosition() + s.getLength()) {
                        isInsideChild = true;
                        break;
                    }
                }
                if (!isInsideChild) {
                    allChildren.add(parseCommentBlock(comment, nodeToBlockMap));
                }
            }
        }

        allChildren.sort(Comparator.comparingInt(b -> b.getAstNode().getStartPosition()));
        for (CodeBlock cb : allChildren) {
            if (cb instanceof StatementBlock) bodyBlock.addStatement((StatementBlock) cb);
        }
        return bodyBlock;
    }

    public Optional<StatementBlock> parseStatement(Statement stmt, Map<ASTNode, CodeBlock> map, BlockDragAndDropManager manager) {
        return blockParser.parseStatement(stmt, map);
    }

    public Optional<ExpressionBlock> parseExpression(Expression expr, Map<ASTNode, CodeBlock> map) {
        return blockParser.parseExpression(expr, map);
    }

    private CommentBlock parseCommentBlock(Comment astNode, Map<ASTNode, CodeBlock> nodeToBlockMap) {
        String text = "Comment";
        if (currentSourceCode != null) {
            try {
                String raw = currentSourceCode.substring(astNode.getStartPosition(), astNode.getStartPosition() + astNode.getLength());
                text = astNode.isLineComment() ? raw.substring(2).trim() : raw.substring(2, raw.length() - 2).trim();
            } catch (Exception ignored) {}
        }
        CommentBlock commentBlock = new CommentBlock(BlockIdPrefix.generate(BlockIdPrefix.COMMENT, astNode), astNode, text);
        nodeToBlockMap.put(astNode, commentBlock);
        return commentBlock;
    }

    public boolean isPrintStatement(Expression expression) {
        if (!(expression instanceof MethodInvocation)) return false;
        MethodInvocation method = (MethodInvocation) expression;
        if (!method.getName().getIdentifier().equals("println")) return false;
        return method.getExpression() != null && "System.out".equals(method.getExpression().toString());
    }

    public boolean isReadInputStatement(VariableDeclarationStatement varDecl) {
        if (varDecl.fragments().isEmpty()) return false;
        VariableDeclarationFragment fragment = (VariableDeclarationFragment) varDecl.fragments().get(0);
        if (!(fragment.getInitializer() instanceof MethodInvocation)) return false;
        MethodInvocation mi = (MethodInvocation) fragment.getInitializer();
        return mi.getExpression() instanceof SimpleName &&
                ((SimpleName) mi.getExpression()).getIdentifier().equals("scanner");
    }

    public CompilationUnit getCompilationUnit() { return ast; }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\parser\BlockIdPrefix.java
=================================================================================

package com.botmaker.util;

/**
 * Constants for block ID prefixes
 */
public class BlockIdPrefix {
    public static final String MAIN = "main_";
    public static final String BODY = "body_";
    public static final String VARIABLE = "var_";
    public static final String IF = "if_";
    public static final String WHILE = "while_";
    public static final String FOR = "for_";
    public static final String BREAK = "break_";
    public static final String CONTINUE = "continue_";
    public static final String ASSIGNMENT = "assign_";
    public static final String INCREMENT = "inc_";
    public static final String DECREMENT = "dec_";
    public static final String READ_INPUT = "read_";
    public static final String PRINT = "print_";
    public static final String BINARY = "binary_";
    public static final String STRING = "string_";
    public static final String NUMBER_FLOAT = "float_";
    public static final String NUMBER_DOUBLE = "double_";
    public static final String NUMBER_INT = "int_";
    public static final String BOOLEAN = "boolean_";
    public static final String IDENTIFIER = "id_";
    public static final String SYNTHETIC_STRING = "synthetic_string_";
    public static final String DO_WHILE = "do_while_";
    public static final String SWITCH = "switch_";
    public static final String RETURN = "return_";
    public static final String COMMENT = "comment_";
    public static final String WAIT = "wait_";
    public static final String LIST = "list_";
    // In BlockIdPrefix.java
    public static final String CLASS = "class_";
    public static final String METHOD = "method_";
    public static final String ENUM = "enum_";

    private BlockIdPrefix() {} // Prevent instantiation

    /**
     * Generate ID with prefix and hash
     */
    public static String generate(String prefix, Object node) {
        return prefix + node.hashCode();
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\parser\BlockParser.java
=================================================================================

package com.botmaker.parser;

import com.botmaker.blocks.*;
import com.botmaker.core.BodyBlock;
import com.botmaker.core.CodeBlock;
import com.botmaker.core.ExpressionBlock;
import com.botmaker.core.StatementBlock;
import com.botmaker.ui.BlockDragAndDropManager;
import com.botmaker.util.BlockIdPrefix;
import org.eclipse.jdt.core.dom.*;

import java.util.List;
import java.util.Map;
import java.util.Optional;

public class BlockParser {

    private final BlockFactory factory;
    private final BlockDragAndDropManager manager;
    private final boolean markNewIdentifiersAsUnedited;

    public BlockParser(BlockFactory factory, BlockDragAndDropManager manager, boolean markNewIdentifiersAsUnedited) {
        this.factory = factory;
        this.manager = manager;
        this.markNewIdentifiersAsUnedited = markNewIdentifiersAsUnedited;
    }

    public Optional<StatementBlock> parseStatement(Statement stmt, Map<ASTNode, CodeBlock> map) {
        try {
            if (stmt instanceof Block) return Optional.of(factory.parseBodyBlock((Block) stmt, map, manager));

            // --- NEW: Handle Local Enums ---
            if (stmt instanceof TypeDeclarationStatement) return parseTypeDeclaration((TypeDeclarationStatement) stmt, map);

            if (stmt instanceof VariableDeclarationStatement) return parseVariableDecl((VariableDeclarationStatement) stmt, map);
            if (stmt instanceof IfStatement) return parseIf((IfStatement) stmt, map);
            if (stmt instanceof WhileStatement) return parseWhile((WhileStatement) stmt, map);
            if (stmt instanceof EnhancedForStatement) return parseFor((EnhancedForStatement) stmt, map);
            if (stmt instanceof DoStatement) return parseDoWhile((DoStatement) stmt, map);
            if (stmt instanceof SwitchStatement) return parseSwitch((SwitchStatement) stmt, map);
            if (stmt instanceof BreakStatement) return Optional.of(new BreakBlock(BlockIdPrefix.generate(BlockIdPrefix.BREAK, stmt), (BreakStatement) stmt));
            if (stmt instanceof ContinueStatement) return Optional.of(new ContinueBlock(BlockIdPrefix.generate(BlockIdPrefix.CONTINUE, stmt), (ContinueStatement) stmt));
            if (stmt instanceof ReturnStatement) return parseReturn((ReturnStatement) stmt, map);
            if (stmt instanceof TryStatement) return parseTry((TryStatement) stmt, map);
            if (stmt instanceof ExpressionStatement) return parseExprStmt((ExpressionStatement) stmt, map);

        } catch (Exception e) {
            System.err.println("Error parsing statement: " + stmt);
            e.printStackTrace();
        }
        return Optional.empty();
    }

    private Optional<StatementBlock> parseReturn(ReturnStatement stmt, Map<ASTNode, CodeBlock> map) {
        ReturnBlock block = new ReturnBlock(BlockIdPrefix.generate(BlockIdPrefix.RETURN, stmt), stmt);
        map.put(stmt, block);
        if (stmt.getExpression() != null) {
            factory.parseExpression(stmt.getExpression(), map).ifPresent(block::setExpression);
        }
        return Optional.of(block);
    }


    private Optional<StatementBlock> parseTypeDeclaration(TypeDeclarationStatement stmt, Map<ASTNode, CodeBlock> map) {
        // Check if the declaration inside the statement is an Enum
        if (stmt.getDeclaration() instanceof EnumDeclaration) {
            DeclareEnumBlock block = new DeclareEnumBlock(BlockIdPrefix.generate(BlockIdPrefix.ENUM, stmt), stmt);
            map.put(stmt, block);
            return Optional.of(block);
        }
        return Optional.empty();
    }

    private Optional<StatementBlock> parseExprStmt(ExpressionStatement stmt, Map<ASTNode, CodeBlock> map) {
        Expression expr = stmt.getExpression();
        if (factory.isPrintStatement(expr)) return parsePrint(stmt, map);
        if (expr instanceof Assignment) return parseAssignment(stmt, map);
        if (expr instanceof PostfixExpression || expr instanceof PrefixExpression) {
            AssignmentBlock block = new AssignmentBlock(BlockIdPrefix.generate(BlockIdPrefix.ASSIGNMENT, stmt), stmt);
            map.put(stmt, block);
            if (expr instanceof PostfixExpression) factory.parseExpression(((PostfixExpression) expr).getOperand(), map).ifPresent(block::setLeftHandSide);
            if (expr instanceof PrefixExpression) factory.parseExpression(((PrefixExpression) expr).getOperand(), map).ifPresent(block::setLeftHandSide);
            return Optional.of(block);
        }
        if (expr instanceof MethodInvocation) {
            MethodInvocationBlock block = new MethodInvocationBlock(BlockIdPrefix.generate("call_", stmt), stmt);
            map.put(stmt, block);
            MethodInvocation mi = (MethodInvocation) expr;
            for (Object arg : mi.arguments()) {
                factory.parseExpression((Expression) arg, map).ifPresent(block::addArgument);
            }
            return Optional.of(block);
        }
        return Optional.empty();
    }

    private Optional<StatementBlock> parseVariableDecl(VariableDeclarationStatement stmt, Map<ASTNode, CodeBlock> map) {
        if (factory.isReadInputStatement(stmt)) {
            VariableDeclarationFragment frag = (VariableDeclarationFragment) stmt.fragments().get(0);
            MethodInvocation mi = (MethodInvocation) frag.getInitializer();
            ReadInputBlock block = new ReadInputBlock(BlockIdPrefix.generate(BlockIdPrefix.READ_INPUT, stmt), stmt, mi.getName().getIdentifier());
            map.put(stmt, block);
            factory.parseExpression(frag.getName(), map).ifPresent(block::setVariableName);
            return Optional.of(block);
        } else {
            VariableDeclarationBlock block = new VariableDeclarationBlock(BlockIdPrefix.generate(BlockIdPrefix.VARIABLE, stmt), stmt);
            map.put(stmt, block);
            VariableDeclarationFragment frag = (VariableDeclarationFragment) stmt.fragments().get(0);
            if (frag.getInitializer() != null) {
                factory.parseExpression(frag.getInitializer(), map).ifPresent(block::setInitializer);
            }
            return Optional.of(block);
        }
    }

    private Optional<StatementBlock> parseIf(IfStatement stmt, Map<ASTNode, CodeBlock> map) {
        IfBlock block = new IfBlock(BlockIdPrefix.generate(BlockIdPrefix.IF, stmt), stmt);
        map.put(stmt, block);
        factory.parseExpression(stmt.getExpression(), map).ifPresent(block::setCondition);
        if (stmt.getThenStatement() instanceof Block) {
            block.setThenBody(factory.parseBodyBlock((Block) stmt.getThenStatement(), map, manager));
        }
        if (stmt.getElseStatement() != null) {
            factory.parseStatement(stmt.getElseStatement(), map, manager).ifPresent(block::setElseStatement);
        }
        return Optional.of(block);
    }

    private Optional<StatementBlock> parseWhile(WhileStatement stmt, Map<ASTNode, CodeBlock> map) {
        WhileBlock block = new WhileBlock(BlockIdPrefix.generate(BlockIdPrefix.WHILE, stmt), stmt, manager);
        map.put(stmt, block);
        factory.parseExpression(stmt.getExpression(), map).ifPresent(block::setCondition);
        if (stmt.getBody() instanceof Block) block.setBody(factory.parseBodyBlock((Block) stmt.getBody(), map, manager));
        return Optional.of(block);
    }

    private Optional<StatementBlock> parseFor(EnhancedForStatement stmt, Map<ASTNode, CodeBlock> map) {
        ForBlock block = new ForBlock(BlockIdPrefix.generate(BlockIdPrefix.FOR, stmt), stmt, manager);
        map.put(stmt, block);
        if (stmt.getParameter() != null) factory.parseExpression(stmt.getParameter().getName(), map).ifPresent(block::setVariable);
        if (stmt.getExpression() != null) factory.parseExpression(stmt.getExpression(), map).ifPresent(block::setCollection);
        if (stmt.getBody() instanceof Block) block.setBody(factory.parseBodyBlock((Block) stmt.getBody(), map, manager));
        return Optional.of(block);
    }

    private Optional<StatementBlock> parseDoWhile(DoStatement stmt, Map<ASTNode, CodeBlock> map) {
        DoWhileBlock block = new DoWhileBlock(BlockIdPrefix.generate(BlockIdPrefix.DO_WHILE, stmt), stmt, manager);
        map.put(stmt, block);
        factory.parseExpression(stmt.getExpression(), map).ifPresent(block::setCondition);
        if (stmt.getBody() instanceof Block) block.setBody(factory.parseBodyBlock((Block) stmt.getBody(), map, manager));
        return Optional.of(block);
    }

    private Optional<StatementBlock> parseSwitch(SwitchStatement stmt, Map<ASTNode, CodeBlock> map) {
        SwitchBlock block = new SwitchBlock(BlockIdPrefix.generate(BlockIdPrefix.SWITCH, stmt), stmt, manager);
        map.put(stmt, block);
        if (stmt.getExpression() != null) factory.parseExpression(stmt.getExpression(), map).ifPresent(block::setExpression);

        BodyBlock currentBody = null;
        SwitchBlock.SwitchCaseBlock currentCase = null;

        for (Object obj : stmt.statements()) {
            Statement s = (Statement) obj;
            if (s instanceof SwitchCase) {
                SwitchCase sc = (SwitchCase) s;
                currentCase = new SwitchBlock.SwitchCaseBlock(BlockIdPrefix.generate(BlockIdPrefix.SWITCH + "_case_", sc), sc, manager);
                map.put(sc, currentCase);
                if (!sc.isDefault() && !sc.expressions().isEmpty()) {
                    factory.parseExpression((Expression) sc.expressions().get(0), map).ifPresent(currentCase::setCaseExpression);
                }

                // FIX: Pass sc directly. Do not cast to Block.
                currentBody = new BodyBlock(BlockIdPrefix.generate(BlockIdPrefix.BODY, sc), sc, manager);

                currentCase.setBody(currentBody);
                block.addCase(currentCase);
            } else if (currentBody != null) {
                factory.parseStatement(s, map, manager).ifPresent(currentBody::addStatement);
            }
        }
        return Optional.of(block);
    }

    private Optional<StatementBlock> parsePrint(ExpressionStatement stmt, Map<ASTNode, CodeBlock> map) {
        PrintBlock block = new PrintBlock(BlockIdPrefix.generate(BlockIdPrefix.PRINT, stmt), stmt);
        map.put(stmt, block);
        MethodInvocation mi = (MethodInvocation) stmt.getExpression();
        if (mi.arguments().isEmpty()) {
            block.addArgument(new LiteralBlock<>(BlockIdPrefix.generate(BlockIdPrefix.SYNTHETIC_STRING, stmt), mi, ""));
        } else {
            for (Object arg : mi.arguments()) factory.parseExpression((Expression) arg, map).ifPresent(block::addArgument);
        }
        return Optional.of(block);
    }

    private Optional<StatementBlock> parseAssignment(ExpressionStatement stmt, Map<ASTNode, CodeBlock> map) {
        AssignmentBlock block = new AssignmentBlock(BlockIdPrefix.generate(BlockIdPrefix.ASSIGNMENT, stmt), stmt);
        map.put(stmt, block);
        Assignment a = (Assignment) stmt.getExpression();
        factory.parseExpression(a.getLeftHandSide(), map).ifPresent(block::setLeftHandSide);
        factory.parseExpression(a.getRightHandSide(), map).ifPresent(block::setRightHandSide);
        return Optional.of(block);
    }

    private Optional<StatementBlock> parseTry(TryStatement stmt, Map<ASTNode, CodeBlock> map) {
        if (isWait(stmt)) {
            WaitBlock block = new WaitBlock(BlockIdPrefix.generate(BlockIdPrefix.WAIT, stmt), stmt);
            map.put(stmt, block);
            Statement inner = (Statement) stmt.getBody().statements().getFirst();
            MethodInvocation mi = (MethodInvocation) ((ExpressionStatement) inner).getExpression();
            if (!mi.arguments().isEmpty()) factory.parseExpression((Expression) mi.arguments().getFirst(), map).ifPresent(block::setDuration);
            return Optional.of(block);
        }
        return Optional.empty();
    }

    private boolean isWait(TryStatement stmt) {
        if (stmt.getBody().statements().size() != 1) return false;
        Statement first = (Statement) stmt.getBody().statements().get(0);
        if (!(first instanceof ExpressionStatement)) return false;
        Expression e = ((ExpressionStatement) first).getExpression();
        return e instanceof MethodInvocation && "sleep".equals(((MethodInvocation) e).getName().getIdentifier()) && "Thread".equals(((MethodInvocation) e).getExpression().toString());
    }

    public Optional<ExpressionBlock> parseExpression(Expression expr, Map<ASTNode, CodeBlock> map) {
        if (expr instanceof StringLiteral) {
            LiteralBlock<String> b = new LiteralBlock<>(BlockIdPrefix.generate(BlockIdPrefix.STRING, expr), expr, ((StringLiteral) expr).getLiteralValue());
            map.put(expr, b);
            return Optional.of(b);
        }
        if (isListStructure(expr)) {
            ListBlock b = new ListBlock(BlockIdPrefix.generate(BlockIdPrefix.LIST, expr), expr);
            map.put(expr, b);
            List<Expression> items = getListItems(expr);
            for (Expression item : items) factory.parseExpression(item, map).ifPresent(b::addElement);
            return Optional.of(b);
        }
        if (expr instanceof MethodInvocation) {
            MethodInvocation mi = (MethodInvocation) expr;
            MethodInvocationBlock block = new MethodInvocationBlock(BlockIdPrefix.generate("call_expr_", expr), expr);
            map.put(expr, block);
            for (Object arg : mi.arguments()) {
                factory.parseExpression((Expression) arg, map).ifPresent(block::addArgument);
            }
            return Optional.of(block);
        }
        if (expr instanceof NumberLiteral) {
            String t = ((NumberLiteral) expr).getToken();
            ExpressionBlock b;
            if (t.toLowerCase().endsWith("f")) b = new LiteralBlock<>(BlockIdPrefix.generate(BlockIdPrefix.NUMBER_FLOAT, expr), expr, Float.parseFloat(t));
            else if (t.contains(".") || t.toLowerCase().endsWith("d")) b = new LiteralBlock<>(BlockIdPrefix.generate(BlockIdPrefix.NUMBER_DOUBLE, expr), expr, Double.parseDouble(t));
            else b = new LiteralBlock<>(BlockIdPrefix.generate(BlockIdPrefix.NUMBER_INT, expr), expr, Integer.parseInt(t));
            map.put(expr, b);
            return Optional.of(b);
        }
        if (expr instanceof BooleanLiteral) {
            BooleanLiteralBlock b = new BooleanLiteralBlock(BlockIdPrefix.generate(BlockIdPrefix.BOOLEAN, expr), (BooleanLiteral) expr);
            map.put(expr, b);
            return Optional.of(b);
        }
        if (expr instanceof SimpleName) {
            if (expr.getParent() instanceof Type) return Optional.empty();
            IdentifierBlock b = new IdentifierBlock(BlockIdPrefix.generate(BlockIdPrefix.IDENTIFIER, expr), (SimpleName) expr, markNewIdentifiersAsUnedited);
            map.put(expr, b);
            return Optional.of(b);
        }
        if (expr instanceof InfixExpression) {
            BinaryExpressionBlock b = new BinaryExpressionBlock(BlockIdPrefix.generate(BlockIdPrefix.BINARY, expr), (InfixExpression) expr);
            map.put(expr, b);
            factory.parseExpression(((InfixExpression) expr).getLeftOperand(), map).ifPresent(b::setLeftOperand);
            factory.parseExpression(((InfixExpression) expr).getRightOperand(), map).ifPresent(b::setRightOperand);
            return Optional.of(b);
        }
        return Optional.empty();
    }

    private boolean isListStructure(Expression expr) {
        if (expr instanceof ArrayInitializer) return true;
        if (expr instanceof ClassInstanceCreation) {
            ClassInstanceCreation cic = (ClassInstanceCreation) expr;
            String typeName = cic.getType().toString();
            return (typeName.startsWith("ArrayList") || typeName.startsWith("java.util.ArrayList")) && !cic.arguments().isEmpty();
        }
        if (expr instanceof MethodInvocation) {
            MethodInvocation mi = (MethodInvocation) expr;
            String scope = mi.getExpression() != null ? mi.getExpression().toString() : "";
            return (scope.equals("Arrays") && mi.getName().getIdentifier().equals("asList")) || (scope.equals("List") && mi.getName().getIdentifier().equals("of"));
        }
        return false;
    }

    @SuppressWarnings("unchecked")
    private List<Expression> getListItems(Expression expr) {
        if (expr instanceof ArrayInitializer) return ((ArrayInitializer) expr).expressions();
        if (expr instanceof ClassInstanceCreation) {
            ClassInstanceCreation cic = (ClassInstanceCreation) expr;
            if (!cic.arguments().isEmpty()) {
                Expression arg = (Expression) cic.arguments().get(0);
                return getListItems(arg);
            }
        }
        if (expr instanceof MethodInvocation) return ((MethodInvocation) expr).arguments();
        return List.of();
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\parser\CodeEditor.java
=================================================================================

package com.botmaker.parser;

import com.botmaker.state.*;
import com.botmaker.core.BodyBlock;
import com.botmaker.core.StatementBlock;
import com.botmaker.events.CoreApplicationEvents;
import com.botmaker.events.EventBus;
import com.botmaker.ui.AddableBlock;
import com.botmaker.ui.AddableExpression;
import org.eclipse.jdt.core.dom.*;

import java.util.List;

public class CodeEditor {

    private final ApplicationState state;
    private final EventBus eventBus;
    private final AstRewriter astRewriter;
    private final BlockFactory blockFactory;

    public CodeEditor(ApplicationState state, EventBus eventBus,
                      AstRewriter astRewriter, BlockFactory blockFactory) {
        this.state = state;
        this.eventBus = eventBus;
        this.astRewriter = astRewriter;
        this.blockFactory = blockFactory;
    }

    private String getCurrentCode() { return state.getCurrentCode(); }
    private CompilationUnit getCompilationUnit() { return state.getCompilationUnit().orElse(null); }

    private void triggerUpdate(String newCode) {
        String previousCode = getCurrentCode();
        eventBus.publish(new CoreApplicationEvents.CodeUpdatedEvent(newCode, previousCode));
    }

    public void updateMethodInvocation(MethodInvocation mi, String newScope, String newMethodName, List<String> newParamTypes) {
        blockFactory.setMarkNewIdentifiersAsUnedited(true);
        String newCode = astRewriter.updateMethodInvocation(getCompilationUnit(), getCurrentCode(), mi, newScope, newMethodName, newParamTypes);
        triggerUpdate(newCode);
    }

    public void addArgumentToMethodInvocation(MethodInvocation mi, AddableExpression type) {
        blockFactory.setMarkNewIdentifiersAsUnedited(true);
        String newCode = astRewriter.addArgumentToMethodInvocation(getCompilationUnit(), getCurrentCode(), mi, type);
        triggerUpdate(newCode);
    }

    public void addArgumentToMethodInvocation(MethodInvocation mi, Expression expr) {
        String newCode = astRewriter.addArgumentToMethodInvocation(getCompilationUnit(), getCurrentCode(), mi, expr);
        triggerUpdate(newCode);
    }

    public void moveStatement(StatementBlock blockToMove, BodyBlock sourceBody, BodyBlock targetBody, int targetIndex) {
        String newCode = astRewriter.moveStatement(getCompilationUnit(), getCurrentCode(), blockToMove, sourceBody, targetBody, targetIndex);
        triggerUpdate(newCode);
    }

    public void replaceLiteralValue(Expression toReplace, String newLiteralValue) {
        String newCode = astRewriter.replaceLiteral(getCompilationUnit(), getCurrentCode(), toReplace, newLiteralValue);
        triggerUpdate(newCode);
    }

    public void renameEnum(EnumDeclaration enumNode, String newName) {
        String newCode = astRewriter.renameEnum(getCompilationUnit(), getCurrentCode(), enumNode, newName);
        triggerUpdate(newCode);
    }

    public void addEnumConstant(EnumDeclaration enumNode, String constantName) {
        String newCode = astRewriter.addEnumConstant(getCompilationUnit(), getCurrentCode(), enumNode, constantName);
        triggerUpdate(newCode);
    }

    public void deleteEnumConstant(EnumDeclaration enumNode, int index) {
        String newCode = astRewriter.deleteEnumConstant(getCompilationUnit(), getCurrentCode(), enumNode, index);
        triggerUpdate(newCode);
    }

    public void renameEnumConstant(EnumDeclaration enumNode, int index, String newName) {
        String newCode = astRewriter.renameEnumConstant(getCompilationUnit(), getCurrentCode(), enumNode, index, newName);
        triggerUpdate(newCode);
    }

    public void addMethodToClass(TypeDeclaration typeDecl, String methodName, String returnType, int index) {
        blockFactory.setMarkNewIdentifiersAsUnedited(true);
        String newCode = astRewriter.addMethodToClass(
                getCompilationUnit(),
                getCurrentCode(),
                typeDecl,
                methodName,
                returnType,
                index
        );
        triggerUpdate(newCode);
    }

    public void deleteMethod(MethodDeclaration method) {
        String newCode = astRewriter.deleteMethodFromClass(
                getCompilationUnit(),
                getCurrentCode(),
                method
        );
        triggerUpdate(newCode);
    }

    public void addStringArgumentToMethodInvocation(MethodInvocation mi, String text) {
        CompilationUnit cu = getCompilationUnit();
        if (cu == null) return;
        AST ast = cu.getAST();
        StringLiteral newArg = ast.newStringLiteral();
        newArg.setLiteralValue(text);
        String newCode = astRewriter.addArgumentToMethodInvocation(cu, getCurrentCode(), mi, newArg);
        triggerUpdate(newCode);
    }

    public void renameMethodParameter(MethodDeclaration method, int index, String newName) {
        String newCode = astRewriter.renameMethodParameter(getCompilationUnit(), getCurrentCode(), method, index, newName);
        triggerUpdate(newCode);
    }

    public void setMethodReturnType(MethodDeclaration method, String newTypeName) {
        String newCode = astRewriter.setMethodReturnType(getCompilationUnit(), getCurrentCode(), method, newTypeName);
        triggerUpdate(newCode);
    }

    public void addParameterToMethod(MethodDeclaration method, String typeName, String paramName) {
        String newCode = astRewriter.addParameterToMethod(getCompilationUnit(), getCurrentCode(), method, typeName, paramName);
        triggerUpdate(newCode);
    }

    public void deleteParameterFromMethod(MethodDeclaration method, int index) {
        String newCode = astRewriter.deleteParameterFromMethod(getCompilationUnit(), getCurrentCode(), method, index);
        triggerUpdate(newCode);
    }

    public void setReturnExpression(ReturnStatement returnStmt, AddableExpression type) {
        blockFactory.setMarkNewIdentifiersAsUnedited(true);
        String newCode = astRewriter.setReturnExpression(getCompilationUnit(), getCurrentCode(), returnStmt, type);
        triggerUpdate(newCode);
    }

    public void addElementToList(ASTNode listNode, AddableExpression type, int insertIndex) {
        blockFactory.setMarkNewIdentifiersAsUnedited(true);
        String newCode = astRewriter.addElementToList(getCompilationUnit(), getCurrentCode(), listNode, type, insertIndex);
        triggerUpdate(newCode);
    }

    public void addEnumToClass(TypeDeclaration typeDecl, String enumName, int index) {
        blockFactory.setMarkNewIdentifiersAsUnedited(true);
        String newCode = astRewriter.addEnumToClass(getCompilationUnit(), getCurrentCode(), typeDecl, enumName, index);
        triggerUpdate(newCode);
    }

    public void deleteEnumFromClass(EnumDeclaration enumDecl) {
        String newCode = astRewriter.deleteEnumFromClass(getCompilationUnit(), getCurrentCode(), enumDecl);
        triggerUpdate(newCode);
    }

    public void deleteElementFromList(ASTNode listNode, int elementIndex) {
        String newCode = astRewriter.deleteElementFromList(getCompilationUnit(), getCurrentCode(), listNode, elementIndex);
        triggerUpdate(newCode);
    }

    public void updateComment(Comment commentNode, String newText) {
        String newCode = astRewriter.updateComment(getCurrentCode(), commentNode, newText);
        triggerUpdate(newCode);
    }

    public void deleteComment(Comment commentNode) {
        String newCode = astRewriter.deleteComment(getCurrentCode(), commentNode);
        triggerUpdate(newCode);
    }

    public void replaceExpression(Expression toReplace, com.botmaker.ui.AddableExpression type) {
        blockFactory.setMarkNewIdentifiersAsUnedited(true);
        String newCode = astRewriter.replaceExpression(getCompilationUnit(), getCurrentCode(), toReplace, type);
        triggerUpdate(newCode);
    }

    public void addStatement(BodyBlock targetBody, AddableBlock type, int index) {
        blockFactory.setMarkNewIdentifiersAsUnedited(true);
        String newCode = astRewriter.addStatement(getCompilationUnit(), getCurrentCode(), targetBody, type, index);
        triggerUpdate(newCode);
    }

    public void deleteElseFromIfStatement(IfStatement ifStmt) {
        String newCode = astRewriter.deleteElseFromIfStatement(getCompilationUnit(), getCurrentCode(), ifStmt);
        triggerUpdate(newCode);
    }

    public void convertElseToElseIf(IfStatement ifStmt) {
        String newCode = astRewriter.convertElseToElseIf(getCompilationUnit(), getCurrentCode(), ifStmt);
        triggerUpdate(newCode);
    }

    public void addElseToIfStatement(IfStatement ifStmt) {
        String newCode = astRewriter.addElseToIfStatement(getCompilationUnit(), getCurrentCode(), ifStmt);
        triggerUpdate(newCode);
    }

    public void replaceSimpleName(SimpleName toReplace, String newName) {
        String newCode = astRewriter.replaceSimpleName(getCompilationUnit(), getCurrentCode(), toReplace, newName);
        triggerUpdate(newCode);
    }

    public void deleteStatement(Statement toDelete) {
        String newCode = astRewriter.deleteNode(getCompilationUnit(), getCurrentCode(), toDelete);
        triggerUpdate(newCode);
    }

    public void replaceVariableType(VariableDeclarationStatement toReplace, String newTypeName) {
        String newCode = astRewriter.replaceVariableType(getCompilationUnit(), getCurrentCode(), toReplace, newTypeName);
        triggerUpdate(newCode);
    }

    public void updateAssignmentOperator(ASTNode node, String newOperatorSymbol) {
        String newCode = null;
        if (node instanceof Assignment) {
            Assignment.Operator op = getAssignmentOperator(newOperatorSymbol);
            if (op != null) {
                newCode = astRewriter.replaceAssignmentOperator(getCompilationUnit(), getCurrentCode(), (Assignment) node, op);
            }
        } else if (node instanceof PrefixExpression) {
            PrefixExpression.Operator op = getPrefixOperator(newOperatorSymbol);
            if (op != null) {
                newCode = astRewriter.replacePrefixOperator(getCompilationUnit(), getCurrentCode(), (org.eclipse.jdt.core.dom.PrefixExpression) node, op);
            }
        } else if (node instanceof org.eclipse.jdt.core.dom.PostfixExpression) {
            org.eclipse.jdt.core.dom.PostfixExpression.Operator op = getPostfixOperator(newOperatorSymbol);
            if (op != null) {
                newCode = astRewriter.replacePostfixOperator(getCompilationUnit(), getCurrentCode(), (org.eclipse.jdt.core.dom.PostfixExpression) node, op);
            }
        }
        if (newCode != null) {
            triggerUpdate(newCode);
        }
    }

    // --- NEW: Binary Operator Updates ---
    public void updateBinaryOperator(ASTNode node, String newOperatorSymbol) {
        if (node instanceof InfixExpression) {
            InfixExpression.Operator op = getInfixOperator(newOperatorSymbol);
            if (op != null) {
                String newCode = astRewriter.replaceInfixOperator(getCompilationUnit(), getCurrentCode(), (InfixExpression) node, op);
                triggerUpdate(newCode);
            }
        }
    }

    // --- Switch Case Methods ---
    public void addCaseToSwitch(SwitchStatement switchStmt) {
        blockFactory.setMarkNewIdentifiersAsUnedited(true);
        String newCode = astRewriter.addCaseToSwitch(getCompilationUnit(), getCurrentCode(), switchStmt);
        triggerUpdate(newCode);
    }

    public void moveSwitchCase(SwitchCase caseNode, boolean moveUp) {
        String newCode = astRewriter.moveSwitchCase(getCompilationUnit(), getCurrentCode(), caseNode, moveUp);
        triggerUpdate(newCode);
    }

    // --- Helpers ---
    private InfixExpression.Operator getInfixOperator(String symbol) {
        if ("+".equals(symbol)) return InfixExpression.Operator.PLUS;
        if ("-".equals(symbol)) return InfixExpression.Operator.MINUS;
        if ("*".equals(symbol)) return InfixExpression.Operator.TIMES;
        if ("/".equals(symbol)) return InfixExpression.Operator.DIVIDE;
        if ("%".equals(symbol)) return InfixExpression.Operator.REMAINDER;
        if ("==".equals(symbol)) return InfixExpression.Operator.EQUALS;
        if ("!=".equals(symbol)) return InfixExpression.Operator.NOT_EQUALS;
        if (">".equals(symbol)) return InfixExpression.Operator.GREATER;
        if (">=".equals(symbol)) return InfixExpression.Operator.GREATER_EQUALS;
        if ("<".equals(symbol)) return InfixExpression.Operator.LESS;
        if ("<=".equals(symbol)) return InfixExpression.Operator.LESS_EQUALS;
        if ("&&".equals(symbol)) return InfixExpression.Operator.CONDITIONAL_AND;
        if ("||".equals(symbol)) return InfixExpression.Operator.CONDITIONAL_OR;
        return null;
    }

    private Assignment.Operator getAssignmentOperator(String symbol) {
        if ("=".equals(symbol)) return Assignment.Operator.ASSIGN;
        if ("+=".equals(symbol)) return Assignment.Operator.PLUS_ASSIGN;
        if ("-=".equals(symbol)) return Assignment.Operator.MINUS_ASSIGN;
        if ("*=".equals(symbol)) return Assignment.Operator.TIMES_ASSIGN;
        if ("/=".equals(symbol)) return Assignment.Operator.DIVIDE_ASSIGN;
        if ("%=".equals(symbol)) return Assignment.Operator.REMAINDER_ASSIGN;
        return null;
    }

    private org.eclipse.jdt.core.dom.PrefixExpression.Operator getPrefixOperator(String symbol) {
        if ("++".equals(symbol)) return org.eclipse.jdt.core.dom.PrefixExpression.Operator.INCREMENT;
        if ("--".equals(symbol)) return org.eclipse.jdt.core.dom.PrefixExpression.Operator.DECREMENT;
        return null;
    }

    private org.eclipse.jdt.core.dom.PostfixExpression.Operator getPostfixOperator(String symbol) {
        if ("++".equals(symbol)) return org.eclipse.jdt.core.dom.PostfixExpression.Operator.INCREMENT;
        if ("--".equals(symbol)) return org.eclipse.jdt.core.dom.PostfixExpression.Operator.DECREMENT;
        return null;
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\parser\ImportManager.java
=================================================================================

package com.botmaker.parser;

import org.eclipse.jdt.core.dom.*;
import org.eclipse.jdt.core.dom.rewrite.ASTRewrite;
import org.eclipse.jdt.core.dom.rewrite.ListRewrite;

import java.util.HashSet;
import java.util.List;
import java.util.Set;

public class ImportManager {

    /**
     * Ensures that the specific class is imported in the CompilationUnit.
     * @param cu The compilation unit.
     * @param rewriter The ASTRewrite instance.
     * @param qualifiedClassName The full class name (e.g., "java.util.ArrayList").
     */
    public static void addImport(CompilationUnit cu, ASTRewrite rewriter, String qualifiedClassName) {
        if (cu == null || qualifiedClassName == null) return;

        // Check existing imports
        List<ImportDeclaration> imports = cu.imports();
        Set<String> existingImports = new HashSet<>();

        for (ImportDeclaration imp : imports) {
            if (imp.isOnDemand()) {
                // e.g., java.util.*
                String packageName = imp.getName().getFullyQualifiedName();
                String targetPackage = qualifiedClassName.substring(0, qualifiedClassName.lastIndexOf('.'));
                if (packageName.equals(targetPackage)) {
                    return; // Covered by wildcard
                }
            } else {
                existingImports.add(imp.getName().getFullyQualifiedName());
            }
        }

        if (existingImports.contains(qualifiedClassName)) {
            return; // Already imported
        }

        // Create new import
        AST ast = cu.getAST();
        ImportDeclaration newImport = ast.newImportDeclaration();
        newImport.setName(ast.newName(qualifiedClassName));

        // Insert into AST
        ListRewrite listRewrite = rewriter.getListRewrite(cu, CompilationUnit.IMPORTS_PROPERTY);
        listRewrite.insertLast(newImport, null);
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\parser\NodeCreator.java
=================================================================================

package com.botmaker.parser;

import com.botmaker.ui.AddableBlock;
import com.botmaker.ui.AddableExpression;
import com.botmaker.util.DefaultNames;
import com.botmaker.util.TypeManager;
import org.eclipse.jdt.core.dom.*;
import org.eclipse.jdt.core.dom.rewrite.ASTRewrite;

import java.util.List;

import static com.botmaker.util.TypeManager.toWrapperType;

public class NodeCreator {


    public Expression createDefaultExpression(AST ast, AddableExpression type, CompilationUnit cu, ASTRewrite rewriter) {
        switch (type) {
            case TEXT:
                StringLiteral newString = ast.newStringLiteral();
                newString.setLiteralValue("text");
                return newString;
            case FUNCTION_CALL:
                MethodInvocation call = ast.newMethodInvocation();
                call.setName(ast.newSimpleName("selectMethod"));
                return call;
            case NUMBER:
                return ast.newNumberLiteral("0");
            case TRUE:
                return ast.newBooleanLiteral(true);
            case FALSE:
                return ast.newBooleanLiteral(false);
            case VARIABLE:
                return ast.newSimpleName(DefaultNames.DEFAULT_VARIABLE);
            case LIST:
                ImportManager.addImport(cu, rewriter, "java.util.Arrays");
                MethodInvocation asList = ast.newMethodInvocation();
                asList.setExpression(ast.newSimpleName("Arrays"));
                asList.setName(ast.newSimpleName("asList"));
                return asList;

            case ADD:
            case SUBTRACT:
            case MULTIPLY:
            case DIVIDE:
            case MODULO:
                InfixExpression infixExpr = ast.newInfixExpression();
                infixExpr.setLeftOperand(ast.newSimpleName(DefaultNames.DEFAULT_VARIABLE));
                infixExpr.setRightOperand(ast.newNumberLiteral("0"));
                switch (type) {
                    case ADD: infixExpr.setOperator(InfixExpression.Operator.PLUS); break;
                    case SUBTRACT: infixExpr.setOperator(InfixExpression.Operator.MINUS); break;
                    case MULTIPLY: infixExpr.setOperator(InfixExpression.Operator.TIMES); break;
                    case DIVIDE: infixExpr.setOperator(InfixExpression.Operator.DIVIDE); break;
                    case MODULO: infixExpr.setOperator(InfixExpression.Operator.REMAINDER); break;
                }
                return infixExpr;
            default:
                return null;
        }
    }

    public Statement createDefaultStatement(AST ast, AddableBlock type, CompilationUnit cu, ASTRewrite rewriter) {
        switch (type) {
            case PRINT:
                MethodInvocation println = ast.newMethodInvocation();
                println.setExpression(ast.newQualifiedName(ast.newSimpleName("System"), ast.newSimpleName("out")));
                println.setName(ast.newSimpleName("println"));
                StringLiteral emptyString = ast.newStringLiteral();
                emptyString.setLiteralValue("");
                println.arguments().add(emptyString);
                return ast.newExpressionStatement(println);

            case DECLARE_INT:
                return createVariableDeclaration(ast, DefaultNames.DEFAULT_INT, "0", PrimitiveType.INT);
            case DECLARE_DOUBLE:
                return createVariableDeclaration(ast, DefaultNames.DEFAULT_DOUBLE, "0.0", PrimitiveType.DOUBLE);
            case DECLARE_BOOLEAN:
                return createVariableDeclaration(ast, DefaultNames.DEFAULT_BOOLEAN, false, PrimitiveType.BOOLEAN);
            case DECLARE_STRING:
                return createStringDeclaration(ast);
            case DECLARE_ARRAY:
                if (cu != null && rewriter != null) {
                    ImportManager.addImport(cu, rewriter, "java.util.ArrayList");
                    ImportManager.addImport(cu, rewriter, "java.util.Arrays");
                }
                VariableDeclarationFragment frag = ast.newVariableDeclarationFragment();
                frag.setName(ast.newSimpleName("myList"));
                frag.setInitializer(createRecursiveListInitializer(ast, "ArrayList<Integer>", cu, rewriter, null));
                VariableDeclarationStatement listDecl = ast.newVariableDeclarationStatement(frag);
                listDecl.setType(TypeManager.createTypeNode(ast, "ArrayList<Integer>"));
                return listDecl;
            case IF:
                IfStatement ifStatement = ast.newIfStatement();
                ifStatement.setExpression(ast.newBooleanLiteral(true));
                ifStatement.setThenStatement(ast.newBlock());
                return ifStatement;

            case WHILE:
                WhileStatement whileStatement = ast.newWhileStatement();
                whileStatement.setExpression(ast.newBooleanLiteral(true));
                whileStatement.setBody(ast.newBlock());
                return whileStatement;

            case FOR:
                EnhancedForStatement enhancedFor = ast.newEnhancedForStatement();
                SingleVariableDeclaration parameter = ast.newSingleVariableDeclaration();
                parameter.setType(TypeManager.createTypeNode(ast, "String"));
                parameter.setName(ast.newSimpleName("item"));
                enhancedFor.setParameter(parameter);
                enhancedFor.setExpression(ast.newSimpleName("array"));
                enhancedFor.setBody(ast.newBlock());
                return enhancedFor;

            case DO_WHILE:
                DoStatement doStatement = ast.newDoStatement();
                doStatement.setExpression(ast.newBooleanLiteral(true));
                doStatement.setBody(ast.newBlock());
                return doStatement;

            case FUNCTION_CALL:
                MethodInvocation methodCall = ast.newMethodInvocation();
                methodCall.setName(ast.newSimpleName("selectMethod"));
                return ast.newExpressionStatement(methodCall);

            case BREAK: return ast.newBreakStatement();
            case CONTINUE: return ast.newContinueStatement();
            case RETURN: return ast.newReturnStatement();

            case COMMENT: return ast.newEmptyStatement();
            case DECLARE_ENUM:
                TypeDeclarationStatement typeDeclStmt = ast.newTypeDeclarationStatement(ast.newEnumDeclaration());
                EnumDeclaration enumDecl = (EnumDeclaration) typeDeclStmt.getDeclaration();
                enumDecl.setName(ast.newSimpleName("MyEnum"));

                EnumConstantDeclaration const1 = ast.newEnumConstantDeclaration();
                const1.setName(ast.newSimpleName("OPTION_A"));
                enumDecl.enumConstants().add(const1);

                EnumConstantDeclaration const2 = ast.newEnumConstantDeclaration();
                const2.setName(ast.newSimpleName("OPTION_B"));
                enumDecl.enumConstants().add(const2);

                return typeDeclStmt;
            case ASSIGNMENT:
                Assignment assignment = ast.newAssignment();
                assignment.setLeftHandSide(ast.newSimpleName(DefaultNames.DEFAULT_VARIABLE));
                assignment.setOperator(Assignment.Operator.ASSIGN);
                assignment.setRightHandSide(ast.newNumberLiteral("0"));
                return ast.newExpressionStatement(assignment);

            case READ_LINE: return createScannerCall(ast, "input", "nextLine", "String");
            case READ_INT: return createScannerCall(ast, "num", "nextInt", PrimitiveType.INT);
            case READ_DOUBLE: return createScannerCall(ast, "num", "nextDouble", PrimitiveType.DOUBLE);

            case SWITCH:
                SwitchStatement switchStmt = ast.newSwitchStatement();
                switchStmt.setExpression(ast.newSimpleName(DefaultNames.DEFAULT_VARIABLE));
                // Add default case
                SwitchCase defaultCase = ast.newSwitchCase();
                // defaultCase.setExpression(null); // Implicitly default
                switchStmt.statements().add(defaultCase);
                switchStmt.statements().add(ast.newBreakStatement());
                return switchStmt;

            // REMOVED: case CASE:

            case WAIT:
                return createWaitStatement(ast);

            default:
                return null;
        }
    }

    // ... [Helpers remain the same] ...
    private Statement createVariableDeclaration(AST ast, String name, String val, PrimitiveType.Code type) {
        VariableDeclarationFragment fragment = ast.newVariableDeclarationFragment();
        fragment.setName(ast.newSimpleName(name));
        fragment.setInitializer(ast.newNumberLiteral(val));
        VariableDeclarationStatement varDecl = ast.newVariableDeclarationStatement(fragment);
        varDecl.setType(ast.newPrimitiveType(type));
        return varDecl;
    }

    private Statement createVariableDeclaration(AST ast, String name, boolean val, PrimitiveType.Code type) {
        VariableDeclarationFragment fragment = ast.newVariableDeclarationFragment();
        fragment.setName(ast.newSimpleName(name));
        fragment.setInitializer(ast.newBooleanLiteral(val));
        VariableDeclarationStatement varDecl = ast.newVariableDeclarationStatement(fragment);
        varDecl.setType(ast.newPrimitiveType(type));
        return varDecl;
    }

    private Statement createStringDeclaration(AST ast) {
        VariableDeclarationFragment fragment = ast.newVariableDeclarationFragment();
        fragment.setName(ast.newSimpleName(DefaultNames.DEFAULT_STRING));
        fragment.setInitializer(ast.newStringLiteral());
        VariableDeclarationStatement varDecl = ast.newVariableDeclarationStatement(fragment);
        varDecl.setType(TypeManager.createTypeNode(ast, "String"));
        return varDecl;
    }

    private Statement createScannerCall(AST ast, String varName, String methodName, Object typeObj) {
        VariableDeclarationFragment fragment = ast.newVariableDeclarationFragment();
        fragment.setName(ast.newSimpleName(varName));
        MethodInvocation scannerCall = ast.newMethodInvocation();
        scannerCall.setExpression(ast.newSimpleName("scanner"));
        scannerCall.setName(ast.newSimpleName(methodName));
        fragment.setInitializer(scannerCall);
        VariableDeclarationStatement varDecl = ast.newVariableDeclarationStatement(fragment);
        if(typeObj instanceof String) varDecl.setType(TypeManager.createTypeNode(ast, (String)typeObj));
        else varDecl.setType(ast.newPrimitiveType((PrimitiveType.Code)typeObj));
        return varDecl;
    }

    private Statement createWaitStatement(AST ast) {
        TryStatement tryStmt = ast.newTryStatement();
        Block tryBody = ast.newBlock();
        MethodInvocation sleepCall = ast.newMethodInvocation();
        sleepCall.setExpression(ast.newSimpleName("Thread"));
        sleepCall.setName(ast.newSimpleName("sleep"));
        sleepCall.arguments().add(ast.newNumberLiteral("1000"));
        tryBody.statements().add(ast.newExpressionStatement(sleepCall));
        tryStmt.setBody(tryBody);
        CatchClause catchClause = ast.newCatchClause();
        SingleVariableDeclaration exceptionDecl = ast.newSingleVariableDeclaration();
        exceptionDecl.setType(ast.newSimpleType(ast.newSimpleName("InterruptedException")));
        exceptionDecl.setName(ast.newSimpleName("e"));
        catchClause.setException(exceptionDecl);
        Block catchBody = ast.newBlock();
        MethodInvocation printStackTrace = ast.newMethodInvocation();
        printStackTrace.setExpression(ast.newSimpleName("e"));
        printStackTrace.setName(ast.newSimpleName("printStackTrace"));
        catchBody.statements().add(ast.newExpressionStatement(printStackTrace));
        catchClause.setBody(catchBody);
        tryStmt.catchClauses().add(catchClause);
        return tryStmt;
    }

    public Expression createRecursiveListInitializer(AST ast, String typeName, CompilationUnit cu, ASTRewrite rewriter, List<Expression> leavesToPreserve) {
        ImportManager.addImport(cu, rewriter, "java.util.ArrayList");
        ImportManager.addImport(cu, rewriter, "java.util.Arrays");

        ClassInstanceCreation creation = ast.newClassInstanceCreation();
        String innerTypeStr = extractArrayListElementType(typeName);
        String wrapperInnerType = toWrapperType(innerTypeStr);
        ParameterizedType paramType = ast.newParameterizedType(ast.newSimpleType(ast.newName("ArrayList")));

        if (!innerTypeStr.equals("Object")) {
            paramType.typeArguments().add(TypeManager.createTypeNode(ast, wrapperInnerType));
        }
        creation.setType(paramType);

        MethodInvocation asList = ast.newMethodInvocation();
        asList.setExpression(ast.newSimpleName("Arrays"));
        asList.setName(ast.newSimpleName("asList"));

        if (innerTypeStr.startsWith("ArrayList<")) {
            Expression innerList = createRecursiveListInitializer(ast, innerTypeStr, cu, rewriter, leavesToPreserve);
            asList.arguments().add(innerList);
        } else {
            if (leavesToPreserve != null && !leavesToPreserve.isEmpty()) {
                for (Expression leaf : leavesToPreserve) {
                    asList.arguments().add((Expression) ASTNode.copySubtree(ast, leaf));
                }
            } else {
                asList.arguments().add(createDefaultInitializer(ast, innerTypeStr));
            }
        }
        creation.arguments().add(asList);
        return creation;
    }

    public Expression createDefaultInitializer(AST ast, String typeName) {
        switch (typeName) {
            case "int": case "long": case "short": case "byte": return ast.newNumberLiteral("0");
            case "double": case "float": return ast.newNumberLiteral("0.0");
            case "boolean": return ast.newBooleanLiteral(false);
            case "char":
                CharacterLiteral literal = ast.newCharacterLiteral();
                literal.setCharValue('a');
                return literal;
            case "String":
                StringLiteral str = ast.newStringLiteral();
                str.setLiteralValue("");
                return str;
            default: return ast.newNullLiteral();
        }
    }

    private String extractArrayListElementType(String arrayListType) {
        if (arrayListType.contains("<") && arrayListType.contains(">")) {
            int start = arrayListType.indexOf("<") + 1;
            int end = arrayListType.lastIndexOf(">");
            return arrayListType.substring(start, end);
        }
        return "Object";
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\project\LibraryManager.java
=================================================================================

package com.botmaker.project;

import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.HashMap;
import java.util.Map;

public class LibraryManager {

    // Map of Relative Path -> Source Code Content
    private static final Map<String, String> LIBRARY_FILES = new HashMap<>();

    // Load the library definition
    static {
        // 1. CAPTURE
        loadSource("capture/Clicker.java");
        loadSource("capture/GDI32.java");
        loadSource("capture/ImageDisplay.java");
        loadSource("capture/ScreenCapture.java");
        loadSource("capture/User32.java");
        loadSource("capture/WindowFinder.java");
        loadSource("capture/WindowInfo.java");

        // 2. EMULATOR
        loadSource("emulator/AdbHelper.java");
        loadSource("emulator/BlueStacksConfig.java");
        loadSource("emulator/BlueStacksEmulator.java");
        loadSource("emulator/BlueStacksInstance.java");
        loadSource("emulator/BlueStacksInstanceManager.java");
        loadSource("emulator/Emulator.java");

        // 3. INSPECTOR
        loadSource("inspector/RegistryInspector.java");

        // 4. INTERACTION
        loadSource("interaction/GameInteractor.java");
        loadSource("interaction/GameType.java");

        // 5. OPENCV
        loadSource("opencv/MatchResult.java");
        loadSource("opencv/MatType.java");
        loadSource("opencv/OpencvManager.java");
        loadSource("opencv/Template.java");

        // 6. LIBRARY ROOT
        loadSource("Main.java"); // The library Main class if needed
    }

    /**
     * Loads source code into memory.
     * Priority 1: Read from current IntelliJ Project (Dev Mode)
     * Priority 2: Read from JAR Resources (Production Mode)
     */
    private static void loadSource(String relativePath) {
        String content = null;
        try {
            // DEV MODE: Try reading directly from your source folder
            // This assumes BotMaker is running from within the project root
            Path devPath = Paths.get("src/main/java/com/botmaker/library", relativePath);
            if (Files.exists(devPath)) {
                content = Files.readString(devPath);
            } else {
                // PROD MODE: Read from classpath resources
                // You must ensure your build process copies these java files to src/main/resources/library_src/
                String resourcePath = "/library_src/" + relativePath;
                InputStream stream = LibraryManager.class.getResourceAsStream(resourcePath);
                if (stream != null) {
                    content = new String(stream.readAllBytes(), StandardCharsets.UTF_8);
                }
            }

            if (content != null) {
                // Correct the package declaration if necessary, though usually it stays com.botmaker.library...
                LIBRARY_FILES.put(relativePath, content);
            } else {
                System.err.println("LibraryManager: Could not find source for " + relativePath);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * Installs the library source code into the user's project.
     */
    public void installLibrary(Path projectPath) {
        try {
            Path libRoot = projectPath.resolve("src/main/java/com/botmaker/library");

            for (Map.Entry<String, String> entry : LIBRARY_FILES.entrySet()) {
                Path targetFile = libRoot.resolve(entry.getKey());
                Files.createDirectories(targetFile.getParent());

                // Only write if different to preserve file modification times if possible
                if (!Files.exists(targetFile) || !Files.readString(targetFile).equals(entry.getValue())) {
                    Files.writeString(targetFile, entry.getValue());
                }
            }
        } catch (IOException e) {
            System.err.println("Failed to install library: " + e.getMessage());
        }
    }

    /**
     * Checks if user modified library files and repairs them.
     * Returns true if repairs were made.
     */
    public boolean verifyAndRepair(Path projectPath) {
        Path libRoot = projectPath.resolve("src/main/java/com/botmaker/library");
        boolean repaired = false;

        try {
            for (Map.Entry<String, String> entry : LIBRARY_FILES.entrySet()) {
                Path targetFile = libRoot.resolve(entry.getKey());
                String expected = entry.getValue();

                if (!Files.exists(targetFile)) {
                    System.out.println("Restoring missing library file: " + entry.getKey());
                    Files.createDirectories(targetFile.getParent());
                    Files.writeString(targetFile, expected);
                    repaired = true;
                } else {
                    // Simple string comparison.
                    // In production, you might ignore whitespace or use a hash.
                    String current = Files.readString(targetFile);
                    // Normalize line endings
                    if (!current.replace("\r\n", "\n").trim().equals(expected.replace("\r\n", "\n").trim())) {
                        System.out.println("Repairing modified library file: " + entry.getKey());
                        Files.writeString(targetFile, expected);
                        repaired = true;
                    }
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
        return repaired;
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\project\ProjectConfig.java
=================================================================================

package com.botmaker.project;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.List;

/**
 * Configuration for BotMaker projects, stored in projects/.botmaker-config.json
 */
public class ProjectConfig {

    private static final Path CONFIG_FILE = Paths.get("projects/.botmaker-config.json");
    private static final Gson GSON = new GsonBuilder()
            .setPrettyPrinting()
            .create();

    private String lastOpenedProject;
    private List<ProjectEntry> recentProjects;

    public ProjectConfig() {
        this.recentProjects = new ArrayList<>();
    }

    public String getLastOpenedProject() {
        return lastOpenedProject;
    }

    public void setLastOpenedProject(String projectName) {
        this.lastOpenedProject = projectName;
    }

    public List<ProjectEntry> getRecentProjects() {
        return recentProjects;
    }

    public void addRecentProject(String projectName) {
        // Remove if already exists
        recentProjects.removeIf(p -> p.getName().equals(projectName));

        // Add at the beginning
        ProjectEntry entry = new ProjectEntry(projectName);
        recentProjects.add(0, entry);

        // Keep only last 10 projects
        if (recentProjects.size() > 10) {
            recentProjects = recentProjects.subList(0, 10);
        }
    }

    /**
     * Loads the configuration from disk
     */
    public static ProjectConfig load() {
        try {
            if (Files.exists(CONFIG_FILE)) {
                String json = Files.readString(CONFIG_FILE);
                return GSON.fromJson(json, ProjectConfig.class);
            }
        } catch (Exception e) {
            System.err.println("Failed to load project config: " + e.getMessage());
        }

        // Return default config if file doesn't exist or can't be read
        return new ProjectConfig();
    }

    /**
     * Saves the configuration to disk
     */
    public void save() {
        try {
            // Ensure projects directory exists
            Files.createDirectories(CONFIG_FILE.getParent());

            // Write JSON
            String json = GSON.toJson(this);
            Files.writeString(CONFIG_FILE, json);
        } catch (IOException e) {
            System.err.println("Failed to save project config: " + e.getMessage());
        }
    }

    /**
     * Updates the last opened project and saves
     */
    public static void updateLastOpened(String projectName) {
        ProjectConfig config = load();
        config.setLastOpenedProject(projectName);
        config.addRecentProject(projectName);
        config.save();
    }

    /**
     * Gets the last opened project name, or null if none
     */
    public static String getLastOpened() {
        ProjectConfig config = load();
        return config.getLastOpenedProject();
    }

    /**
     * Represents a recent project entry
     */
    public static class ProjectEntry {
        private String name;
        private String lastOpened; // ISO-8601 timestamp string

        public ProjectEntry() {
            // For Gson
        }

        public ProjectEntry(String name) {
            this.name = name;
            this.lastOpened = LocalDateTime.now().format(DateTimeFormatter.ISO_LOCAL_DATE_TIME);
        }

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }

        public String getLastOpened() {
            return lastOpened;
        }

        public void setLastOpened(String lastOpened) {
            this.lastOpened = lastOpened;
        }

        /**
         * Gets the last opened time as LocalDateTime
         */
        public LocalDateTime getLastOpenedDateTime() {
            try {
                return LocalDateTime.parse(lastOpened, DateTimeFormatter.ISO_LOCAL_DATE_TIME);
            } catch (Exception e) {
                return LocalDateTime.now();
            }
        }
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\project\ProjectCreator.java
=================================================================================

package com.botmaker.project;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

/**
 * Handles creation of new Gradle projects with proper structure
 */
public class ProjectCreator {

    private static final Path PROJECTS_ROOT = Paths.get("projects");

    private final LibraryManager libraryManager = new LibraryManager();
    /**
     * Creates a new Gradle project with standard structure
     *
     * @param projectName The name of the project to create
     * @throws IOException if project creation fails
     * @throws IllegalArgumentException if project name is invalid or already exists
     */
    public void createProject(String projectName) throws IOException {
        // Validate project name
        validateProjectName(projectName);

        // Check if project already exists
        if (projectExists(projectName)) {
            throw new IllegalArgumentException("Project '" + projectName + "' already exists");
        }

        // Create project structure
        Path projectPath = PROJECTS_ROOT.resolve(projectName);
        createProjectStructure(projectPath, projectName);

        System.out.println("Successfully created project: " + projectName);
    }

    /**
     * Validates the project name
     */
    private void validateProjectName(String projectName) {
        if (projectName == null || projectName.trim().isEmpty()) {
            throw new IllegalArgumentException("Project name cannot be empty");
        }

        // Check for valid Java class name (starts with letter, contains only letters/digits)
        if (!projectName.matches("^[A-Z][a-zA-Z0-9]*$")) {
            throw new IllegalArgumentException(
                    "Project name must start with an uppercase letter and contain only letters and numbers"
            );
        }

        // Check length
        if (projectName.length() < 2 || projectName.length() > 50) {
            throw new IllegalArgumentException("Project name must be between 2 and 50 characters");
        }
    }

    /**
     * Checks if a project already exists
     */
    public boolean projectExists(String projectName) {
        Path projectPath = PROJECTS_ROOT.resolve(projectName);
        return Files.exists(projectPath);
    }

    /**
     * Creates the complete project structure
     */
    private void createProjectStructure(Path projectPath, String projectName) throws IOException {
        // Create directories
        Files.createDirectories(projectPath);

        String packageName = projectName.toLowerCase();
        Path srcPath = projectPath.resolve("src/main/java/com/" + packageName);
        Files.createDirectories(srcPath);

        Path gradlePath = projectPath.resolve("gradle/wrapper");
        Files.createDirectories(gradlePath);

        // Create build.gradle
        createBuildGradle(projectPath, projectName);

        // Create settings.gradle
        createSettingsGradle(projectPath, projectName);

        // Create gradle-wrapper.properties
        createGradleWrapperProperties(gradlePath);

        // Create gradlew scripts
        createGradlewScripts(projectPath);

        // Create main Java file
        createMainJavaFile(srcPath, projectName, packageName);

        // 2. Install Native Library
        libraryManager.installLibrary(projectPath);

        // 3. Create main Java file
        createMainJavaFile(srcPath, projectName, packageName);
    }

    /**
     * Creates build.gradle file
     */
    private void createBuildGradle(Path projectPath, String projectName) throws IOException {
        String packageName = projectName.toLowerCase();
                String content = String.format("""
            plugins {
                id 'java'
                id 'application'
            }
            
            group = 'com.%s'
            version = '0.0.1-SNAPSHOT'
            
            repositories {
                mavenCentral()
                google() // For Android ddmlib
            }
            
            dependencies {
                // JNA for Windows Interaction
                implementation 'net.java.dev.jna:jna:5.13.0'
                implementation 'net.java.dev.jna:jna-platform:5.13.0'
            
                // OpenCV
                implementation 'org.bytedeco:opencv-platform:4.7.0-1.5.9'
            
                // JSON processing
                implementation 'com.fasterxml.jackson.core:jackson-databind:2.15.2'
            
                // ADB Connection (ddmlib)
                // Note: You may need to adjust version based on availability
                implementation 'com.android.tools.ddms:ddmlib:30.0.0'
            }
            
            application {
                mainClass = 'com.%s.%s'
            }
            
            java {
                sourceCompatibility = JavaVersion.VERSION_17
                targetCompatibility = JavaVersion.VERSION_17
            }
            """, packageName, packageName, projectName);

        Files.writeString(projectPath.resolve("build.gradle"), content);
    }

    /**
     * Creates settings.gradle file
     */
    private void createSettingsGradle(Path projectPath, String projectName) throws IOException {
        String content = String.format("""
            
            pluginManagement {
                repositories {
                    gradlePluginPortal()
                    mavenCentral()
                }
            }
            
            
            
            rootProject.name = '%s'
            
            """, projectName);

        Files.writeString(projectPath.resolve("settings.gradle"), content);
    }

    /**
     * Creates gradle-wrapper.properties file
     */
    private void createGradleWrapperProperties(Path gradlePath) throws IOException {
        String content = """
            distributionBase=GRADLE_USER_HOME
            distributionPath=wrapper/dists
            distributionUrl=https\\://services.gradle.org/distributions/gradle-9.1.0-bin.zip
            networkTimeout=10000
            validateDistributionUrl=true
            zipStoreBase=GRADLE_USER_HOME
            zipStorePath=wrapper/dists
            """;

        Files.writeString(gradlePath.resolve("gradle-wrapper.properties"), content);
    }

    /**
     * Creates gradlew scripts (Unix and Windows)
     */
    private void createGradlewScripts(Path projectPath) throws IOException {
        // Create Unix gradlew script
        String gradlewUnix = """
            #!/bin/sh
            
            #
            # Copyright © 2015 the original authors.
            #
            # Licensed under the Apache License, Version 2.0 (the "License");
            # you may not use this file except in compliance with the License.
            # You may obtain a copy of the License at
            #
            #      https://www.apache.org/licenses/LICENSE-2.0
            #
            # Unless required by applicable law or agreed to in writing, software
            # distributed under the License is distributed on an "AS IS" BASIS,
            # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
            # See the License for the specific language governing permissions and
            # limitations under the License.
            #
            
            ##############################################################################
            #
            #   Gradle start up script for POSIX generated by Gradle.
            #
            ##############################################################################
            
            # Attempt to set APP_HOME
            app_path=$0
            
            APP_HOME=${app_path%"${app_path##*/}"}
            APP_BASE_NAME=${0##*/}
            APP_HOME=$( cd -P "${APP_HOME:-./}" > /dev/null && printf '%s\\n' "$PWD" ) || exit
            
            DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'
            
            JAVACMD=java
            if [ -n "$JAVA_HOME" ] ; then
                if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
                    JAVACMD=$JAVA_HOME/jre/sh/java
                else
                    JAVACMD=$JAVA_HOME/bin/java
                fi
            fi
            
            exec "$JAVACMD" "$@"
            """;

        Path gradlewPath = projectPath.resolve("gradlew");
        Files.writeString(gradlewPath, gradlewUnix);

        // Make it executable on Unix systems
        try {
            gradlewPath.toFile().setExecutable(true);
        } catch (Exception e) {
            System.err.println("Warning: Could not set gradlew as executable: " + e.getMessage());
        }

        // Create Windows gradlew.bat script
        String gradlewBat = """
            @rem
            @rem Copyright 2015 the original author or authors.
            @rem
            @rem Licensed under the Apache License, Version 2.0 (the "License");
            @rem you may not use this file except in compliance with the License.
            @rem You may obtain a copy of the License at
            @rem
            @rem      https://www.apache.org/licenses/LICENSE-2.0
            @rem
            @rem Unless required by applicable law or agreed to in writing, software
            @rem distributed under the License is distributed on an "AS IS" BASIS,
            @rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
            @rem See the License for the specific language governing permissions and
            @rem limitations under the License.
            @rem
            
            @if "%DEBUG%"=="" @echo off
            
            set DIRNAME=%~dp0
            if "%DIRNAME%"=="" set DIRNAME=.
            set APP_BASE_NAME=%~n0
            
            set DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"
            
            set JAVA_EXE=java.exe
            if defined JAVA_HOME goto findJavaFromJavaHome
            
            %JAVA_EXE% -version >NUL 2>&1
            if %ERRORLEVEL% equ 0 goto execute
            
            :findJavaFromJavaHome
            set JAVA_HOME=%JAVA_HOME:"=%
            set JAVA_EXE=%JAVA_HOME%/bin/java.exe
            
            :execute
            "%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -jar "%DIRNAME%\\gradle\\wrapper\\gradle-wrapper.jar" %*
            
            :end
            if %ERRORLEVEL% equ 0 goto mainEnd
            
            :fail
            exit /b %ERRORLEVEL%
            
            :mainEnd
            """;

        Files.writeString(projectPath.resolve("gradlew.bat"), gradlewBat);
    }

    /**
     * Creates the main Java source file
     */
    private void createMainJavaFile(Path srcPath, String projectName, String packageName) throws IOException {
        String content = String.format("""
            package com.%s;
            
            public class %s {
                public static void main(String[] args) {
                    System.out.println("Hello from %s!");
                }
            }
            """, packageName, projectName, projectName);

        Files.writeString(srcPath.resolve(projectName + ".java"), content);
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\project\ProjectFile.java
=================================================================================

package com.botmaker.project;

import org.eclipse.jdt.core.dom.CompilationUnit;
import java.nio.file.Path;

public class ProjectFile {
    private final Path path;
    private String content;
    private CompilationUnit ast;
    private final String className; // e.g., "Movement"

    public ProjectFile(Path path, String content) {
        this.path = path;
        this.content = content;
        String filename = path.getFileName().toString();
        this.className = filename.substring(0, filename.lastIndexOf('.'));
    }

    public Path getPath() { return path; }

    public String getContent() { return content; }
    public void setContent(String content) { this.content = content; }

    public CompilationUnit getAst() { return ast; }
    public void setAst(CompilationUnit ast) { this.ast = ast; }

    public String getClassName() { return className; }

    public String getUri() {
        return path.toUri().toString();
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\project\ProjectInfo.java
=================================================================================

package com.botmaker.project;

import java.nio.file.Path;
import java.time.LocalDateTime;

/**
 * Information about a project
 */
public class ProjectInfo {
    private final String name;
    private final Path projectPath;
    private final LocalDateTime lastModified;

    public ProjectInfo(String name, Path projectPath, LocalDateTime lastModified) {
        this.name = name;
        this.projectPath = projectPath;
        this.lastModified = lastModified;
    }

    public String getName() {
        return name;
    }

    public Path getProjectPath() {
        return projectPath;
    }

    public LocalDateTime getLastModified() {
        return lastModified;
    }

    @Override
    public String toString() {
        return name;
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\project\ProjectManager.java
=================================================================================

package com.botmaker.project;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.attribute.FileTime;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Stream;

/**
 * Manages project discovery and listing
 */
public class ProjectManager {

    private static final Path PROJECTS_ROOT = Paths.get("projects");

    /**
     * Lists all available projects
     */
    public List<ProjectInfo> listProjects() {
        List<ProjectInfo> projects = new ArrayList<>();

        if (!Files.exists(PROJECTS_ROOT)) {
            return projects;
        }

        try (Stream<Path> paths = Files.list(PROJECTS_ROOT)) {
            paths.filter(Files::isDirectory)
                    .filter(this::isValidProject)
                    .forEach(projectPath -> {
                        try {
                            String projectName = projectPath.getFileName().toString();
                            FileTime lastModified = Files.getLastModifiedTime(projectPath);
                            LocalDateTime modifiedDate = LocalDateTime.ofInstant(
                                    lastModified.toInstant(),
                                    ZoneId.systemDefault()
                            );
                            projects.add(new ProjectInfo(projectName, projectPath, modifiedDate));
                        } catch (IOException e) {
                            System.err.println("Error reading project: " + projectPath);
                        }
                    });
        } catch (IOException e) {
            System.err.println("Error listing projects: " + e.getMessage());
        }

        return projects;
    }

    /**
     * Checks if a directory is a valid project
     * (has src/main/java structure and build.gradle)
     */
    private boolean isValidProject(Path projectPath) {
        Path srcPath = projectPath.resolve("src/main/java");
        Path buildGradle = projectPath.resolve("build.gradle");
        boolean isValid = Files.exists(srcPath) && Files.exists(buildGradle);

        // Debug output
        System.out.println("Checking project: " + projectPath);
        System.out.println("  src/main/java exists: " + Files.exists(srcPath));
        System.out.println("  build.gradle exists: " + Files.exists(buildGradle));
        System.out.println("  Valid: " + isValid);

        return isValid;
    }

    /**
     * Gets the source file path for a project
     */
    public Path getSourceFilePath(String projectName) {
        String packageName = projectName.toLowerCase();
        return PROJECTS_ROOT
                .resolve(projectName)
                .resolve("src/main/java/com")
                .resolve(packageName)
                .resolve(projectName + ".java");
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\runtime\CodeExecutionService.java
=================================================================================

package com.botmaker.runtime;

import com.botmaker.config.ApplicationConfig;
import com.botmaker.project.ProjectFile;
import com.botmaker.state.ApplicationState;
import com.botmaker.validation.DiagnosticsManager;
import javafx.application.Platform;

import java.io.IOException;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.function.Consumer;

public class CodeExecutionService {

    private final Consumer<String> appendOutputConsumer;
    private final Runnable clearOutputConsumer;
    private final Consumer<String> setOutputConsumer;
    private final Consumer<String> statusConsumer;
    private final DiagnosticsManager diagnosticsManager;
    private final ApplicationConfig config;
    private final ApplicationState state;

    private volatile Process currentRunningProcess;
    private final AtomicBoolean isRunning = new AtomicBoolean(false);

    private static final int MAX_UI_BUFFER_SIZE = 4096;
    private static final int UI_UPDATE_RATE_MS = 100;

    public CodeExecutionService(
            Consumer<String> appendOutputConsumer,
            Runnable clearOutputConsumer,
            Consumer<String> setOutputConsumer,
            Consumer<String> statusConsumer,
            DiagnosticsManager diagnosticsManager,
            ApplicationConfig config,
            ApplicationState state) {
        this.appendOutputConsumer = appendOutputConsumer;
        this.clearOutputConsumer = clearOutputConsumer;
        this.setOutputConsumer = setOutputConsumer;
        this.statusConsumer = statusConsumer;
        this.diagnosticsManager = diagnosticsManager;
        this.config = config;
        this.state = state;
    }

    public void runCode(String currentEditorCode) {
        if (diagnosticsManager.hasErrors()) {
            Platform.runLater(() -> statusConsumer.accept("Run aborted due to errors."));
            return;
        }

        if (isRunning.get()) {
            Platform.runLater(() -> statusConsumer.accept("Program is already running. Stop it first."));
            return;
        }

        try {
            Path compiledOutputPath = config.getCompiledOutputPath();

            // 1. Compile (Blocking)
            if (!compileAndWait(currentEditorCode, compiledOutputPath)) {
                Platform.runLater(() -> statusConsumer.accept("Run aborted due to compilation failure."));
                return;
            }

            // 2. Setup Execution
            Platform.runLater(() -> {
                statusConsumer.accept("Running... (Press Stop to terminate)");
                clearOutputConsumer.run();
            });

            isRunning.set(true);

            String classPath = compiledOutputPath.toString();
            String className = config.getMainClassName();
            String javaExecutable = config.getJavaExecutable();

            ProcessBuilder pb = new ProcessBuilder(javaExecutable, "-cp", classPath, className);
            currentRunningProcess = pb.start();

            // 3. Start IO Readers and keep references to them
            Thread outReader = startLeakyBucketReader(currentRunningProcess.getInputStream());
            Thread errReader = startLeakyBucketReader(currentRunningProcess.getErrorStream());

            // 4. Wait for process to exit
            int exitCode = currentRunningProcess.waitFor();

            // 5. CRITICAL FIX: Wait for readers to drain the stream before stopping UI updates
            try {
                outReader.join(1000); // Wait up to 1s for streams to flush
                errReader.join(1000);
            } catch (InterruptedException ignored) {}

            Platform.runLater(() -> {
                if (exitCode == 0) statusConsumer.accept("Program completed successfully.");
                else if (exitCode == 143 || exitCode == 130 || exitCode == 1 || exitCode == -1) statusConsumer.accept("Program stopped.");
                else statusConsumer.accept("Program exited with code: " + exitCode);
            });

        } catch (InterruptedException e) {
            Platform.runLater(() -> statusConsumer.accept("Program stopped by user."));
        } catch (Exception e) {
            e.printStackTrace();
            Platform.runLater(() -> statusConsumer.accept("Error: " + e.getMessage()));
        } finally {
            isRunning.set(false); // NOW safe to stop UI updates
            currentRunningProcess = null;
        }
    }

    public void compileCode(String code) {
        new Thread(() -> {
            try {
                Platform.runLater(() -> setOutputConsumer.accept("Saving and compiling..."));
                Path compiledOutputPath = config.getCompiledOutputPath();
                if (compileAndWait(code, compiledOutputPath)) {
                    Platform.runLater(() -> setOutputConsumer.accept("Compilation successful."));
                }
            } catch (IOException | InterruptedException e) {
                Platform.runLater(() -> setOutputConsumer.accept("Compilation Error: " + e.getMessage()));
            }
        }).start();
    }

    public boolean compileAndWait(String currentActiveCode, Path compiledOutputPath) throws IOException, InterruptedException {
        // Sync memory
        state.setCurrentCode(currentActiveCode);

        // Save ALL files to disk
        for (ProjectFile file : state.getAllFiles()) {
            Path path = file.getPath();
            if (path != null) {
                Files.createDirectories(path.getParent());
                Files.writeString(path, file.getContent());
            }
        }

        Files.createDirectories(compiledOutputPath);

        String javacExecutable = Paths.get(System.getProperty("java.home"), "bin", "javac").toString();

        // Calculate source root (3 levels up from Main file: com/pkg/Main.java -> src/main/java)
        Path sourcePathRoot = config.getSourceFilePath().getParent().getParent().getParent();

        ProcessBuilder pb = new ProcessBuilder(
                javacExecutable,
                "-g",
                "-d", compiledOutputPath.toString(),
                "-sourcepath", sourcePathRoot.toString(),
                config.getSourceFilePath().toString()
        );

        Process process = pb.start();

        String errors = new String(process.getErrorStream().readAllBytes());
        int exitCode = process.waitFor();

        if (exitCode != 0) {
            Platform.runLater(() -> setOutputConsumer.accept("Compilation Failed:\n" + errors));
            return false;
        }
        return true;
    }

    public void stopRunningProgram() {
        if (currentRunningProcess != null && currentRunningProcess.isAlive()) {
            currentRunningProcess.destroyForcibly();
        }
    }

    public boolean isRunning() { return isRunning.get(); }

    // CHANGED: Returns the Thread so we can join() it
    private Thread startLeakyBucketReader(InputStream inputStream) {
        final StringBuilder buffer = new StringBuilder();
        final ScheduledExecutorService uiUpdater = Executors.newSingleThreadScheduledExecutor();

        // UI Pusher Loop
        uiUpdater.scheduleAtFixedRate(() -> {
            // Only stop if process is dead AND buffer is empty
            if (!isRunning.get() && buffer.length() == 0) {
                uiUpdater.shutdown();
                return;
            }

            String textToSend = "";
            synchronized (buffer) {
                if (buffer.length() > 0) {
                    textToSend = buffer.toString();
                    buffer.setLength(0);
                }
            }

            if (!textToSend.isEmpty()) {
                String finalTx = textToSend;
                Platform.runLater(() -> appendOutputConsumer.accept(finalTx));
            }
        }, UI_UPDATE_RATE_MS, UI_UPDATE_RATE_MS, TimeUnit.MILLISECONDS);

        // Stream Reader Thread
        Thread readerThread = new Thread(() -> {
            byte[] readBuf = new byte[1024];
            int len;
            try {
                while ((len = inputStream.read(readBuf)) != -1) {
                    synchronized (buffer) {
                        if (buffer.length() < MAX_UI_BUFFER_SIZE) {
                            buffer.append(new String(readBuf, 0, len, StandardCharsets.UTF_8));
                        }
                    }
                }
            } catch (IOException ignored) {
            } finally {
                // Do not shut down UI updater here; let the scheduler decide based on buffer/isRunning state
            }
        }, "Leaky-Reader");

        readerThread.start();
        return readerThread;
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\services\CodeEditorService.java
=================================================================================

package com.botmaker.services;

import com.botmaker.blocks.MainBlock;
import com.botmaker.config.ApplicationConfig;
import com.botmaker.core.AbstractCodeBlock;
import com.botmaker.core.CodeBlock;
import com.botmaker.events.CoreApplicationEvents;
import com.botmaker.events.EventBus;
import com.botmaker.lsp.CompletionContext;
import com.botmaker.parser.AstRewriter;
import com.botmaker.parser.BlockFactory;
import com.botmaker.parser.CodeEditor;
import com.botmaker.project.ProjectFile;
import com.botmaker.state.ApplicationState;
import com.botmaker.state.HistoryManager;
import com.botmaker.ui.BlockDragAndDropManager;
import com.botmaker.validation.DiagnosticsManager;
import javafx.application.Platform;

import java.nio.file.Files;
import java.nio.file.Path;
import java.util.stream.Stream;

public class CodeEditorService {

    // ... (Constructor and fields remain exactly the same) ...
    private final ApplicationConfig config;
    private final ApplicationState state;
    private final EventBus eventBus;
    private final BlockFactory blockFactory;
    private final AstRewriter astRewriter;
    private final CodeEditor codeEditor;
    private final BlockDragAndDropManager dragAndDropManager;
    private final LanguageServerService languageServerService;
    private final DiagnosticsManager diagnosticsManager;
    private final HistoryManager historyManager;
    private boolean isRestoringHistory = false;

    public CodeEditorService(
            ApplicationConfig config,
            ApplicationState state,
            EventBus eventBus,
            BlockFactory blockFactory,
            AstRewriter astRewriter,
            BlockDragAndDropManager dragAndDropManager,
            LanguageServerService languageServerService,
            DiagnosticsManager diagnosticsManager) {
        this.config = config;
        this.state = state;
        this.eventBus = eventBus;
        this.blockFactory = blockFactory;
        this.astRewriter = astRewriter;
        this.dragAndDropManager = dragAndDropManager;
        this.languageServerService = languageServerService;
        this.diagnosticsManager = diagnosticsManager;
        this.historyManager = new HistoryManager();
        this.codeEditor = new CodeEditor(state, eventBus, astRewriter, blockFactory);
        setupEventHandlers();
    }

    private void setupEventHandlers() {
        eventBus.subscribe(CoreApplicationEvents.UIRefreshRequestedEvent.class, event -> Platform.runLater(() -> refreshUI(event.getCode())), false);
        eventBus.subscribe(CoreApplicationEvents.BreakpointToggledEvent.class, this::handleBreakpointToggle, false);
        eventBus.subscribe(CoreApplicationEvents.CodeUpdatedEvent.class, this::handleCodeUpdateForHistory, false);
        eventBus.subscribe(CoreApplicationEvents.UndoRequestedEvent.class, e -> undo(), false);
        eventBus.subscribe(CoreApplicationEvents.RedoRequestedEvent.class, e -> redo(), false);
    }

    private void handleCodeUpdateForHistory(CoreApplicationEvents.CodeUpdatedEvent event) {
        if (isRestoringHistory) return;
        String previousCode = event.getPreviousCode();
        if (previousCode != null && !previousCode.isEmpty()) {
            historyManager.pushState(previousCode);
            broadcastHistoryState();
        }
    }

    private void undo() {
        if (!historyManager.canUndo()) return;
        applyHistoryState(historyManager.undo(state.getCurrentCode()));
    }

    private void redo() {
        if (!historyManager.canRedo()) return;
        applyHistoryState(historyManager.redo(state.getCurrentCode()));
    }

    private void applyHistoryState(String code) {
        isRestoringHistory = true;
        try {
            eventBus.publish(new CoreApplicationEvents.CodeUpdatedEvent(code, state.getCurrentCode()));
            broadcastHistoryState();
        } finally {
            isRestoringHistory = false;
        }
    }

    private void broadcastHistoryState() {
        eventBus.publish(new CoreApplicationEvents.HistoryStateChangedEvent(historyManager.canUndo(), historyManager.canRedo()));
    }

    private void handleBreakpointToggle(CoreApplicationEvents.BreakpointToggledEvent event) {
        if (event.isEnabled()) {
            state.addBreakpoint(event.getBlock().getId());
        } else {
            state.removeBreakpoint(event.getBlock().getId());
        }
    }

    // --- FIX: LOAD AND OPEN ALL FILES ---
    public void loadInitialCode() {
        try {
            Path mainFile = config.getSourceFilePath();
            Path sourceDir = mainFile.getParent();

            // Load all java files in the directory
            if (Files.exists(sourceDir)) {
                try (Stream<Path> files = Files.list(sourceDir)) {
                    files.filter(p -> p.toString().endsWith(".java")).forEach(path -> {
                        try {
                            String content = Files.readString(path);
                            ProjectFile pf = new ProjectFile(path, content);
                            state.addFile(pf);

                            // FIX: Explicitly open every file in the Language Server
                            // This ensures the LSP knows about secondary files immediately.
                            languageServerService.openFile(path, content);

                        } catch (Exception e) {
                            e.printStackTrace();
                        }
                    });
                }
            }

            // Set Active File to Main and refresh UI
            switchToFile(mainFile);

        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public void switchToFile(Path path) {
        ProjectFile file = state.getAllFiles().stream()
                .filter(f -> f.getPath().equals(path))
                .findFirst().orElse(null);

        if (file == null) return;

        state.setActiveFile(path);
        // Update doc version/uri in state for LSP sync context
        state.setDocUri(file.getUri());

        refreshUI(file.getContent());
    }

    public void createFile(String className) {
        try {
            String packageName = config.getMainClassName().substring(0, config.getMainClassName().lastIndexOf('.'));
            Path dir = config.getSourceFilePath().getParent();
            Path newPath = dir.resolve(className + ".java");

            String template = "package " + packageName + ";\n\n" +
                    "public class " + className + " {\n" +
                    "    // Add functions here\n" +
                    "    public static void action() {\n" +
                    "        System.out.println(\"Action from " + className + "\");\n" +
                    "    }\n" +
                    "}";

            Files.writeString(newPath, template);
            ProjectFile pf = new ProjectFile(newPath, template);
            state.addFile(pf);

            languageServerService.openFile(newPath, template);
            switchToFile(newPath);

        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private void refreshUI(String javaCode) {
        state.setCurrentCode(javaCode);
        state.clearNodeToBlockMap();

        if (diagnosticsManager != null) {
            diagnosticsManager.updateSource(state.getMutableNodeToBlockMap(), javaCode);
        }

        AbstractCodeBlock rootBlock = blockFactory.convert(
                javaCode,
                state.getMutableNodeToBlockMap(),
                dragAndDropManager
        );

        for (CodeBlock block : state.getNodeToBlockMap().values()) {
            if (state.hasBreakpoint(block.getId())) {
                block.setBreakpoint(true);
            }
        }

        state.setCompilationUnit(blockFactory.getCompilationUnit());
        eventBus.publish(new CoreApplicationEvents.UIBlocksUpdatedEvent(rootBlock));

        if (state.getActiveFile() != null) {
            eventBus.publish(new CoreApplicationEvents.StatusMessageEvent("Loaded: " + state.getActiveFile().getClassName()));
        }
    }

    public CompletionContext createCompletionContext() {
        return new CompletionContext(
                codeEditor,
                languageServerService.getServer(),
                state.getDocUri(),
                state.getCurrentCode(),
                state.getDocVersion(),
                dragAndDropManager,
                state
        );
    }

    public CodeEditor getCodeEditor() { return codeEditor; }
    public BlockFactory getBlockFactory() { return blockFactory; }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\services\DebuggingService.java
=================================================================================

package com.botmaker.services;

import com.botmaker.config.ApplicationConfig;
import com.botmaker.config.Constants;
import com.botmaker.core.CodeBlock;
import com.botmaker.core.StatementBlock;
import com.botmaker.events.CoreApplicationEvents;
import com.botmaker.events.EventBus;
import com.botmaker.parser.BlockFactory;
import com.botmaker.runtime.CodeExecutionService;
import com.botmaker.state.ApplicationState;
import com.sun.jdi.*;
import com.sun.jdi.connect.AttachingConnector;
import com.sun.jdi.connect.Connector;
import com.sun.jdi.event.*;
import com.sun.jdi.request.BreakpointRequest;
import com.sun.jdi.request.ClassPrepareRequest;
import com.sun.jdi.request.EventRequestManager;
import com.sun.jdi.request.StepRequest;
import javafx.application.Platform;
import org.eclipse.jdt.core.dom.CompilationUnit;

import java.io.IOException;
import java.io.InputStream;
import java.net.ServerSocket;
import java.util.*;
import java.util.concurrent.CountDownLatch;

/**
 * Handles the entire debugging lifecycle:
 * 1. Mapping AST nodes to line numbers.
 * 2. Launching the JVM in debug mode.
 * 3. Attaching via JDI (Java Debug Interface).
 * 4. Managing Breakpoints, Stepping, and Resuming.
 */
public class DebuggingService {

    // Console Coloring for internal logs
    private static final String ANSI_RESET = "\u001B[0m";
    private static final String ANSI_BLUE = "\u001B[34m";
    private static final String ANSI_GREEN = "\u001B[32m";
    private static final String ANSI_RED = "\u001B[31m";

    private final ApplicationState state;
    private final EventBus eventBus;
    private final CodeExecutionService codeExecutionService;
    private final BlockFactory factory;
    private final ApplicationConfig config;

    // Debug Session State
    private volatile Process currentProcess;
    private VirtualMachine vm;
    private ThreadReference currentDebugThread;
    private Map<Integer, CodeBlock> lineToBlockMap;

    public DebuggingService(
            ApplicationState state,
            EventBus eventBus,
            CodeExecutionService codeExecutionService,
            BlockFactory factory,
            ApplicationConfig config) {
        this.state = state;
        this.eventBus = eventBus;
        this.codeExecutionService = codeExecutionService;
        this.factory = factory;
        this.config = config;

        setupEventHandlers();
    }

    private void setupEventHandlers() {
        eventBus.subscribe(CoreApplicationEvents.DebugStartRequestedEvent.class, e -> startDebugging(), false);
        eventBus.subscribe(CoreApplicationEvents.DebugStepOverRequestedEvent.class, e -> stepOver(), false);
        eventBus.subscribe(CoreApplicationEvents.DebugContinueRequestedEvent.class, e -> continueExecution(), false);
        eventBus.subscribe(CoreApplicationEvents.DebugStopRequestedEvent.class, e -> stopDebugging(), false);
    }

    /**
     * Kicks off the debugging session on a separate thread.
     */
    public void startDebugging() {
        new Thread(() -> {
            try {
                String code = state.getCurrentCode();

                // 1. Compile
                // FIXED: Removed config.getSourceFilePath() argument to match new signature
                if (!codeExecutionService.compileAndWait(code, config.getCompiledOutputPath())) {
                    eventBus.publish(new CoreApplicationEvents.StatusMessageEvent("Debug aborted due to compilation failure."));
                    return;
                }

                // 2. Map Breakpoints (AST -> Line Numbers)
                CompilationUnit cu = factory.getCompilationUnit();
                // Note: getNodeToBlockMap only refers to the ACTIVE file.
                // Multi-file debugging requires mapping logic expansion, but this works for the active file.
                if (cu == null || state.getNodeToBlockMap().isEmpty()) {
                    eventBus.publish(new CoreApplicationEvents.StatusMessageEvent("Error: Could not parse code to get breakpoints."));
                    return;
                }

                this.lineToBlockMap = new HashMap<>();
                List<Integer> activeBreakpointLines = new ArrayList<>();

                for (CodeBlock block : state.getNodeToBlockMap().values()) {
                    int line = block.getBreakpointLine(cu);
                    if (line > 0) {
                        // Only map StatementBlocks (executable lines)
                        if (!lineToBlockMap.containsKey(line) || block instanceof StatementBlock) {
                            lineToBlockMap.put(line, block);
                        }
                        if (block.isBreakpoint()) {
                            activeBreakpointLines.add(line);
                        }
                    }
                }

                // If no breakpoints, add one at start so it doesn't just run to finish immediately
                if (activeBreakpointLines.isEmpty() && !lineToBlockMap.isEmpty()) {
                    lineToBlockMap.keySet().stream().min(Integer::compareTo).ifPresent(firstLine -> {
                        activeBreakpointLines.add(firstLine);
                        eventBus.publish(new CoreApplicationEvents.StatusMessageEvent("No breakpoints set. Pausing at start (Line " + firstLine + ")."));
                    });
                }

                // 3. Find Free Port
                int freePort;
                try (ServerSocket socket = new ServerSocket(0)) {
                    freePort = socket.getLocalPort();
                }

                // 4. Launch Target Process
                eventBus.publish(new CoreApplicationEvents.StatusMessageEvent("Starting debugger on port " + freePort + "..."));
                eventBus.publish(new CoreApplicationEvents.DebugSessionStartedEvent());
                Platform.runLater(() -> eventBus.publish(new CoreApplicationEvents.OutputClearedEvent()));

                String classPath = config.getCompiledOutputPath().toString();
                // We debug the Main class defined in config
                String className = config.getMainClassName();
                String javaExecutable = config.getJavaExecutable();

                // Suspend=y waits for us to attach before running main()
                String debugAgent = String.format("-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=%d", freePort);

                ProcessBuilder pb = new ProcessBuilder(javaExecutable, debugAgent, "-cp", classPath, className);
                this.currentProcess = pb.start();

                // Redirect output to UI
                redirectStream(currentProcess.getInputStream());
                redirectStream(currentProcess.getErrorStream());

                // 5. Attach JDI
                attachJdi(className, freePort, activeBreakpointLines);

            } catch (Exception e) {
                eventBus.publish(new CoreApplicationEvents.StatusMessageEvent("Debugger Error: " + e.getMessage()));
                e.printStackTrace();
                stopDebugging(); // Cleanup if fail
            }
        }).start();
    }

    /**
     * Connects the JDI VirtualMachine to the running process.
     */
    private void attachJdi(String mainClassName, int port, List<Integer> breakpointLines) throws Exception {
        VirtualMachineManager vmMgr = Bootstrap.virtualMachineManager();
        AttachingConnector connector = vmMgr.attachingConnectors().stream()
                .filter(c -> c.transport().name().equals("dt_socket"))
                .findFirst()
                .orElseThrow(() -> new RuntimeException("Socket attaching connector not found"));

        Map<String, Connector.Argument> arguments = connector.defaultArguments();
        arguments.get("port").setValue(String.valueOf(port));
        arguments.get("hostname").setValue("localhost");

        // Retry logic for connection
        int maxRetries = Constants.DEBUGGER_MAX_CONNECT_RETRIES;
        for (int i = 0; i < maxRetries; i++) {
            try {
                vm = connector.attach(arguments);
                System.out.println(ANSI_BLUE + "Attached to VM: " + vm.name() + ANSI_RESET);
                break;
            } catch (IOException e) {
                if (i == maxRetries - 1) throw e;
                Thread.sleep(Constants.DEBUGGER_RETRY_DELAY_MS);
            }
        }

        EventRequestManager erm = vm.eventRequestManager();

        // Handle Breakpoints
        List<ReferenceType> classes = vm.classesByName(mainClassName);
        if (!classes.isEmpty()) {
            applyBreakpointsToClass(classes.get(0), breakpointLines);
        } else {
            ClassPrepareRequest classPrepareRequest = erm.createClassPrepareRequest();
            classPrepareRequest.addClassFilter(mainClassName);
            classPrepareRequest.enable();
        }

        // Start Event Loop
        CountDownLatch listenerReadyLatch = new CountDownLatch(1);
        new Thread(() -> jdiEventLoop(listenerReadyLatch, mainClassName, breakpointLines)).start();

        listenerReadyLatch.await();
        vm.resume();
    }

    private void jdiEventLoop(CountDownLatch listenerReadyLatch, String mainClassName, List<Integer> breakpointLines) {
        EventQueue eventQueue = vm.eventQueue();
        listenerReadyLatch.countDown();

        while (true) {
            try {
                EventSet eventSet = eventQueue.remove();
                boolean shouldResume = true;

                for (Event event : eventSet) {
                    if (event instanceof VMDisconnectEvent) {
                        handleDisconnect();
                        return;
                    }

                    if (event instanceof ClassPrepareEvent) {
                        ClassPrepareEvent cpe = (ClassPrepareEvent) event;
                        if (cpe.referenceType().name().equals(mainClassName)) {
                            applyBreakpointsToClass(cpe.referenceType(), breakpointLines);
                        }
                    }
                    else if (event instanceof LocatableEvent) {
                        handleLocatableEvent((LocatableEvent) event);
                        shouldResume = false;
                    }
                }

                if (shouldResume) {
                    eventSet.resume();
                }
            } catch (InterruptedException | VMDisconnectedException e) {
                handleDisconnect();
                return;
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }

    private void applyBreakpointsToClass(ReferenceType refType, List<Integer> lines) {
        if (lines == null || lines.isEmpty()) return;
        try {
            EventRequestManager erm = vm.eventRequestManager();
            for (int lineNumber : lines) {
                List<Location> locations = refType.locationsOfLine(lineNumber);
                if (!locations.isEmpty()) {
                    BreakpointRequest bpReq = erm.createBreakpointRequest(locations.get(0));
                    bpReq.enable();
                }
            }
        } catch (AbsentInformationException e) {
            System.err.println("No debug info available (compiled without -g?).");
        }
    }

    private void handleLocatableEvent(LocatableEvent event) {
        this.currentDebugThread = event.thread();

        if (event instanceof StepEvent) {
            vm.eventRequestManager().deleteEventRequest(event.request());
        }

        int lineNumber = event.location().lineNumber();
        CodeBlock block = lineToBlockMap.get(lineNumber);
        CodeBlock target = (block != null) ? block.getHighlightTarget() : null;

        eventBus.publish(new CoreApplicationEvents.DebugSessionPausedEvent(lineNumber, target));
        eventBus.publish(new CoreApplicationEvents.BlockHighlightEvent(target));
        eventBus.publish(new CoreApplicationEvents.StatusMessageEvent("Paused at line: " + lineNumber));
    }

    private void handleDisconnect() {
        this.currentDebugThread = null;
        this.vm = null;
        this.currentProcess = null;

        eventBus.publish(new CoreApplicationEvents.DebugSessionFinishedEvent());
        eventBus.publish(new CoreApplicationEvents.StatusMessageEvent("Debug session finished."));
        eventBus.publish(new CoreApplicationEvents.BlockHighlightEvent(null));
    }

    public void stepOver() {
        if (vm == null || currentDebugThread == null) return;
        try {
            eventBus.publish(new CoreApplicationEvents.DebugSessionResumedEvent());
            EventRequestManager erm = vm.eventRequestManager();

            erm.stepRequests().stream()
                    .filter(r -> r.thread().equals(currentDebugThread))
                    .forEach(erm::deleteEventRequest);

            StepRequest request = erm.createStepRequest(currentDebugThread, StepRequest.STEP_LINE, StepRequest.STEP_OVER);
            request.addCountFilter(1);
            request.enable();

            vm.resume();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public void continueExecution() {
        if (vm != null) {
            eventBus.publish(new CoreApplicationEvents.DebugSessionResumedEvent());
            vm.resume();
        }
    }

    public void stopDebugging() {
        if (vm != null) {
            try {
                vm.dispose();
            } catch (VMDisconnectedException ignored) {
            } catch (Exception e) { e.printStackTrace(); }
        }

        if (currentProcess != null && currentProcess.isAlive()) {
            try {
                currentProcess.destroyForcibly();
                eventBus.publish(new CoreApplicationEvents.StatusMessageEvent("Debug process terminated."));
            } catch (Exception e) { e.printStackTrace(); }
        }

        handleDisconnect();
    }

    private void redirectStream(InputStream stream) {
        new Thread(() -> {
            try (Scanner s = new Scanner(stream)) {
                while (s.hasNextLine()) {
                    String line = s.nextLine();
                    Platform.runLater(() -> eventBus.publish(new CoreApplicationEvents.OutputAppendedEvent(line + "\n")));
                }
            }
        }).start();
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\services\ExecutionService.java
=================================================================================

package com.botmaker.services;

import com.botmaker.config.ApplicationConfig;
import com.botmaker.events.CoreApplicationEvents;
import com.botmaker.events.EventBus;
import com.botmaker.runtime.CodeExecutionService;
import com.botmaker.state.ApplicationState;

/**
 * Service wrapper for code execution (compilation and running).
 * Bridges between the event system and the existing CodeExecutionService.
 */
public class ExecutionService {

    private final ApplicationConfig config;
    private final ApplicationState state;
    private final EventBus eventBus;
    private final CodeExecutionService codeExecutionService;
    private final com.botmaker.validation.DiagnosticsManager diagnosticsManager;

    public ExecutionService(
            ApplicationConfig config,
            ApplicationState state,
            EventBus eventBus,
            CodeExecutionService codeExecutionService,
            com.botmaker.validation.DiagnosticsManager diagnosticsManager) {

        this.config = config;
        this.state = state;
        this.eventBus = eventBus;
        this.codeExecutionService = codeExecutionService;
        this.diagnosticsManager = diagnosticsManager;

        setupEventHandlers();
    }

    private void setupEventHandlers() {
        // Subscribe to compilation requests
        eventBus.subscribe(
                CoreApplicationEvents.CompilationRequestedEvent.class,
                event -> compile(),
                false
        );

        // Subscribe to execution requests
        eventBus.subscribe(
                CoreApplicationEvents.ExecutionRequestedEvent.class,
                event -> run(),
                false
        );

        // NEW: Subscribe to stop run requests
        eventBus.subscribe(
                CoreApplicationEvents.StopRunRequestedEvent.class,
                event -> stopRun(),
                false
        );
    }

    /**
     * Compiles the current code
     */
    public void compile() {
        codeExecutionService.compileCode(state.getCurrentCode());
    }

    /**
     * Runs the current code
     */
    public void run() {
        // 1. UI Updates to RUNNING state
        eventBus.publish(new CoreApplicationEvents.ProgramStartedEvent());

        // 2. Thread Starts
        new Thread(() -> {
            // 3. Blocks here while program runs
            codeExecutionService.runCode(state.getCurrentCode());

            // 4. Program finishes/dies, then UI Updates to IDLE state
            eventBus.publish(new CoreApplicationEvents.ProgramStoppedEvent());
        }).start();
    }

    /**
     * NEW: Stops the currently running program
     */
    public void stopRun() {
        codeExecutionService.stopRunningProgram();
        eventBus.publish(new CoreApplicationEvents.ProgramStoppedEvent());
    }

    /**
     * Get the underlying code execution service
     */
    public CodeExecutionService getCodeExecutionService() {
        return codeExecutionService;
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\services\LanguageServerService.java
=================================================================================

package com.botmaker.services;

import com.botmaker.config.ApplicationConfig;
import com.botmaker.config.Constants;
import com.botmaker.events.CoreApplicationEvents;
import com.botmaker.events.EventBus;
import com.botmaker.lsp.JdtLanguageServerLauncher;
import com.botmaker.state.ApplicationState;
import javafx.application.Platform;
import org.eclipse.lsp4j.*;
import org.eclipse.lsp4j.services.LanguageServer;

import java.nio.file.Files;
import java.nio.file.Path;
import java.util.List;

public class LanguageServerService {

    private final ApplicationConfig config;
    private final ApplicationState state;
    private final EventBus eventBus;
    private final com.botmaker.validation.DiagnosticsManager diagnosticsManager;

    private LanguageServer server;
    private JdtLanguageServerLauncher launcher;
    private boolean shouldClearCache = false;

    public LanguageServerService(
            ApplicationConfig config,
            ApplicationState state,
            EventBus eventBus,
            com.botmaker.validation.DiagnosticsManager diagnosticsManager) {
        this.config = config;
        this.state = state;
        this.eventBus = eventBus;
        this.diagnosticsManager = diagnosticsManager;
        setupEventHandlers();
    }

    public void setShouldClearCache(boolean shouldClear) { this.shouldClearCache = shouldClear; }

    private void setupEventHandlers() {
        eventBus.subscribe(CoreApplicationEvents.CodeUpdatedEvent.class, this::handleCodeUpdate, false);
    }

    public void initialize() throws Exception {
        if (shouldClearCache) {
            JdtLanguageServerLauncher.cleanupWorkspace(config.getWorkspaceDataPath());
        }

        launcher = new JdtLanguageServerLauncher(
                config.getJdtServerPath(),
                config.getProjectPath(),
                config.getWorkspaceDataPath(),
                (PublishDiagnosticsParams params) -> {
                    Platform.runLater(() -> {
                        List<Diagnostic> diagnostics = params.getDiagnostics();
                        eventBus.publish(new CoreApplicationEvents.DiagnosticsUpdatedEvent(diagnostics));
                    });
                }
        );

        server = launcher.getServer();

        // Ensure the Main file exists on disk, but do NOT open it here.
        // CodeEditorService.loadInitialCode() will open it shortly after.
        Path docPath = config.getSourceFilePath().toAbsolutePath().normalize();

        if (!Files.exists(docPath)) {
            Files.createDirectories(docPath.getParent());
            String mainClassName = config.getMainClassName();
            String[] parts = mainClassName.split("\\.");
            String packageName = parts.length > 1 ? String.join(".", java.util.Arrays.copyOf(parts, parts.length - 1)) : "com.demo";
            String className = parts[parts.length - 1];

            String defaultCode = String.format("""
            package %s;
            public class %s {
                public static void main(String[] args) {
                    System.out.println("Hello from %s!");
                }
            }
            """, packageName, className, className);
            Files.writeString(docPath, defaultCode);
        }

        // Setup initial state URIs
        String docUri = docPath.toUri().toString();
        state.setDocUri(docUri);
        state.setDocVersion(1);
    }

    private void handleCodeUpdate(CoreApplicationEvents.CodeUpdatedEvent event) {
        try {
            // Write to file
            Path docPath = Path.of(new java.net.URI(state.getDocUri()));
            Files.writeString(docPath, event.getNewCode());

            // Update state
            state.incrementDocVersion();
            state.setCurrentCode(event.getNewCode());

            // Notify LSP server
            if (server != null) {
                server.getTextDocumentService().didChange(new DidChangeTextDocumentParams(
                        new VersionedTextDocumentIdentifier(state.getDocUri(), (int) state.getDocVersion()),
                        List.of(new TextDocumentContentChangeEvent(event.getNewCode()))
                ));
            }

            eventBus.publish(new CoreApplicationEvents.UIRefreshRequestedEvent(event.getNewCode()));

        } catch (Exception e) {
            e.printStackTrace();
            eventBus.publish(new CoreApplicationEvents.StatusMessageEvent("Error saving file: " + e.getMessage()));
        }
    }

    public void openFile(Path path, String content) {
        if (server == null) return;
        String uri = path.toUri().toString();
        // Use version 1 for newly opened files
        server.getTextDocumentService().didOpen(new DidOpenTextDocumentParams(
                new TextDocumentItem(uri, "java", 1, content)
        ));
    }

    public void shutdown() {
        if (launcher != null) {
            try {
                System.out.println("Requesting server shutdown...");
                if (server != null) {
                    server.shutdown().get(Constants.DEBUGGER_SHUTDOWN_TIMEOUT_SECONDS, java.util.concurrent.TimeUnit.SECONDS);
                    server.exit();
                }
                Thread.sleep(Constants.SHORT_SLEEP_MS);
            } catch (Exception e) {
                System.err.println("Error during server shutdown: " + e.getMessage());
            } finally {
                launcher.stop();
            }
        }
    }

    public LanguageServer getServer() { return server; }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\state\ApplicationState.java
=================================================================================

package com.botmaker.state;

import com.botmaker.core.CodeBlock;
import com.botmaker.project.ProjectFile;
import org.eclipse.jdt.core.dom.ASTNode;
import org.eclipse.jdt.core.dom.CompilationUnit;

import java.nio.file.Path;
import java.util.*;

public class ApplicationState {

    // Multi-file state
    private final Map<Path, ProjectFile> openFiles = new HashMap<>();
    private ProjectFile activeFile;

    // AST and block mappings (For the ACTIVE file)
    private Map<ASTNode, CodeBlock> nodeToBlockMap = new HashMap<>();

    // UI state
    private CodeBlock highlightedBlock;
    private boolean isDebugging;
    private final Set<String> breakpointIds = new HashSet<>();
    private long docVersion = 1;

    // --- File Management ---

    public void addFile(ProjectFile file) {
        openFiles.put(file.getPath(), file);
    }

    public void setActiveFile(Path path) {
        this.activeFile = openFiles.get(path);
        // Reset or sync doc version when switching if necessary,
        // though usually we track version per file.
        // For now, we keep a global version counter for LSP sync simplicity.
    }

    public ProjectFile getActiveFile() {
        return activeFile;
    }

    public Collection<ProjectFile> getAllFiles() {
        return Collections.unmodifiableCollection(openFiles.values());
    }

    // --- Helpers (Delegate to Active File) ---

    public String getCurrentCode() {
        return activeFile != null ? activeFile.getContent() : "";
    }

    public void setCurrentCode(String code) {
        if (activeFile != null) activeFile.setContent(code);
    }

    public String getDocUri() {
        return activeFile != null ? activeFile.getUri() : "";
    }

    /**
     * Set Doc URI.
     * Note: In multi-file mode, the URI is derived from the ProjectFile path.
     * This method exists for backward compatibility with LanguageServerService.
     */
    public void setDocUri(String docUri) {
        // No-op: The URI is determined by the active file's path.
        // We accept the call to satisfy the compiler, but rely on setActiveFile() being called previously.
    }

    public Optional<CompilationUnit> getCompilationUnit() {
        return activeFile != null ? Optional.ofNullable(activeFile.getAst()) : Optional.empty();
    }

    public void setCompilationUnit(CompilationUnit cu) {
        if (activeFile != null) activeFile.setAst(cu);
    }

    // --- Versioning ---

    public long getDocVersion() {
        return docVersion;
    }

    public void setDocVersion(long version) {
        this.docVersion = version;
    }

    public void incrementDocVersion() {
        this.docVersion++;
    }

    // --- Mappings & UI State ---

    public Map<ASTNode, CodeBlock> getNodeToBlockMap() {
        return Collections.unmodifiableMap(nodeToBlockMap);
    }

    public Map<ASTNode, CodeBlock> getMutableNodeToBlockMap() {
        return nodeToBlockMap;
    }

    public void setNodeToBlockMap(Map<ASTNode, CodeBlock> nodeToBlockMap) {
        this.nodeToBlockMap = nodeToBlockMap != null ?
                new HashMap<>(nodeToBlockMap) : new HashMap<>();
    }

    public void clearNodeToBlockMap() {
        this.nodeToBlockMap.clear();
    }

    public Optional<CodeBlock> getBlockForNode(ASTNode node) {
        return Optional.ofNullable(nodeToBlockMap.get(node));
    }

    public Optional<CodeBlock> getHighlightedBlock() {
        return Optional.ofNullable(highlightedBlock);
    }

    public void setHighlightedBlock(CodeBlock block) {
        if (this.highlightedBlock != null) {
            this.highlightedBlock.unhighlight();
        }
        this.highlightedBlock = block;
        if (this.highlightedBlock != null) {
            this.highlightedBlock.highlight();
        }
    }

    public void clearHighlight() {
        setHighlightedBlock(null);
    }

    // --- Debugging ---

    public boolean isDebugging() {
        return isDebugging;
    }

    public void setDebugging(boolean debugging) {
        this.isDebugging = debugging;
    }

    public Set<String> getBreakpointIds() {
        return Collections.unmodifiableSet(breakpointIds);
    }

    public void addBreakpoint(String blockId) {
        breakpointIds.add(blockId);
    }

    public void removeBreakpoint(String blockId) {
        breakpointIds.remove(blockId);
    }

    public boolean hasBreakpoint(String blockId) {
        return breakpointIds.contains(blockId);
    }

    /**
     * Snapshot for debugging/logging
     */
    public StateSnapshot createSnapshot() {
        return new StateSnapshot(
                getCurrentCode(),
                getDocUri(),
                docVersion,
                nodeToBlockMap.size(),
                highlightedBlock != null,
                isDebugging
        );
    }

    public static class StateSnapshot {
        public final String currentCode;
        public final String docUri;
        public final long docVersion;
        public final int blockCount;
        public final boolean hasHighlight;
        public final boolean isDebugging;

        private StateSnapshot(String currentCode, String docUri, long docVersion,
                              int blockCount, boolean hasHighlight, boolean isDebugging) {
            this.currentCode = currentCode;
            this.docUri = docUri;
            this.docVersion = docVersion;
            this.blockCount = blockCount;
            this.hasHighlight = hasHighlight;
            this.isDebugging = isDebugging;
        }

        @Override
        public String toString() {
            return String.format(
                    "StateSnapshot{docVersion=%d, codeLength=%d, blockCount=%d, hasHighlight=%s, isDebugging=%s}",
                    docVersion, currentCode != null ? currentCode.length() : 0, blockCount, hasHighlight, isDebugging
            );
        }
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\state\HistoryManager.java
=================================================================================

package com.botmaker.state;

import java.util.Stack;

public class HistoryManager {

    private final Stack<String> undoStack = new Stack<>();
    private final Stack<String> redoStack = new Stack<>();
    private static final int MAX_HISTORY_SIZE = 50; // Limit memory usage

    /**
     * Saves a snapshot of the code.
     * Call this BEFORE applying a new change.
     */
    public void pushState(String code) {
        // Avoid saving duplicates (e.g. if multiple events fire for same code)
        if (!undoStack.isEmpty() && undoStack.peek().equals(code)) {
            return;
        }

        undoStack.push(code);

        // Enforce size limit
        if (undoStack.size() > MAX_HISTORY_SIZE) {
            undoStack.remove(0);
        }

        // New change clears the redo future
        redoStack.clear();
    }

    public boolean canUndo() { return !undoStack.isEmpty(); }
    public boolean canRedo() { return !redoStack.isEmpty(); }

    public String undo(String currentCode) {
        if (!canUndo()) return currentCode;

        // Save current state to Redo stack
        redoStack.push(currentCode);

        // Return previous state
        return undoStack.pop();
    }

    public String redo(String currentCode) {
        if (!canRedo()) return currentCode;

        // Save current state to Undo stack
        undoStack.push(currentCode);

        // Return future state
        return redoStack.pop();
    }

    public void clear() {
        undoStack.clear();
        redoStack.clear();
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\ui\AddableBlock.java
=================================================================================

package com.botmaker.ui;

import com.botmaker.blocks.*;
import com.botmaker.core.StatementBlock;

public enum AddableBlock {
    PRINT("Print", PrintBlock.class, BlockCategory.OUTPUT),

    // --- FLOW CONTROL ---
    IF("If Statement", IfBlock.class, BlockCategory.FLOW),
    SWITCH("Switch", SwitchBlock.class, BlockCategory.FLOW),

    // --- LOOPS ---
    WHILE("While Loop", WhileBlock.class, BlockCategory.LOOPS),
    FOR("For Each Loop", ForBlock.class, BlockCategory.LOOPS),
    DO_WHILE("Do While", DoWhileBlock.class, BlockCategory.LOOPS),

    // --- CONTROL COMMANDS ---
    BREAK("Break", BreakBlock.class, BlockCategory.CONTROL),
    CONTINUE("Continue", ContinueBlock.class, BlockCategory.CONTROL),
    RETURN("Return", ReturnBlock.class, BlockCategory.CONTROL),
    WAIT("Wait (ms)", WaitBlock.class, BlockCategory.CONTROL),

    // --- VARIABLES ---
    DECLARE_INT("Int Variable", VariableDeclarationBlock.class, BlockCategory.VARIABLES),
    DECLARE_DOUBLE("Double Variable", VariableDeclarationBlock.class, BlockCategory.VARIABLES),
    DECLARE_BOOLEAN("Bool Variable", VariableDeclarationBlock.class, BlockCategory.VARIABLES),
    DECLARE_STRING("String Variable", VariableDeclarationBlock.class, BlockCategory.VARIABLES),
    DECLARE_ARRAY("Create List", VariableDeclarationBlock.class, BlockCategory.VARIABLES),
    ASSIGNMENT("Set Variable", AssignmentBlock.class, BlockCategory.VARIABLES),

    // --- INPUT ---
    READ_LINE("Read Text", ReadInputBlock.class, BlockCategory.INPUT),
    READ_INT("Read Int", ReadInputBlock.class, BlockCategory.INPUT),
    READ_DOUBLE("Read Double", ReadInputBlock.class, BlockCategory.INPUT),

    // --- FUNCTIONS ---
    FUNCTION_CALL("Call Function", MethodInvocationBlock.class, BlockCategory.FUNCTIONS), // MOVED HERE
    METHOD_DECLARATION("Declare Function", MethodDeclarationBlock.class, BlockCategory.FUNCTIONS),
    DECLARE_ENUM("Define Enum", DeclareEnumBlock.class, BlockCategory.VARIABLES),
    // --- UTILITY ---
    COMMENT("Comment", CommentBlock.class, BlockCategory.UTILITY);


    private final String displayName;
    private final Class<? extends StatementBlock> blockClass;
    private final BlockCategory category;

    AddableBlock(String displayName, Class<? extends StatementBlock> blockClass, BlockCategory category) {
        this.displayName = displayName;
        this.blockClass = blockClass;
        this.category = category;
    }

    public String getDisplayName() { return displayName; }
    public Class<? extends StatementBlock> getBlockClass() { return blockClass; }
    public BlockCategory getCategory() { return category; }

    public enum BlockCategory {
        OUTPUT("Output"),
        INPUT("Input"),
        VARIABLES("Variables"),
        FLOW("Logic"),
        LOOPS("Loops"),
        CONTROL("Control"),
        FUNCTIONS("Functions"),
        UTILITY("Utility");

        private final String label;
        BlockCategory(String label) { this.label = label; }
        public String getLabel() { return label; }
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\ui\AddableExpression.java
=================================================================================

package com.botmaker.ui;

import com.botmaker.util.TypeManager;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

public enum AddableExpression {
    // Literals
    TEXT("Text", "String"),
    NUMBER("Number", "number"),
    TRUE("True", "boolean"),
    FALSE("False", "boolean"),
    VARIABLE("Variable", "any"),

    // NEW: Function Call
    FUNCTION_CALL("Function Call", "any"), // Can return anything

    // Nested
    LIST("Sub-List", "list"),

    // Math Operations
    ADD("Addition (+)", "+", "number"),
    SUBTRACT("Subtraction (-)", "-", "number"),
    MULTIPLY("Multiplication (*)", "*", "number"),
    DIVIDE("Division (/)", "/", "number"),
    MODULO("Modulo (%)", "%", "number");

    private final String displayName;
    private final String operator;
    private final String returnType;

    AddableExpression(String displayName, String returnType) {
        this(displayName, null, returnType);
    }

    AddableExpression(String displayName, String operator, String returnType) {
        this.displayName = displayName;
        this.operator = operator;
        this.returnType = returnType;
    }

    public String getDisplayName() { return displayName; }
    public String getOperator() { return operator; }

    public static List<AddableExpression> getForType(String targetType) {
        if (targetType == null || targetType.equals("any")) {
            return Arrays.asList(values());
        }

        // NEW: Filter for Switch Compatibility
        if (targetType.equals(TypeManager.UI_TYPE_SWITCH_COMPATIBLE)) {
            return Arrays.stream(values())
                    .filter(e -> {
                        // Explicitly allow Variable, Text, Function Call
                        if (e == VARIABLE || e == TEXT || e == FUNCTION_CALL) return true;

                        // Allow Number (creates 0, which is an int, thus valid)
                        if (e == NUMBER) return true;

                        // Allow math (creates int expressions usually)
                        if (e.returnType.equals("number")) return true;

                        // Exclude Boolean literals and Lists
                        return false;
                    })
                    .collect(Collectors.toList());
        }

        return Arrays.stream(values())
                .filter(e -> {
                    if (e.returnType.equals("any")) return true;
                    return e.returnType.equals(targetType);
                })
                .collect(Collectors.toList());
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\ui\BlockDragAndDropManager.java
=================================================================================

package com.botmaker.ui;

import com.botmaker.blocks.ClassBlock;
import com.botmaker.core.BodyBlock;
import com.botmaker.core.StatementBlock;
import javafx.scene.Node;
import javafx.scene.input.ClipboardContent;
import javafx.scene.input.DataFormat;
import javafx.scene.input.Dragboard;
import javafx.scene.input.TransferMode;
import javafx.scene.layout.Region;

import java.util.function.Consumer;

public class BlockDragAndDropManager {

    public static final DataFormat ADDABLE_BLOCK_FORMAT = new DataFormat("application/x-java-addable-block");
    public static final DataFormat EXISTING_BLOCK_FORMAT = new DataFormat("application/x-java-existing-block");

    // Callbacks
    private Consumer<DropInfo> onDrop;
    private Consumer<MoveBlockInfo> onBlockMove;

    public BlockDragAndDropManager(Consumer<DropInfo> onDrop) {
        this.onDrop = onDrop;
    }

    public void setCallback(Consumer<DropInfo> onDrop) {
        this.onDrop = onDrop;
    }

    public void setMoveCallback(Consumer<MoveBlockInfo> onBlockMove) {
        this.onBlockMove = onBlockMove;
    }

    /**
     * Makes a UI node draggable (Palette Items).
     * Added visual feedback (Opacity).
     */
    public void makeDraggable(Node node, AddableBlock blockType) {
        node.setOnDragDetected(event -> {
            Dragboard db = node.startDragAndDrop(TransferMode.COPY);
            ClipboardContent content = new ClipboardContent();
            content.put(ADDABLE_BLOCK_FORMAT, blockType.name());
            db.setContent(content);

            // Visual feedback: reduce opacity to show it's being dragged
            node.setOpacity(0.5);

            System.out.println("Drag detected for: " + blockType.name());
            event.consume();
        });

        // Reset opacity when drag finishes (success or cancel)
        node.setOnDragDone(event -> {
            node.setOpacity(1.0);
            event.consume();
        });
    }

    /**
     * Makes an existing block's UI node draggable for repositioning.
     */
    public void makeBlockMovable(Node node, StatementBlock block, BodyBlock sourceBody) {
        node.setOnDragDetected(event -> {
            if (event.getTarget() instanceof javafx.scene.control.Control) {
                return;
            }

            Dragboard db = node.startDragAndDrop(TransferMode.MOVE);
            ClipboardContent content = new ClipboardContent();
            content.put(EXISTING_BLOCK_FORMAT, block.getId());
            db.setContent(content);

            node.setOpacity(0.5);

            System.out.println("Dragging existing block: " + block.getDetails());
            event.consume();
        });

        node.setOnDragDone(event -> {
            node.setOpacity(1.0);
            javafx.application.Platform.runLater(() -> {
                javafx.scene.Node current = node;
                javafx.scene.control.ScrollPane scrollPane = null;
                while (current != null) {
                    if (current instanceof javafx.scene.control.ScrollPane) {
                        scrollPane = (javafx.scene.control.ScrollPane) current;
                        break;
                    }
                    current = current.getParent();
                }

                if (scrollPane != null) {
                    scrollPane.setFocusTraversable(true);
                    scrollPane.requestFocus();
                }
            });
        });
    }

    public Region createSeparator() {
        Region separator = new Region();
        separator.setMinHeight(8);
        separator.setStyle("-fx-background-color: transparent;");
        return separator;
    }

    public void addSeparatorDragHandlers(Region separator, BodyBlock targetBody, int insertionIndex, StatementBlock adjacentBlock) {
        String defaultColor = "transparent";
        String hoverColor = "#007bff";
        String moveHoverColor = "#28a745";

        separator.setOnDragEntered(event -> {
            Dragboard db = event.getDragboard();
            if (db.hasContent(ADDABLE_BLOCK_FORMAT)) {
                separator.setStyle("-fx-background-color: " + hoverColor + ";");
            } else if (db.hasContent(EXISTING_BLOCK_FORMAT)) {
                separator.setStyle("-fx-background-color: " + moveHoverColor + ";");
            }
            event.consume();
        });

        separator.setOnDragExited(event -> {
            separator.setStyle("-fx-background-color: " + defaultColor);
            event.consume();
        });

        separator.setOnDragOver(event -> {
            Dragboard db = event.getDragboard();
            if (db.hasContent(ADDABLE_BLOCK_FORMAT) || db.hasContent(EXISTING_BLOCK_FORMAT)) {
                event.acceptTransferModes(TransferMode.COPY_OR_MOVE);
            }
            event.consume();
        });

        separator.setOnDragDropped(event -> {
            Dragboard db = event.getDragboard();
            boolean success = false;

            if (db.hasContent(ADDABLE_BLOCK_FORMAT)) {
                String blockTypeName = (String) db.getContent(ADDABLE_BLOCK_FORMAT);
                AddableBlock type = AddableBlock.valueOf(blockTypeName);
                if (onDrop != null) {
                    onDrop.accept(new DropInfo(type, targetBody, insertionIndex));
                    success = true;
                }
            } else if (db.hasContent(EXISTING_BLOCK_FORMAT)) {
                String blockId = (String) db.getContent(EXISTING_BLOCK_FORMAT);
                if (onBlockMove != null) {
                    onBlockMove.accept(new MoveBlockInfo(blockId, targetBody, insertionIndex));
                    success = true;
                }
            }

            event.setDropCompleted(success);
            event.consume();
        });
    }

    public void addClassMemberDropHandlers(Region separator, ClassBlock targetClass, int insertionIndex) {

        separator.setOnDragOver(event -> {
            Dragboard db = event.getDragboard();
            if (db.hasContent(ADDABLE_BLOCK_FORMAT)) {
                String blockTypeName = (String) db.getContent(ADDABLE_BLOCK_FORMAT);
                AddableBlock type = AddableBlock.valueOf(blockTypeName);

                // Allow Methods OR Enums
                if (type == AddableBlock.METHOD_DECLARATION || type == AddableBlock.DECLARE_ENUM) {
                    event.acceptTransferModes(TransferMode.COPY);
                }
            }
            event.consume();
        });

        separator.setOnDragDropped(event -> {
            Dragboard db = event.getDragboard();
            boolean success = false;
            if (db.hasContent(ADDABLE_BLOCK_FORMAT)) {
                String blockTypeName = (String) db.getContent(ADDABLE_BLOCK_FORMAT);
                AddableBlock type = AddableBlock.valueOf(blockTypeName);

                if ((type == AddableBlock.METHOD_DECLARATION || type == AddableBlock.DECLARE_ENUM) && onDrop != null) {
                    // We reuse DropInfo but check type in CodeEditorService
                    onDrop.accept(new DropInfo(type, null, insertionIndex, targetClass));
                    success = true;
                }
            }
            event.setDropCompleted(success);
            event.consume();
        });
    }

    public void addEmptyBodyDropHandlers(Region target, BodyBlock targetBody) {
        target.setOnDragEntered(event -> {
            if (event.getDragboard().hasContent(ADDABLE_BLOCK_FORMAT) || event.getDragboard().hasContent(EXISTING_BLOCK_FORMAT)) {
                target.getStyleClass().add("empty-body-drop-hover");
            }
            event.consume();
        });

        target.setOnDragExited(event -> {
            target.getStyleClass().remove("empty-body-drop-hover");
            event.consume();
        });

        target.setOnDragOver(event -> {
            if (event.getDragboard().hasContent(ADDABLE_BLOCK_FORMAT) || event.getDragboard().hasContent(EXISTING_BLOCK_FORMAT)) {
                event.acceptTransferModes(TransferMode.COPY_OR_MOVE);
            }
            event.consume();
        });

        target.setOnDragDropped(event -> {
            Dragboard db = event.getDragboard();
            boolean success = false;
            if (db.hasContent(ADDABLE_BLOCK_FORMAT)) {
                String blockTypeName = (String) db.getContent(ADDABLE_BLOCK_FORMAT);
                AddableBlock type = AddableBlock.valueOf(blockTypeName);
                if (onDrop != null) {
                    onDrop.accept(new DropInfo(type, targetBody, 0));
                    success = true;
                }
            } else if (db.hasContent(EXISTING_BLOCK_FORMAT)) {
                String blockId = (String) db.getContent(EXISTING_BLOCK_FORMAT);
                if (onBlockMove != null) {
                    onBlockMove.accept(new MoveBlockInfo(blockId, targetBody, 0));
                    success = true;
                }
            }
            event.setDropCompleted(success);
            event.consume();
        });
    }

    public void addExpressionDropHandlers(Region target) {
        String defaultStyle = "-fx-background-color: #f0f0f0; -fx-border-color: #c0c0c0; -fx-border-style: dashed; -fx-min-width: 50; -fx-min-height: 25;";
        String hoverStyle = defaultStyle + "-fx-border-color: #007bff;";

        target.setStyle(defaultStyle);

        target.setOnDragEntered(event -> {
            if (event.getDragboard().hasContent(ADDABLE_BLOCK_FORMAT)) {
                target.setStyle(hoverStyle);
            }
            event.consume();
        });

        target.setOnDragExited(event -> {
            target.setStyle(defaultStyle);
            event.consume();
        });

        target.setOnDragOver(event -> {
            if (event.getDragboard().hasContent(ADDABLE_BLOCK_FORMAT)) {
                event.acceptTransferModes(TransferMode.COPY);
            }
            event.consume();
        });

        target.setOnDragDropped(event -> {
            Dragboard db = event.getDragboard();
            boolean success = false;
            if (db.hasContent(ADDABLE_BLOCK_FORMAT)) {
                success = true;
                // Handled by expression replacement logic usually, but here we just accept it
                // to indicate valid drop target visually
            }
            event.setDropCompleted(success);
            event.consume();
        });
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\ui\BlockEvent.java
=================================================================================

package com.botmaker.ui;

import com.botmaker.core.CodeBlock;
import javafx.event.Event;
import javafx.event.EventType;

public class BlockEvent extends Event {
    public static final EventType<BlockEvent> ANY = new EventType<>(Event.ANY, "BLOCK_EVENT");

    public BlockEvent(EventType<? extends Event> eventType) {
        super(eventType);
    }

    public static class BreakpointToggleEvent extends BlockEvent {
        public static final EventType<BreakpointToggleEvent> TOGGLE_BREAKPOINT = new EventType<>(ANY, "TOGGLE_BREAKPOINT");

        private final CodeBlock block;
        private final boolean isEnabled;

        public BreakpointToggleEvent(CodeBlock block, boolean isEnabled) {
            super(TOGGLE_BREAKPOINT);
            this.block = block;
            this.isEnabled = isEnabled;
        }

        public CodeBlock getBlock() { return block; }
        public boolean isEnabled() { return isEnabled; }
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\ui\DropInfo.java
=================================================================================

// In DropInfo.java - update the record
package com.botmaker.ui;

import com.botmaker.blocks.ClassBlock;
import com.botmaker.core.BodyBlock;

public record DropInfo(
        AddableBlock type,
        BodyBlock targetBody,
        int insertionIndex,
        ClassBlock targetClass // NEW: for method declarations
) {
    // Convenience constructor for statement drops (existing behavior)
    public DropInfo(AddableBlock type, BodyBlock targetBody, int insertionIndex) {
        this(type, targetBody, insertionIndex, null);
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\ui\EventLogManager.java
=================================================================================

package com.botmaker.ui;

import com.botmaker.events.ApplicationEvent;
import com.botmaker.events.CoreApplicationEvents;
import com.botmaker.events.EventBus;
import javafx.application.Platform;
import javafx.scene.control.ListView;
import javafx.scene.control.SelectionMode;

import java.time.Instant;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

/**
 * Manages the Event Log pane.
 * Buffers events to prevent UI flooding and filters out high-frequency noise.
 */
public class EventLogManager {

    private final ListView<String> eventListView;
    private final ConcurrentLinkedQueue<String> pendingLogs = new ConcurrentLinkedQueue<>();
    private final ScheduledExecutorService uiUpdater;
    private final DateTimeFormatter timeFormatter = DateTimeFormatter.ofPattern("HH:mm:ss.SSS")
            .withZone(ZoneId.systemDefault());

    private static final int MAX_LOG_ENTRIES = 1000;
    private static final int UPDATE_INTERVAL_MS = 250; // Update UI max 4 times per second

    public EventLogManager(EventBus eventBus) {
        this.eventListView = new ListView<>();
        this.eventListView.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE);
        this.eventListView.getStyleClass().add("event-log-list");

        // Use a monospaced font style via CSS or inline for now
        this.eventListView.setStyle("-fx-font-family: 'Consolas', 'Monospaced'; -fx-font-size: 11px;");

        // Subscribe to everything
        eventBus.subscribeAll(this::handleEvent);

        // Start the UI update thread
        this.uiUpdater = Executors.newSingleThreadScheduledExecutor(r -> {
            Thread t = new Thread(r, "EventLog-Updater");
            t.setDaemon(true);
            return t;
        });

        startUiLoop();
    }

    public ListView<String> getView() {
        return eventListView;
    }

    private void handleEvent(ApplicationEvent event) {
        // 1. FILTERING: Ignore extremely frequent events that have their own displays
        if (event instanceof CoreApplicationEvents.OutputAppendedEvent) return;

        // Optional: Filter CodeUpdatedEvent if it's too noisy (happens on every keypress)
        // if (event instanceof CoreApplicationEvents.CodeUpdatedEvent) return;

        // 2. FORMATTING
        String timestamp = timeFormatter.format(Instant.ofEpochMilli(event.getTimestamp()));
        String eventName = event.getClass().getSimpleName();
        String source = event.getSource();

        String details = "";

        // Extract interesting details for specific events
        if (event instanceof CoreApplicationEvents.StatusMessageEvent) {
            details = ": " + ((CoreApplicationEvents.StatusMessageEvent) event).getMessage();
        } else if (event instanceof CoreApplicationEvents.DebugSessionPausedEvent) {
            details = " @ Line " + ((CoreApplicationEvents.DebugSessionPausedEvent) event).getLineNumber();
        } else if (event instanceof CoreApplicationEvents.BreakpointToggledEvent) {
            var bp = (CoreApplicationEvents.BreakpointToggledEvent) event;
            details = " (" + (bp.isEnabled() ? "ON" : "OFF") + ") ID: " + bp.getBlock().getId();
        }

        String logEntry = String.format("[%s] %-25s | %s%s", timestamp, eventName, source, details);

        // 3. QUEUING
        pendingLogs.offer(logEntry);
    }

    private void startUiLoop() {
        uiUpdater.scheduleAtFixedRate(() -> {
            if (pendingLogs.isEmpty()) return;

            // Drain the queue into a temporary list
            List<String> batch = new ArrayList<>();
            String log;
            while ((log = pendingLogs.poll()) != null) {
                batch.add(log);
            }

            if (!batch.isEmpty()) {
                Platform.runLater(() -> {
                    eventListView.getItems().addAll(batch);

                    // Prune old entries
                    if (eventListView.getItems().size() > MAX_LOG_ENTRIES) {
                        eventListView.getItems().remove(0, eventListView.getItems().size() - MAX_LOG_ENTRIES);
                    }

                    // Auto-scroll to bottom
                    eventListView.scrollTo(eventListView.getItems().size() - 1);
                });
            }
        }, UPDATE_INTERVAL_MS, UPDATE_INTERVAL_MS, TimeUnit.MILLISECONDS);
    }

    public void shutdown() {
        uiUpdater.shutdownNow();
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\ui\FileExplorerManager.java
=================================================================================

package com.botmaker.ui;

import com.botmaker.config.ApplicationConfig;
import com.botmaker.services.CodeEditorService;
import com.botmaker.state.ApplicationState;
import javafx.scene.control.*;
import javafx.scene.layout.VBox;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Optional;
import java.util.stream.Stream;

public class FileExplorerManager {

    private final ApplicationConfig config;
    private final CodeEditorService codeEditorService;
    private final ApplicationState state;
    private final TreeView<Path> fileTree;

    public FileExplorerManager(ApplicationConfig config, CodeEditorService codeEditorService, ApplicationState state) {
        this.config = config;
        this.codeEditorService = codeEditorService;
        this.state = state;
        this.fileTree = new TreeView<>();
    }

    public VBox createView() {
        VBox container = new VBox();
        container.getStyleClass().add("file-explorer");

        Label header = new Label("Project Files");
        header.getStyleClass().add("sidebar-header");

        Button newFileBtn = new Button("New Function Library");
        newFileBtn.setMaxWidth(Double.MAX_VALUE);
        newFileBtn.setOnAction(e -> showCreateFileDialog());

        configureTree();
        refreshTree();

        container.getChildren().addAll(header, newFileBtn, fileTree);
        return container;
    }

    private void configureTree() {
        // We hide the root "java" folder to make it look cleaner
        fileTree.setShowRoot(false);

        fileTree.setCellFactory(tv -> new TreeCell<>() {
            @Override
            protected void updateItem(Path item, boolean empty) {
                super.updateItem(item, empty);
                if (empty || item == null) {
                    setText(null);
                    setGraphic(null);
                    setStyle("");
                } else {
                    String fileName = item.getFileName().toString();

                    // Visual Logic
                    boolean isDirectory = Files.isDirectory(item);
                    String pathStr = item.toString().replace("\\", "/");
                    boolean isLibrary = pathStr.contains("com/botmaker/library");

                    if (isDirectory) {
                        setText(fileName);
                        setStyle("-fx-font-weight: bold; -fx-text-fill: #333;");
                    }
                    else if (isLibrary) {
                        setText(fileName + " [Lib]");
                        // Locked/Library style
                        setStyle("-fx-text-fill: #888; -fx-font-style: italic;");
                    }
                    else {
                        setText(fileName);
                        // Highlight active file
                        if (state.getActiveFile() != null && item.equals(state.getActiveFile().getPath())) {
                            setStyle("-fx-font-weight: bold; -fx-text-fill: #007bff;");
                        } else {
                            setStyle("-fx-text-fill: black;");
                        }
                    }
                }
            }
        });

        fileTree.getSelectionModel().selectedItemProperty().addListener((obs, oldVal, newVal) -> {
            if (newVal != null && newVal.getValue() != null) {
                Path selectedPath = newVal.getValue();

                // Only open if it's a file, not a directory
                if (Files.isRegularFile(selectedPath)) {
                    // Optional: Check if it's a library file to prevent editing
                    // For now, we just open everything
                    if (state.getActiveFile() == null || !state.getActiveFile().getPath().equals(selectedPath)) {
                        codeEditorService.switchToFile(selectedPath);
                        fileTree.refresh();
                    }
                }
            }
        });
    }

    public void refreshTree() {
        // 1. Find the root 'src/main/java' directory
        // Start from Main file: .../src/main/java/com/myproject/Main.java
        Path current = config.getSourceFilePath().getParent();

        // Traverse up until we hit "java" (or run out of parents)
        while (current != null && !current.getFileName().toString().equals("java")) {
            current = current.getParent();
        }

        // Fallback if structure is weird
        if (current == null) {
            current = config.getSourceFilePath().getParent();
        }

        TreeItem<Path> root = new TreeItem<>(current);
        root.setExpanded(true);

        // 2. Recursively build the tree
        buildFileTree(root, current);

        fileTree.setRoot(root);
    }

    private void buildFileTree(TreeItem<Path> parentItem, Path parentPath) {
        try (Stream<Path> files = Files.list(parentPath)) {
            files.sorted((p1, p2) -> {
                // Sort directories first, then files
                boolean d1 = Files.isDirectory(p1);
                boolean d2 = Files.isDirectory(p2);
                if (d1 && !d2) return -1;
                if (!d1 && d2) return 1;
                return p1.getFileName().toString().compareTo(p2.getFileName().toString());
            }).forEach(path -> {
                TreeItem<Path> item = new TreeItem<>(path);
                parentItem.getChildren().add(item);

                if (Files.isDirectory(path)) {
                    // Auto-expand 'com' and 'botmaker' folders for convenience
                    String name = path.getFileName().toString();
                    if (name.equals("com") || name.equals("botmaker") || name.equals("library")) {
                        item.setExpanded(true);
                    }
                    buildFileTree(item, path);
                }
            });
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private void showCreateFileDialog() {
        TextInputDialog dialog = new TextInputDialog();
        dialog.setTitle("New Function Library");
        dialog.setHeaderText("Create a new library of functions");
        dialog.setContentText("Name (e.g. Movement):");

        Optional<String> result = dialog.showAndWait();
        result.ifPresent(name -> {
            String className = name.trim().replaceAll("[^a-zA-Z0-9]", "");
            if (!className.isEmpty()) {
                codeEditorService.createFile(className);
                refreshTree();
            }
        });
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\ui\MenuBarManager.java
=================================================================================

package com.botmaker.ui;

import com.botmaker.events.CoreApplicationEvents;
import com.botmaker.events.EventBus;
import javafx.scene.control.Menu;
import javafx.scene.control.MenuBar;
import javafx.scene.control.MenuItem;
import javafx.scene.control.SeparatorMenuItem;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyCodeCombination;
import javafx.scene.input.KeyCombination;
import javafx.stage.Stage;

import java.util.function.Consumer;

/**
 * Manages the application menu bar
 */
public class MenuBarManager {

    private final MenuBar menuBar;
    private final Stage primaryStage;
    private Consumer<Void> onSelectProject;
    private EventBus eventBus;
    private MenuItem undoItem;
    private MenuItem redoItem;
    public MenuBarManager(Stage primaryStage) {
        this.primaryStage = primaryStage;
        this.menuBar = new MenuBar();
        createMenus();
    }

    /**
     * Creates all menus
     */
    private void createMenus() {
        // File menu
        Menu fileMenu = createFileMenu();

        // Edit menu (placeholder for future)
        Menu editMenu = createEditMenu();

        // View menu (placeholder for future)
        Menu viewMenu = createViewMenu();

        // Help menu
        Menu helpMenu = createHelpMenu();

        menuBar.getMenus().addAll(fileMenu, editMenu, viewMenu, helpMenu);
    }

    /**
     * Creates the File menu
     */
    private Menu createFileMenu() {
        Menu fileMenu = new Menu("File");

        // Select Project
        MenuItem selectProjectItem = new MenuItem("Select Project...");
        selectProjectItem.setAccelerator(new KeyCodeCombination(
                KeyCode.O,
                KeyCombination.CONTROL_DOWN,
                KeyCombination.SHIFT_DOWN
        ));
        selectProjectItem.setOnAction(e -> {
            if (onSelectProject != null) {
                onSelectProject.accept(null);
            }
        });

        // Separator
        SeparatorMenuItem separator1 = new SeparatorMenuItem();

        // Exit
        MenuItem exitItem = new MenuItem("Exit");
        exitItem.setAccelerator(new KeyCodeCombination(
                KeyCode.Q,
                KeyCombination.CONTROL_DOWN
        ));

        // UPDATED: Force system exit
        exitItem.setOnAction(e -> {
            javafx.application.Platform.exit(); // Close JavaFX
            System.exit(0); // Kill JVM (stops LSP, Debugger, etc.)
        });

        fileMenu.getItems().addAll(
                selectProjectItem,
                separator1,
                exitItem
        );

        return fileMenu;
    }

    /**
     * Creates the Edit menu
     */
    private Menu createEditMenu() {
        Menu editMenu = new Menu("Edit");

        undoItem = new MenuItem("Undo");
        undoItem.setAccelerator(new KeyCodeCombination(KeyCode.Z, KeyCombination.CONTROL_DOWN));
        undoItem.setDisable(true);
        undoItem.setOnAction(e -> {
            if (eventBus != null) eventBus.publish(new CoreApplicationEvents.UndoRequestedEvent());
        });

        redoItem = new MenuItem("Redo");
        redoItem.setAccelerator(new KeyCodeCombination(KeyCode.Y, KeyCombination.CONTROL_DOWN));
        redoItem.setDisable(true);
        redoItem.setOnAction(e -> {
            if (eventBus != null) eventBus.publish(new CoreApplicationEvents.RedoRequestedEvent());
        });

        SeparatorMenuItem separator = new SeparatorMenuItem();

        MenuItem cutItem = new MenuItem("Cut");
        cutItem.setAccelerator(new KeyCodeCombination(KeyCode.X, KeyCombination.CONTROL_DOWN));
        cutItem.setDisable(true); // Not implemented yet

        MenuItem copyItem = new MenuItem("Copy");
        copyItem.setAccelerator(new KeyCodeCombination(KeyCode.C, KeyCombination.CONTROL_DOWN));
        copyItem.setDisable(true); // Not implemented yet

        MenuItem pasteItem = new MenuItem("Paste");
        pasteItem.setAccelerator(new KeyCodeCombination(KeyCode.V, KeyCombination.CONTROL_DOWN));
        pasteItem.setDisable(true); // Not implemented yet

        editMenu.getItems().addAll(
                undoItem,
                redoItem,
                separator,
                cutItem,
                copyItem,
                pasteItem
        );

        return editMenu;
    }

    /**
     * Creates the View menu
     */
    private Menu createViewMenu() {
        Menu viewMenu = new Menu("View");

        // Placeholder items for future implementation
        MenuItem zoomInItem = new MenuItem("Zoom In");
        zoomInItem.setAccelerator(new KeyCodeCombination(
                KeyCode.PLUS,
                KeyCombination.CONTROL_DOWN
        ));
        zoomInItem.setDisable(true); // Not implemented yet

        MenuItem zoomOutItem = new MenuItem("Zoom Out");
        zoomOutItem.setAccelerator(new KeyCodeCombination(
                KeyCode.MINUS,
                KeyCombination.CONTROL_DOWN
        ));
        zoomOutItem.setDisable(true); // Not implemented yet

        MenuItem resetZoomItem = new MenuItem("Reset Zoom");
        resetZoomItem.setAccelerator(new KeyCodeCombination(
                KeyCode.DIGIT0,
                KeyCombination.CONTROL_DOWN
        ));
        resetZoomItem.setDisable(true); // Not implemented yet

        viewMenu.getItems().addAll(
                zoomInItem,
                zoomOutItem,
                resetZoomItem
        );

        return viewMenu;
    }


    public void setEventBus(EventBus eventBus) {
        this.eventBus = eventBus;
        eventBus.subscribe(CoreApplicationEvents.HistoryStateChangedEvent.class, this::updateMenuState, true);
    }

    private void updateMenuState(CoreApplicationEvents.HistoryStateChangedEvent event) {
        if (undoItem != null) undoItem.setDisable(!event.canUndo());
        if (redoItem != null) redoItem.setDisable(!event.canRedo());
    }

    /**
     * Creates the Help menu
     */
    private Menu createHelpMenu() {
        Menu helpMenu = new Menu("Help");

        MenuItem aboutItem = new MenuItem("About BotMaker");
        aboutItem.setOnAction(e -> showAboutDialog());

        helpMenu.getItems().add(aboutItem);

        return helpMenu;
    }

    /**
     * Shows the about dialog
     */
    private void showAboutDialog() {
        javafx.scene.control.Alert alert = new javafx.scene.control.Alert(
                javafx.scene.control.Alert.AlertType.INFORMATION
        );
        alert.initOwner(primaryStage);
        alert.setTitle("About BotMaker");
        alert.setHeaderText("BotMaker Blocks");
        alert.setContentText(
                "Version: 1.0.0\n\n" +
                        "A visual block-based programming environment for Java.\n\n" +
                        "Build Java applications using drag-and-drop blocks!"
        );
        alert.showAndWait();
    }

    /**
     * Gets the menu bar
     */
    public MenuBar getMenuBar() {
        return menuBar;
    }

    /**
     * Sets the callback for when "Select Project" is clicked
     */
    public void setOnSelectProject(Consumer<Void> callback) {
        this.onSelectProject = callback;
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\ui\MoveBlockInfo.java
=================================================================================

package com.botmaker.ui;

import com.botmaker.core.BodyBlock;

/**
 * Information about moving an existing block to a new position.
 * @param blockId The ID of the block being moved
 * @param targetBody The BodyBlock where the block should be moved to
 * @param insertionIndex The index where the block should be inserted
 */
public record MoveBlockInfo(String blockId, BodyBlock targetBody, int insertionIndex) {
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\ui\PaletteManager.java
=================================================================================

package com.botmaker.ui;

import com.botmaker.ui.AddableBlock.BlockCategory;
import javafx.geometry.Pos;
import javafx.scene.control.CustomMenuItem;
import javafx.scene.control.Label;
import javafx.scene.control.MenuButton;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Priority;
import javafx.scene.layout.Region;

import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

public class PaletteManager {

    private final BlockDragAndDropManager dragAndDropManager;

    public PaletteManager(BlockDragAndDropManager dragAndDropManager) {
        this.dragAndDropManager = dragAndDropManager;
    }

    public HBox createHorizontalPalette() {
        HBox container = new HBox(8);
        container.setAlignment(Pos.CENTER);
        // Remove padding here so buttons can touch edges if needed
        container.setStyle("-fx-padding: 0;");
        container.getStyleClass().add("palette-bar");

        Map<BlockCategory, List<AddableBlock>> grouped = Arrays.stream(AddableBlock.values())
                .collect(Collectors.groupingBy(AddableBlock::getCategory));

        BlockCategory[] order = {
                BlockCategory.OUTPUT,
                BlockCategory.INPUT,
                BlockCategory.VARIABLES,
                BlockCategory.FLOW,
                BlockCategory.LOOPS,
                BlockCategory.CONTROL,
                BlockCategory.FUNCTIONS,
                BlockCategory.UTILITY
        };

        for (BlockCategory category : order) {
            List<AddableBlock> blocks = grouped.get(category);
            if (blocks == null) continue;

            String categoryColor = getCategoryColor(category);

            MenuButton categoryMenu = new MenuButton();
            categoryMenu.getStyleClass().addAll("palette-category-btn", "palette-" + category.name().toLowerCase());

            // Make button stretch to fill toolbar height
            categoryMenu.setMaxHeight(Double.MAX_VALUE);
            // Allow button to shrink horizontally if needed
            categoryMenu.setMinWidth(Region.USE_PREF_SIZE);

            // Allow HBox to distribute extra space or shrink components
            HBox.setHgrow(categoryMenu, Priority.SOMETIMES);

            Label btnLabel = new Label(category.getLabel());
            btnLabel.setStyle(
                    "-fx-text-fill: white; " +
                            "-fx-font-family: 'Segoe UI', sans-serif; " +
                            "-fx-font-weight: bold; " +
                            "-fx-font-size: 13px;"
            );
            categoryMenu.setGraphic(btnLabel);

            categoryMenu.setStyle(
                    "-fx-background-color: " + categoryColor + "; " +
                            "-fx-background-radius: 4; " + // Slightly smaller radius for "bar" look
                            "-fx-border-color: rgba(0,0,0,0.1); " +
                            "-fx-border-radius: 4; " +
                            "-fx-cursor: hand;"
                    // Removed fixed padding here to allow layout to control height
            );

            for (AddableBlock blockType : blocks) {
                Label blockLabel = new Label(blockType.getDisplayName());
                blockLabel.setPrefWidth(180);
                blockLabel.setMaxWidth(Double.MAX_VALUE);

                blockLabel.setStyle(
                        "-fx-background-color: " + categoryColor + "; " +
                                "-fx-text-fill: white; " +
                                "-fx-font-weight: bold; " +
                                "-fx-font-size: 12px; " +
                                "-fx-padding: 8 12 8 12; " +
                                "-fx-background-radius: 2;"
                );

                dragAndDropManager.makeDraggable(blockLabel, blockType);

                CustomMenuItem item = new CustomMenuItem(blockLabel);
                item.setHideOnClick(false);
                categoryMenu.getItems().add(item);
            }

            container.getChildren().add(categoryMenu);
        }

        return container;
    }

    private String getCategoryColor(BlockCategory category) {
        return switch (category) {
            case OUTPUT -> "#3498DB";
            case INPUT -> "#9B59B6";
            case VARIABLES -> "#F39C12";
            case FLOW -> "#E67E22";
            case LOOPS -> "#2ECC71";
            case CONTROL -> "#E74C3C";
            case FUNCTIONS -> "#8E44AD";
            case UTILITY -> "#7F8C8D";
            default -> "#34495E";
        };
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\ui\ProjectSelectionScreen.java
=================================================================================

package com.botmaker.ui;

import com.botmaker.project.ProjectCreator;
import com.botmaker.project.ProjectInfo;
import com.botmaker.project.ProjectManager;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.Scene;
import javafx.scene.control.*;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.HBox;
import javafx.scene.layout.VBox;
import javafx.stage.Stage;

import java.time.format.DateTimeFormatter;
import java.util.List;
import java.util.Optional;
import java.util.function.BiConsumer;
import java.util.function.Consumer;

/**
 * Project selection screen shown on startup with project creation capability
 */
public class ProjectSelectionScreen {

    private final ProjectManager projectManager;
    private final ProjectCreator projectCreator;

    // Changed to BiConsumer to pass (ProjectName, ShouldClearCache)
    private final BiConsumer<String, Boolean> onProjectSelected;

    private final Stage stage;
    private ListView<ProjectInfo> projectListView;

    // New Checkbox
    private CheckBox clearCacheCheckbox;

    public ProjectSelectionScreen(Stage stage, BiConsumer<String, Boolean> onProjectSelected) {
        this.stage = stage;
        this.projectManager = new ProjectManager();
        this.projectCreator = new ProjectCreator();
        this.onProjectSelected = onProjectSelected;
    }

    public Scene createScene() {
        BorderPane root = new BorderPane();
        root.setPadding(new Insets(20));

        // Header
        Label titleLabel = new Label("Select a Project");
        titleLabel.setStyle("-fx-font-size: 24px; -fx-font-weight: bold;");
        VBox header = new VBox(10, titleLabel);
        header.setAlignment(Pos.CENTER);
        header.setPadding(new Insets(0, 0, 20, 0));

        // Project list
        projectListView = new ListView<>();
        projectListView.setPrefHeight(400);

        projectListView.setCellFactory(lv -> new ListCell<>() {
            @Override
            protected void updateItem(ProjectInfo project, boolean empty) {
                super.updateItem(project, empty);
                if (empty || project == null) {
                    setText(null);
                    setGraphic(null);
                } else {
                    VBox box = new VBox(5);
                    Label nameLabel = new Label(project.getName());
                    nameLabel.setStyle("-fx-font-size: 16px; -fx-font-weight: bold;");

                    Label pathLabel = new Label(project.getProjectPath().toString());
                    pathLabel.setStyle("-fx-font-size: 11px; -fx-text-fill: gray;");

                    Label dateLabel = new Label("Last modified: " +
                            project.getLastModified().format(DateTimeFormatter.ofPattern("MMM dd, yyyy HH:mm")));
                    dateLabel.setStyle("-fx-font-size: 11px; -fx-text-fill: gray;");

                    box.getChildren().addAll(nameLabel, pathLabel, dateLabel);
                    setGraphic(box);
                }
            }
        });

        refreshProjectList();

        if (!projectListView.getItems().isEmpty()) {
            projectListView.getSelectionModel().select(0);
        }

        // Controls Area
        Button openButton = new Button("Open Project");
        openButton.setPrefWidth(150);
        openButton.setDefaultButton(true);
        openButton.setOnAction(e -> openSelectedProject());

        Button createButton = new Button("Create New Project");
        createButton.setPrefWidth(150);
        createButton.setOnAction(e -> showCreateProjectDialog());

        // CLEAR CACHE CHECKBOX
        clearCacheCheckbox = new CheckBox("Clear Language Server Cache (Fix startup freeze)");
        clearCacheCheckbox.setStyle("-fx-text-fill: #666; -fx-font-size: 11px;");
        clearCacheCheckbox.setTooltip(new Tooltip("Check this if the application hangs on loading."));

        projectListView.setOnMouseClicked(e -> {
            if (e.getClickCount() == 2) {
                openSelectedProject();
            }
        });

        HBox buttonBox = new HBox(10, openButton, createButton);
        buttonBox.setAlignment(Pos.CENTER);

        VBox footer = new VBox(15, clearCacheCheckbox, buttonBox);
        footer.setAlignment(Pos.CENTER);
        footer.setPadding(new Insets(20, 0, 0, 0));

        VBox center = new VBox(10, projectListView, footer);
        root.setTop(header);
        root.setCenter(center);

        Scene scene = new Scene(root, 600, 550); // Increased height slightly
        scene.getStylesheets().add(getClass().getResource("/com/botmaker/styles.css").toExternalForm());

        return scene;
    }

    private void openSelectedProject() {
        ProjectInfo selected = projectListView.getSelectionModel().getSelectedItem();
        if (selected != null) {
            onProjectSelected.accept(selected.getName(), clearCacheCheckbox.isSelected());
        }
    }

    // ... rest of file (refreshProjectList, showCreateProjectDialog, etc) remains the same ...

    private void refreshProjectList() {
        List<ProjectInfo> projects = projectManager.listProjects();
        projectListView.getItems().clear();
        projectListView.getItems().addAll(projects);
    }

    private void showCreateProjectDialog() {
        Dialog<String> dialog = new Dialog<>();
        dialog.setTitle("Create New Project");
        dialog.setHeaderText("Enter project name");

        ButtonType createButtonType = new ButtonType("Create", ButtonBar.ButtonData.OK_DONE);
        dialog.getDialogPane().getButtonTypes().addAll(createButtonType, ButtonType.CANCEL);

        VBox content = new VBox(10);
        content.setPadding(new Insets(20));

        TextField projectNameField = new TextField();
        projectNameField.setPromptText("ProjectName");

        Label instructionLabel = new Label("Project name must:");
        instructionLabel.setStyle("-fx-font-size: 11px; -fx-text-fill: gray;");

        Label rule1 = new Label("• Start with an uppercase letter");
        rule1.setStyle("-fx-font-size: 10px; -fx-text-fill: gray;");

        Label rule2 = new Label("• Contain only letters and numbers");
        rule2.setStyle("-fx-font-size: 10px; -fx-text-fill: gray;");

        Label rule3 = new Label("• Be between 2-50 characters");
        rule3.setStyle("-fx-font-size: 10px; -fx-text-fill: gray;");

        Label exampleLabel = new Label("Example: MyFirstProject");
        exampleLabel.setStyle("-fx-font-size: 10px; -fx-font-style: italic; -fx-text-fill: gray;");

        content.getChildren().addAll(
                new Label("Project Name:"),
                projectNameField,
                instructionLabel,
                rule1,
                rule2,
                rule3,
                exampleLabel
        );

        dialog.getDialogPane().setContent(content);

        Button createButton = (Button) dialog.getDialogPane().lookupButton(createButtonType);
        createButton.setDisable(true);

        projectNameField.textProperty().addListener((observable, oldValue, newValue) -> {
            boolean isValid = isValidProjectName(newValue);
            createButton.setDisable(!isValid);
            if (newValue.isEmpty()) projectNameField.setStyle("");
            else if (isValid) projectNameField.setStyle("-fx-border-color: green; -fx-border-width: 2px;");
            else projectNameField.setStyle("-fx-border-color: red; -fx-border-width: 2px;");
        });

        javafx.application.Platform.runLater(projectNameField::requestFocus);

        dialog.setResultConverter(dialogButton -> {
            if (dialogButton == createButtonType) return projectNameField.getText();
            return null;
        });

        Optional<String> result = dialog.showAndWait();
        result.ifPresent(this::createProject);
    }

    private boolean isValidProjectName(String name) {
        if (name == null || name.trim().isEmpty()) return false;
        if (!name.matches("^[A-Z][a-zA-Z0-9]*$")) return false;
        if (name.length() < 2 || name.length() > 50) return false;
        if (projectCreator.projectExists(name)) return false;
        return true;
    }

    private void createProject(String projectName) {
        try {
            projectCreator.createProject(projectName);
            refreshProjectList();
            for (ProjectInfo project : projectListView.getItems()) {
                if (project.getName().equals(projectName)) {
                    projectListView.getSelectionModel().select(project);
                    break;
                }
            }
        } catch (Exception e) {
            Alert errorAlert = new Alert(Alert.AlertType.ERROR);
            errorAlert.setTitle("Error");
            errorAlert.setHeaderText("Failed to create project");
            errorAlert.setContentText(e.getMessage());
            errorAlert.showAndWait();
        }
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\ui\ToolbarManager.java
=================================================================================

package com.botmaker.ui;

import com.botmaker.events.CoreApplicationEvents;
import com.botmaker.events.EventBus;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.control.Button;
import javafx.scene.control.Tooltip;
import javafx.scene.layout.HBox;

public class ToolbarManager {

    private final EventBus eventBus;

    // Controls
    private Button undoButton, redoButton;
    private Button runButton, debugButton, unifiedStopButton;
    private Button stepOverButton, continueButton;

    private enum AppState { IDLE, RUNNING, DEBUGGING }
    private AppState currentAppState = AppState.IDLE;

    public ToolbarManager(EventBus eventBus) {
        this.eventBus = eventBus;
        setupEventHandlers();
    }

    private void setupEventHandlers() {
        eventBus.subscribe(CoreApplicationEvents.ProgramStartedEvent.class, e -> setAppState(AppState.RUNNING), true);
        eventBus.subscribe(CoreApplicationEvents.ProgramStoppedEvent.class, e -> setAppState(AppState.IDLE), true);
        eventBus.subscribe(CoreApplicationEvents.DebugSessionStartedEvent.class, e -> setAppState(AppState.DEBUGGING), true);
        eventBus.subscribe(CoreApplicationEvents.DebugSessionFinishedEvent.class, e -> setAppState(AppState.IDLE), true);
        eventBus.subscribe(CoreApplicationEvents.DebugSessionPausedEvent.class, e -> updateDebugControls(true), true);
        eventBus.subscribe(CoreApplicationEvents.DebugSessionResumedEvent.class, e -> updateDebugControls(false), true);
        eventBus.subscribe(CoreApplicationEvents.HistoryStateChangedEvent.class, event -> {
            if (undoButton != null) undoButton.setDisable(!event.canUndo());
            if (redoButton != null) redoButton.setDisable(!event.canRedo());
        }, true);
    }

    /**
     * Creates the Left-side group: Undo, Redo, Compile
     */
    public HBox createEditGroup() {
        undoButton = new Button("↶");
        undoButton.setTooltip(new Tooltip("Undo (Ctrl+Z)"));
        undoButton.setDisable(true);
        undoButton.setOnAction(e -> eventBus.publish(new CoreApplicationEvents.UndoRequestedEvent()));

        redoButton = new Button("↷");
        redoButton.setTooltip(new Tooltip("Redo (Ctrl+Y)"));
        redoButton.setDisable(true);
        redoButton.setOnAction(e -> eventBus.publish(new CoreApplicationEvents.RedoRequestedEvent()));

        Button compileButton = new Button("⚙ Compile");
        compileButton.getStyleClass().add("toolbar-btn");
        compileButton.setOnAction(e -> eventBus.publish(new CoreApplicationEvents.CompilationRequestedEvent()));

        HBox group = new HBox(5, undoButton, redoButton, compileButton);
        group.setAlignment(Pos.CENTER_LEFT);
        group.setPadding(new Insets(0, 10, 0, 0));
        return group;
    }

    /**
     * Creates the Right-side group: Run, Debug, Stop, Step, Continue
     */
    public HBox createExecutionGroup() {
        runButton = new Button("▶ Run");
        runButton.getStyleClass().addAll("toolbar-btn", "btn-run");
        runButton.setOnAction(e -> eventBus.publish(new CoreApplicationEvents.ExecutionRequestedEvent()));

        debugButton = new Button("🐞 Debug");
        debugButton.getStyleClass().addAll("toolbar-btn", "btn-debug");
        debugButton.setOnAction(e -> eventBus.publish(new CoreApplicationEvents.DebugStartRequestedEvent()));

        unifiedStopButton = new Button("⏹ Stop");
        unifiedStopButton.getStyleClass().addAll("toolbar-btn", "btn-stop");
        unifiedStopButton.setDisable(true);
        unifiedStopButton.setOnAction(e -> {
            if (currentAppState == AppState.RUNNING) eventBus.publish(new CoreApplicationEvents.StopRunRequestedEvent());
            else if (currentAppState == AppState.DEBUGGING) eventBus.publish(new CoreApplicationEvents.DebugStopRequestedEvent());
        });

        stepOverButton = new Button("⤵ Step");
        stepOverButton.setDisable(true);
        stepOverButton.setOnAction(e -> eventBus.publish(new CoreApplicationEvents.DebugStepOverRequestedEvent()));

        continueButton = new Button("⏩ Cont");
        continueButton.setDisable(true);
        continueButton.setOnAction(e -> eventBus.publish(new CoreApplicationEvents.DebugContinueRequestedEvent()));

        HBox group = new HBox(5, runButton, debugButton, unifiedStopButton, stepOverButton, continueButton);
        group.setAlignment(Pos.CENTER_RIGHT);
        return group;
    }

    private void setAppState(AppState state) {
        this.currentAppState = state;
        updateToolbarState();
    }

    private void updateToolbarState() {
        boolean isBusy = (currentAppState != AppState.IDLE);
        runButton.setDisable(isBusy);
        debugButton.setDisable(isBusy);
        unifiedStopButton.setDisable(!isBusy);

        if (currentAppState == AppState.DEBUGGING) {
            unifiedStopButton.setStyle("-fx-background-color: #E74C3C; -fx-text-fill: white;");
        } else if (currentAppState == AppState.RUNNING) {
            unifiedStopButton.setStyle("-fx-background-color: #E74C3C; -fx-text-fill: white;");
            stepOverButton.setDisable(true);
            continueButton.setDisable(true);
        } else {
            unifiedStopButton.setStyle("");
            stepOverButton.setDisable(true);
            continueButton.setDisable(true);
        }
    }

    private void updateDebugControls(boolean isPaused) {
        if (currentAppState == AppState.DEBUGGING) {
            stepOverButton.setDisable(!isPaused);
            continueButton.setDisable(!isPaused);
        }
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\ui\UIManager.java
=================================================================================

package com.botmaker.ui;

import com.botmaker.config.ApplicationConfig;
import com.botmaker.events.CoreApplicationEvents;
import com.botmaker.events.EventBus;
import com.botmaker.lsp.CompletionContext;
import com.botmaker.services.CodeEditorService;
import com.botmaker.state.ApplicationState;
import com.botmaker.validation.DiagnosticsManager;
import com.botmaker.validation.ErrorTranslator;
import javafx.geometry.Insets;
import javafx.geometry.Orientation;
import javafx.geometry.Pos;
import javafx.scene.Node;
import javafx.scene.Scene;
import javafx.scene.control.*;
import javafx.scene.layout.*;
import javafx.stage.Stage;
import org.eclipse.lsp4j.Diagnostic;
import org.eclipse.lsp4j.DiagnosticSeverity;

import java.util.List;
import java.util.function.Consumer;

public class UIManager {

    private final EventBus eventBus;
    private final CodeEditorService codeEditorService;
    private final DiagnosticsManager diagnosticsManager;
    private final Stage primaryStage;

    private final PaletteManager paletteManager;
    private final ToolbarManager toolbarManager;
    private final EventLogManager eventLogManager;
    private final MenuBarManager menuBarManager;
    private final FileExplorerManager fileExplorerManager;

    private VBox blocksContainer;
    private Label statusLabel;
    private TextArea outputArea;
    private ListView<Diagnostic> errorListView;
    private TabPane bottomTabPane;
    private Consumer<Void> onSelectProject;

    public UIManager(BlockDragAndDropManager dragAndDropManager,
                     EventBus eventBus,
                     CodeEditorService codeEditorService,
                     DiagnosticsManager diagnosticsManager,
                     Stage primaryStage,
                     ApplicationConfig config,
                     ApplicationState state) {
        this.eventBus = eventBus;
        this.codeEditorService = codeEditorService;
        this.diagnosticsManager = diagnosticsManager;
        this.primaryStage = primaryStage;

        this.paletteManager = new PaletteManager(dragAndDropManager);
        this.toolbarManager = new ToolbarManager(eventBus);
        this.eventLogManager = new EventLogManager(eventBus);
        this.menuBarManager = new MenuBarManager(primaryStage);
        this.menuBarManager.setEventBus(eventBus);
        this.fileExplorerManager = new FileExplorerManager(config, codeEditorService, state);

        setupEventHandlers();
    }

    private void setupEventHandlers() {
        eventBus.subscribe(CoreApplicationEvents.UIBlocksUpdatedEvent.class, this::handleBlocksUpdate, true);
        eventBus.subscribe(CoreApplicationEvents.OutputAppendedEvent.class, event -> {
            if (outputArea.getText().length() > 10_000) {
                String current = outputArea.getText();
                outputArea.setText("[...Trimmed...]\n" + current.substring(current.length() - 5000) + event.getText());
                outputArea.positionCaret(outputArea.getLength());
            } else {
                outputArea.appendText(event.getText());
            }
        }, true);
        eventBus.subscribe(CoreApplicationEvents.OutputClearedEvent.class, event -> outputArea.clear(), true);
        eventBus.subscribe(CoreApplicationEvents.OutputSetEvent.class, event -> outputArea.setText(event.getText()), true);
        eventBus.subscribe(CoreApplicationEvents.StatusMessageEvent.class, event -> statusLabel.setText(event.getMessage()), true);
        eventBus.subscribe(CoreApplicationEvents.DiagnosticsUpdatedEvent.class, event -> {
            diagnosticsManager.processDiagnostics(event.getDiagnostics());
            updateErrors(diagnosticsManager.getDiagnostics());
            statusLabel.setText(diagnosticsManager.getErrorSummary());
        }, true);
        eventBus.subscribe(CoreApplicationEvents.ProgramStartedEvent.class, e -> selectBottomTab(0), true);
        eventBus.subscribe(CoreApplicationEvents.DebugSessionStartedEvent.class, e -> selectBottomTab(0), true);
    }

    private void handleBlocksUpdate(CoreApplicationEvents.UIBlocksUpdatedEvent event) {
        blocksContainer.getChildren().clear();
        if (event.getRootBlock() != null) {
            CompletionContext context = codeEditorService.createCompletionContext();
            Node rootNode = event.getRootBlock().getUINode(context);
            rootNode.addEventHandler(BlockEvent.BreakpointToggleEvent.TOGGLE_BREAKPOINT, e ->
                    eventBus.publish(new CoreApplicationEvents.BreakpointToggledEvent(e.getBlock(), e.isEnabled())));
            blocksContainer.getChildren().add(rootNode);
        }
    }

    public Scene createScene() {
        menuBarManager.setOnSelectProject(v -> { if (onSelectProject != null) onSelectProject.accept(null); });

        // --- 1. Top Bar Construction ---

        // Left
        HBox editControls = toolbarManager.createEditGroup();
        Separator leftSep = new Separator(Orientation.VERTICAL);
        leftSep.setPadding(new Insets(0, 5, 0, 5));
        HBox leftContainer = new HBox(editControls, leftSep);
        leftContainer.setAlignment(Pos.CENTER_LEFT);

        // Center: Palette
        HBox paletteControls = paletteManager.createHorizontalPalette();

        ScrollPane paletteScroll = new ScrollPane(paletteControls);
        paletteScroll.setVbarPolicy(ScrollPane.ScrollBarPolicy.NEVER);
        paletteScroll.setHbarPolicy(ScrollPane.ScrollBarPolicy.NEVER); // Hide Horizontal Bar too, let it shrink

        // Ensure content fills the scroll pane area
        paletteScroll.setFitToWidth(true);
        paletteScroll.setFitToHeight(true);

        paletteScroll.setStyle("-fx-background-color: transparent; -fx-padding: 0;");
        paletteScroll.getStyleClass().add("edge-to-edge");

        // Right
        HBox executionControls = toolbarManager.createExecutionGroup();
        Separator rightSep = new Separator(Orientation.VERTICAL);
        rightSep.setPadding(new Insets(0, 5, 0, 5));
        HBox rightContainer = new HBox(rightSep, executionControls);
        rightContainer.setAlignment(Pos.CENTER_RIGHT);

        BorderPane topBar = new BorderPane();
        topBar.setPadding(new Insets(6)); // Comfortable padding around the whole bar
        topBar.setLeft(leftContainer);
        topBar.setCenter(paletteScroll);
        topBar.setRight(rightContainer);
        topBar.getStyleClass().add("main-toolbar");

        // FIXED HEIGHT CONSTRAINTS
        // This stops the "Expand as much as I want" issue.
        // 45px content + 12px padding = ~57px total height
        topBar.setMinHeight(50);
        topBar.setPrefHeight(50);
        topBar.setMaxHeight(50);

        topBar.setStyle("-fx-border-color: #dcdcdc; -fx-border-width: 0 0 1 0; -fx-background-color: #f4f4f4;");

        // --- 2. Left Panel: File Explorer ---
        VBox fileExplorer = fileExplorerManager.createView();
        fileExplorer.setMinWidth(150);
        fileExplorer.setMaxWidth(400);

        // --- 3. Center: Code Canvas ---
        blocksContainer = new VBox(10);
        blocksContainer.getStyleClass().add("blocks-canvas");
        blocksContainer.setPadding(new Insets(20));

        ScrollPane canvasScroll = new ScrollPane(blocksContainer);
        canvasScroll.setFitToWidth(true);
        canvasScroll.setFitToHeight(true);
        canvasScroll.getStyleClass().add("code-scroll-pane");

        // --- 4. Bottom Panel: Terminal/Errors ---
        outputArea = new TextArea();
        outputArea.setEditable(false);
        outputArea.getStyleClass().add("console-area");
        addContextMenu(outputArea);

        errorListView = new ListView<>();
        configureErrorList(errorListView);
        addContextMenu(errorListView);

        bottomTabPane = new TabPane();
        Tab terminalTab = new Tab("Terminal", outputArea); terminalTab.setClosable(false);
        Tab errorsTab = new Tab("Errors", errorListView); errorsTab.setClosable(false);
        Tab eventsTab = new Tab("Event Log", eventLogManager.getView()); eventsTab.setClosable(false);
        bottomTabPane.getTabs().addAll(terminalTab, errorsTab, eventsTab);

        // --- 5. Layout Assembly ---

        SplitPane verticalSplit = new SplitPane();
        verticalSplit.setOrientation(Orientation.VERTICAL);
        verticalSplit.getItems().addAll(canvasScroll, bottomTabPane);
        verticalSplit.setDividerPositions(0.82);

        SplitPane mainSplit = new SplitPane();
        mainSplit.setOrientation(Orientation.HORIZONTAL);
        mainSplit.getItems().addAll(fileExplorer, verticalSplit);
        mainSplit.setDividerPositions(0.25);

        statusLabel = new Label("Ready");
        statusLabel.setId("status-label");
        statusLabel.setPadding(new Insets(2, 5, 2, 5));

        VBox root = new VBox(menuBarManager.getMenuBar(), topBar, mainSplit, statusLabel);
        VBox.setVgrow(mainSplit, Priority.ALWAYS);
        root.getStyleClass().add("light-theme");

        primaryStage.setOnHidden(e -> eventLogManager.shutdown());

        Scene scene = new Scene(root, 1000, 700);
        return scene;
    }

    private void configureErrorList(ListView<Diagnostic> lv) {
        lv.setPlaceholder(new Label("No errors."));
        lv.setCellFactory(list -> new ListCell<>() {
            @Override
            protected void updateItem(Diagnostic diagnostic, boolean empty) {
                super.updateItem(diagnostic, empty);
                getStyleClass().removeAll("error-cell", "warning-cell");
                if (empty || diagnostic == null) {
                    setText(null);
                    setOnMouseClicked(null);
                } else {
                    String message = ErrorTranslator.getShortSummary(diagnostic);
                    int line = diagnostic.getRange().getStart().getLine() + 1;
                    setText(String.format("Line %d: %s", line, message));
                    if (diagnostic.getSeverity() == DiagnosticSeverity.Error) getStyleClass().add("error-cell");
                    else if (diagnostic.getSeverity() == DiagnosticSeverity.Warning) getStyleClass().add("warning-cell");
                    setOnMouseClicked(event -> {
                        if (event.getClickCount() >= 1) {
                            diagnosticsManager.findBlockForDiagnostic(diagnostic).ifPresent(block -> {
                                Node uiNode = block.getUINode();
                                if (uiNode != null) uiNode.requestFocus();
                            });
                        }
                    });
                }
            }
        });
    }

    private void addContextMenu(Control control) {
        ContextMenu cm = new ContextMenu();
        if (control instanceof TextArea) {
            TextArea ta = (TextArea) control;
            MenuItem copy = new MenuItem("Copy");
            copy.setOnAction(e -> ta.copy());
            MenuItem clear = new MenuItem("Clear");
            clear.setOnAction(e -> ta.clear());
            cm.getItems().addAll(copy, new SeparatorMenuItem(), clear);
            ta.setContextMenu(cm);
        } else if (control instanceof ListView) {
            ListView<?> lv = (ListView<?>) control;
            MenuItem copy = new MenuItem("Copy Selection");
            copy.setOnAction(e -> {
                Object selected = lv.getSelectionModel().getSelectedItem();
                if (selected != null) {
                    javafx.scene.input.ClipboardContent content = new javafx.scene.input.ClipboardContent();
                    content.putString(selected.toString());
                    javafx.scene.input.Clipboard.getSystemClipboard().setContent(content);
                }
            });
            cm.getItems().add(copy);
            lv.setContextMenu(cm);
        }
    }

    private void updateErrors(List<Diagnostic> diagnostics) {
        if (diagnostics == null) errorListView.getItems().clear();
        else errorListView.getItems().setAll(diagnostics);
        if (diagnostics != null && !diagnostics.isEmpty()) selectBottomTab(1);
    }

    private void selectBottomTab(int index) {
        if (bottomTabPane != null && index < bottomTabPane.getTabs().size()) {
            bottomTabPane.getSelectionModel().select(index);
        }
    }

    public void setOnSelectProject(Consumer<Void> callback) { this.onSelectProject = callback; }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\ui\components\BlockUIComponents.java
=================================================================================

package com.botmaker.ui.components;

import com.botmaker.ui.AddableExpression;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.geometry.Pos;
import javafx.scene.Node;
import javafx.scene.control.*;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Pane;
import javafx.scene.layout.Priority;

import java.util.function.Consumer;

public class BlockUIComponents {

    public static Button createDeleteButton(Runnable onDelete) {
        Button btn = new Button("X");
        btn.setOnAction(e -> onDelete.run());
        // Optional: Add a specific style class if you want to target it specifically later
        // btn.getStyleClass().add("delete-button");
        return btn;
    }

    public static Button createAddButton(EventHandler<ActionEvent> handler) {
        Button btn = new Button("+");
        btn.getStyleClass().add("expression-add-button");
        btn.setOnAction(handler);
        return btn;
    }

    public static Button createChangeButton(EventHandler<ActionEvent> handler) {
        Button btn = new Button("↻");
        btn.getStyleClass().add("icon-button");
        btn.setOnAction(handler);
        return btn;
    }

    public static Label createKeywordLabel(String text) {
        Label label = new Label(text);
        label.getStyleClass().add("keyword-label");
        return label;
    }

    public static Label createTypeLabel(String type) {
        Label label = new Label(type);
        label.getStyleClass().add("type-label");
        return label;
    }

    public static Label createOperatorLabel(String operator) {
        Label label = new Label(operator);
        label.getStyleClass().add("operator-label");
        return label;
    }

    public static Pane createSpacer() {
        Pane spacer = new Pane();
        HBox.setHgrow(spacer, Priority.ALWAYS);
        return spacer;
    }

    /**
     * Creates a standard header row: [Content Nodes] + [Spacer] + [Delete Button]
     */
    public static HBox createHeaderRow(Runnable onDelete, Node... content) {
        HBox container = new HBox(5);
        container.setAlignment(Pos.CENTER_LEFT);

        if (content != null) {
            container.getChildren().addAll(content);
        }

        container.getChildren().addAll(createSpacer(), createDeleteButton(onDelete));
        return container;
    }

    public static ContextMenu createExpressionTypeMenu(String targetType, Consumer<AddableExpression> onSelect) {
        ContextMenu menu = new ContextMenu();
        menu.setStyle("-fx-control-inner-background: white;");

        for (AddableExpression type : AddableExpression.getForType(targetType)) {
            MenuItem menuItem = new MenuItem(type.getDisplayName());
            menuItem.setStyle("-fx-text-fill: black;");
            menuItem.setOnAction(e -> onSelect.accept(type));
            menu.getItems().add(menuItem);
        }
        return menu;
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\ui\components\LayoutComponents.java
=================================================================================

package com.botmaker.ui.components;

import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.Node;
import javafx.scene.layout.HBox;
import javafx.scene.layout.VBox;

public class LayoutComponents {

    private static final Insets STANDARD_INDENTATION = new Insets(5, 0, 0, 20);

    /**
     * Creates a VBox representing a nested body of code (e.g., inside an If or Loop).
     * Applies standard indentation and specific style classes.
     */
    public static VBox createIndentedBody(Node content, String... styleClasses) {
        VBox container = new VBox();
        if (styleClasses != null) {
            container.getStyleClass().addAll(styleClasses);
        }
        container.setPadding(STANDARD_INDENTATION);
        if (content != null) {
            container.getChildren().add(content);
        }
        return container;
    }

    /**
     * Creates a horizontal row for building "sentences" (e.g., "for each [var] in [list]").
     */
    public static HBox createSentenceRow(Node... nodes) {
        HBox row = new HBox(5);
        row.setAlignment(Pos.CENTER_LEFT);
        if (nodes != null) {
            row.getChildren().addAll(nodes);
        }
        return row;
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\ui\components\PlaceholderComponents.java
=================================================================================

package com.botmaker.ui.components;

import com.botmaker.core.ExpressionBlock;
import com.botmaker.lsp.CompletionContext;
import javafx.scene.Node;

import java.util.function.Supplier;

public class PlaceholderComponents {

    /**
     * Returns the UI node for an expression if it exists, otherwise creates a Drop Zone.
     *
     * @param expression The expression block (can be null)
     * @param context The completion context needed to render the block
     * @param dropZoneFactory A supplier to create the drop zone (usually provided by AbstractCodeBlock)
     * @return The Node to display
     */
    public static Node createExpressionOrDropZone(
            ExpressionBlock expression,
            CompletionContext context,
            Supplier<Node> dropZoneFactory) {

        if (expression != null) {
            return expression.getUINode(context);
        } else {
            return dropZoneFactory.get();
        }
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\ui\components\SelectorComponents.java
=================================================================================

package com.botmaker.ui.components;

import javafx.scene.control.ComboBox;

import java.util.function.Consumer;

public class SelectorComponents {

    public static ComboBox<String> createOperatorSelector(String[] names, String[] symbols, String currentSymbol, Consumer<String> onSymbolChange) {
        ComboBox<String> selector = new ComboBox<>();
        selector.getItems().addAll(names);
        selector.getStyleClass().add("operator-selector"); // or math-operator-selector based on context
        selector.setEditable(false);

        // Find display name for current symbol
        String currentName = names[0];
        for (int i = 0; i < symbols.length; i++) {
            if (symbols[i].equals(currentSymbol)) {
                currentName = names[i];
                break;
            }
        }
        selector.setValue(currentName);

        selector.setOnAction(e -> {
            String selectedName = selector.getValue();
            String newSymbol = null;
            for (int i = 0; i < names.length; i++) {
                if (names[i].equals(selectedName)) {
                    newSymbol = symbols[i];
                    break;
                }
            }
            if (newSymbol != null && !newSymbol.equals(currentSymbol)) {
                onSymbolChange.accept(newSymbol);
            }
        });

        return selector;
    }

    public static ComboBox<String> createSimpleSelector(String[] options, String current, Consumer<String> onChange) {
        ComboBox<String> selector = new ComboBox<>();
        selector.getItems().addAll(options);
        selector.setValue(current);
        selector.setOnAction(e -> {
            if (!selector.getValue().equals(current)) {
                onChange.accept(selector.getValue());
            }
        });
        return selector;
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\ui\components\StyleComponents.java
=================================================================================

package com.botmaker.ui.components;

import javafx.geometry.Pos;
import javafx.scene.Node;
import javafx.scene.layout.HBox;

public class StyleComponents {

    /**
     * Creates a "Pill" shaped container (used for parameters and method calls).
     */
    public static HBox createPillContainer(String backgroundColor, Node... content) {
        HBox container = new HBox(4);
        container.setAlignment(Pos.CENTER_LEFT);
        // We use inline styles here because these often have dynamic colors,
        // but ideally this should map to CSS classes.
        container.setStyle(
                "-fx-background-color: " + backgroundColor + ";" +
                        "-fx-background-radius: 12;" +
                        "-fx-padding: 3 8 3 8;"
        );
        if (content != null) {
            container.getChildren().addAll(content);
        }
        return container;
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\ui\components\TextFieldComponents.java
=================================================================================

package com.botmaker.ui.components;

import javafx.scene.Cursor;
import javafx.scene.control.TextField;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Priority;

import java.util.function.Consumer;

public class TextFieldComponents {

    public static TextField createCommentField(String initialText, String prompt, Consumer<String> onCommit) {
        TextField field = new TextField(initialText != null ? initialText : "");
        field.setPromptText(prompt);
        field.getStyleClass().add("comment-text-field");
        HBox.setHgrow(field, Priority.ALWAYS);

        // Save on Focus Lost or Enter
        field.focusedProperty().addListener((obs, oldVal, newVal) -> {
            if (!newVal) onCommit.accept(field.getText());
        });
        field.setOnAction(e -> onCommit.accept(field.getText()));

        return field;
    }

    public static TextField createVariableNameField(String initialText, Consumer<String> onCommit) {
        TextField nameField = new TextField(initialText);
        nameField.getStyleClass().add("variable-name-field");
        nameField.setPrefWidth(100);

        nameField.focusedProperty().addListener((obs, oldVal, newVal) -> {
            if (!newVal) onCommit.accept(nameField.getText());
        });

        return nameField;
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\util\BlockLookupHelper.java
=================================================================================

package com.botmaker.util;

import com.botmaker.core.BodyBlock;
import com.botmaker.core.BlockWithChildren;
import com.botmaker.core.CodeBlock;
import com.botmaker.core.StatementBlock;

import java.util.Map;

/**
 * Helper class for looking up blocks in the block tree.
 */
public class BlockLookupHelper {

    /**
     * Finds a block by its ID in the node-to-block map.
     * @param blockId The ID of the block to find
     * @param nodeToBlockMap The map of AST nodes to CodeBlocks
     * @return The StatementBlock if found, null otherwise
     */
    public static StatementBlock findBlockById(String blockId, Map<?, CodeBlock> nodeToBlockMap) {
        if (blockId == null || nodeToBlockMap == null) {
            return null;
        }

        // Search through all blocks in the map
        for (CodeBlock block : nodeToBlockMap.values()) {
            if (block.getId().equals(blockId) && block instanceof StatementBlock) {
                return (StatementBlock) block;
            }
        }

        return null;
    }

    /**
     * Finds the BodyBlock that contains the given statement block.
     * @param targetBlock The statement block to find the parent for
     * @param nodeToBlockMap The map of AST nodes to CodeBlocks
     * @return The BodyBlock containing the statement, null if not found
     */
    public static BodyBlock findParentBody(StatementBlock targetBlock, Map<?, CodeBlock> nodeToBlockMap) {
        if (targetBlock == null || nodeToBlockMap == null) {
            return null;
        }

        // Search through all blocks to find which BodyBlock contains the target
        for (CodeBlock block : nodeToBlockMap.values()) {
            if (block instanceof BodyBlock) {
                BodyBlock bodyBlock = (BodyBlock) block;
                if (bodyBlock.getStatements().contains(targetBlock)) {
                    return bodyBlock;
                }
            }

            // Also check nested structures
            if (block instanceof BlockWithChildren) {
                BodyBlock found = findParentBodyInChildren(targetBlock, (BlockWithChildren) block);
                if (found != null) {
                    return found;
                }
            }
        }

        return null;
    }

    /**
     * Recursively searches for the parent body in a block's children.
     */
    private static BodyBlock findParentBodyInChildren(StatementBlock targetBlock, BlockWithChildren parent) {
        for (CodeBlock child : parent.getChildren()) {
            if (child instanceof BodyBlock) {
                BodyBlock bodyBlock = (BodyBlock) child;
                if (bodyBlock.getStatements().contains(targetBlock)) {
                    return bodyBlock;
                }
            }

            if (child instanceof BlockWithChildren) {
                BodyBlock found = findParentBodyInChildren(targetBlock, (BlockWithChildren) child);
                if (found != null) {
                    return found;
                }
            }
        }

        return null;
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\util\DefaultNames.java
=================================================================================

package com.botmaker.util;

/**
 * Provides sensible default names for auto-generated elements
 */
public class DefaultNames {

    // Variable names by type
    public static final String DEFAULT_INT = "number";
    public static final String DEFAULT_DOUBLE = "decimal";
    public static final String DEFAULT_BOOLEAN = "flag";
    public static final String DEFAULT_STRING = "text";
    public static final String DEFAULT_VARIABLE = "variable";

    // Method to get default name by type
    public static String forType(String typeName) {
        if (typeName == null) return DEFAULT_VARIABLE;

        switch (typeName.toLowerCase()) {
            case "int":
            case "long":
            case "short":
            case "byte":
                return DEFAULT_INT;
            case "double":
            case "float":
                return DEFAULT_DOUBLE;
            case "boolean":
                return DEFAULT_BOOLEAN;
            case "string":
                return DEFAULT_STRING;
            default:
                return DEFAULT_VARIABLE;
        }
    }

    private DefaultNames() {} // Prevent instantiation
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\util\TypeManager.java
=================================================================================

package com.botmaker.util;

import org.eclipse.jdt.core.dom.*;

import java.util.List;
import java.util.Set;

public class TypeManager {

    // --- Constants for UI Categories ---
    public static final String UI_TYPE_ANY = "any";
    public static final String UI_TYPE_NUMBER = "number";
    public static final String UI_TYPE_BOOLEAN = "boolean";
    public static final String UI_TYPE_STRING = "String";
    public static final String UI_TYPE_TEXT = "Text";
    public static final String UI_TYPE_LIST = "list";
    // NEW: Special type for Switch statements
    public static final String UI_TYPE_SWITCH_COMPATIBLE = "switch_compatible";

    // --- Mapping Tables ---

    private static final List<String> FUNDAMENTAL_TYPES = List.of(
            "int", "double", "boolean", "String", "long", "float", "char"
    );

    private static final Set<String> HIDDEN_VARIABLES = Set.of(
            "args", "this", "super", "scanner", "class"
    );

    private static final Set<String> NUMBER_TYPES = Set.of(
            "int", "double", "float", "long", "short", "byte",
            "java.lang.Integer", "java.lang.Double", "java.lang.Float",
            "java.lang.Long", "java.lang.Short", "java.lang.Byte",
            "Integer", "Double", "Float", "Long", "Short", "Byte"
    );

    private static final Set<String> BOOLEAN_TYPES = Set.of(
            "boolean", "java.lang.Boolean", "Boolean"
    );

    private static final Set<String> STRING_TYPES = Set.of(
            "String", "java.lang.String", "char", "java.lang.Character", "Character"
    );

    // Types explicitly FORBIDDEN in a switch statement (pre-pattern matching)
    private static final Set<String> SWITCH_FORBIDDEN_TYPES = Set.of(
            "long", "java.lang.Long", "Long",
            "float", "java.lang.Float", "Float",
            "double", "java.lang.Double", "Double",
            "boolean", "java.lang.Boolean", "Boolean"
    );

    public static List<String> getFundamentalTypeNames() {
        return FUNDAMENTAL_TYPES;
    }

    public static boolean isUserVariable(String variableName) {
        if (variableName == null || variableName.isEmpty()) return false;
        String cleanName = variableName.split(" ")[0].split(":")[0].trim();
        if (HIDDEN_VARIABLES.contains(cleanName)) return false;
        if (cleanName.startsWith("_")) return false;
        return true;
    }

    public static String determineUiType(String typeName) {
        if (typeName == null || typeName.isBlank()) return UI_TYPE_ANY;
        String clean = typeName.trim();

        if (isArrayList(clean)) return UI_TYPE_LIST;
        if (clean.endsWith("[]")) return UI_TYPE_LIST;

        if (NUMBER_TYPES.contains(clean)) return UI_TYPE_NUMBER;
        if (BOOLEAN_TYPES.contains(clean)) return UI_TYPE_BOOLEAN;
        if (STRING_TYPES.contains(clean)) return UI_TYPE_STRING;

        return UI_TYPE_ANY;
    }

    // --- Type Compatibility (ITypeBinding) ---

    public static boolean isCompatible(ITypeBinding binding, String targetUiType) {
        if (targetUiType == null || targetUiType.equals(UI_TYPE_ANY)) return true;
        if (binding == null) return true;

        String qualifiedName = binding.getQualifiedName();
        String simpleName = binding.getName();

        // NEW: Handle Switch Compatibility
        if (targetUiType.equals(UI_TYPE_SWITCH_COMPATIBLE)) {
            if (binding.isArray()) return false;
            // Blacklist check is safer for Enums (since we don't have a list of all enums)
            return !SWITCH_FORBIDDEN_TYPES.contains(simpleName) &&
                    !SWITCH_FORBIDDEN_TYPES.contains(qualifiedName);
        }

        if (binding.isArray()) {
            return targetUiType.equals(UI_TYPE_LIST) || targetUiType.endsWith("[]");
        }

        switch (targetUiType) {
            case UI_TYPE_NUMBER:
                return NUMBER_TYPES.contains(simpleName) || NUMBER_TYPES.contains(qualifiedName);
            case UI_TYPE_BOOLEAN:
                return BOOLEAN_TYPES.contains(simpleName) || BOOLEAN_TYPES.contains(qualifiedName);
            case UI_TYPE_STRING:
            case UI_TYPE_TEXT:
                return STRING_TYPES.contains(simpleName) || STRING_TYPES.contains(qualifiedName);
            default:
                return targetUiType.equals(simpleName) || targetUiType.equals(qualifiedName);
        }
    }

    // --- Type Compatibility (String) ---

    public static boolean isCompatible(String typeName, String targetUiType) {
        if (targetUiType == null || targetUiType.equals(UI_TYPE_ANY)) return true;
        if (typeName == null || typeName.isBlank()) return true;

        String cleanType = typeName.trim();

        // NEW: Handle Switch Compatibility
        if (targetUiType.equals(UI_TYPE_SWITCH_COMPATIBLE)) {
            if (cleanType.endsWith("[]") || cleanType.contains("ArrayList")) return false;
            return !SWITCH_FORBIDDEN_TYPES.contains(cleanType);
        }

        if (cleanType.endsWith("[]")) {
            return targetUiType.equals(UI_TYPE_LIST) || targetUiType.endsWith("[]");
        }

        switch (targetUiType) {
            case UI_TYPE_NUMBER:
                return NUMBER_TYPES.contains(cleanType);
            case UI_TYPE_BOOLEAN:
                return BOOLEAN_TYPES.contains(cleanType);
            case UI_TYPE_STRING:
            case UI_TYPE_TEXT:
                return STRING_TYPES.contains(cleanType) || cleanType.endsWith("String");
            default:
                return cleanType.equals(targetUiType);
        }
    }

    public static String getFriendlyTypeName(ITypeBinding typeBinding) {
        if (typeBinding == null) return "unknown";
        if (typeBinding.isArray()) return "list";
        String name = typeBinding.getName();
        if (NUMBER_TYPES.contains(name)) return "number";
        if (STRING_TYPES.contains(name)) return "text";
        if (BOOLEAN_TYPES.contains(name)) return "bool";
        return name;
    }

    // ... [Rest of the file (toWrapperType, isPrimitive, etc.) remains unchanged] ...
    public static String toWrapperType(String typeName) {
        if (typeName == null) return typeName;
        switch (typeName) {
            case "int": return "Integer";
            case "double": return "Double";
            case "boolean": return "Boolean";
            case "char": return "Character";
            case "long": return "Long";
            case "float": return "Float";
            case "short": return "Short";
            case "byte": return "Byte";
            default: return typeName;
        }
    }

    public static boolean isPrimitive(String typeName) {
        if (typeName == null) return false;
        return typeName.equals("int") || typeName.equals("double") || typeName.equals("boolean") ||
                typeName.equals("char") || typeName.equals("long") || typeName.equals("float") ||
                typeName.equals("short") || typeName.equals("byte");
    }

    public static String toPrimitiveType(String typeName) {
        if (typeName == null) return typeName;
        switch (typeName) {
            case "Integer": return "int";
            case "Double": return "double";
            case "Boolean": return "boolean";
            case "Character": return "char";
            case "Long": return "long";
            case "Float": return "float";
            case "Short": return "short";
            case "Byte": return "byte";
            default: return typeName;
        }
    }

    public static int getListNestingLevel(String typeName) {
        if (typeName == null) return 0;
        int level = 0;
        String temp = typeName;
        while (temp.startsWith("ArrayList<") || temp.startsWith("List<")) {
            level++;
            int start = temp.indexOf("<") + 1;
            int end = temp.lastIndexOf(">");
            if (start < end) {
                temp = temp.substring(start, end);
            } else {
                break;
            }
        }
        return level;
    }

    public static String getLeafType(String typeName) {
        if (typeName == null) return "Object";
        String temp = typeName;
        while (temp.startsWith("ArrayList<") || temp.startsWith("List<")) {
            int start = temp.indexOf("<") + 1;
            int end = temp.lastIndexOf(">");
            if (start < end) {
                temp = temp.substring(start, end);
            } else {
                break;
            }
        }
        return temp;
    }

    public static boolean isArrayList(String typeName) {
        if (typeName == null) return false;
        return typeName.startsWith("ArrayList<") || typeName.equals("ArrayList");
    }

    public static Type createTypeNode(AST ast, String typeName) {
        if (typeName.startsWith("ArrayList<") && typeName.endsWith(">")) {
            int start = typeName.indexOf("<") + 1;
            int end = typeName.lastIndexOf(">");
            String elementTypeName = typeName.substring(start, end);
            ParameterizedType paramType = ast.newParameterizedType(ast.newSimpleType(ast.newName("ArrayList")));
            Type elementType = createTypeNode(ast, elementTypeName);
            paramType.typeArguments().add(elementType);
            return paramType;
        }
        int dimensions = 0;
        String baseName = typeName;
        while (baseName.endsWith("[]")) {
            dimensions++;
            baseName = baseName.substring(0, baseName.length() - 2);
        }
        Type baseType;
        switch (baseName) {
            case "int": baseType = ast.newPrimitiveType(PrimitiveType.INT); break;
            case "double": baseType = ast.newPrimitiveType(PrimitiveType.DOUBLE); break;
            case "boolean": baseType = ast.newPrimitiveType(PrimitiveType.BOOLEAN); break;
            case "char": baseType = ast.newPrimitiveType(PrimitiveType.CHAR); break;
            case "long": baseType = ast.newPrimitiveType(PrimitiveType.LONG); break;
            case "float": baseType = ast.newPrimitiveType(PrimitiveType.FLOAT); break;
            case "short": baseType = ast.newPrimitiveType(PrimitiveType.SHORT); break;
            case "byte": baseType = ast.newPrimitiveType(PrimitiveType.BYTE); break;
            default: baseType = ast.newSimpleType(ast.newName(baseName)); break;
        }
        if (dimensions > 0) {
            return ast.newArrayType(baseType, dimensions);
        } else {
            return baseType;
        }
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\validation\DiagnosticsManager.java
=================================================================================

package com.botmaker.validation;

import com.botmaker.core.CodeBlock;
import javafx.application.Platform;
import org.eclipse.jdt.core.dom.ASTNode;
import org.eclipse.lsp4j.Diagnostic;
import org.eclipse.lsp4j.DiagnosticSeverity;
import org.eclipse.lsp4j.PublishDiagnosticsParams;

import java.util.*;

public class DiagnosticsManager {

    private Map<ASTNode, CodeBlock> nodeToBlockMap;
    private String sourceCode;
    private final Set<CodeBlock> blocksWithErrors = new HashSet<>();
    private List<Diagnostic> lastDiagnostics = new ArrayList<>();

    // NEW: Track line numbers to blocks for fallback matching
    private Map<Integer, Set<CodeBlock>> lineToBlocksMap = new HashMap<>();

    public List<Diagnostic> getDiagnostics() {
        return lastDiagnostics;
    }

    public boolean hasErrors() {
        if (lastDiagnostics == null || lastDiagnostics.isEmpty()) {
            return false;
        }
        return lastDiagnostics.stream().anyMatch(d -> {
            DiagnosticSeverity severity = d.getSeverity();
            return severity == null || severity == DiagnosticSeverity.Error;
        });
    }

    public void updateSource(Map<ASTNode, CodeBlock> nodeToBlockMap, String sourceCode) {
        this.nodeToBlockMap = nodeToBlockMap;
        this.sourceCode = sourceCode;

        // Build line-to-block mapping for fallback
        buildLineToBlockMap();
    }

    /**
     * Builds a map from line numbers to blocks for fallback matching
     * when AST node matching fails.
     */
    private void buildLineToBlockMap() {
        lineToBlocksMap.clear();

        if (nodeToBlockMap == null || sourceCode == null) {
            return;
        }

        for (Map.Entry<ASTNode, CodeBlock> entry : nodeToBlockMap.entrySet()) {
            ASTNode node = entry.getKey();
            CodeBlock block = entry.getValue();

            // Calculate which lines this node spans
            int startLine = getLineNumber(node.getStartPosition());
            int endLine = getLineNumber(node.getStartPosition() + node.getLength());

            // Add block to all lines it spans
            for (int line = startLine; line <= endLine; line++) {
                lineToBlocksMap.computeIfAbsent(line, k -> new HashSet<>()).add(block);
            }
        }
    }

    public void processDiagnostics(List<Diagnostic> diagnostics) {
        this.lastDiagnostics = diagnostics;

        // Clear previous errors
        for (CodeBlock block : blocksWithErrors) {
            block.clearError();
        }
        blocksWithErrors.clear();

        if (nodeToBlockMap == null) return;

        // Process new diagnostics
        for (Diagnostic diagnostic : diagnostics) {
            // Only show errors, not warnings (unless you want warnings too)
            if (diagnostic.getSeverity() != DiagnosticSeverity.Error) {
                continue;
            }

            Optional<CodeBlock> blockOpt = findBlockForDiagnostic(diagnostic);

            if (blockOpt.isPresent()) {
                CodeBlock block = blockOpt.get();

                // Use translated error message
                String userFriendlyMessage = ErrorTranslator.getShortSummary(diagnostic);
                String suggestion = ErrorTranslator.getSuggestion(diagnostic);

                block.setError(userFriendlyMessage + "\n" + suggestion);
                blocksWithErrors.add(block);
            } else {
                // Log unmapped diagnostics for debugging
                System.err.println("Warning: Could not map diagnostic to block: " +
                        diagnostic.getMessage() + " at line " +
                        (diagnostic.getRange().getStart().getLine() + 1));
            }
        }
    }

    /**
     * Finds the code block responsible for a diagnostic.
     * Uses multiple strategies for better matching.
     */
    public Optional<CodeBlock> findBlockForDiagnostic(Diagnostic diagnostic) {
        // Strategy 1: Precise AST node matching (best)
        Optional<CodeBlock> block = findBlockByASTNode(diagnostic);
        if (block.isPresent()) {
            return block;
        }

        // Strategy 2: Line-based fallback (good for edge cases)
        block = findBlockByLine(diagnostic);
        if (block.isPresent()) {
            return block;
        }

        // Strategy 3: Parent node search (for nested expressions)
        return findBlockByParentNode(diagnostic);
    }

    /**
     * Strategy 1: Find block by matching AST node ranges
     */
    private Optional<CodeBlock> findBlockByASTNode(Diagnostic diagnostic) {
        int startOffset = getOffsetFromPosition(diagnostic.getRange().getStart());
        int endOffset = getOffsetFromPosition(diagnostic.getRange().getEnd());

        // Find the most specific (smallest) block that contains the diagnostic range
        ASTNode bestNode = null;
        int bestLength = Integer.MAX_VALUE;

        for (ASTNode node : nodeToBlockMap.keySet()) {
            int nodeStart = node.getStartPosition();
            int nodeEnd = nodeStart + node.getLength();

            // Check if node contains the diagnostic range
            if (nodeStart <= startOffset && nodeEnd >= endOffset) {
                int nodeLength = node.getLength();

                // Prefer the smallest containing node
                if (nodeLength < bestLength) {
                    bestNode = node;
                    bestLength = nodeLength;
                }
            }
        }

        return Optional.ofNullable(bestNode).map(nodeToBlockMap::get);
    }

    /**
     * Strategy 2: Find block by line number (fallback)
     */
    private Optional<CodeBlock> findBlockByLine(Diagnostic diagnostic) {
        int line = diagnostic.getRange().getStart().getLine();

        Set<CodeBlock> blocksOnLine = lineToBlocksMap.get(line);
        if (blocksOnLine == null || blocksOnLine.isEmpty()) {
            return Optional.empty();
        }

        // If multiple blocks on same line, prefer the first one
        // (Could be improved with more sophisticated heuristics)
        return blocksOnLine.stream().findFirst();
    }

    /**
     * Strategy 3: Find block by searching parent nodes
     */
    private Optional<CodeBlock> findBlockByParentNode(Diagnostic diagnostic) {
        int startOffset = getOffsetFromPosition(diagnostic.getRange().getStart());

        // Find any node that contains the start position
        for (ASTNode node : nodeToBlockMap.keySet()) {
            int nodeStart = node.getStartPosition();
            int nodeEnd = nodeStart + node.getLength();

            if (nodeStart <= startOffset && nodeEnd >= startOffset) {
                return Optional.of(nodeToBlockMap.get(node));
            }
        }

        return Optional.empty();
    }

    /**
     * Converts LSP position to source code offset
     */
    private int getOffsetFromPosition(org.eclipse.lsp4j.Position pos) {
        int line = pos.getLine();
        int character = pos.getCharacter();
        int offset = 0;
        int currentLine = 0;

        if (sourceCode == null) return 0;

        while (currentLine < line && offset < sourceCode.length()) {
            if (sourceCode.charAt(offset) == '\n') {
                currentLine++;
            }
            offset++;
        }

        return offset + character;
    }

    /**
     * Gets line number from character offset
     */
    private int getLineNumber(int offset) {
        if (sourceCode == null || offset < 0) return 0;

        int line = 0;
        for (int i = 0; i < Math.min(offset, sourceCode.length()); i++) {
            if (sourceCode.charAt(i) == '\n') {
                line++;
            }
        }
        return line;
    }

    /**
     * Get all blocks that have errors (useful for UI highlighting)
     */
    public Set<CodeBlock> getBlocksWithErrors() {
        return Collections.unmodifiableSet(blocksWithErrors);
    }

    /**
     * Check if a specific block has errors
     */
    public boolean hasError(CodeBlock block) {
        return blocksWithErrors.contains(block);
    }

    /**
     * Get diagnostics for a specific block
     */
    public List<Diagnostic> getDiagnosticsForBlock(CodeBlock block) {
        if (lastDiagnostics == null || nodeToBlockMap == null) {
            return Collections.emptyList();
        }

        List<Diagnostic> blockDiagnostics = new ArrayList<>();

        for (Diagnostic diagnostic : lastDiagnostics) {
            Optional<CodeBlock> diagBlock = findBlockForDiagnostic(diagnostic);
            if (diagBlock.isPresent() && diagBlock.get() == block) {
                blockDiagnostics.add(diagnostic);
            }
        }

        return blockDiagnostics;
    }

    /**
     * Get a summary of all errors (useful for status bar)
     */
    public String getErrorSummary() {
        if (!hasErrors()) {
            return "✅ No errors";
        }

        long errorCount = lastDiagnostics.stream()
                .filter(d -> d.getSeverity() == DiagnosticSeverity.Error)
                .count();

        long warningCount = lastDiagnostics.stream()
                .filter(d -> d.getSeverity() == DiagnosticSeverity.Warning)
                .count();

        StringBuilder summary = new StringBuilder();
        if (errorCount > 0) {
            summary.append(String.format("❌ %d error%s", errorCount, errorCount == 1 ? "" : "s"));
        }
        if (warningCount > 0) {
            if (summary.length() > 0) summary.append(", ");
            summary.append(String.format("⚠️ %d warning%s", warningCount, warningCount == 1 ? "" : "s"));
        }

        return summary.toString();
    }
}


=================================================================================
FILE: rs\bgroi\Documents\dev\IntellijProjects\BotMaker\src\main\java\com\botmaker\validation\ErrorTranslator.java
=================================================================================

package com.botmaker.validation;

import org.eclipse.lsp4j.Diagnostic;
import org.eclipse.lsp4j.DiagnosticSeverity;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class ErrorTranslator {

    private static final Map<Integer, ErrorInfo> ERROR_MAPPINGS = new HashMap<>();
    private static final Pattern ERROR_CODE_PATTERN = Pattern.compile("\\b(\\d{7,})\\b");

    static class ErrorInfo {
        String userMessage;
        String suggestion;
        DiagnosticSeverity severity;

        ErrorInfo(String userMessage, String suggestion, DiagnosticSeverity severity) {
            this.userMessage = userMessage;
            this.suggestion = suggestion;
            this.severity = severity;
        }

        ErrorInfo(String userMessage, String suggestion) {
            this(userMessage, suggestion, DiagnosticSeverity.Error);
        }
    }

    static {
        // PRIORITY 1: Critical Errors (Must Handle)

        // 16777233 - TypeMismatch
        ERROR_MAPPINGS.put(16777233, new ErrorInfo(
                "Wrong type used: You're trying to use a {0} where a {1} is expected",
                "Check that you're using the right type of value (number, text, true/false, etc.)"
        ));

        // 570425394 - UndefinedName (Variable doesn't exist)
        ERROR_MAPPINGS.put(570425394, new ErrorInfo(
                "Variable or name '{0}' doesn't exist",
                "Did you forget to create this variable? Check for typos in the name."
        ));

        // 536870963 - UninitializedLocalVariable
        ERROR_MAPPINGS.put(536870963, new ErrorInfo(
                "Variable '{0}' is used before being given a value",
                "Set a value to this variable before using it."
        ));

        // 536870967 - RedefinedLocal (Duplicate variable)
        ERROR_MAPPINGS.put(536870967, new ErrorInfo(
                "A variable named '{0}' already exists",
                "Choose a different name or remove the duplicate variable."
        ));

        // 67108979 - ParameterMismatch
        ERROR_MAPPINGS.put(67108979, new ErrorInfo(
                "Wrong number of parameters: Expected {0} but got {1}",
                "Check how many inputs this function needs."
        ));

        // 603979884 - ShouldReturnValue
        ERROR_MAPPINGS.put(603979884, new ErrorInfo(
                "This function must return a value",
                "Add a return statement with a value at the end of the function."
        ));

        // PRIORITY 2: Type System Errors

        // 16777218 - UndefinedType
        ERROR_MAPPINGS.put(16777218, new ErrorInfo(
                "Type '{0}' cannot be found",
                "This type doesn't exist. Check for typos or missing imports."
        ));

        // 67108964 - UndefinedMethod
        ERROR_MAPPINGS.put(67108964, new ErrorInfo(
                "Method '{0}' doesn't exist",
                "Check the spelling of the method name or if it's available."
        ));

        // 33554502 - UndefinedField
        ERROR_MAPPINGS.put(33554502, new ErrorInfo(
                "Field '{0}' doesn't exist",
                "This field is not defined. Check the name and spelling."
        ));

        // PRIORITY 3: Syntax Errors (If user can edit code)

        // 1610612960 - MissingSemiColon
        ERROR_MAPPINGS.put(1610612960, new ErrorInfo(
                "Missing semicolon (;) at the end of the line",
                "Add a semicolon (;) at the end of this statement."
        ));

        // 1610612995 - UnterminatedString
        ERROR_MAPPINGS.put(1610612995, new ErrorInfo(
                "Text is missing a closing quote",
                "Add a closing quote (\") at the end of the text."
        ));

        // 1610612941 - ParsingErrorNoSuggestion
        ERROR_MAPPINGS.put(1610612941, new ErrorInfo(
                "Syntax error: The code structure is incorrect",
                "Check for missing brackets, parentheses, or other syntax issues."
        ));

        // 1610612956 - UnmatchedBracket
        ERROR_MAPPINGS.put(1610612956, new ErrorInfo(
                "Unmatched bracket - missing opening or closing bracket",
                "Check that all { } brackets are properly paired."
        ));

        // PRIORITY 4: Flow Control

        // 536870908 - InvalidBreak
        ERROR_MAPPINGS.put(536870908, new ErrorInfo(
                "'break' can only be used inside a loop or switch",
                "Move this break statement inside a loop block."
        ));

        // 536870909 - InvalidContinue
        ERROR_MAPPINGS.put(536870909, new ErrorInfo(
                "'continue' can only be used inside a loop",
                "Move this continue statement inside a loop block."
        ));

        // 536870161 - CodeCannotBeReached
        ERROR_MAPPINGS.put(536870161, new ErrorInfo(
                "This code will never run (unreachable code)",
                "Remove this code or fix the logic that prevents it from running.",
                DiagnosticSeverity.Warning
        ));

        // PRIORITY 5: Warnings

        // 536870973 - LocalVariableIsNeverUsed
        ERROR_MAPPINGS.put(536870973, new ErrorInfo(
                "Variable '{0}' is created but never used",
                "Remove this variable or use it somewhere in your code.",
                DiagnosticSeverity.Warning
        ));

        // 536870974 - ArgumentIsNeverUsed
        ERROR_MAPPINGS.put(536870974, new ErrorInfo(
                "Parameter '{0}' is never used",
                "Remove this parameter or use it in the function.",
                DiagnosticSeverity.Warning
        ));

        // 536871185 - AssignmentHasNoEffect
        ERROR_MAPPINGS.put(536871185, new ErrorInfo(
                "This assignment does nothing",
                "You're assigning a variable to itself. Remove this line or fix the logic.",
                DiagnosticSeverity.Warning
        ));
    }

    /**
     * Extracts the JDT error code from a diagnostic message
     */
    private static Integer extractErrorCode(String message) {
        Matcher matcher = ERROR_CODE_PATTERN.matcher(message);
        if (matcher.find()) {
            try {
                return Integer.parseInt(matcher.group(1));
            } catch (NumberFormatException e) {
                return null;
            }
        }
        return null;
    }

    /**
     * Translates diagnostics to user-friendly messages
     */
    public static String translate(List<Diagnostic> diagnostics) {
        if (diagnostics == null || diagnostics.isEmpty()) {
            return "✅ No errors found. Your code looks good!";
        }

        StringBuilder result = new StringBuilder();
        int errorCount = 0;
        int warningCount = 0;

        for (Diagnostic diagnostic : diagnostics) {
            if (diagnostic.getSeverity() == DiagnosticSeverity.Error) {
                errorCount++;
            } else if (diagnostic.getSeverity() == DiagnosticSeverity.Warning) {
                warningCount++;
            }
        }

        if (errorCount > 0) {
            result.append(String.format("❌ Found %d error%s:\n\n", errorCount, errorCount == 1 ? "" : "s"));
        }
        if (warningCount > 0) {
            result.append(String.format("⚠️  Found %d warning%s:\n\n", warningCount, warningCount == 1 ? "" : "s"));
        }

        for (Diagnostic diagnostic : diagnostics) {
            String icon = diagnostic.getSeverity() == DiagnosticSeverity.Error ? "❌" : "⚠️";
            int lineNumber = diagnostic.getRange().getStart().getLine() + 1;

            String translated = translateSingleDiagnostic(diagnostic);
            result.append(String.format("%s Line %d: %s\n\n", icon, lineNumber, translated));
        }

        return result.toString().trim();
    }

    /**
     * Translates a single diagnostic to a user-friendly message
     */
    public static String translateSingleDiagnostic(Diagnostic diagnostic) {
        String originalMessage = diagnostic.getMessage();

        // Try to extract error code
        Integer errorCode = extractErrorCode(originalMessage);

        if (errorCode != null && ERROR_MAPPINGS.containsKey(errorCode)) {
            ErrorInfo info = ERROR_MAPPINGS.get(errorCode);

            // Try to extract variable/type names from the original message
            String enrichedMessage = enrichMessage(info.userMessage, originalMessage);

            return String.format("%s\n   💡 %s", enrichedMessage, info.suggestion);
        }

        // Fallback: Try pattern matching for common error messages (backward compatibility)
        return translateByPattern(originalMessage);
    }

    /**
     * Enriches the user message with context from the original error message
     */
    private static String enrichMessage(String template, String originalMessage) {
        // Extract quoted strings (variable names, type names, etc.)
        Pattern quotedPattern = Pattern.compile("'([^']+)'|\"([^\"]+)\"");
        Matcher matcher = quotedPattern.matcher(originalMessage);

        int index = 0;
        String result = template;
        while (matcher.find() && result.contains("{" + index + "}")) {
            String value = matcher.group(1) != null ? matcher.group(1) : matcher.group(2);
            result = result.replace("{" + index + "}", "'" + value + "'");
            index++;
        }

        // Remove unreplaced placeholders
        result = result.replaceAll("\\{\\d+\\}", "the value");

        return result;
    }

    /**
     * Fallback pattern-based translation (for backward compatibility)
     */
    private static String translateByPattern(String message) {
        if (message.contains("cannot be resolved to a type")) {
            return "A type or class could not be found.\n   💡 Check for typos or if the type exists.";
        }
        if (message.contains("cannot be resolved")) {
            return "A variable, method, or name could not be found.\n   💡 Check for typos or if it was declared.";
        }
        if (message.contains("Syntax error, insert")) {
            try {
                String suggestion = message.split("insert \"")[1].split("\" to")[0];
                return String.format("Syntax error: Something is missing.\n   💡 Try adding '%s'", suggestion);
            } catch (Exception e) {
                return "Syntax error: Something is missing in the code structure.\n   💡 Check for missing semicolons, brackets, or parentheses.";
            }
        }
        if (message.contains("incompatible types") || message.contains("Type mismatch")) {
            return "Wrong type used: You're using a value of the wrong type.\n   💡 Make sure you're using the right kind of value (number, text, etc.)";
        }
        if (message.contains("might not have been initialized")) {
            return "Variable used before being set.\n   💡 Give this variable a value before using it.";
        }
        if (message.contains("is not a statement")) {
            return "This line is not a valid statement.\n   💡 It might be an incomplete expression or command.";
        }
        if (message.contains("Duplicate local variable")) {
            return "A variable with this name already exists.\n   💡 Choose a different name for this variable.";
        }

        // Return original message if no translation found
        return message;
    }

    /**
     * Get a short summary for UI display (e.g., tooltip)
     */
    public static String getShortSummary(Diagnostic diagnostic) {
        String originalMessage = diagnostic.getMessage();
        Integer errorCode = extractErrorCode(originalMessage);

        if (errorCode != null && ERROR_MAPPINGS.containsKey(errorCode)) {
            ErrorInfo info = ERROR_MAPPINGS.get(errorCode);
            return enrichMessage(info.userMessage, originalMessage);
        }

        // Fallback: Return first line of original message
        return originalMessage.split("\n")[0];
    }

    /**
     * Get just the suggestion part
     */
    public static String getSuggestion(Diagnostic diagnostic) {
        String originalMessage = diagnostic.getMessage();
        Integer errorCode = extractErrorCode(originalMessage);

        if (errorCode != null && ERROR_MAPPINGS.containsKey(errorCode)) {
            return ERROR_MAPPINGS.get(errorCode).suggestion;
        }

        return "Check your code for issues.";
    }
}


