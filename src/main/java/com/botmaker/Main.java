package com.botmaker;

import javafx.application.Application;
import javafx.application.Platform;
import javafx.scene.Scene;
import javafx.scene.control.*;
import javafx.scene.layout.*;
import javafx.stage.Stage;
import org.eclipse.lsp4j.DidChangeTextDocumentParams;
import org.eclipse.lsp4j.DidOpenTextDocumentParams;
import org.eclipse.lsp4j.TextDocumentContentChangeEvent;
import org.eclipse.lsp4j.TextDocumentItem;
import org.eclipse.lsp4j.VersionedTextDocumentIdentifier;
import org.eclipse.lsp4j.services.LanguageServer;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.List;

public class Main extends Application {

    private LanguageServer jdtServer;
    private final BlockFactory factory = new BlockFactory();
    private final VBox blocksContainer = new VBox(10);
    private final Label statusLabel = new Label("Ready");
    private TextArea outputArea;

    private String docUri;
    private String currentCode;
    private long docVersion = 1;
    private boolean isDirty = true;

    @Override
    public void start(Stage primaryStage) throws Exception {
        // 1. Start JDT Language Server
        JdtLanguageServerLauncher launcher = new JdtLanguageServerLauncher(Paths.get("tools/jdt-language-server"));
        jdtServer = launcher.getServer();

        // 2. Load the project file
        Path docPath = Paths.get("projects/Demo.java").toAbsolutePath();
        docUri = docPath.toUri().toString();
        currentCode = Files.readString(docPath);

        // 3. Tell JDT LS that the file exists
        jdtServer.getTextDocumentService().didOpen(new DidOpenTextDocumentParams(
                new TextDocumentItem(docUri, "java", (int) docVersion, currentCode)
        ));

        // 4. Initial UI Render
        refreshUI(currentCode);

        // 5. Layout
        Button compileButton = new Button("Compile");
        compileButton.setOnAction(e -> compileCode());
        Button runButton = new Button("Run");
        runButton.setOnAction(e -> runCode());
        HBox buttonBox = new HBox(10, compileButton, runButton);

        outputArea = new TextArea();
        outputArea.setEditable(false);
        outputArea.setPrefHeight(200);

        ScrollPane scrollPane = new ScrollPane(blocksContainer);
        scrollPane.setFitToWidth(true);
        VBox root = new VBox(10, buttonBox, scrollPane, outputArea, statusLabel);
        root.setPadding(new javafx.geometry.Insets(10));
        primaryStage.setScene(new Scene(root, 600, 800));
        primaryStage.setTitle("BotMaker Blocks");
        primaryStage.show();

        primaryStage.setOnCloseRequest(e -> {
            launcher.stop();
            Platform.exit();
        });
    }

    private void handleCodeUpdate(String newCode) {
        this.docVersion++;
        this.isDirty = true;
        // Notify the LSP server that the document has changed
        jdtServer.getTextDocumentService().didChange(new DidChangeTextDocumentParams(
                new VersionedTextDocumentIdentifier(docUri, (int) docVersion),
                List.of(new TextDocumentContentChangeEvent(newCode))
        ));
        // Trigger a UI refresh with the new code
        refreshUI(newCode);
    }

    private void refreshUI(String javaCode) {
        this.currentCode = javaCode;
        blocksContainer.getChildren().clear();

        // Create the context for this refresh cycle
        CompletionContext context = new CompletionContext(
                jdtServer,
                docUri,
                currentCode,
                docVersion,
                this::handleCodeUpdate // Pass the handler method as a callback
        );

        BodyBlock rootBlock = factory.convert(javaCode);

        if (rootBlock != null) {
            // The entire UI is now generated by the block objects themselves.
            blocksContainer.getChildren().add(rootBlock.getUINode(context));
        }
        statusLabel.setText("UI Refreshed.");
    }

    public static void main(String[] args) {
        launch(args);
    }

    private void compileCode() {
        new Thread(() -> {
            try {
                Platform.runLater(() -> outputArea.setText("Saving and compiling..."));

                Path sourceFile = Paths.get("projects/Demo.java");
                Files.writeString(sourceFile, currentCode);

                String sourcePath = sourceFile.toString();
                String outDir = "build/compiled";
                Files.createDirectories(Paths.get(outDir));

                String javacExecutable = Paths.get(System.getProperty("java.home"), "bin", "javac").toString();
                ProcessBuilder pb = new ProcessBuilder(javacExecutable, "-d", outDir, sourcePath);
                Process process = pb.start();

                String errors = new String(process.getErrorStream().readAllBytes());
                int exitCode = process.waitFor();

                if (exitCode == 0) {
                    Platform.runLater(() -> outputArea.setText("Compilation successful."));
                    isDirty = false;
                } else {
                    Platform.runLater(() -> outputArea.setText("Compilation Failed:\n" + errors));
                }
            } catch (IOException | InterruptedException e) {
                Platform.runLater(() -> outputArea.setText("Compilation Error: " + e.getMessage()));
            }
        }).start();
    }

    private void runCode() {
        new Thread(() -> {
            try {
                if (isDirty) {
                    Platform.runLater(() -> outputArea.setText("Changes detected, compiling..."));
                    if (!compileAndWait()) {
                        Platform.runLater(() -> outputArea.setText("Run aborted due to compilation failure."));
                        return;
                    }
                }

                Platform.runLater(() -> outputArea.setText("Running..."));

                String classPath = "build/compiled";
                String className = "Demo";

                String javaExecutable = Paths.get(System.getProperty("java.home"), "bin", "java").toString();
                ProcessBuilder pb = new ProcessBuilder(javaExecutable, "-cp", classPath, className);
                Process process = pb.start();

                String output = new String(process.getInputStream().readAllBytes());
                String errors = new String(process.getErrorStream().readAllBytes());
                int exitCode = process.waitFor();

                Platform.runLater(() -> {
                    if (exitCode == 0) {
                        outputArea.setText("--- Run Output ---\n" + output);
                    } else {
                        outputArea.setText("--- Run Failed ---\n" + errors);
                    }
                });

            } catch (IOException | InterruptedException e) {
                Platform.runLater(() -> outputArea.setText("Execution Error: " + e.getMessage()));
            }
        }).start();
    }

    // A synchronous helper method for compilation
    private boolean compileAndWait() throws IOException, InterruptedException {
        Path sourceFile = Paths.get("projects/Demo.java");
        Files.writeString(sourceFile, currentCode);

        String sourcePath = sourceFile.toString();
        String outDir = "build/compiled";
        Files.createDirectories(Paths.get(outDir));

        String javacExecutable = Paths.get(System.getProperty("java.home"), "bin", "javac").toString();
        ProcessBuilder pb = new ProcessBuilder(javacExecutable, "-d", outDir, sourcePath);
        Process process = pb.start();

        int exitCode = process.waitFor();
        if (exitCode == 0) {
            isDirty = false;
            return true;
        } else {
            String errors = new String(process.getErrorStream().readAllBytes());
            Platform.runLater(() -> outputArea.setText("Compilation Failed:\n" + errors));
            return false;
        }
    }
}