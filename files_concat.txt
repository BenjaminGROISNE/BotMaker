=================================================================================
FILE: ./src/main/java/com/botmaker/blocks/BinaryExpressionBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractExpressionBlock;
import com.botmaker.core.ExpressionBlock;
import com.botmaker.lsp.CompletionContext;
import javafx.geometry.Pos;
import javafx.scene.Node;
import javafx.scene.control.Label;
import javafx.scene.layout.HBox;
import org.eclipse.jdt.core.dom.ITypeBinding;
import org.eclipse.jdt.core.dom.InfixExpression;

public class BinaryExpressionBlock extends AbstractExpressionBlock {

    private ExpressionBlock leftOperand;
    private ExpressionBlock rightOperand;
    private final String operator;
    private final ITypeBinding returnType;

    public BinaryExpressionBlock(String id, InfixExpression astNode) {
        super(id, astNode);
        this.operator = astNode.getOperator().toString();
        this.returnType = astNode.resolveTypeBinding();
    }

    public ExpressionBlock getLeftOperand() {
        return leftOperand;
    }

    public void setLeftOperand(ExpressionBlock leftOperand) {
        this.leftOperand = leftOperand;
    }

    public ExpressionBlock getRightOperand() {
        return rightOperand;
    }

    public void setRightOperand(ExpressionBlock rightOperand) {
        this.rightOperand = rightOperand;
    }

    public String getOperator() {
        return operator;
    }

    public ITypeBinding getReturnType() {
        return returnType;
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        HBox container = new HBox(5);
        container.setAlignment(Pos.CENTER_LEFT);
        container.getStyleClass().add("binary-expression-block");

        HBox expressionBox = new HBox(5);
        expressionBox.setAlignment(Pos.CENTER_LEFT);
        if (leftOperand != null) {
            expressionBox.getChildren().add(leftOperand.getUINode(context));
        }
        expressionBox.getChildren().add(new Label(operator));
        if (rightOperand != null) {
            expressionBox.getChildren().add(rightOperand.getUINode(context));
        }

        container.getChildren().add(expressionBox);

        String typeName = "unknown";
        if (returnType != null) {
            typeName = returnType.getName();
        }
        Label typeLabel = new Label("-> " + typeName);
        typeLabel.setStyle("-fx-font-style: italic; -fx-text-fill: #555;");
        container.getChildren().add(typeLabel);


        return container;
    }
}


=================================================================================
FILE: ./src/main/java/com/botmaker/blocks/IdentifierBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractExpressionBlock;
import com.botmaker.lsp.CompletionContext;
import javafx.application.Platform;
import javafx.scene.Cursor;
import javafx.scene.Node;
import javafx.scene.control.ContextMenu;
import javafx.scene.control.MenuItem;
import javafx.scene.control.Tooltip;
import javafx.scene.layout.HBox;
import javafx.scene.text.Text;
import org.eclipse.jdt.core.dom.SimpleName;
import org.eclipse.lsp4j.*;

import java.util.List;

public class IdentifierBlock extends AbstractExpressionBlock {
    private final String identifier;
    private boolean isUnedited = false; // Track if this is a default/auto-populated identifier
    private static final String UNEDITED_STYLE_CLASS = "unedited-identifier";

    public IdentifierBlock(String id, SimpleName astNode) {
        super(id, astNode);
        this.identifier = astNode.getIdentifier();
    }

    /**
     * Constructor for creating new IdentifierBlocks with default value
     */
    public IdentifierBlock(String id, SimpleName astNode, boolean markAsUnedited) {
        super(id, astNode);
        this.identifier = astNode.getIdentifier();
        this.isUnedited = markAsUnedited;
    }

    public String getIdentifier() {
        return identifier;
    }

    public boolean isUnedited() {
        return isUnedited;
    }

    public void markAsEdited() {
        this.isUnedited = false;
        if (uiNode != null) {
            uiNode.getStyleClass().remove(UNEDITED_STYLE_CLASS);
        }
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        Text text = new Text(this.identifier);
        HBox container = new HBox(text);
        container.setAlignment(javafx.geometry.Pos.CENTER_LEFT);
        container.getStyleClass().add("identifier-block");

        // Add unedited styling if applicable
        if (isUnedited) {
            container.getStyleClass().add(UNEDITED_STYLE_CLASS);
        }

        // Add visual cues for interaction
        container.setCursor(Cursor.HAND);

        String tooltipText = isUnedited
                ? "⚠️ Default variable name - Click to choose a variable or edit it"
                : "Click for variable suggestions";

        Tooltip tooltip = new Tooltip(tooltipText);
        Tooltip.install(container, tooltip);

        // Add the click handler for suggestions
        container.setOnMouseClicked(e -> {
            if (e.getClickCount() == 1) {
                requestSuggestions(container, context);
            }
        });

        // If this is unedited, automatically request suggestions once to auto-populate
        if (isUnedited) {
            Platform.runLater(() -> autoPopulateWithSuggestion(container, context));
        }

        return container;
    }

    /**
     * Automatically populate with the first available variable suggestion
     */
    private void autoPopulateWithSuggestion(Node uiNode, CompletionContext context) {
        try {
            Position pos = getPositionFromOffset(context.sourceCode(), this.astNode.getStartPosition());
            CompletionParams params = new CompletionParams(new TextDocumentIdentifier(context.docUri()), pos);

            context.server().getTextDocumentService().completion(params).thenAccept(result -> {
                if (result == null || (result.isLeft() && result.getLeft().isEmpty()) || (result.isRight() && result.getRight().getItems().isEmpty())) {
                    return; // No suggestions found, keep default value
                }

                List<CompletionItem> items = result.isLeft() ? result.getLeft() : result.getRight().getItems();

                // Find the first variable suggestion
                CompletionItem firstVariable = items.stream()
                        .filter(item -> item.getKind() == CompletionItemKind.Variable)
                        .findFirst()
                        .orElse(null);

                if (firstVariable != null) {
                    Platform.runLater(() -> {
                        // Auto-apply the first suggestion
                        applySuggestion(firstVariable, context);

                        // Update tooltip to reflect the auto-population
                        Tooltip newTooltip = new Tooltip("✓ Auto-selected variable - Click to change or confirm");
                        Tooltip.install(uiNode, newTooltip);
                    });
                }
            });
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private void requestSuggestions(Node uiNode, CompletionContext context) {
        try {
            Position pos = getPositionFromOffset(context.sourceCode(), this.astNode.getStartPosition());
            CompletionParams params = new CompletionParams(new TextDocumentIdentifier(context.docUri()), pos);

            context.server().getTextDocumentService().completion(params).thenAccept(result -> {
                if (result == null || (result.isLeft() && result.getLeft().isEmpty()) || (result.isRight() && result.getRight().getItems().isEmpty())) {
                    return; // No suggestions found
                }

                List<CompletionItem> items = result.isLeft() ? result.getLeft() : result.getRight().getItems();

                Platform.runLater(() -> {
                    ContextMenu menu = new ContextMenu();
                    for (CompletionItem item : items) {
                        // Filter for variables, as requested by the user
                        if (item.getKind() == CompletionItemKind.Variable) {
                            MenuItem mi = new MenuItem(item.getLabel());
                            mi.setOnAction(event -> {
                                applySuggestion(item, context);
                                markAsEdited(); // Mark as edited when user explicitly selects
                            });
                            menu.getItems().add(mi);
                        }
                    }
                    if (!menu.getItems().isEmpty()) {
                        menu.show(uiNode, javafx.geometry.Side.BOTTOM, 0, 0);
                    }
                });
            });
        } catch (Exception e) {
            e.printStackTrace(); // Log error
        }
    }

    private void applySuggestion(CompletionItem item, CompletionContext context) {
        try {
            String insertText = item.getInsertText() != null ? item.getInsertText() : item.getLabel();
            // The astNode for an IdentifierBlock is a SimpleName.
            context.codeEditor().replaceSimpleName((SimpleName) this.astNode, insertText);
        } catch (Exception e) {
            e.printStackTrace(); // Log error
        }
    }

    // Helper to convert a string offset to a line/character position
    private Position getPositionFromOffset(String code, int offset) {
        int line = 0;
        int lastNewline = -1;
        for (int i = 0; i < offset; i++) {
            if (code.charAt(i) == '\n') {
                line++;
                lastNewline = i;
            }
        }
        int character = offset - lastNewline - 1;
        return new Position(line, character);
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/blocks/IfBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractStatementBlock;
import com.botmaker.core.BodyBlock;
import com.botmaker.core.CodeBlock;
import com.botmaker.core.ExpressionBlock;
import com.botmaker.lsp.CompletionContext;
import javafx.geometry.Pos;
import javafx.scene.Node;
import javafx.scene.control.Label;
import javafx.scene.layout.HBox;
import javafx.scene.layout.VBox;
import org.eclipse.jdt.core.dom.CompilationUnit;
import org.eclipse.jdt.core.dom.IfStatement;

public class IfBlock extends AbstractStatementBlock {

    private ExpressionBlock condition;
    private BodyBlock thenBody;
    private com.botmaker.core.StatementBlock elseStatement; // Can be null

    public IfBlock(String id, IfStatement astNode) {
        super(id, astNode);
    }

    public ExpressionBlock getCondition() {
        return condition;
    }

    public void setCondition(ExpressionBlock condition) {
        this.condition = condition;
    }

    public BodyBlock getThenBody() {
        return thenBody;
    }

    public void setThenBody(BodyBlock thenBody) {
        this.thenBody = thenBody;
    }

    public com.botmaker.core.StatementBlock getElseStatement() {
        return elseStatement;
    }

    public void setElseStatement(com.botmaker.core.StatementBlock elseStatement) {
        this.elseStatement = elseStatement;
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        VBox container = new VBox(5);
        container.getStyleClass().add("if-block");

        // Header: If + condition + delete button
        HBox header = new HBox(5);
        header.setAlignment(Pos.CENTER_LEFT);
        header.getChildren().add(new Label("If"));
        if (condition != null) {
            header.getChildren().add(condition.getUINode(context));
        } else {
            header.getChildren().add(createExpressionDropZone(context));
        }
        javafx.scene.layout.Pane spacer = new javafx.scene.layout.Pane();
        HBox.setHgrow(spacer, javafx.scene.layout.Priority.ALWAYS);
        javafx.scene.control.Button deleteButton = new javafx.scene.control.Button("X");
        deleteButton.setOnAction(e -> context.codeEditor().deleteStatement((org.eclipse.jdt.core.dom.Statement) this.astNode));
        header.getChildren().addAll(spacer, deleteButton);
        container.getChildren().add(header);

        // Then body
        if (thenBody != null) {
            Node thenBodyNode = thenBody.getUINode(context);
            thenBodyNode.getStyleClass().add("if-body");
            HBox.setHgrow(thenBodyNode, javafx.scene.layout.Priority.ALWAYS);
            container.getChildren().add(thenBodyNode);
        }

        // Else part
        if (elseStatement != null) {
            if (elseStatement instanceof com.botmaker.core.BodyBlock) {
                VBox elseContainer = new VBox(5);
                HBox elseHeader = new HBox(5);
                elseHeader.setAlignment(Pos.CENTER_LEFT);
                Label elseLabel = new Label("Else");
                javafx.scene.control.Button addElseIfButton = new javafx.scene.control.Button("+ if");
                addElseIfButton.setOnAction(e -> context.codeEditor().convertElseToElseIf((IfStatement) this.astNode));
                javafx.scene.layout.Pane elseSpacer = new javafx.scene.layout.Pane();
                HBox.setHgrow(elseSpacer, javafx.scene.layout.Priority.ALWAYS);
                javafx.scene.control.Button deleteElseButton = new javafx.scene.control.Button("X");
                deleteElseButton.setOnAction(e -> context.codeEditor().deleteElseFromIfStatement((IfStatement) this.astNode));
                elseHeader.getChildren().addAll(elseLabel, addElseIfButton, elseSpacer, deleteElseButton);

                Node elseBodyNode = elseStatement.getUINode(context);
                elseBodyNode.getStyleClass().add("if-body");
                HBox.setHgrow(elseBodyNode, javafx.scene.layout.Priority.ALWAYS);
                elseContainer.getChildren().addAll(elseHeader, elseBodyNode);
                container.getChildren().add(elseContainer);
            } else { // Assuming IfBlock
                HBox elseIfContainer = new HBox(5);
                elseIfContainer.setAlignment(Pos.CENTER_LEFT);
                elseIfContainer.getChildren().add(new Label("Else"));
                Node elseNode = elseStatement.getUINode(context);
                HBox.setHgrow(elseNode, javafx.scene.layout.Priority.ALWAYS);
                elseIfContainer.getChildren().add(elseNode);
                container.getChildren().add(elseIfContainer);
            }
        } else {
            javafx.scene.control.Button addElseButton = new javafx.scene.control.Button("+");
            addElseButton.setOnAction(e -> context.codeEditor().addElseToIfStatement((IfStatement) this.astNode));
            container.getChildren().add(addElseButton);
        }

        return container;
    }

    @Override
    public void highlight() {
        if (condition != null) {
            condition.highlight();
        } else {
            super.highlight();
        }
    }

    @Override
    public void unhighlight() {
        if (condition != null) {
            condition.unhighlight();
        } else {
            super.unhighlight();
        }
    }

    @Override
    public int getBreakpointLine(CompilationUnit cu) {
        // The breakpoint for an IfBlock should be on its condition.
        if (condition != null) {
            return condition.getBreakpointLine(cu);
        }
        return super.getBreakpointLine(cu);
    }

    @Override
    public CodeBlock getHighlightTarget() {
        return condition != null ? condition : this;
    }

    @Override
    public String getDetails() {
        String conditionDetails = (condition != null) ? condition.getDetails() : "no condition";
        return "If Statement (condition: " + conditionDetails + ")";
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/blocks/LiteralBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractExpressionBlock;
import com.botmaker.lsp.CompletionContext;
import javafx.scene.Cursor;
import javafx.scene.Node;
import javafx.scene.control.TextField;
import javafx.scene.layout.HBox;
import javafx.scene.text.Text;
import org.eclipse.jdt.core.dom.Expression;

public class LiteralBlock<T> extends AbstractExpressionBlock {
    private final T value;

    public LiteralBlock(String id, Expression astNode, T value) {
        super(id, astNode);
        this.value = value;
    }

    public T getValue() {
        return value;
    }

    public Class<?> getValueType() {
        if (value == null) return null;
        return value.getClass();
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        String initialText = (value instanceof String) ? (String) value : String.valueOf(value);
        TextField textField = new TextField(initialText);

        if (initialText.isEmpty() && value instanceof String) {
            textField.setPromptText("Type a value...");
        }
        textField.setCursor(Cursor.TEXT);

        // Update when the text field loses focus, if the value has changed.
        textField.focusedProperty().addListener((obs, oldVal, newVal) -> {
            // newVal is false when focus is lost
            if (!newVal) {
                String newText = textField.getText();
                String oldText = (value instanceof String) ? (String) value : String.valueOf(value);

                if (!newText.equals(oldText)) {
                    // Handle the special synthetic case for an empty println
                    if (this.astNode instanceof org.eclipse.jdt.core.dom.MethodInvocation) {
                        org.eclipse.jdt.core.dom.MethodInvocation mi = (org.eclipse.jdt.core.dom.MethodInvocation) this.astNode;
                        context.codeEditor().addStringArgumentToMethodInvocation(mi, newText);
                    } else {
                        // This is the normal case for editing an existing literal
                        context.codeEditor().replaceLiteralValue((Expression) this.astNode, newText);
                    }
                }
            }
        });

        HBox container = new HBox(textField);
        container.setAlignment(javafx.geometry.Pos.CENTER_LEFT);
        container.getStyleClass().add("literal-block");
        return container;
    }
}


=================================================================================
FILE: ./src/main/java/com/botmaker/blocks/MainBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractCodeBlock;
import com.botmaker.core.BlockWithChildren;
import com.botmaker.core.BodyBlock;
import com.botmaker.core.CodeBlock;
import com.botmaker.lsp.CompletionContext;

import javafx.geometry.Insets;
import javafx.scene.Node;
import javafx.scene.control.Label;
import javafx.scene.layout.VBox;
import org.eclipse.jdt.core.dom.ASTNode;

import java.util.ArrayList;
import java.util.List;

public class MainBlock extends AbstractCodeBlock implements BlockWithChildren {

    private BodyBlock mainBody;

    public MainBlock(String id, ASTNode astNode) {
        super(id, astNode);
    }

    public void setMainBody(BodyBlock mainBody) {
        this.mainBody = mainBody;
    }

    @Override
    public List<CodeBlock> getChildren() {
        List<CodeBlock> children = new ArrayList<>();
        if (mainBody != null) {
            children.add(mainBody);
        }
        return children;
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        VBox container = new VBox(5);
        container.getStyleClass().add("main-block");
        container.setPadding(new Insets(10));

        Label header = new Label("Main");
        header.getStyleClass().add("main-block-header");
        container.getChildren().add(header);

        if (mainBody != null) {
            container.getChildren().add(mainBody.getUINode(context));
        }

        return container;
    }
}


=================================================================================
FILE: ./src/main/java/com/botmaker/blocks/PrintBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractStatementBlock;
import com.botmaker.core.ExpressionBlock;
import com.botmaker.lsp.CompletionContext;
import javafx.geometry.Pos;
import javafx.scene.Node;
import javafx.scene.layout.HBox;
import javafx.scene.text.Text;
import org.eclipse.jdt.core.dom.ExpressionStatement;
import org.eclipse.jdt.core.dom.MethodInvocation;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

public class PrintBlock extends AbstractStatementBlock {

    private final List<ExpressionBlock> arguments = new ArrayList<>();

    public PrintBlock(String id, ExpressionStatement astNode) {
        super(id, astNode);
    }

    public List<ExpressionBlock> getArguments() {
        return arguments;
    }

    public void addArgument(ExpressionBlock argument) {
        this.arguments.add(argument);
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        HBox container = new HBox(5);
        container.setAlignment(Pos.CENTER_LEFT);
        container.getStyleClass().add("print-block");

        container.getChildren().add(new Text("Print:"));

        if (arguments.isEmpty()) {
            container.getChildren().add(createExpressionDropZone(context));
        } else {
            for (ExpressionBlock arg : arguments) {
                container.getChildren().add(arg.getUINode(context));
            }
        }

        javafx.scene.control.Button addButton = new javafx.scene.control.Button("+");
        javafx.scene.control.ContextMenu contextMenu = new javafx.scene.control.ContextMenu();

        for (com.botmaker.ui.AddableExpression type : com.botmaker.ui.AddableExpression.values()) {
            javafx.scene.control.MenuItem menuItem = new javafx.scene.control.MenuItem(type.getDisplayName());
            menuItem.setOnAction(e -> {
                if (!arguments.isEmpty()) {
                    // We are assuming one argument for now
                    org.eclipse.jdt.core.dom.Expression toReplace = (org.eclipse.jdt.core.dom.Expression) arguments.get(0).getAstNode();
                    context.codeEditor().replaceExpression(toReplace, type);
                }
            });
            contextMenu.getItems().add(menuItem);
        }

        addButton.setOnAction(e -> contextMenu.show(addButton, javafx.geometry.Side.BOTTOM, 0, 0));
        container.getChildren().add(addButton);

        javafx.scene.control.Button deleteButton = new javafx.scene.control.Button("X");
        deleteButton.setOnAction(e -> {
            context.codeEditor().deleteStatement((org.eclipse.jdt.core.dom.Statement) this.astNode);
        });

        javafx.scene.layout.Pane spacer = new javafx.scene.layout.Pane();
        HBox.setHgrow(spacer, javafx.scene.layout.Priority.ALWAYS);

        container.getChildren().addAll(spacer, deleteButton);

        return container;
    }

    @Override
    public String getDetails() {
        String argsString = arguments.stream()
                .map(ExpressionBlock::getDetails)
                .collect(Collectors.joining(", "));
        return "Print Statement: " + argsString;
    }
}


=================================================================================
FILE: ./src/main/java/com/botmaker/blocks/VariableDeclarationBlock.java
=================================================================================

package com.botmaker.blocks;

import com.botmaker.core.AbstractStatementBlock;
import com.botmaker.core.ExpressionBlock;
import com.botmaker.lsp.CompletionContext;
import com.botmaker.util.TypeManager;
import javafx.application.Platform;
import javafx.geometry.Pos;
import javafx.scene.Cursor;
import javafx.scene.Node;
import javafx.scene.control.*;
import javafx.scene.layout.HBox;
import org.eclipse.jdt.core.dom.Type;
import org.eclipse.jdt.core.dom.VariableDeclarationFragment;
import org.eclipse.jdt.core.dom.VariableDeclarationStatement;
import org.eclipse.lsp4j.*;

import java.util.List;

public class VariableDeclarationBlock extends AbstractStatementBlock {

    private final String variableName;
    private final Type variableType;
    private ExpressionBlock initializer;

    public VariableDeclarationBlock(String id, VariableDeclarationStatement astNode) {
        super(id, astNode);
        VariableDeclarationFragment fragment = (VariableDeclarationFragment) astNode.fragments().get(0);
        this.variableName = fragment.getName().getIdentifier();
        this.variableType = astNode.getType();
        this.initializer = null; // This will be set by the converter
    }

    public String getVariableName() {
        return variableName;
    }

    public Type getVariableType() {
        return variableType;
    }

    public ExpressionBlock getInitializer() {
        return initializer;
    }

    public void setInitializer(ExpressionBlock initializer) {
        this.initializer = initializer;
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        HBox container = new HBox(5);
        container.setAlignment(Pos.CENTER_LEFT);
        container.getStyleClass().add("variable-declaration-block");

        Label typeLabel = new Label(variableType.toString());
        typeLabel.getStyleClass().add("type-label");
        typeLabel.setCursor(Cursor.HAND);
        typeLabel.setOnMouseClicked(e -> requestTypeSuggestions(typeLabel, context));
        container.getChildren().add(typeLabel);

        TextField nameField = new TextField(variableName);
        nameField.focusedProperty().addListener((obs, oldVal, newVal) -> {
            if (!newVal) { // Focus lost
                String newName = nameField.getText();
                VariableDeclarationFragment fragment = (VariableDeclarationFragment) ((VariableDeclarationStatement) this.astNode).fragments().get(0);
                String currentName = fragment.getName().getIdentifier();

                if (!newName.equals(currentName)) {
                    context.codeEditor().replaceSimpleName(fragment.getName(), newName);
                }
            }
        });
        container.getChildren().add(nameField);

        container.getChildren().add(new Label("="));

        if (initializer != null) {
            container.getChildren().add(initializer.getUINode(context));
        } else {
            container.getChildren().add(createExpressionDropZone(context));
        }

        javafx.scene.control.Button deleteButton = new javafx.scene.control.Button("X");
        deleteButton.setOnAction(e -> {
            context.codeEditor().deleteStatement((org.eclipse.jdt.core.dom.Statement) this.astNode);
        });

        javafx.scene.layout.Pane spacer = new javafx.scene.layout.Pane();
        HBox.setHgrow(spacer, javafx.scene.layout.Priority.ALWAYS);

        container.getChildren().addAll(spacer, deleteButton);

        return container;
    }

    private void requestTypeSuggestions(Node uiNode, CompletionContext context) {
        try {
            Position pos = getPositionFromOffset(context.sourceCode(), this.variableType.getStartPosition());
            CompletionParams params = new CompletionParams(new TextDocumentIdentifier(context.docUri()), pos);

            context.server().getTextDocumentService().completion(params).thenAccept(result -> {
                Platform.runLater(() -> {
                    ContextMenu menu = new ContextMenu();

                    // Manually add fundamental types from TypeManager
                    for (String typeName : TypeManager.getFundamentalTypeNames()) {
                        CompletionItem dummyItem = new CompletionItem(typeName);
                        MenuItem mi = new MenuItem(typeName);
                        mi.setOnAction(event -> applyTypeSuggestion(dummyItem, context));
                        menu.getItems().add(mi);
                    }
                    menu.getItems().add(new SeparatorMenuItem());

                    // Add types from language server if any
                    if (result != null && (result.isRight() || (result.isLeft() && !result.getLeft().isEmpty()))) {
                        List<CompletionItem> items = result.isLeft() ? result.getLeft() : result.getRight().getItems();
                        for (CompletionItem item : items) {
                            CompletionItemKind kind = item.getKind();
                            // Filter for classes and interfaces suggested by the server
                            if (kind == CompletionItemKind.Class || kind == CompletionItemKind.Interface) {
                                // Avoid duplicating types we added manually
                                if (TypeManager.getFundamentalTypeNames().contains(item.getLabel())) continue;

                                MenuItem mi = new MenuItem(item.getLabel());
                                mi.setOnAction(event -> applyTypeSuggestion(item, context));
                                menu.getItems().add(mi);
                            }
                        }
                    }
                    menu.show(uiNode, javafx.geometry.Side.BOTTOM, 0, 0);
                });
            });
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private void applyTypeSuggestion(CompletionItem item, CompletionContext context) {
        try {
            String newTypeName = item.getInsertText() != null ? item.getInsertText() : item.getLabel();
            context.codeEditor().replaceVariableType((VariableDeclarationStatement) this.astNode, newTypeName);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private Position getPositionFromOffset(String code, int offset) {
        int line = 0;
        int lastNewline = -1;
        // Handle case where offset is at the beginning of the file
        if (offset == 0) {
            return new Position(0, 0);
        }
        for (int i = 0; i < offset; i++) {
            if (i >= code.length()) { // Boundary check
                return new Position(line, i - lastNewline - 1);
            }
            if (code.charAt(i) == '\n') {
                line++;
                lastNewline = i;
            }
        }
        int character = offset - lastNewline - 1;
        return new Position(line, character);
    }


    @Override
    public String getDetails() {
        String initializerText = initializer != null ? " = ..." : "";
        return "Variable Declaration: " + variableType.toString() + " " + variableName + initializerText;
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/core/AbstractCodeBlock.java
=================================================================================

package com.botmaker.core;

import com.botmaker.lsp.CompletionContext;
import javafx.geometry.Pos;
import javafx.scene.Node;
import javafx.scene.control.Button;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Pane;
import javafx.scene.layout.Priority;
import javafx.scene.layout.Region;
import org.eclipse.jdt.core.dom.ASTNode;
import org.eclipse.jdt.core.dom.CompilationUnit;
import org.eclipse.jdt.core.dom.Statement;

public abstract class AbstractCodeBlock implements CodeBlock {
    protected final String id;
    protected final ASTNode astNode;
    protected Node uiNode; // A cached reference to the UI node
    private javafx.scene.control.Tooltip errorTooltip;

    public AbstractCodeBlock(String id, ASTNode astNode) {
        this.id = id;
        this.astNode = astNode;
    }

    @Override
    public String getId() {
        return id;
    }

    @Override
    public ASTNode getAstNode() {
        return astNode;
    }

    @Override
    public Node getUINode(CompletionContext context) {
        if (uiNode == null) {
            this.uiNode = createUINode(context);
        }
        return uiNode;
    }

    @Override
    public Node getUINode() {
        return uiNode;
    }


    @Override
    public void highlight() {
        if (uiNode != null) {
            if (!uiNode.getStyleClass().contains("highlighted")) {
                uiNode.getStyleClass().add("highlighted");
            }
        }
    }

    @Override
    public void unhighlight() {
        if (uiNode != null) {
            uiNode.getStyleClass().remove("highlighted");
        }
    }

    @Override
    public void setError(String message) {
        if (uiNode != null) {
            if (!uiNode.getStyleClass().contains("error-block")) {
                uiNode.getStyleClass().add("error-block");
            }
            if (errorTooltip == null) {
                errorTooltip = new javafx.scene.control.Tooltip(message);
                javafx.scene.control.Tooltip.install(uiNode, errorTooltip);
            } else {
                errorTooltip.setText(message);
            }
        }
    }

    @Override
    public void clearError() {
        if (uiNode != null) {
            uiNode.getStyleClass().remove("error-block");
            if (errorTooltip != null) {
                javafx.scene.control.Tooltip.uninstall(uiNode, errorTooltip);
                errorTooltip = null;
            }
        }
    }

    @Override
    public int getBreakpointLine(CompilationUnit cu) {
        if (cu == null || astNode == null) return -1;
        return cu.getLineNumber(astNode.getStartPosition());
    }

    @Override
    public CodeBlock getHighlightTarget() {
        return this; // Default behavior is to highlight the block itself.
    }

    @Override
    public String getDetails() {
        return this.getClass().getSimpleName() + " (ID: " + this.getId() + ")";
    }

    /**
     * Creates a standard placeholder for a missing expression, which acts as a drop target.
     * @param context The completion context containing the drag-and-drop manager.
     * @return A Node representing the drop zone.
     */
    protected Node createExpressionDropZone(CompletionContext context) {
        Region dropZone = new Region();
        context.dragAndDropManager().addExpressionDropHandlers(dropZone);
        return dropZone;
    }

    // Abstract method for subclasses to implement their specific UI creation logic.
    protected abstract Node createUINode(CompletionContext context);
}


=================================================================================
FILE: ./src/main/java/com/botmaker/core/AbstractExpressionBlock.java
=================================================================================

package com.botmaker.core;

import org.eclipse.jdt.core.dom.ASTNode;

public abstract class AbstractExpressionBlock extends AbstractCodeBlock implements ExpressionBlock {
    public AbstractExpressionBlock(String id, ASTNode astNode) {
        super(id, astNode);
    }
}


=================================================================================
FILE: ./src/main/java/com/botmaker/core/AbstractStatementBlock.java
=================================================================================

package com.botmaker.core;

import org.eclipse.jdt.core.dom.ASTNode;

public abstract class AbstractStatementBlock extends AbstractCodeBlock implements StatementBlock {
    public AbstractStatementBlock(String id, ASTNode astNode) {
        super(id, astNode);
    }
}


=================================================================================
FILE: ./src/main/java/com/botmaker/core/BlockWithChildren.java
=================================================================================

package com.botmaker.core;

import java.util.List;

public interface BlockWithChildren {
    List<CodeBlock> getChildren();
}


=================================================================================
FILE: ./src/main/java/com/botmaker/core/BodyBlock.java
=================================================================================

package com.botmaker.core;

import com.botmaker.core.AbstractStatementBlock;
import com.botmaker.lsp.CompletionContext;
import com.botmaker.ui.BlockDragAndDropManager;
import com.botmaker.ui.DropInfo;
import javafx.scene.Node;
import javafx.scene.layout.Priority;
import javafx.scene.layout.VBox;

import java.util.ArrayList;
import java.util.List;

public class BodyBlock extends AbstractStatementBlock implements BlockWithChildren {
    private final List<StatementBlock> statements = new ArrayList<>();
    private final BlockDragAndDropManager dragAndDropManager;

    public BodyBlock(String id, org.eclipse.jdt.core.dom.Block astNode, BlockDragAndDropManager dragAndDropManager) {
        super(id, astNode);
        this.dragAndDropManager = dragAndDropManager;
    }

    public void addStatement(StatementBlock statement) {
        statements.add(statement);
    }

    @Override
    public List<CodeBlock> getChildren() {
        return new ArrayList<>(statements);
    }

    @Override
    protected Node createUINode(CompletionContext context) {
        VBox container = new VBox();
        container.getStyleClass().add("body-block");
        VBox.setVgrow(container, Priority.ALWAYS);

        if (statements.isEmpty()) {
            javafx.scene.control.Label placeholder = new javafx.scene.control.Label("Drag block here");
            placeholder.getStyleClass().add("empty-body-placeholder");
            placeholder.setMouseTransparent(true);
            container.getChildren().add(placeholder);
            container.setAlignment(javafx.geometry.Pos.CENTER);
            container.setMinHeight(30);
            dragAndDropManager.addEmptyBodyDropHandlers(container, this);
        } else {
            // Add a separator at the beginning
            container.getChildren().add(createSeparatorWithHandlers(this, 0));

            for (int i = 0; i < statements.size(); i++) {
                StatementBlock statement = statements.get(i);
                container.getChildren().add(statement.getUINode(context));
                // Add a separator after each statement
                container.getChildren().add(createSeparatorWithHandlers(this, i + 1));
            }
        }
        return container;
    }

    private Node createSeparatorWithHandlers(BodyBlock targetBody, int insertionIndex) {
        javafx.scene.layout.Region separator = dragAndDropManager.createSeparator();
        separator.getStyleClass().add("body-block-separator");
        StatementBlock adjacentBlock = (insertionIndex < statements.size()) ? statements.get(insertionIndex) : null;
        dragAndDropManager.addSeparatorDragHandlers(separator, targetBody, insertionIndex, adjacentBlock);
        return separator;
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/core/CodeBlock.java
=================================================================================

package com.botmaker.core;

import com.botmaker.lsp.CompletionContext;
import javafx.scene.Node;
import org.eclipse.jdt.core.dom.ASTNode;

import org.eclipse.jdt.core.dom.CompilationUnit;

public interface CodeBlock {
    String getId();
    ASTNode getAstNode();
    Node getUINode(CompletionContext context);
    Node getUINode();
    void highlight();
    void unhighlight();
    int getBreakpointLine(CompilationUnit cu);
    CodeBlock getHighlightTarget();
    String getDetails();
    void setError(String message);
    void clearError();
}


=================================================================================
FILE: ./src/main/java/com/botmaker/core/ExpressionBlock.java
=================================================================================

package com.botmaker.core;

/**
 * A block that represents a value that can be evaluated.
 * Examples: a literal "hello", a variable `x`, a calculation `2 + 2`.
 */
public interface ExpressionBlock extends CodeBlock {
}


=================================================================================
FILE: ./src/main/java/com/botmaker/core/StatementBlock.java
=================================================================================

package com.botmaker.core;

/**
 * A block that represents a complete action or step in execution.
 * Examples: a variable declaration, an if-statement, a method call.
 */
public interface StatementBlock extends CodeBlock {
}


=================================================================================
FILE: ./src/main/java/com/botmaker/lsp/CompletionContext.java
=================================================================================

package com.botmaker.lsp;

import com.botmaker.Main;
import com.botmaker.parser.CodeEditor;
import com.botmaker.ui.BlockDragAndDropManager;
import org.eclipse.lsp4j.services.LanguageServer;

// Using a record for a simple, immutable data carrier to pass to UI creation.
public record CompletionContext(
        Main mainApp, // Reference to the main application
        CodeEditor codeEditor,
        LanguageServer server,
        String docUri,
        String sourceCode,
        long docVersion,
        BlockDragAndDropManager dragAndDropManager
) {}

=================================================================================
FILE: ./src/main/java/com/botmaker/lsp/JdtLanguageServerLauncher.java
=================================================================================

package com.botmaker.lsp;

import org.eclipse.jdt.core.compiler.IProblem;
import org.eclipse.jdt.internal.compiler.IProblemFactory;
import org.eclipse.jdt.internal.compiler.lookup.ProblemReasons;
import org.eclipse.jdt.internal.compiler.problem.ProblemHandler;
import org.eclipse.jdt.internal.compiler.problem.ProblemReporter;
import org.eclipse.jdt.internal.core.builder.ProblemFactory;
import org.eclipse.lsp4j.*;
import org.eclipse.lsp4j.jsonrpc.Launcher;
import org.eclipse.lsp4j.launch.LSPLauncher;
import org.eclipse.lsp4j.services.LanguageClient;
import org.eclipse.lsp4j.services.LanguageServer;

import java.io.*;
import java.nio.file.*;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.function.Consumer;
import java.util.logging.Level;
import java.util.logging.Logger;

public class JdtLanguageServerLauncher {

    private final Process process;
    private final LanguageServer server;

    public JdtLanguageServerLauncher(Path jdtlsPath, Consumer<PublishDiagnosticsParams> diagnosticsConsumer) throws Exception {
        // Suppress LSP4J warnings about unsupported notifications
        Logger.getLogger("org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint").setLevel(Level.SEVERE);

        // Find the Equinox launcher JAR
        Path launcherJar = Files.list(jdtlsPath.resolve("plugins"))
                .filter(p -> p.getFileName().toString().startsWith("org.eclipse.equinox.launcher_"))
                .findFirst()
                .orElseThrow(() -> new RuntimeException("Launcher JAR not found"));

        String javaExecutable = Paths.get(System.getProperty("java.home"), "bin", "java").toString();
        Path projectDir = Paths.get("./projects");

        // Create a dedicated workspace data directory (not the project itself!)
        Path workspaceData = Paths.get(System.getProperty("user.home"), ".jdtls-workspace", "Demo");
        Files.createDirectories(workspaceData);

        // Build command with all necessary flags from VS Code implementation
        ProcessBuilder pb = new ProcessBuilder(
                javaExecutable,
                // Java 25 specific flags
                "-Djdk.xml.maxGeneralEntitySizeLimit=0",
                "-Djdk.xml.totalEntitySizeLimit=0",
                // Module system flags
                "--add-modules=ALL-SYSTEM",
                "--add-opens", "java.base/java.util=ALL-UNNAMED",
                "--add-opens", "java.base/java.lang=ALL-UNNAMED",
                "--add-opens", "java.base/sun.nio.fs=ALL-UNNAMED",
                // Eclipse/JDT configuration
                "-Declipse.application=org.eclipse.jdt.ls.core.id1",
                "-Dosgi.bundles.defaultStartLevel=4",
                "-Declipse.product=org.eclipse.jdt.ls.core.product",
                // Important: Disable automatic VM detection
                "-DDetectVMInstallationsJob.disabled=true",
                // Encoding
                "-Dfile.encoding=UTF-8",
                // Disable verbose logging
                "-Xlog:disable",
                // Memory settings
                "-Xmx1G",
                // Dependency collector (improves Maven/Gradle performance)
                "-Daether.dependencyCollector.impl=bf",
                // Suppress JavaFX warnings about restricted methods
                "--enable-native-access=javafx.graphics",
                // Logging (remove these for production, useful for debugging)
                "-Dlog.protocol=true",
                "-Dlog.level=ALL",
                // Launcher JAR
                "-jar", launcherJar.toString(),
                // Configuration directory
                "-configuration", jdtlsPath.resolve("config_linux").toString(),
                // Workspace data directory (NOT your project directory!)
                "-data", workspaceData.toString()
        );

        process = pb.start();

        // Log the error stream separately to see any server-side issues.
        new Thread(() -> {
            try (BufferedReader br = new BufferedReader(new InputStreamReader(process.getErrorStream()))) {
                String line;
                while ((line = br.readLine()) != null) {
                    System.err.println("[JDT LS ERR] " + line);
                }
            } catch (IOException ignored) {}
        }).start();

        // Connect LSP4J client to the process
        Launcher<LanguageServer> launcher = LSPLauncher.createClientLauncher(
                new SimpleLanguageClient(diagnosticsConsumer),
                process.getInputStream(),
                process.getOutputStream()
        );

        launcher.startListening();
        server = launcher.getRemoteProxy();

        // Initialize LSP params
        InitializeParams init = new InitializeParams();
        init.setProcessId((int) ProcessHandle.current().pid());

        // Set up client capabilities
        ClientCapabilities capabilities = new ClientCapabilities();
        WorkspaceClientCapabilities workspaceCaps = new WorkspaceClientCapabilities();
        workspaceCaps.setDidChangeConfiguration(new DidChangeConfigurationCapabilities(true));
        workspaceCaps.setWorkspaceFolders(true);
        capabilities.setWorkspace(workspaceCaps);

        TextDocumentClientCapabilities textDocCaps = new TextDocumentClientCapabilities();
        capabilities.setTextDocument(textDocCaps);

        init.setCapabilities(capabilities);

        // Add workspace folder - this should point to your actual project
        WorkspaceFolder folder = new WorkspaceFolder(projectDir.toUri().toString());
        init.setWorkspaceFolders(List.of(folder));
        init.setRootUri(folder.getUri());

        System.out.println("Workspace root: " + folder.getUri());
        System.out.println("Workspace data: " + workspaceData);

        // Initialize the server
        InitializeResult result = server.initialize(init).get();
        System.out.println("Server initialized: " + result.getCapabilities());

        // Send initialized notification
        server.initialized(new InitializedParams());
    }

    public LanguageServer getServer() {
        return server;
    }

    public void stop() {
        try { server.shutdown().get(); } catch (Exception ignored) {}
        server.exit();
        process.destroy();
    }

    // Minimal LSP client
    static class SimpleLanguageClient implements LanguageClient {
        private final Consumer<PublishDiagnosticsParams> diagnosticsConsumer;

        public SimpleLanguageClient(Consumer<PublishDiagnosticsParams> diagnosticsConsumer) {
            this.diagnosticsConsumer = diagnosticsConsumer;
        }

        @Override
        public void telemetryEvent(Object o) {
            System.out.println("[Telemetry] " + o);
        }

        @Override
        public void publishDiagnostics(PublishDiagnosticsParams diagnostics) {
            System.out.println("[Diagnostics] " + diagnostics.getUri() + " -> " + diagnostics.getDiagnostics().size() + " issues");
            if (diagnosticsConsumer != null) {
                diagnosticsConsumer.accept(diagnostics);
            }
        }

        @Override
        public void showMessage(MessageParams messageParams) {
            System.out.println("[Message] " + messageParams.getMessage());
        }

        @Override
        public CompletableFuture<MessageActionItem> showMessageRequest(ShowMessageRequestParams showMessageRequestParams) {
            System.out.println("[MessageRequest] " + showMessageRequestParams.getMessage());
            return CompletableFuture.completedFuture(null);
        }

        @Override
        public void logMessage(MessageParams messageParams) {
            System.out.println("[Log] " + messageParams.getMessage());
        }

        @Override
        public CompletableFuture<Void> registerCapability(RegistrationParams params) {
            System.out.println("[RegisterCapability] " + params.getRegistrations().size() + " capabilities");
            return CompletableFuture.completedFuture(null);
        }

        @Override
        public CompletableFuture<Void> unregisterCapability(UnregistrationParams params) {
            System.out.println("[UnregisterCapability] " + params.getUnregisterations().size() + " capabilities");
            return CompletableFuture.completedFuture(null);
        }
    }
}


=================================================================================
FILE: ./src/main/java/com/botmaker/Main.java
=================================================================================

package com.botmaker;

import com.botmaker.blocks.MainBlock;
import com.botmaker.core.BodyBlock;
import com.botmaker.core.CodeBlock;
import com.botmaker.lsp.CompletionContext;
import com.botmaker.lsp.JdtLanguageServerLauncher;
import com.botmaker.parser.AstRewriter;
import com.botmaker.parser.BlockFactory;
import com.botmaker.parser.CodeEditor;
import com.botmaker.runtime.CodeExecutionService;
import com.botmaker.runtime.DebuggingManager;
import com.botmaker.ui.BlockDragAndDropManager;
import com.botmaker.ui.UIManager;
import javafx.application.Application;
import javafx.application.Platform;
import javafx.stage.Stage;
import org.eclipse.jdt.core.dom.ASTNode;
import org.eclipse.lsp4j.DidChangeTextDocumentParams;
import org.eclipse.lsp4j.DidOpenTextDocumentParams;
import org.eclipse.lsp4j.TextDocumentContentChangeEvent;
import org.eclipse.lsp4j.TextDocumentItem;
import org.eclipse.lsp4j.VersionedTextDocumentIdentifier;
import org.eclipse.lsp4j.services.LanguageServer;

import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class Main extends Application {

    private LanguageServer jdtServer;
    private final BlockFactory factory = new BlockFactory();
    private String docUri;
    private String currentCode;
    private long docVersion = 1;

    private Map<ASTNode, CodeBlock> nodeToBlockMap;
    private CodeBlock highlightedBlock;

    private UIManager uiManager;
    private CodeExecutionService executionService;
    private DebuggingManager debuggingManager;
    private BlockDragAndDropManager dragAndDropManager;
    private AstRewriter astRewriter;
    private CodeEditor codeEditor;
    private com.botmaker.validation.DiagnosticsManager diagnosticsManager;

    @Override
    public void start(Stage primaryStage) throws Exception {
        diagnosticsManager = new com.botmaker.validation.DiagnosticsManager();
        JdtLanguageServerLauncher launcher = new JdtLanguageServerLauncher(Paths.get("tools/jdt-language-server"), (params) -> {
            // This is called on a background thread.
            // We pass the params to the FX thread to do all UI work.
            Platform.runLater(() -> {
                diagnosticsManager.processDiagnostics(params.getDiagnostics());
                uiManager.updateErrors(diagnosticsManager.getDiagnostics());
                uiManager.getStatusLabel().setText(diagnosticsManager.getErrorSummary());
            });
        });
        jdtServer = launcher.getServer();

        astRewriter = new AstRewriter();
        codeEditor = new CodeEditor(this, astRewriter, factory);

        dragAndDropManager = new BlockDragAndDropManager(dropInfo ->
                codeEditor.addStatement(dropInfo.targetBody(), dropInfo.type(), dropInfo.insertionIndex()));

        uiManager = new UIManager(this, dragAndDropManager);
        primaryStage.setScene(uiManager.createScene());

        executionService = new CodeExecutionService(
                uiManager.getOutputArea()::appendText,
                uiManager.getOutputArea()::clear,
                uiManager.getOutputArea()::setText,
                uiManager.getStatusLabel()::setText,
                diagnosticsManager
        );

        debuggingManager = new DebuggingManager(
                executionService,
                uiManager.getStatusLabel()::setText,
                uiManager.getOutputArea()::appendText,
                uiManager.getOutputArea()::clear,
                uiManager::onDebuggerStarted,
                uiManager::onDebuggerPaused,
                uiManager::onDebuggerResumed,
                uiManager::onDebuggerFinished,
                this::highlightBlock,
                factory
        );

        Path docPath = Paths.get("./projects/src/main/java/com/demo/Demo.java").toAbsolutePath();
        docUri = docPath.toUri().toString();
        currentCode = Files.readString(docPath);

        jdtServer.getTextDocumentService().didOpen(new DidOpenTextDocumentParams(
                new TextDocumentItem(docUri, "java", (int) docVersion, currentCode)
        ));

        refreshUI(currentCode);

        primaryStage.setTitle("BotMaker Blocks");
        primaryStage.show();

        primaryStage.setOnCloseRequest(e -> {
            launcher.stop();
            Platform.exit();
        });
    }

    public void compileCode() {
        executionService.compileCode(currentCode);
    }

    public void runCode() {
        executionService.runCode(currentCode);
    }

    public void startDebugging() {
        debuggingManager.setNodeToBlockMap(nodeToBlockMap);
        debuggingManager.startDebugging(currentCode);
    }

    public void resumeDebugging() {
        debuggingManager.resume();
    }

    public void handleCodeUpdate(String newCode) {
        try {
            Files.writeString(Paths.get(new java.net.URI(docUri)), newCode);
        } catch (java.io.IOException | java.net.URISyntaxException e) {
            e.printStackTrace();
            Platform.runLater(() -> uiManager.getStatusLabel().setText("Error saving file: " + e.getMessage()));
        }

        this.docVersion++;
        jdtServer.getTextDocumentService().didChange(new DidChangeTextDocumentParams(
                new VersionedTextDocumentIdentifier(docUri, (int) docVersion),
                List.of(new TextDocumentContentChangeEvent(newCode))
        ));
        refreshUI(newCode);
    }

    private void refreshUI(String javaCode) {
        this.currentCode = javaCode;
        this.nodeToBlockMap = new HashMap<>();
        if (diagnosticsManager != null) {
            diagnosticsManager.updateSource(nodeToBlockMap, currentCode);
        }
        uiManager.getBlocksContainer().getChildren().clear();

        CompletionContext context = new CompletionContext(
                this,
                codeEditor,
                jdtServer,
                docUri,
                currentCode,
                docVersion,
                dragAndDropManager
        );

        MainBlock rootBlock = factory.convert(javaCode, nodeToBlockMap, dragAndDropManager);

        if (rootBlock != null) {
            uiManager.getBlocksContainer().getChildren().add(rootBlock.getUINode(context));
        }
        uiManager.getStatusLabel().setText("UI Refreshed.");
    }

    private void highlightBlock(CodeBlock block) {
        if (highlightedBlock != null) {
            highlightedBlock.unhighlight();
        }
        highlightedBlock = block;
        if (highlightedBlock != null) {
            highlightedBlock.highlight();
        }
    }

    public String getCurrentCode() {
        return currentCode;
    }

    public BlockFactory getBlockFactory() {
        return factory;
    }

    public LanguageServer getJdtServer() {
        return jdtServer;
    }

    public String getDocUri() {
        return docUri;
    }

    public com.botmaker.validation.DiagnosticsManager getDiagnosticsManager() {
        return diagnosticsManager;
    }

    public static void main(String[] args) {
        launch(args);
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/parser/AstRewriter.java
=================================================================================

package com.botmaker.parser;

import com.botmaker.core.BodyBlock;
import com.botmaker.ui.AddableBlock;
import com.botmaker.util.TypeManager;
import org.eclipse.jdt.core.dom.*;
import org.eclipse.jdt.core.dom.rewrite.ASTRewrite;
import org.eclipse.jdt.core.dom.rewrite.ListRewrite;
import org.eclipse.jface.text.Document;
import org.eclipse.jface.text.IDocument;
import org.eclipse.text.edits.TextEdit;

public class AstRewriter {

    public String addStatement(CompilationUnit cu, String originalCode, BodyBlock targetBody, AddableBlock type, int index) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);

        Statement newStatement = createDefaultStatement(ast, type);
        if (newStatement == null) {
            return originalCode; // Or throw an exception
        }

        Block targetAstBlock = (Block) targetBody.getAstNode();
        ListRewrite listRewrite = rewriter.getListRewrite(targetAstBlock, Block.STATEMENTS_PROPERTY);
        listRewrite.insertAt(newStatement, index, null);

        IDocument document = new Document(originalCode);
        try {
            TextEdit edits = rewriter.rewriteAST(document, null);
            edits.apply(document);
            return document.get();
        } catch (Exception e) {
            e.printStackTrace();
            return originalCode; // Return original on failure
        }
    }

    public String replaceExpression(CompilationUnit cu, String originalCode, Expression toReplace, com.botmaker.ui.AddableExpression type) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);

        Expression newExpression = createDefaultExpression(ast, type);
        if (newExpression == null) {
            return originalCode;
        }

        rewriter.replace(toReplace, newExpression, null);

        IDocument document = new Document(originalCode);
        try {
            TextEdit edits = rewriter.rewriteAST(document, null);
            edits.apply(document);
            return document.get();
        } catch (Exception e) {
            e.printStackTrace();
            return originalCode; // Return original on failure
        }
    }

    public String replaceLiteral(CompilationUnit cu, String originalCode, Expression toReplace, String newLiteralValue) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);

        Expression newExpression;
        if (toReplace instanceof StringLiteral) {
            StringLiteral newString = ast.newStringLiteral();
            newString.setLiteralValue(newLiteralValue);
            newExpression = newString;
        } else if (toReplace instanceof NumberLiteral) {
            newExpression = ast.newNumberLiteral(newLiteralValue);
        } else if (toReplace instanceof BooleanLiteral) {
            newExpression = ast.newBooleanLiteral(Boolean.parseBoolean(newLiteralValue));
        } else {
            // Not a literal we can handle, return original code
            return originalCode;
        }

        rewriter.replace(toReplace, newExpression, null);

        IDocument document = new Document(originalCode);
        try {
            TextEdit edits = rewriter.rewriteAST(document, null);
            edits.apply(document);
            return document.get();
        } catch (Exception e) {
            e.printStackTrace();
            return originalCode;
        }
    }

    public String addArgumentToMethodInvocation(CompilationUnit cu, String originalCode, MethodInvocation mi, Expression newArgument) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);
        ListRewrite listRewrite = rewriter.getListRewrite(mi, MethodInvocation.ARGUMENTS_PROPERTY);
        listRewrite.insertLast(newArgument, null);

        IDocument document = new Document(originalCode);
        try {
            TextEdit edits = rewriter.rewriteAST(document, null);
            edits.apply(document);
            return document.get();
        } catch (Exception e) {
            e.printStackTrace();
            return originalCode; // Return original on failure
        }
    }

    public String replaceSimpleName(CompilationUnit cu, String originalCode, SimpleName toReplace, String newName) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);
        SimpleName newSimpleName = ast.newSimpleName(newName);
        rewriter.replace(toReplace, newSimpleName, null);

        IDocument document = new Document(originalCode);
        try {
            TextEdit edits = rewriter.rewriteAST(document, null);
            edits.apply(document);
            return document.get();
        } catch (Exception e) {
            e.printStackTrace();
            return originalCode;
        }
    }

    public String deleteNode(CompilationUnit cu, String originalCode, ASTNode toDelete) {
        ASTRewrite rewriter = ASTRewrite.create(cu.getAST());
        rewriter.remove(toDelete, null);

        IDocument document = new Document(originalCode);
        try {
            TextEdit edits = rewriter.rewriteAST(document, null);
            edits.apply(document);
            return document.get();
        } catch (Exception e) {
            e.printStackTrace();
            return originalCode;
        }
    }

    public String deleteElseFromIfStatement(CompilationUnit cu, String originalCode, IfStatement ifStatement) {
        ASTRewrite rewriter = ASTRewrite.create(cu.getAST());
        if (ifStatement.getElseStatement() != null) {
            rewriter.remove(ifStatement.getElseStatement(), null);
        } else {
            return originalCode;
        }
        IDocument document = new Document(originalCode);
        try {
            TextEdit edits = rewriter.rewriteAST(document, null);
            edits.apply(document);
            return document.get();
        } catch (Exception e) {
            e.printStackTrace();
            return originalCode;
        }
    }

    public String convertElseToElseIf(CompilationUnit cu, String originalCode, IfStatement ifStatement) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);
        Statement elseStatement = ifStatement.getElseStatement();
        if (elseStatement == null || elseStatement.getNodeType() != ASTNode.BLOCK) {
            return originalCode;
        }
        IfStatement newElseIf = ast.newIfStatement();
        newElseIf.setExpression(ast.newBooleanLiteral(true));
        newElseIf.setThenStatement((Block) ASTNode.copySubtree(ast, elseStatement));
        rewriter.replace(elseStatement, newElseIf, null);
        IDocument document = new Document(originalCode);
        try {
            TextEdit edits = rewriter.rewriteAST(document, null);
            edits.apply(document);
            return document.get();
        } catch (Exception e) {
            e.printStackTrace();
            return originalCode;
        }
    }

    public String addElseToIfStatement(CompilationUnit cu, String originalCode, IfStatement ifStatement) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);

        if (ifStatement.getElseStatement() == null) {
            Block elseBlock = ast.newBlock();
            rewriter.set(ifStatement, IfStatement.ELSE_STATEMENT_PROPERTY, elseBlock, null);
        } else {
            // else already exists, do nothing
            return originalCode;
        }

        IDocument document = new Document(originalCode);
        try {
            TextEdit edits = rewriter.rewriteAST(document, null);
            edits.apply(document);
            return document.get();
        } catch (Exception e) {
            e.printStackTrace();
            return originalCode;
        }
    }

    private Expression createDefaultExpression(AST ast, com.botmaker.ui.AddableExpression type) {
        switch (type) {
            case TEXT:
                StringLiteral newString = ast.newStringLiteral();
                newString.setLiteralValue("text");
                return newString;
            case VARIABLE:
                return ast.newSimpleName("defaultVar");
            default:
                return null;
        }
    }

    private Statement createDefaultStatement(AST ast, AddableBlock type) {
        switch (type) {
            case PRINT:
                // System.out.println("");
                MethodInvocation println = ast.newMethodInvocation();
                println.setExpression(ast.newQualifiedName(
                        ast.newSimpleName("System"),
                        ast.newSimpleName("out"))
                );
                println.setName(ast.newSimpleName("println"));
                StringLiteral emptyString = ast.newStringLiteral();
                emptyString.setLiteralValue("");
                println.arguments().add(emptyString);
                return ast.newExpressionStatement(println);

            case DECLARE_INT: {
                VariableDeclarationFragment fragment = ast.newVariableDeclarationFragment();
                fragment.setName(ast.newSimpleName("i"));
                fragment.setInitializer(ast.newNumberLiteral("0"));
                VariableDeclarationStatement varDecl = ast.newVariableDeclarationStatement(fragment);
                varDecl.setType(ast.newPrimitiveType(PrimitiveType.INT));
                return varDecl;
            }
            case DECLARE_DOUBLE: {
                VariableDeclarationFragment fragment = ast.newVariableDeclarationFragment();
                fragment.setName(ast.newSimpleName("d"));
                fragment.setInitializer(ast.newNumberLiteral("0.0"));
                VariableDeclarationStatement varDecl = ast.newVariableDeclarationStatement(fragment);
                varDecl.setType(ast.newPrimitiveType(PrimitiveType.DOUBLE));
                return varDecl;
            }
            case DECLARE_BOOLEAN: {
                VariableDeclarationFragment fragment = ast.newVariableDeclarationFragment();
                fragment.setName(ast.newSimpleName("b"));
                fragment.setInitializer(ast.newBooleanLiteral(false));
                VariableDeclarationStatement varDecl = ast.newVariableDeclarationStatement(fragment);
                varDecl.setType(ast.newPrimitiveType(PrimitiveType.BOOLEAN));
                return varDecl;
            }
            case DECLARE_STRING: {
                VariableDeclarationFragment fragment = ast.newVariableDeclarationFragment();
                fragment.setName(ast.newSimpleName("s"));
                fragment.setInitializer(ast.newStringLiteral());
                VariableDeclarationStatement varDecl = ast.newVariableDeclarationStatement(fragment);
                varDecl.setType(TypeManager.createTypeNode(ast, "String"));
                return varDecl;
            }

            case IF:
                // if (true) {}
                IfStatement ifStatement = ast.newIfStatement();
                ifStatement.setExpression(ast.newBooleanLiteral(true));
                ifStatement.setThenStatement(ast.newBlock());
                return ifStatement;

            default:
                return null;
        }
    }

    private Expression createDefaultInitializer(AST ast, String typeName) {
        switch (typeName) {
            case "int":
            case "long":
            case "short":
            case "byte":
                return ast.newNumberLiteral("0");
            case "double":
            case "float":
                return ast.newNumberLiteral("0.0");
            case "boolean":
                return ast.newBooleanLiteral(false);
            case "char":
                CharacterLiteral literal = ast.newCharacterLiteral();
                literal.setCharValue('a'); // Default char
                return literal;
            case "String":
                StringLiteral stringLiteral = ast.newStringLiteral();
                stringLiteral.setLiteralValue(""); // Default empty string
                return stringLiteral;
            default:
                // For any other object type, the safest default is null.
                return ast.newNullLiteral();
        }
    }

    public String replaceVariableType(CompilationUnit cu, String originalCode, VariableDeclarationStatement varDecl, String newTypeName) {
        AST ast = cu.getAST();
        ASTRewrite rewriter = ASTRewrite.create(ast);

        // 1. Create the new type node
        Type newType = TypeManager.createTypeNode(ast, newTypeName);
        rewriter.replace(varDecl.getType(), newType, null);

        // 2. Get the fragment and its current initializer
        if (!varDecl.fragments().isEmpty()) {
            VariableDeclarationFragment fragment = (VariableDeclarationFragment) varDecl.fragments().get(0);
            Expression currentInitializer = fragment.getInitializer();

            // 3. Create a new default initializer based on the new type
            Expression newInitializer = createDefaultInitializer(ast, newTypeName);

            // 4. Replace the old initializer if it exists and we have a new one
            if (currentInitializer != null && newInitializer != null) {
                rewriter.replace(currentInitializer, newInitializer, null);
            }
        }

        IDocument document = new Document(originalCode);
        try {
            TextEdit edits = rewriter.rewriteAST(document, null);
            edits.apply(document);
            return document.get();
        } catch (Exception e) {
            e.printStackTrace();
            return originalCode;
        }
    }
}


=================================================================================
FILE: ./src/main/java/com/botmaker/parser/BlockFactory.java
=================================================================================

package com.botmaker.parser;

import com.botmaker.blocks.*;
import com.botmaker.core.*;
import com.botmaker.ui.BlockDragAndDropManager;
import org.eclipse.jdt.core.dom.*;
import org.eclipse.jdt.core.dom.IMethodBinding;
import org.eclipse.jdt.core.dom.ITypeBinding;

import java.util.Map;
import java.util.Optional;

public class BlockFactory {

    private CompilationUnit ast;
    private boolean markNewIdentifiersAsUnedited = false;

    public MainBlock convert(String javaCode, Map<ASTNode, CodeBlock> nodeToBlockMap, BlockDragAndDropManager manager) {
        try {
            ASTParser parser = ASTParser.newParser(AST.getJLSLatest());
            parser.setSource(javaCode.toCharArray());
            parser.setResolveBindings(true);
            parser.setKind(ASTParser.K_COMPILATION_UNIT);
            parser.setUnitName("Demo.java");
            parser.setEnvironment(null, null, null, true);
            this.ast = (CompilationUnit) parser.createAST(null);

            MainMethodVisitor visitor = new MainMethodVisitor();
            ast.accept(visitor);

            return visitor.getMainMethodDeclaration()
                    .map(mainMethodDecl -> {
                        MainBlock mainBlock = new MainBlock("main_" + mainMethodDecl.hashCode(), mainMethodDecl);
                        nodeToBlockMap.put(mainMethodDecl, mainBlock);
                        visitor.getMainMethodBody().ifPresent(bodyAstNode -> {
                            BodyBlock bodyBlock = parseBodyBlock(bodyAstNode, nodeToBlockMap, manager);
                            mainBlock.setMainBody(bodyBlock);
                        });
                        return mainBlock;
                    })
                    .orElse(null);
        } finally {
            setMarkNewIdentifiersAsUnedited(false);
        }
    }

    /**
     * Enable marking of newly created identifiers as unedited
     * Call this before converting code that contains newly added blocks
     */
    public void setMarkNewIdentifiersAsUnedited(boolean mark) {
        this.markNewIdentifiersAsUnedited = mark;
    }

    private BodyBlock parseBodyBlock(Block astBlock, Map<ASTNode, CodeBlock> nodeToBlockMap, BlockDragAndDropManager manager) {
        System.out.println("Creating BodyBlock for: " + astBlock.hashCode());
        BodyBlock bodyBlock = new BodyBlock("body_" + astBlock.hashCode(), astBlock, manager);
        nodeToBlockMap.put(astBlock, bodyBlock);
        for (Object statementObj : astBlock.statements()) {
            Statement statement = (Statement) statementObj;
            parseStatement(statement, nodeToBlockMap, manager).ifPresent(bodyBlock::addStatement);
        }
        return bodyBlock;
    }

    private Optional<StatementBlock> parseStatement(Statement astStatement, Map<ASTNode, CodeBlock> nodeToBlockMap, BlockDragAndDropManager manager) {
        if (astStatement instanceof Block) {
            return Optional.of(parseBodyBlock((Block) astStatement, nodeToBlockMap, manager));
        }
        if (astStatement instanceof VariableDeclarationStatement) {
            return Optional.of(parseVariableDeclaration((VariableDeclarationStatement) astStatement, nodeToBlockMap));
        }
        if (astStatement instanceof IfStatement) {
            return Optional.of(parseIfStatement((IfStatement) astStatement, nodeToBlockMap, manager));
        }
        if (astStatement instanceof ExpressionStatement) {
            Expression expression = ((ExpressionStatement) astStatement).getExpression();
            if (isPrintStatement(expression)) {
                return Optional.of(parsePrintStatement((ExpressionStatement) astStatement, nodeToBlockMap));
            }
        }
        return Optional.empty();
    }

    private VariableDeclarationBlock parseVariableDeclaration(VariableDeclarationStatement astNode, Map<ASTNode, CodeBlock> nodeToBlockMap) {
        System.out.println("Creating VariableDeclarationBlock for: " + astNode);
        VariableDeclarationBlock varBlock = new VariableDeclarationBlock("var_" + astNode.hashCode(), astNode);
        nodeToBlockMap.put(astNode, varBlock);
        VariableDeclarationFragment fragment = (VariableDeclarationFragment) astNode.fragments().get(0);

        if (fragment.getInitializer() != null) {
            parseExpression(fragment.getInitializer(), nodeToBlockMap).ifPresent(varBlock::setInitializer);
        }
        return varBlock;
    }

    private IfBlock parseIfStatement(IfStatement astNode, Map<ASTNode, CodeBlock> nodeToBlockMap, BlockDragAndDropManager manager) {
        System.out.println("Creating IfBlock for: " + astNode);
        IfBlock ifBlock = new IfBlock("if_" + astNode.hashCode(), astNode);
        nodeToBlockMap.put(astNode, ifBlock);
        parseExpression(astNode.getExpression(), nodeToBlockMap).ifPresent(ifBlock::setCondition);

        if (astNode.getThenStatement() instanceof Block) {
            ifBlock.setThenBody(parseBodyBlock((Block) astNode.getThenStatement(), nodeToBlockMap, manager));
        }

        Statement elseStmt = astNode.getElseStatement();
        if (elseStmt != null) {
            parseStatement(elseStmt, nodeToBlockMap, manager).ifPresent(ifBlock::setElseStatement);
        }

        return ifBlock;
    }

    private PrintBlock parsePrintStatement(ExpressionStatement astNode, Map<ASTNode, CodeBlock> nodeToBlockMap) {
        System.out.println("Creating PrintBlock for: " + astNode);
        PrintBlock printBlock = new PrintBlock("print_" + astNode.hashCode(), astNode);
        nodeToBlockMap.put(astNode, printBlock);

        MethodInvocation methodInvocation = (MethodInvocation) astNode.getExpression();

        if (methodInvocation.arguments().isEmpty()) {
            System.out.println("Creating synthetic String LiteralBlock for empty println");
            LiteralBlock<String> block = new LiteralBlock<>("synthetic_string_" + astNode.hashCode(), methodInvocation, "");
            printBlock.addArgument(block);
        } else {
            for (Object arg : methodInvocation.arguments()) {
                parseExpression((Expression) arg, nodeToBlockMap).ifPresent(printBlock::addArgument);
            }
        }
        return printBlock;
    }

    private BinaryExpressionBlock parseBinaryExpression(InfixExpression astNode, Map<ASTNode, CodeBlock> nodeToBlockMap) {
        System.out.println("Creating BinaryExpressionBlock for: " + astNode);
        BinaryExpressionBlock binaryBlock = new BinaryExpressionBlock("binary_" + astNode.hashCode(), astNode);
        nodeToBlockMap.put(astNode, binaryBlock);
        parseExpression(astNode.getLeftOperand(), nodeToBlockMap).ifPresent(binaryBlock::setLeftOperand);
        parseExpression(astNode.getRightOperand(), nodeToBlockMap).ifPresent(binaryBlock::setRightOperand);
        return binaryBlock;
    }

    private Optional<ExpressionBlock> parseExpression(Expression astExpression, Map<ASTNode, CodeBlock> nodeToBlockMap) {
        if (astExpression instanceof StringLiteral) {
            System.out.println("Creating String LiteralBlock for: " + astExpression);
            StringLiteral literalNode = (StringLiteral) astExpression;
            LiteralBlock<String> block = new LiteralBlock<>("string_" + literalNode.hashCode(), literalNode, literalNode.getLiteralValue());
            nodeToBlockMap.put(astExpression, block);
            return Optional.of(block);
        }
        if (astExpression instanceof NumberLiteral) {
            System.out.println("Creating Number LiteralBlock for: " + astExpression);
            NumberLiteral literalNode = (NumberLiteral) astExpression;
            String token = literalNode.getToken();
            ExpressionBlock block;
            if (token.toLowerCase().endsWith("f")) {
                block = new LiteralBlock<>("float_" + literalNode.hashCode(), literalNode, Float.parseFloat(token));
            } else if (token.contains(".") || token.toLowerCase().endsWith("d")) {
                block = new LiteralBlock<>("double_" + literalNode.hashCode(), literalNode, Double.parseDouble(token));
            } else {
                block = new LiteralBlock<>("int_" + literalNode.hashCode(), literalNode, Integer.parseInt(token));
            }
            nodeToBlockMap.put(astExpression, block);
            return Optional.of(block);
        }
        if (astExpression instanceof BooleanLiteral) {
            System.out.println("Creating Boolean LiteralBlock for: " + astExpression);
            BooleanLiteral literalNode = (BooleanLiteral) astExpression;
            LiteralBlock<Boolean> block = new LiteralBlock<>("boolean_" + literalNode.hashCode(), literalNode, literalNode.booleanValue());
            nodeToBlockMap.put(astExpression, block);
            return Optional.of(block);
        }
        if (astExpression instanceof SimpleName) {
            // Do not convert type names into identifier blocks
            if (astExpression.getParent() instanceof Type) {
                return Optional.empty();
            }
            System.out.println("Creating IdentifierBlock for: " + astExpression);
            SimpleName simpleName = (SimpleName) astExpression;

            // Check if this identifier should be marked as unedited
            boolean shouldMarkAsUnedited = markNewIdentifiersAsUnedited &&
                    "defaultVar".equals(simpleName.getIdentifier());

            IdentifierBlock block = new IdentifierBlock("id_" + astExpression.hashCode(), simpleName, shouldMarkAsUnedited);
            nodeToBlockMap.put(astExpression, block);
            return Optional.of(block);
        }
        if (astExpression instanceof InfixExpression) {
            return Optional.of(parseBinaryExpression((InfixExpression) astExpression, nodeToBlockMap));
        }
        return Optional.empty();
    }

    private boolean isPrintStatement(Expression expression) {
        if (!(expression instanceof MethodInvocation)) {
            return false;
        }
        MethodInvocation method = (MethodInvocation) expression;

        if (!method.getName().getIdentifier().equals("println")) {
            return false;
        }

        if (method.arguments().isEmpty()) {
            return method.toString().startsWith("System.out.println");
        } else {
            Expression expr = method.getExpression();
            return expr != null && "System.out".equals(expr.toString());
        }
    }

    public CompilationUnit getCompilationUnit() {
        return ast;
    }

    private static class MainMethodVisitor extends ASTVisitor {
        private MethodDeclaration mainMethodDeclaration;

        @Override
        public boolean visit(MethodDeclaration node) {
            if ("main".equals(node.getName().getIdentifier())) {
                mainMethodDeclaration = node;
                return false;
            }
            return true;
        }

        public Optional<MethodDeclaration> getMainMethodDeclaration() {
            return Optional.ofNullable(mainMethodDeclaration);
        }

        public Optional<Block> getMainMethodBody() {
            return Optional.ofNullable(mainMethodDeclaration != null ? mainMethodDeclaration.getBody() : null);
        }
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/parser/CodeEditor.java
=================================================================================

package com.botmaker.parser;

import com.botmaker.core.BodyBlock;
import com.botmaker.ui.AddableBlock;
import com.botmaker.ui.AddableExpression;
import javafx.application.Platform;
import org.eclipse.jdt.core.dom.*;
import com.botmaker.Main;

public class CodeEditor {

    private final Main mainApp;
    private final AstRewriter astRewriter;
    private final BlockFactory blockFactory;

    public CodeEditor(Main mainApp, AstRewriter astRewriter, BlockFactory blockFactory) {
        this.mainApp = mainApp;
        this.astRewriter = astRewriter;
        this.blockFactory = blockFactory;
    }

    private String getCurrentCode() {
        return mainApp.getCurrentCode();
    }

    private CompilationUnit getCompilationUnit() {
        return blockFactory.getCompilationUnit();
    }

    private void triggerUpdate(String newCode) {
        Platform.runLater(() -> mainApp.handleCodeUpdate(newCode));
    }

    public void replaceLiteralValue(Expression toReplace, String newLiteralValue) {
        String newCode = astRewriter.replaceLiteral(
                getCompilationUnit(),
                getCurrentCode(),
                toReplace,
                newLiteralValue
        );
        triggerUpdate(newCode);
    }

    public void addStringArgumentToMethodInvocation(MethodInvocation mi, String text) {
        AST ast = getCompilationUnit().getAST();
        StringLiteral newArg = ast.newStringLiteral();
        newArg.setLiteralValue(text);

        String newCode = astRewriter.addArgumentToMethodInvocation(
                getCompilationUnit(),
                getCurrentCode(),
                mi,
                newArg
        );
        triggerUpdate(newCode);
    }

    public void replaceExpression(Expression toReplace, AddableExpression type) {
        blockFactory.setMarkNewIdentifiersAsUnedited(true);
        String newCode = astRewriter.replaceExpression(
                getCompilationUnit(),
                getCurrentCode(),
                toReplace,
                type
        );
        triggerUpdate(newCode);
    }

    public void addStatement(BodyBlock targetBody, AddableBlock type, int index) {
        blockFactory.setMarkNewIdentifiersAsUnedited(true);
        String newCode = astRewriter.addStatement(
                getCompilationUnit(),
                getCurrentCode(),
                targetBody,
                type,
                index
        );
        triggerUpdate(newCode);
    }

    public void deleteElseFromIfStatement(IfStatement ifStmt) {
        String newCode = astRewriter.deleteElseFromIfStatement(getCompilationUnit(), getCurrentCode(), ifStmt);
        triggerUpdate(newCode);
    }

    public void convertElseToElseIf(IfStatement ifStmt) {
        String newCode = astRewriter.convertElseToElseIf(getCompilationUnit(), getCurrentCode(), ifStmt);
        triggerUpdate(newCode);
    }

    public void addElseToIfStatement(IfStatement ifStmt) {
        String newCode = astRewriter.addElseToIfStatement(
                getCompilationUnit(),
                getCurrentCode(),
                ifStmt
        );
        triggerUpdate(newCode);
    }

    public void replaceSimpleName(SimpleName toReplace, String newName) {
        String newCode = astRewriter.replaceSimpleName(
            getCompilationUnit(),
            getCurrentCode(),
            toReplace,
            newName
        );
        triggerUpdate(newCode);
    }

    public void deleteStatement(Statement toDelete) {
        String newCode = astRewriter.deleteNode(
                getCompilationUnit(),
                getCurrentCode(),
                toDelete
        );
        triggerUpdate(newCode);
    }

    public void replaceVariableType(VariableDeclarationStatement toReplace, String newTypeName) {
        String newCode = astRewriter.replaceVariableType(
            getCompilationUnit(),
            getCurrentCode(),
            toReplace,
            newTypeName
        );
        triggerUpdate(newCode);
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/runtime/CodeExecutionService.java
=================================================================================

package com.botmaker.runtime;

import javafx.application.Platform;

import java.io.IOException;
import java.io.InputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Scanner;
import java.util.function.Consumer;

public class CodeExecutionService {

    private final Consumer<String> appendOutputConsumer;
    private final Runnable clearOutputConsumer;
    private final Consumer<String> statusConsumer;
    private final Consumer<String> setOutputConsumer;
    private final com.botmaker.validation.DiagnosticsManager diagnosticsManager;

    public CodeExecutionService(Consumer<String> appendOutputConsumer, Runnable clearOutputConsumer, Consumer<String> setOutputConsumer, Consumer<String> statusConsumer, com.botmaker.validation.DiagnosticsManager diagnosticsManager) {
        this.appendOutputConsumer = appendOutputConsumer;
        this.clearOutputConsumer = clearOutputConsumer;
        this.setOutputConsumer = setOutputConsumer;
        this.statusConsumer = statusConsumer;
        this.diagnosticsManager = diagnosticsManager;
    }

    public void runCode(String code) {
        if (diagnosticsManager.hasErrors()) {
            String translatedErrors = com.botmaker.validation.ErrorTranslator.translate(diagnosticsManager.getDiagnostics());
            System.err.println(translatedErrors);
            Platform.runLater(() -> {
                statusConsumer.accept("Run aborted due to errors.");
            });
            return; // Abort run
        }

        new Thread(() -> {
            try {
                if (!compileAndWait(code)) {
                    Platform.runLater(() -> statusConsumer.accept("Run aborted due to compilation failure."));
                    return;
                }

                Platform.runLater(() -> {
                    statusConsumer.accept("Running code...");
                    clearOutputConsumer.run();
                });

                String classPath = "build/compiled";
                String className = "Demo";
                String javaExecutable = Paths.get(System.getProperty("java.home"), "bin", "java").toString();

                ProcessBuilder pb = new ProcessBuilder(javaExecutable, "-cp", classPath, className);
                Process process = pb.start();

                redirectStream(process.getInputStream());
                redirectStream(process.getErrorStream());

                int exitCode = process.waitFor();
                Platform.runLater(() -> statusConsumer.accept("Run finished with exit code: " + exitCode));

            } catch (IOException | InterruptedException e) {
                Platform.runLater(() -> statusConsumer.accept("Run Error: " + e.getMessage()));
            }
        }).start();
    }

    public void compileCode(String code) {
        if (diagnosticsManager.hasErrors()) {
            String translatedErrors = com.botmaker.validation.ErrorTranslator.translate(diagnosticsManager.getDiagnostics());
            System.err.println(translatedErrors);
            Platform.runLater(() -> {
                statusConsumer.accept("Compilation failed. See errors above.");
            });
            return; // Abort compilation
        }

        new Thread(() -> {
            try {
                Platform.runLater(() -> setOutputConsumer.accept("Saving and compiling..."));
                if (compileAndWait(code)) {
                    Platform.runLater(() -> setOutputConsumer.accept("Compilation successful."));
                }
            } catch (IOException | InterruptedException e) {
                Platform.runLater(() -> setOutputConsumer.accept("Compilation Error: " + e.getMessage()));
            }
        }).start();
    }

    public boolean compileAndWait(String code) throws IOException, InterruptedException {
        Path sourceFile = Paths.get("projects/Demo.java");
        Files.writeString(sourceFile, code);

        String sourcePath = sourceFile.toString();
        String outDir = "build/compiled";
        Files.createDirectories(Paths.get(outDir));

        String javacExecutable = Paths.get(System.getProperty("java.home"), "bin", "javac").toString();
        // Add -g to include debug information for the debugger
        ProcessBuilder pb = new ProcessBuilder(javacExecutable, "-g", "-d", outDir, sourcePath);
        Process process = pb.start();

        String errors = new String(process.getErrorStream().readAllBytes());
        int exitCode = process.waitFor();

        if (exitCode == 0) {
            return true;
        } else {
            final String errorMessage = "Compilation Failed:\n" + errors;
            System.err.println(errorMessage);
            Platform.runLater(() -> {
                setOutputConsumer.accept(errorMessage);
            });
            return false;
        }
    }

    private void redirectStream(InputStream stream) {
        new Thread(() -> {
            try (Scanner s = new Scanner(stream)) {
                while (s.hasNextLine()) {
                    String line = s.nextLine();
                    Platform.runLater(() -> appendOutputConsumer.accept(line + "\n"));
                }
            }
        }).start();
    }
}


=================================================================================
FILE: ./src/main/java/com/botmaker/runtime/DebuggerService.java
=================================================================================

package com.botmaker.runtime;

import com.sun.jdi.*;
import com.sun.jdi.connect.AttachingConnector;
import com.sun.jdi.connect.Connector;
import com.sun.jdi.connect.IllegalConnectorArgumentsException;
import com.sun.jdi.event.*;
import com.sun.jdi.request.BreakpointRequest;
import com.sun.jdi.request.ClassPrepareRequest;
import com.sun.jdi.request.EventRequestManager;

import java.io.IOException;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CountDownLatch;
import java.util.function.Consumer;

public class DebuggerService {

    // ANSI escape codes for colors
    public static final String ANSI_RESET = "\u001B[0m";
    public static final String ANSI_BLUE = "\u001B[34m";
    public static final String ANSI_GREEN = "\u001B[32m";
    public static final String ANSI_YELLOW = "\u001B[33m";
    public static final String ANSI_RED = "\u001B[31m";

    private VirtualMachine vm;
    private Consumer<LocatableEvent> onPause;
    private Runnable onDisconnect;

    public void setOnPause(Consumer<LocatableEvent> onPause) {
        this.onPause = onPause;
    }

    public void setOnDisconnect(Runnable onDisconnect) {
        this.onDisconnect = onDisconnect;
    }

    public void connectAndRun(String mainClassName, int port, List<Integer> breakpointLines) throws IOException, IllegalConnectorArgumentsException, InterruptedException {
        VirtualMachineManager vmMgr = Bootstrap.virtualMachineManager();
        AttachingConnector connector = vmMgr.attachingConnectors().stream()
                .filter(c -> c.transport().name().equals("dt_socket"))
                .findFirst()
                .orElseThrow(() -> new RuntimeException("Socket attaching connector not found"));

        Map<String, Connector.Argument> arguments = connector.defaultArguments();
        arguments.get("port").setValue(String.valueOf(port));
        arguments.get("hostname").setValue("localhost");

        int maxRetries = 10;
        int retryDelayMs = 250;
        for (int i = 0; i < maxRetries; i++) {
            try {
                System.out.println(ANSI_BLUE + "Attaching to process on port " + port + " (Attempt " + (i + 1) + ")..." + ANSI_RESET);
                vm = connector.attach(arguments);
                System.out.println(ANSI_BLUE + "Attached to VM: " + vm.name() + ANSI_RESET);
                break; // Success, exit the loop
            } catch (IOException e) {
                if (e instanceof java.net.ConnectException && i < maxRetries - 1) {
                    System.out.println(ANSI_YELLOW + "Connection refused. Retrying in " + retryDelayMs + "ms..." + ANSI_RESET);
                    Thread.sleep(retryDelayMs);
                } else {
                    // For other IOExceptions or on the last retry, re-throw.
                    throw e;
                }
            }
        }

        EventRequestManager erm = vm.eventRequestManager();

        List<ReferenceType> classes = vm.classesByName(mainClassName);
        if (!classes.isEmpty()) {
            System.out.println(ANSI_YELLOW + "Class " + mainClassName + " is already loaded. Setting breakpoints immediately." + ANSI_RESET);
            setBreakpoints(classes.getFirst(), breakpointLines);
        } else {
            System.out.println(ANSI_YELLOW + "Class " + mainClassName + " is not loaded yet. Requesting notification for when it is." + ANSI_RESET);
            ClassPrepareRequest classPrepareRequest = erm.createClassPrepareRequest();
            classPrepareRequest.addClassFilter(mainClassName);
            classPrepareRequest.enable();
        }

        CountDownLatch listenerReadyLatch = new CountDownLatch(1);
        new Thread(() -> listenForEvents(listenerReadyLatch, mainClassName, breakpointLines)).start();

        System.out.println(ANSI_BLUE + "Waiting for debugger event listener to be ready..." + ANSI_RESET);
        listenerReadyLatch.await();

        System.out.println(ANSI_BLUE + "Listener is ready. Resuming VM to trigger class loading and hit initial breakpoint." + ANSI_RESET);
        vm.resume();
    }

    private void listenForEvents(CountDownLatch listenerReadyLatch, String mainClassName, List<Integer> breakpointLines) {
        if (vm == null) return;
        EventQueue eventQueue = vm.eventQueue();
        while (true) {
            try {
                if (listenerReadyLatch != null) {
                    listenerReadyLatch.countDown();
                    listenerReadyLatch = null;
                }

                EventSet eventSet = eventQueue.remove();
                boolean shouldResume = true;

                try {
                    for (Event event : eventSet) {
                        if (event instanceof BreakpointEvent) {
                            System.out.println(ANSI_GREEN + "---> Hit Breakpoint: " + event + ANSI_RESET);
                            if (onPause != null) {
                                onPause.accept((BreakpointEvent) event);
                            }
                            shouldResume = false; // PAUSE the VM
                        } else if (event instanceof ClassPrepareEvent) {
                            System.out.println(ANSI_YELLOW + "Class Prepared: " + ((ClassPrepareEvent) event).referenceType().name() + ANSI_RESET);
                            ClassPrepareEvent cpe = (ClassPrepareEvent) event;
                            if (cpe.referenceType().name().equals(mainClassName)) {
                                setBreakpoints(cpe.referenceType(), breakpointLines);
                            }
                        } else if (event instanceof VMDisconnectEvent) {
                            System.out.println(ANSI_RED + "VM Disconnected." + ANSI_RESET);
                            if (onDisconnect != null) {
                                onDisconnect.run();
                            }
                            return; // Exit thread
                        } else {
                            // Other events like VMStartEvent, ThreadStartEvent etc.
                            System.out.println(ANSI_BLUE + "JDI Event: " + event + ANSI_RESET);
                        }
                    }
                } finally {
                    if (shouldResume) {
                        eventSet.resume();
                    }
                }
            } catch (InterruptedException e) {
                System.out.println(ANSI_RED + "Event listener interrupted." + ANSI_RESET);
                return;
            } catch (VMDisconnectedException e) {
                System.out.println(ANSI_RED + "VM Disconnected. Exiting event listener." + ANSI_RESET);
                if (onDisconnect != null) {
                    onDisconnect.run();
                }
                return;
            } catch (Exception e) {
                System.out.println(ANSI_RED + "Exception in event loop: " + e.getMessage() + ANSI_RESET);
                e.printStackTrace();
            }
        }
    }

    private void setBreakpoints(ReferenceType refType, List<Integer> lines) {
        try {
            for (int lineNumber : lines) {
                List<Location> locations = refType.locationsOfLine(lineNumber);
                if (!locations.isEmpty()) {
                    Location loc = locations.get(0);
                    System.out.println(ANSI_YELLOW + "Setting breakpoint at: " + loc + ANSI_RESET);
                    BreakpointRequest bpReq = vm.eventRequestManager().createBreakpointRequest(loc);
                    bpReq.enable();
                } else {
                    System.out.println(ANSI_YELLOW + "Warning: Could not find a location for line " + lineNumber + ANSI_RESET);
                }
            }
        } catch (AbsentInformationException e) {
            System.err.println(ANSI_RED + "Could not set breakpoints. Compile the source with debug information (-g)." + ANSI_RESET);
        }
    }

    public void resume() {
        if (vm != null) {
            System.out.println(ANSI_BLUE + "Resuming VM..." + ANSI_RESET);
            vm.resume();
        }
    }
}


=================================================================================
FILE: ./src/main/java/com/botmaker/runtime/DebuggingManager.java
=================================================================================

package com.botmaker.runtime;

import com.botmaker.core.CodeBlock;
import com.botmaker.core.StatementBlock;
import com.botmaker.parser.BlockFactory;
import com.sun.jdi.connect.IllegalConnectorArgumentsException;
import com.sun.jdi.event.LocatableEvent;
import javafx.application.Platform;
import org.eclipse.jdt.core.dom.ASTNode;
import org.eclipse.jdt.core.dom.CompilationUnit;

import java.io.IOException;
import java.io.InputStream;
import java.net.ServerSocket;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Scanner;
import java.util.function.Consumer;

public class DebuggingManager {

    private final CodeExecutionService codeExecutionService;
    private final Consumer<String> statusConsumer;
    private final Consumer<String> appendOutputConsumer;
    private final Runnable clearOutputConsumer;
    private final Runnable onDebugStart;
    private final Runnable onPause;
    private final Runnable onResume;
    private final Runnable onDebugFinish;
    private final Consumer<CodeBlock> highlightConsumer;
    private final BlockFactory factory;
    private Map<ASTNode, CodeBlock> nodeToBlockMap; // This needs to be updated from Main

    private DebuggerService debuggerService;
    private Map<Integer, CodeBlock> lineToBlockMap;

    public DebuggingManager(CodeExecutionService codeExecutionService,
                            Consumer<String> statusConsumer,
                            Consumer<String> appendOutputConsumer,
                            Runnable clearOutputConsumer,
                            Runnable onDebugStart,
                            Runnable onPause,
                            Runnable onResume,
                            Runnable onDebugFinish,
                            Consumer<CodeBlock> highlightConsumer,
                            BlockFactory factory) {
        this.codeExecutionService = codeExecutionService;
        this.statusConsumer = statusConsumer;
        this.appendOutputConsumer = appendOutputConsumer;
        this.clearOutputConsumer = clearOutputConsumer;
        this.onDebugStart = onDebugStart;
        this.onPause = onPause;
        this.onResume = onResume;
        this.onDebugFinish = onDebugFinish;
        this.highlightConsumer = highlightConsumer;
        this.factory = factory;
    }

    public void setNodeToBlockMap(Map<ASTNode, CodeBlock> nodeToBlockMap) {
        this.nodeToBlockMap = nodeToBlockMap;
    }

    public void startDebugging(String code) {
        new Thread(() -> {
            try {
                if (!codeExecutionService.compileAndWait(code)) {
                    Platform.runLater(() -> statusConsumer.accept("Debug aborted due to compilation failure."));
                    return;
                }

                CompilationUnit cu = factory.getCompilationUnit();
                if (cu == null || nodeToBlockMap == null) {
                    Platform.runLater(() -> statusConsumer.accept("Error: Could not parse code to get breakpoints."));
                    return;
                }

                this.lineToBlockMap = new HashMap<>();
                for (CodeBlock block : nodeToBlockMap.values()) {
                    int line = block.getBreakpointLine(cu);
                    if (line > 0) {
                        if (!lineToBlockMap.containsKey(line) || block instanceof StatementBlock) {
                            lineToBlockMap.put(line, block);
                        }
                    }
                }
                List<Integer> breakpointLines = new ArrayList<>(this.lineToBlockMap.keySet());

                int freePort;
                try (ServerSocket socket = new ServerSocket(0)) {
                    freePort = socket.getLocalPort();
                }

                Platform.runLater(() -> {
                    statusConsumer.accept("Starting debugger on port " + freePort + "...");
                    onDebugStart.run();
                    clearOutputConsumer.run();
                });

                String classPath = "build/compiled";
                String className = "Demo";
                String javaExecutable = Paths.get(System.getProperty("java.home"), "bin", "java").toString();
                String debugAgent = String.format("-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=%d", freePort);

                ProcessBuilder pb = new ProcessBuilder(javaExecutable, debugAgent, "-cp", classPath, className);
                Process process = pb.start();

                redirectStream(process.getInputStream());
                redirectStream(process.getErrorStream());

                debuggerService = new DebuggerService();
                debuggerService.setOnPause(this::handlePauseEvent);
                debuggerService.setOnDisconnect(this::onDebugSessionFinished);
                debuggerService.connectAndRun(className, freePort, breakpointLines);

            } catch (IOException | IllegalConnectorArgumentsException | InterruptedException e) {
                Platform.runLater(() -> statusConsumer.accept("Debugger Error: " + e.getMessage()));
                e.printStackTrace();
            }
        }).start();
    }

    public void resume() {
        if (debuggerService != null) {
            Platform.runLater(onResume);
            debuggerService.resume();
        }
    }

    private void handlePauseEvent(LocatableEvent event) {
        Platform.runLater(() -> {
            onPause.run();
            int lineNumber = event.location().lineNumber();
            CodeBlock block = lineToBlockMap.get(lineNumber);

            if (block != null) {
                CodeBlock target = block.getHighlightTarget();
                highlightConsumer.accept(target);
                statusConsumer.accept("Paused at line: " + lineNumber);
            } else {
                statusConsumer.accept("Paused at line: " + lineNumber + " (No block found)");
            }
        });
    }

    private void onDebugSessionFinished() {
        Platform.runLater(() -> {
            statusConsumer.accept("Debug session finished.");
            onDebugFinish.run();
            highlightConsumer.accept(null); // Clear highlight
        });
    }

    private void redirectStream(InputStream stream) {
        new Thread(() -> {
            try (Scanner s = new Scanner(stream)) {
                while (s.hasNextLine()) {
                    String line = s.nextLine();
                    Platform.runLater(() -> appendOutputConsumer.accept(line + "\n"));
                }
            }
        }).start();
    }
}


=================================================================================
FILE: ./src/main/java/com/botmaker/ui/AddableBlock.java
=================================================================================

package com.botmaker.ui;

import com.botmaker.blocks.IfBlock;
import com.botmaker.blocks.PrintBlock;
import com.botmaker.blocks.VariableDeclarationBlock;
import com.botmaker.core.StatementBlock;

public enum AddableBlock {
    PRINT("Print", PrintBlock.class),
    IF("If", IfBlock.class),
    DECLARE_INT("Declare Int", VariableDeclarationBlock.class),
    DECLARE_DOUBLE("Declare Double", VariableDeclarationBlock.class),
    DECLARE_BOOLEAN("Declare Boolean", VariableDeclarationBlock.class),
    DECLARE_STRING("Declare String", VariableDeclarationBlock.class);

    private final String displayName;
    private final Class<? extends StatementBlock> blockClass;

    AddableBlock(String displayName, Class<? extends StatementBlock> blockClass) {
        this.displayName = displayName;
        this.blockClass = blockClass;
    }

    public String getDisplayName() {
        return displayName;
    }

    public Class<? extends StatementBlock> getBlockClass() {
        return blockClass;
    }
}


=================================================================================
FILE: ./src/main/java/com/botmaker/ui/AddableExpression.java
=================================================================================

package com.botmaker.ui;

public enum AddableExpression {
    TEXT("Text"),
    VARIABLE("Variable");

    private final String displayName;

    AddableExpression(String displayName) {
        this.displayName = displayName;
    }

    public String getDisplayName() {
        return displayName;
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/ui/BlockDragAndDropManager.java
=================================================================================

package com.botmaker.ui;

import com.botmaker.core.BodyBlock;
import com.botmaker.core.StatementBlock;
import javafx.scene.Node;
import javafx.scene.input.ClipboardContent;
import javafx.scene.input.DataFormat;
import javafx.scene.input.Dragboard;
import javafx.scene.input.TransferMode;
import javafx.scene.layout.Region;

import java.util.function.Consumer;

public class BlockDragAndDropManager {

    public static final DataFormat ADDABLE_BLOCK_FORMAT = new DataFormat("application/x-java-addable-block");
    private final Consumer<DropInfo> onDrop;

    public BlockDragAndDropManager(Consumer<DropInfo> onDrop) {
        this.onDrop = onDrop;
    }

    /**
     * Makes a UI node draggable, associating it with a specific type of AddableBlock.
     * @param node The node to make draggable (e.g., a Label in the palette).
     * @param blockType The type of block this node represents.
     */
    public void makeDraggable(Node node, AddableBlock blockType) {
        node.setOnDragDetected(event -> {
            Dragboard db = node.startDragAndDrop(TransferMode.COPY);
            ClipboardContent content = new ClipboardContent();
            // Store the enum name as a string.
            content.put(ADDABLE_BLOCK_FORMAT, blockType.name());
            db.setContent(content);
            System.out.println("Drag detected for: " + blockType.name()); // For debugging
            event.consume();
        });
    }

    /**
     * Creates a thin, transparent region to act as a separator and drop target.
     */
    public Region createSeparator() {
        Region separator = new Region();
        separator.setMinHeight(8);
        separator.setStyle("-fx-background-color: transparent;");
        return separator;
    }

    /**
     * Adds all necessary drag-and-drop event handlers to a separator region.
     * @param separator The region to add handlers to.
     * @param insertionIndex The index in the list where a drop should occur.
     * @param adjacentBlock The block next to the separator, for context (can be null).
     */
    public void addSeparatorDragHandlers(Region separator, BodyBlock targetBody, int insertionIndex, StatementBlock adjacentBlock) {
        String defaultColor = "transparent";
        String hoverColor = "#007bff"; // A distinct blue

        separator.setOnDragEntered(event -> {
            if (event.getDragboard().hasContent(BlockDragAndDropManager.ADDABLE_BLOCK_FORMAT)) {
                separator.setStyle("-fx-background-color: " + hoverColor + ";");
                String logMessage = "Hovering insertion point at index: " + insertionIndex;
                if (adjacentBlock != null) {
                    logMessage += " (next to: " + adjacentBlock.getDetails() + ")";
                }
                System.out.println(logMessage);
            }
            event.consume();
        });

        separator.setOnDragExited(event -> {
            separator.setStyle("-fx-background-color: " + defaultColor );
            event.consume();
        });

        separator.setOnDragOver(event -> {
            if (event.getDragboard().hasContent(BlockDragAndDropManager.ADDABLE_BLOCK_FORMAT)) {
                event.acceptTransferModes(TransferMode.COPY);
            }
            event.consume();
        });

        separator.setOnDragDropped(event -> {
            Dragboard db = event.getDragboard();
            boolean success = false;
            if (db.hasContent(ADDABLE_BLOCK_FORMAT)) {
                String blockTypeName = (String) db.getContent(ADDABLE_BLOCK_FORMAT);
                AddableBlock type = AddableBlock.valueOf(blockTypeName);
                onDrop.accept(new DropInfo(type, targetBody, insertionIndex));
                success = true;
            }
            event.setDropCompleted(success);
            event.consume();
        });
    }

    public void addEmptyBodyDropHandlers(Region target, BodyBlock targetBody) {
        target.setOnDragEntered(event -> {
            if (event.getDragboard().hasContent(ADDABLE_BLOCK_FORMAT)) {
                target.getStyleClass().add("empty-body-drop-hover");
            }
            event.consume();
        });

        target.setOnDragExited(event -> {
            target.getStyleClass().remove("empty-body-drop-hover");
            event.consume();
        });

        target.setOnDragOver(event -> {
            if (event.getDragboard().hasContent(ADDABLE_BLOCK_FORMAT)) {
                event.acceptTransferModes(TransferMode.COPY);
            }
            event.consume();
        });

        target.setOnDragDropped(event -> {
            Dragboard db = event.getDragboard();
            boolean success = false;
            if (db.hasContent(ADDABLE_BLOCK_FORMAT)) {
                String blockTypeName = (String) db.getContent(ADDABLE_BLOCK_FORMAT);
                AddableBlock type = AddableBlock.valueOf(blockTypeName);
                onDrop.accept(new DropInfo(type, targetBody, 0)); // Always index 0 for empty body
                success = true;
            }
            event.setDropCompleted(success);
            event.consume();
        });
    }

    public void addExpressionDropHandlers(Region target) {
        String defaultStyle = "-fx-background-color: #f0f0f0; -fx-border-color: #c0c0c0; -fx-border-style: dashed; -fx-min-width: 50; -fx-min-height: 25;";
        String hoverStyle = defaultStyle + "-fx-border-color: #007bff;"; // Highlight with blue

        target.setStyle(defaultStyle);

        target.setOnDragEntered(event -> {
            if (event.getDragboard().hasContent(ADDABLE_BLOCK_FORMAT)) {
                target.setStyle(hoverStyle);
                System.out.println("Hovering expression slot.");
            }
            event.consume();
        });

        target.setOnDragExited(event -> {
            target.setStyle(defaultStyle);
            event.consume();
        });

        target.setOnDragOver(event -> {
            if (event.getDragboard().hasContent(ADDABLE_BLOCK_FORMAT)) {
                event.acceptTransferModes(TransferMode.COPY);
            }
            event.consume();
        });

        target.setOnDragDropped(event -> {
            Dragboard db = event.getDragboard();
            boolean success = false;
            if (db.hasContent(ADDABLE_BLOCK_FORMAT)) {
                // For now, we just acknowledge the drop and show a message.
                // In the future, we would need a different DataFormat for expressions.
                String blockTypeName = (String) db.getContent(ADDABLE_BLOCK_FORMAT);
                System.out.println("Cannot drop a Statement block ('" + blockTypeName + "') into an Expression slot.");
                // We'll still mark it as a "successful" drop to finalize the gesture.
                success = true;
            }
            event.setDropCompleted(success);
            event.consume();
        });
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/ui/DropInfo.java
=================================================================================

package com.botmaker.ui;

import com.botmaker.core.BodyBlock;

public record DropInfo(AddableBlock type, BodyBlock targetBody, int insertionIndex) {
}


=================================================================================
FILE: ./src/main/java/com/botmaker/ui/UIManager.java
=================================================================================

package com.botmaker.ui;

import com.botmaker.Main;
import com.botmaker.core.CodeBlock;
import com.botmaker.validation.ErrorTranslator;
import javafx.animation.PauseTransition;
import javafx.geometry.Insets;
import javafx.geometry.Orientation;
import javafx.scene.Node;
import javafx.scene.Scene;
import javafx.scene.control.*;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Priority;
import javafx.scene.layout.VBox;
import javafx.util.Duration;
import org.eclipse.lsp4j.Diagnostic;
import org.eclipse.lsp4j.DiagnosticSeverity;

import java.util.List;

public class UIManager {

    private final Main mainApp;
    private final BlockDragAndDropManager dragAndDropManager;
    private VBox blocksContainer;
    private Label statusLabel;
    private TextArea outputArea;
    private Button debugButton;
    private Button resumeButton;
    private ScrollPane scrollPane;
    private ListView<Diagnostic> errorListView;
    private TabPane bottomTabPane;


    public UIManager(Main mainApp, BlockDragAndDropManager dragAndDropManager) {
        this.mainApp = mainApp;
        this.dragAndDropManager = dragAndDropManager;
    }

    private boolean isDarkMode = false;

    public Scene createScene() {
        blocksContainer = new VBox(10);
        statusLabel = new Label("Ready");
        statusLabel.setId("status-label");

        // Initialize the components for the tabs
        outputArea = new TextArea();
        outputArea.setEditable(false);

        errorListView = new ListView<>();
        errorListView.setPlaceholder(new Label("No errors to display."));

        errorListView.setCellFactory(lv -> new ListCell<>() {
            @Override
            protected void updateItem(Diagnostic diagnostic, boolean empty) {
                super.updateItem(diagnostic, empty);
                getStyleClass().removeAll("error-cell", "warning-cell");

                if (empty || diagnostic == null) {
                    setText(null);
                    setOnMouseClicked(null);
                } else {
                    String message = ErrorTranslator.getShortSummary(diagnostic);
                    int line = diagnostic.getRange().getStart().getLine() + 1;
                    setText(String.format("Line %d: %s", line, message));

                    if (diagnostic.getSeverity() == DiagnosticSeverity.Error) {
                        getStyleClass().add("error-cell");
                    } else if (diagnostic.getSeverity() == DiagnosticSeverity.Warning) {
                        getStyleClass().add("warning-cell");
                    }

                    setOnMouseClicked(event -> {
                        if (event.getClickCount() >= 1) { // Use single-click
                            mainApp.getDiagnosticsManager().findBlockForDiagnostic(diagnostic)
                                    .ifPresent(this::scrollToBlock);
                        }
                    });
                }
            }

            private void scrollToBlock(CodeBlock block) {
                Node uiNode = block.getUINode();
                if (uiNode == null) return;

                // --- Blinking Animation ---
                final String blinkStyle = "error-block-blink";
                if (!uiNode.getStyleClass().contains(blinkStyle)) { // Prevent multiple animations
                    uiNode.getStyleClass().add(blinkStyle);
                    PauseTransition blinkOff = new PauseTransition(Duration.seconds(1));
                    blinkOff.setOnFinished(event -> uiNode.getStyleClass().remove(blinkStyle));
                    blinkOff.play();
                }
                // --- End Animation ---

                uiNode.requestFocus();
                double containerHeight = blocksContainer.getBoundsInLocal().getHeight();
                double blockY = uiNode.getBoundsInParent().getMinY();
                double scrollPaneHeight = scrollPane.getViewportBounds().getHeight();
                double vValue = blockY / (containerHeight - scrollPaneHeight);
                scrollPane.setVvalue(Math.max(0, Math.min(1, vValue)));
            }
        });

        // Create the TabPane
        bottomTabPane = new TabPane();
        Tab terminalTab = new Tab("Terminal", outputArea);
        terminalTab.setClosable(false);
        Tab errorsTab = new Tab("Errors", errorListView);
        errorsTab.setClosable(false);
        bottomTabPane.getTabs().addAll(terminalTab, errorsTab);


        HBox palette = createBlockPalette();
        palette.getStyleClass().add("palette");

        Button compileButton = new Button("Compile");
        compileButton.setOnAction(e -> mainApp.compileCode());

        Button runButton = new Button("Run");
        runButton.setOnAction(e -> {
            bottomTabPane.getSelectionModel().select(terminalTab);
            mainApp.runCode();
        });

        debugButton = new Button("Debug");
        debugButton.setOnAction(e -> mainApp.startDebugging());

        resumeButton = new Button("Resume");
        resumeButton.setDisable(true);
        resumeButton.setOnAction(e -> mainApp.resumeDebugging());

        HBox buttonBox = new HBox(10, compileButton, runButton, debugButton, resumeButton);

        Button themeButton = new Button("Toggle Theme");
        HBox topBar = new HBox(10, themeButton);

        scrollPane = new ScrollPane(blocksContainer);
        scrollPane.setFitToWidth(true);

        // Create a SplitPane for resizable vertical layout
        SplitPane splitPane = new SplitPane();
        splitPane.setOrientation(Orientation.VERTICAL);
        splitPane.getItems().addAll(scrollPane, bottomTabPane);
        splitPane.setDividerPositions(0.7); // 70% for code blocks, 30% for tabs

        VBox.setVgrow(splitPane, Priority.ALWAYS); // Make the SplitPane grow to fill space

        VBox root = new VBox(10, topBar, palette, buttonBox, splitPane, statusLabel);
        root.setPadding(new Insets(10));

        Scene scene = new Scene(root, 600, 800);
        scene.getStylesheets().add(getClass().getResource("/com/botmaker/styles.css").toExternalForm());
        root.getStyleClass().add("light-theme");

        themeButton.setOnAction(e -> {
            isDarkMode = !isDarkMode;
            root.getStyleClass().remove(isDarkMode ? "light-theme" : "dark-theme");
            root.getStyleClass().add(isDarkMode ? "dark-theme" : "light-theme");
        });

        return scene;
    }

    private HBox createBlockPalette() {
        HBox palette = new HBox(10);
        palette.setPadding(new Insets(5));

        for (AddableBlock blockType : AddableBlock.values()) {
            Label blockLabel = new Label(blockType.getDisplayName());
            blockLabel.getStyleClass().add("palette-block-label");
            blockLabel.getStyleClass().add("palette-" + blockType.name().toLowerCase() + "-label");
            dragAndDropManager.makeDraggable(blockLabel, blockType);
            palette.getChildren().add(blockLabel);
        }
        return palette;
    }

    public VBox getBlocksContainer() {
        return blocksContainer;
    }

    public Label getStatusLabel() {
        return statusLabel;
    }

    public TextArea getOutputArea() {
        return outputArea;
    }

    public void updateErrors(List<Diagnostic> diagnostics) {
        if (diagnostics == null) {
            errorListView.getItems().clear();
        } else {
            errorListView.getItems().setAll(diagnostics);
        }
        // If there are errors, automatically switch to the errors tab
        if (diagnostics != null && !diagnostics.isEmpty()) {
            bottomTabPane.getSelectionModel().select(1); // Select the second tab (Errors)
        }
    }


    public void onDebuggerStarted() {
        debugButton.setDisable(true);
    }

    public void onDebuggerPaused() {
        resumeButton.setDisable(false);
    }

    public void onDebuggerResumed() {
        resumeButton.setDisable(true);
    }

    public void onDebuggerFinished() {
        debugButton.setDisable(false);
        resumeButton.setDisable(true);
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/util/TypeManager.java
=================================================================================

package com.botmaker.util;

import org.eclipse.jdt.core.dom.AST;
import org.eclipse.jdt.core.dom.PrimitiveType;
import org.eclipse.jdt.core.dom.Type;

import java.util.List;

public class TypeManager {

    private static final List<String> FUNDAMENTAL_TYPES = List.of(
        "int", "double", "boolean", "String", "long", "float", "char", "short", "byte"
    );

    /**
     * Returns a list of fundamental Java type names (primitives + String).
     */
    public static List<String> getFundamentalTypeNames() {
        return FUNDAMENTAL_TYPES;
    }

    /**
     * Creates a JDT AST Type node from a string representation of the type name.
     * Handles both primitive types and class/interface names.
     *
     * @param ast The AST instance to use for creating the node.
     * @param typeName The name of the type (e.g., "int", "String", "java.util.List").
     * @return The constructed Type node.
     */
    public static Type createTypeNode(AST ast, String typeName) {
        switch (typeName) {
            case "int": return ast.newPrimitiveType(PrimitiveType.INT);
            case "double": return ast.newPrimitiveType(PrimitiveType.DOUBLE);
            case "boolean": return ast.newPrimitiveType(PrimitiveType.BOOLEAN);
            case "char": return ast.newPrimitiveType(PrimitiveType.CHAR);
            case "long": return ast.newPrimitiveType(PrimitiveType.LONG);
            case "float": return ast.newPrimitiveType(PrimitiveType.FLOAT);
            case "short": return ast.newPrimitiveType(PrimitiveType.SHORT);
            case "byte": return ast.newPrimitiveType(PrimitiveType.BYTE);
            default:
                // For non-primitives, ast.newName() can handle simple and qualified names.
                return ast.newSimpleType(ast.newName(typeName));
        }
    }
}


=================================================================================
FILE: ./src/main/java/com/botmaker/validation/DiagnosticsManager.java
=================================================================================

package com.botmaker.validation;

import com.botmaker.core.CodeBlock;
import javafx.application.Platform;
import org.eclipse.jdt.core.dom.ASTNode;
import org.eclipse.lsp4j.Diagnostic;
import org.eclipse.lsp4j.DiagnosticSeverity;
import org.eclipse.lsp4j.PublishDiagnosticsParams;

import java.util.*;

public class DiagnosticsManager {

    private Map<ASTNode, CodeBlock> nodeToBlockMap;
    private String sourceCode;
    private final Set<CodeBlock> blocksWithErrors = new HashSet<>();
    private List<Diagnostic> lastDiagnostics = new ArrayList<>();

    // NEW: Track line numbers to blocks for fallback matching
    private Map<Integer, Set<CodeBlock>> lineToBlocksMap = new HashMap<>();

    public List<Diagnostic> getDiagnostics() {
        return lastDiagnostics;
    }

    public boolean hasErrors() {
        if (lastDiagnostics == null || lastDiagnostics.isEmpty()) {
            return false;
        }
        return lastDiagnostics.stream().anyMatch(d -> {
            DiagnosticSeverity severity = d.getSeverity();
            return severity == null || severity == DiagnosticSeverity.Error;
        });
    }

    public void updateSource(Map<ASTNode, CodeBlock> nodeToBlockMap, String sourceCode) {
        this.nodeToBlockMap = nodeToBlockMap;
        this.sourceCode = sourceCode;

        // Build line-to-block mapping for fallback
        buildLineToBlockMap();
    }

    /**
     * Builds a map from line numbers to blocks for fallback matching
     * when AST node matching fails.
     */
    private void buildLineToBlockMap() {
        lineToBlocksMap.clear();

        if (nodeToBlockMap == null || sourceCode == null) {
            return;
        }

        for (Map.Entry<ASTNode, CodeBlock> entry : nodeToBlockMap.entrySet()) {
            ASTNode node = entry.getKey();
            CodeBlock block = entry.getValue();

            // Calculate which lines this node spans
            int startLine = getLineNumber(node.getStartPosition());
            int endLine = getLineNumber(node.getStartPosition() + node.getLength());

            // Add block to all lines it spans
            for (int line = startLine; line <= endLine; line++) {
                lineToBlocksMap.computeIfAbsent(line, k -> new HashSet<>()).add(block);
            }
        }
    }

    public void processDiagnostics(List<Diagnostic> diagnostics) {
        this.lastDiagnostics = diagnostics;

        // Clear previous errors
        for (CodeBlock block : blocksWithErrors) {
            block.clearError();
        }
        blocksWithErrors.clear();

        if (nodeToBlockMap == null) return;

        // Process new diagnostics
        for (Diagnostic diagnostic : diagnostics) {
            // Only show errors, not warnings (unless you want warnings too)
            if (diagnostic.getSeverity() != DiagnosticSeverity.Error) {
                continue;
            }

            Optional<CodeBlock> blockOpt = findBlockForDiagnostic(diagnostic);

            if (blockOpt.isPresent()) {
                CodeBlock block = blockOpt.get();

                // Use translated error message
                String userFriendlyMessage = ErrorTranslator.getShortSummary(diagnostic);
                String suggestion = ErrorTranslator.getSuggestion(diagnostic);

                block.setError(userFriendlyMessage + "\n" + suggestion);
                blocksWithErrors.add(block);
            } else {
                // Log unmapped diagnostics for debugging
                System.err.println("Warning: Could not map diagnostic to block: " +
                        diagnostic.getMessage() + " at line " +
                        (diagnostic.getRange().getStart().getLine() + 1));
            }
        }
    }

    /**
     * Finds the code block responsible for a diagnostic.
     * Uses multiple strategies for better matching.
     */
    public Optional<CodeBlock> findBlockForDiagnostic(Diagnostic diagnostic) {
        // Strategy 1: Precise AST node matching (best)
        Optional<CodeBlock> block = findBlockByASTNode(diagnostic);
        if (block.isPresent()) {
            return block;
        }

        // Strategy 2: Line-based fallback (good for edge cases)
        block = findBlockByLine(diagnostic);
        if (block.isPresent()) {
            return block;
        }

        // Strategy 3: Parent node search (for nested expressions)
        return findBlockByParentNode(diagnostic);
    }

    /**
     * Strategy 1: Find block by matching AST node ranges
     */
    private Optional<CodeBlock> findBlockByASTNode(Diagnostic diagnostic) {
        int startOffset = getOffsetFromPosition(diagnostic.getRange().getStart());
        int endOffset = getOffsetFromPosition(diagnostic.getRange().getEnd());

        // Find the most specific (smallest) block that contains the diagnostic range
        ASTNode bestNode = null;
        int bestLength = Integer.MAX_VALUE;

        for (ASTNode node : nodeToBlockMap.keySet()) {
            int nodeStart = node.getStartPosition();
            int nodeEnd = nodeStart + node.getLength();

            // Check if node contains the diagnostic range
            if (nodeStart <= startOffset && nodeEnd >= endOffset) {
                int nodeLength = node.getLength();

                // Prefer the smallest containing node
                if (nodeLength < bestLength) {
                    bestNode = node;
                    bestLength = nodeLength;
                }
            }
        }

        return Optional.ofNullable(bestNode).map(nodeToBlockMap::get);
    }

    /**
     * Strategy 2: Find block by line number (fallback)
     */
    private Optional<CodeBlock> findBlockByLine(Diagnostic diagnostic) {
        int line = diagnostic.getRange().getStart().getLine();

        Set<CodeBlock> blocksOnLine = lineToBlocksMap.get(line);
        if (blocksOnLine == null || blocksOnLine.isEmpty()) {
            return Optional.empty();
        }

        // If multiple blocks on same line, prefer the first one
        // (Could be improved with more sophisticated heuristics)
        return blocksOnLine.stream().findFirst();
    }

    /**
     * Strategy 3: Find block by searching parent nodes
     */
    private Optional<CodeBlock> findBlockByParentNode(Diagnostic diagnostic) {
        int startOffset = getOffsetFromPosition(diagnostic.getRange().getStart());

        // Find any node that contains the start position
        for (ASTNode node : nodeToBlockMap.keySet()) {
            int nodeStart = node.getStartPosition();
            int nodeEnd = nodeStart + node.getLength();

            if (nodeStart <= startOffset && nodeEnd >= startOffset) {
                return Optional.of(nodeToBlockMap.get(node));
            }
        }

        return Optional.empty();
    }

    /**
     * Converts LSP position to source code offset
     */
    private int getOffsetFromPosition(org.eclipse.lsp4j.Position pos) {
        int line = pos.getLine();
        int character = pos.getCharacter();
        int offset = 0;
        int currentLine = 0;

        if (sourceCode == null) return 0;

        while (currentLine < line && offset < sourceCode.length()) {
            if (sourceCode.charAt(offset) == '\n') {
                currentLine++;
            }
            offset++;
        }

        return offset + character;
    }

    /**
     * Gets line number from character offset
     */
    private int getLineNumber(int offset) {
        if (sourceCode == null || offset < 0) return 0;

        int line = 0;
        for (int i = 0; i < Math.min(offset, sourceCode.length()); i++) {
            if (sourceCode.charAt(i) == '\n') {
                line++;
            }
        }
        return line;
    }

    /**
     * Get all blocks that have errors (useful for UI highlighting)
     */
    public Set<CodeBlock> getBlocksWithErrors() {
        return Collections.unmodifiableSet(blocksWithErrors);
    }

    /**
     * Check if a specific block has errors
     */
    public boolean hasError(CodeBlock block) {
        return blocksWithErrors.contains(block);
    }

    /**
     * Get diagnostics for a specific block
     */
    public List<Diagnostic> getDiagnosticsForBlock(CodeBlock block) {
        if (lastDiagnostics == null || nodeToBlockMap == null) {
            return Collections.emptyList();
        }

        List<Diagnostic> blockDiagnostics = new ArrayList<>();

        for (Diagnostic diagnostic : lastDiagnostics) {
            Optional<CodeBlock> diagBlock = findBlockForDiagnostic(diagnostic);
            if (diagBlock.isPresent() && diagBlock.get() == block) {
                blockDiagnostics.add(diagnostic);
            }
        }

        return blockDiagnostics;
    }

    /**
     * Get a summary of all errors (useful for status bar)
     */
    public String getErrorSummary() {
        if (!hasErrors()) {
            return "✅ No errors";
        }

        long errorCount = lastDiagnostics.stream()
                .filter(d -> d.getSeverity() == DiagnosticSeverity.Error)
                .count();

        long warningCount = lastDiagnostics.stream()
                .filter(d -> d.getSeverity() == DiagnosticSeverity.Warning)
                .count();

        StringBuilder summary = new StringBuilder();
        if (errorCount > 0) {
            summary.append(String.format("❌ %d error%s", errorCount, errorCount == 1 ? "" : "s"));
        }
        if (warningCount > 0) {
            if (summary.length() > 0) summary.append(", ");
            summary.append(String.format("⚠️ %d warning%s", warningCount, warningCount == 1 ? "" : "s"));
        }

        return summary.toString();
    }
}

=================================================================================
FILE: ./src/main/java/com/botmaker/validation/ErrorTranslator.java
=================================================================================

package com.botmaker.validation;

import org.eclipse.lsp4j.Diagnostic;
import org.eclipse.lsp4j.DiagnosticSeverity;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class ErrorTranslator {

    private static final Map<Integer, ErrorInfo> ERROR_MAPPINGS = new HashMap<>();
    private static final Pattern ERROR_CODE_PATTERN = Pattern.compile("\\b(\\d{7,})\\b");

    static class ErrorInfo {
        String userMessage;
        String suggestion;
        DiagnosticSeverity severity;

        ErrorInfo(String userMessage, String suggestion, DiagnosticSeverity severity) {
            this.userMessage = userMessage;
            this.suggestion = suggestion;
            this.severity = severity;
        }

        ErrorInfo(String userMessage, String suggestion) {
            this(userMessage, suggestion, DiagnosticSeverity.Error);
        }
    }

    static {
        // PRIORITY 1: Critical Errors (Must Handle)

        // 16777233 - TypeMismatch
        ERROR_MAPPINGS.put(16777233, new ErrorInfo(
                "Wrong type used: You're trying to use a {0} where a {1} is expected",
                "Check that you're using the right type of value (number, text, true/false, etc.)"
        ));

        // 570425394 - UndefinedName (Variable doesn't exist)
        ERROR_MAPPINGS.put(570425394, new ErrorInfo(
                "Variable or name '{0}' doesn't exist",
                "Did you forget to create this variable? Check for typos in the name."
        ));

        // 536870963 - UninitializedLocalVariable
        ERROR_MAPPINGS.put(536870963, new ErrorInfo(
                "Variable '{0}' is used before being given a value",
                "Set a value to this variable before using it."
        ));

        // 536870967 - RedefinedLocal (Duplicate variable)
        ERROR_MAPPINGS.put(536870967, new ErrorInfo(
                "A variable named '{0}' already exists",
                "Choose a different name or remove the duplicate variable."
        ));

        // 67108979 - ParameterMismatch
        ERROR_MAPPINGS.put(67108979, new ErrorInfo(
                "Wrong number of parameters: Expected {0} but got {1}",
                "Check how many inputs this function needs."
        ));

        // 603979884 - ShouldReturnValue
        ERROR_MAPPINGS.put(603979884, new ErrorInfo(
                "This function must return a value",
                "Add a return statement with a value at the end of the function."
        ));

        // PRIORITY 2: Type System Errors

        // 16777218 - UndefinedType
        ERROR_MAPPINGS.put(16777218, new ErrorInfo(
                "Type '{0}' cannot be found",
                "This type doesn't exist. Check for typos or missing imports."
        ));

        // 67108964 - UndefinedMethod
        ERROR_MAPPINGS.put(67108964, new ErrorInfo(
                "Method '{0}' doesn't exist",
                "Check the spelling of the method name or if it's available."
        ));

        // 33554502 - UndefinedField
        ERROR_MAPPINGS.put(33554502, new ErrorInfo(
                "Field '{0}' doesn't exist",
                "This field is not defined. Check the name and spelling."
        ));

        // PRIORITY 3: Syntax Errors (If user can edit code)

        // 1610612960 - MissingSemiColon
        ERROR_MAPPINGS.put(1610612960, new ErrorInfo(
                "Missing semicolon (;) at the end of the line",
                "Add a semicolon (;) at the end of this statement."
        ));

        // 1610612995 - UnterminatedString
        ERROR_MAPPINGS.put(1610612995, new ErrorInfo(
                "Text is missing a closing quote",
                "Add a closing quote (\") at the end of the text."
        ));

        // 1610612941 - ParsingErrorNoSuggestion
        ERROR_MAPPINGS.put(1610612941, new ErrorInfo(
                "Syntax error: The code structure is incorrect",
                "Check for missing brackets, parentheses, or other syntax issues."
        ));

        // 1610612956 - UnmatchedBracket
        ERROR_MAPPINGS.put(1610612956, new ErrorInfo(
                "Unmatched bracket - missing opening or closing bracket",
                "Check that all { } brackets are properly paired."
        ));

        // PRIORITY 4: Flow Control

        // 536870908 - InvalidBreak
        ERROR_MAPPINGS.put(536870908, new ErrorInfo(
                "'break' can only be used inside a loop or switch",
                "Move this break statement inside a loop block."
        ));

        // 536870909 - InvalidContinue
        ERROR_MAPPINGS.put(536870909, new ErrorInfo(
                "'continue' can only be used inside a loop",
                "Move this continue statement inside a loop block."
        ));

        // 536870161 - CodeCannotBeReached
        ERROR_MAPPINGS.put(536870161, new ErrorInfo(
                "This code will never run (unreachable code)",
                "Remove this code or fix the logic that prevents it from running.",
                DiagnosticSeverity.Warning
        ));

        // PRIORITY 5: Warnings

        // 536870973 - LocalVariableIsNeverUsed
        ERROR_MAPPINGS.put(536870973, new ErrorInfo(
                "Variable '{0}' is created but never used",
                "Remove this variable or use it somewhere in your code.",
                DiagnosticSeverity.Warning
        ));

        // 536870974 - ArgumentIsNeverUsed
        ERROR_MAPPINGS.put(536870974, new ErrorInfo(
                "Parameter '{0}' is never used",
                "Remove this parameter or use it in the function.",
                DiagnosticSeverity.Warning
        ));

        // 536871185 - AssignmentHasNoEffect
        ERROR_MAPPINGS.put(536871185, new ErrorInfo(
                "This assignment does nothing",
                "You're assigning a variable to itself. Remove this line or fix the logic.",
                DiagnosticSeverity.Warning
        ));
    }

    /**
     * Extracts the JDT error code from a diagnostic message
     */
    private static Integer extractErrorCode(String message) {
        Matcher matcher = ERROR_CODE_PATTERN.matcher(message);
        if (matcher.find()) {
            try {
                return Integer.parseInt(matcher.group(1));
            } catch (NumberFormatException e) {
                return null;
            }
        }
        return null;
    }

    /**
     * Translates diagnostics to user-friendly messages
     */
    public static String translate(List<Diagnostic> diagnostics) {
        if (diagnostics == null || diagnostics.isEmpty()) {
            return "✅ No errors found. Your code looks good!";
        }

        StringBuilder result = new StringBuilder();
        int errorCount = 0;
        int warningCount = 0;

        for (Diagnostic diagnostic : diagnostics) {
            if (diagnostic.getSeverity() == DiagnosticSeverity.Error) {
                errorCount++;
            } else if (diagnostic.getSeverity() == DiagnosticSeverity.Warning) {
                warningCount++;
            }
        }

        if (errorCount > 0) {
            result.append(String.format("❌ Found %d error%s:\n\n", errorCount, errorCount == 1 ? "" : "s"));
        }
        if (warningCount > 0) {
            result.append(String.format("⚠️  Found %d warning%s:\n\n", warningCount, warningCount == 1 ? "" : "s"));
        }

        for (Diagnostic diagnostic : diagnostics) {
            String icon = diagnostic.getSeverity() == DiagnosticSeverity.Error ? "❌" : "⚠️";
            int lineNumber = diagnostic.getRange().getStart().getLine() + 1;

            String translated = translateSingleDiagnostic(diagnostic);
            result.append(String.format("%s Line %d: %s\n\n", icon, lineNumber, translated));
        }

        return result.toString().trim();
    }

    /**
     * Translates a single diagnostic to a user-friendly message
     */
    public static String translateSingleDiagnostic(Diagnostic diagnostic) {
        String originalMessage = diagnostic.getMessage();

        // Try to extract error code
        Integer errorCode = extractErrorCode(originalMessage);

        if (errorCode != null && ERROR_MAPPINGS.containsKey(errorCode)) {
            ErrorInfo info = ERROR_MAPPINGS.get(errorCode);

            // Try to extract variable/type names from the original message
            String enrichedMessage = enrichMessage(info.userMessage, originalMessage);

            return String.format("%s\n   💡 %s", enrichedMessage, info.suggestion);
        }

        // Fallback: Try pattern matching for common error messages (backward compatibility)
        return translateByPattern(originalMessage);
    }

    /**
     * Enriches the user message with context from the original error message
     */
    private static String enrichMessage(String template, String originalMessage) {
        // Extract quoted strings (variable names, type names, etc.)
        Pattern quotedPattern = Pattern.compile("'([^']+)'|\"([^\"]+)\"");
        Matcher matcher = quotedPattern.matcher(originalMessage);

        int index = 0;
        String result = template;
        while (matcher.find() && result.contains("{" + index + "}")) {
            String value = matcher.group(1) != null ? matcher.group(1) : matcher.group(2);
            result = result.replace("{" + index + "}", "'" + value + "'");
            index++;
        }

        // Remove unreplaced placeholders
        result = result.replaceAll("\\{\\d+\\}", "the value");

        return result;
    }

    /**
     * Fallback pattern-based translation (for backward compatibility)
     */
    private static String translateByPattern(String message) {
        if (message.contains("cannot be resolved to a type")) {
            return "A type or class could not be found.\n   💡 Check for typos or if the type exists.";
        }
        if (message.contains("cannot be resolved")) {
            return "A variable, method, or name could not be found.\n   💡 Check for typos or if it was declared.";
        }
        if (message.contains("Syntax error, insert")) {
            try {
                String suggestion = message.split("insert \"")[1].split("\" to")[0];
                return String.format("Syntax error: Something is missing.\n   💡 Try adding '%s'", suggestion);
            } catch (Exception e) {
                return "Syntax error: Something is missing in the code structure.\n   💡 Check for missing semicolons, brackets, or parentheses.";
            }
        }
        if (message.contains("incompatible types") || message.contains("Type mismatch")) {
            return "Wrong type used: You're using a value of the wrong type.\n   💡 Make sure you're using the right kind of value (number, text, etc.)";
        }
        if (message.contains("might not have been initialized")) {
            return "Variable used before being set.\n   💡 Give this variable a value before using it.";
        }
        if (message.contains("is not a statement")) {
            return "This line is not a valid statement.\n   💡 It might be an incomplete expression or command.";
        }
        if (message.contains("Duplicate local variable")) {
            return "A variable with this name already exists.\n   💡 Choose a different name for this variable.";
        }

        // Return original message if no translation found
        return message;
    }

    /**
     * Get a short summary for UI display (e.g., tooltip)
     */
    public static String getShortSummary(Diagnostic diagnostic) {
        String originalMessage = diagnostic.getMessage();
        Integer errorCode = extractErrorCode(originalMessage);

        if (errorCode != null && ERROR_MAPPINGS.containsKey(errorCode)) {
            ErrorInfo info = ERROR_MAPPINGS.get(errorCode);
            return enrichMessage(info.userMessage, originalMessage);
        }

        // Fallback: Return first line of original message
        return originalMessage.split("\n")[0];
    }

    /**
     * Get just the suggestion part
     */
    public static String getSuggestion(Diagnostic diagnostic) {
        String originalMessage = diagnostic.getMessage();
        Integer errorCode = extractErrorCode(originalMessage);

        if (errorCode != null && ERROR_MAPPINGS.containsKey(errorCode)) {
            return ERROR_MAPPINGS.get(errorCode).suggestion;
        }

        return "Check your code for issues.";
    }
}


=================================================================================
FILE: ./src/main/resources/com/botmaker/styles.css
=================================================================================

/* General styles for both light and dark themes */
.root {
    -fx-font-family: "Inter", sans-serif;

    /* Block Color Variables */
    -fx-if-block-background: #FF8C00;
    -fx-if-block-border: #D2691E;

    -fx-binary-expression-block-background: #B060D0;
    -fx-binary-expression-block-border: #9040E0;

    -fx-identifier-block-background: #A9A9A9;
    -fx-identifier-block-border: #696969;

    -fx-literal-block-background: #FF80C0;
    -fx-literal-block-border: #C03090;

    -fx-print-block-background: #3090E0;
    -fx-print-block-border: #2020C0;

    -fx-variable-declaration-block-background: #50C050;
    -fx-variable-declaration-block-border: #408040;

    -fx-if-body-background: #FFB34D;
    -fx-main-body-background: #B20000;

    -fx-declare-int-block-background: #4682B4; /* SteelBlue */
    -fx-declare-int-block-border: #4169E1; /* RoyalBlue */

    -fx-declare-double-block-background: #20B2AA; /* LightSeaGreen */
    -fx-declare-double-block-border: #008B8B; /* DarkCyan */

    -fx-declare-boolean-block-background: #9370DB; /* MediumPurple */
    -fx-declare-boolean-block-border: #8A2BE2; /* BlueViolet */

    -fx-declare-string-block-background: #DAA520; /* GoldenRod */
    -fx-declare-string-block-border: #B8860B; /* DarkGoldenRod */
}

.button {
    -fx-background-color: #e0e0e0;
    -fx-text-fill: black;
    -fx-background-radius: 4;
    -fx-font-weight: bold;
}

.button:hover {
    -fx-background-color: #d0d0d0;
}

.text-area {
    -fx-background-color: #ffffff;
    -fx-text-fill: black;
    -fx-border-color: #cccccc;
    -fx-border-radius: 4;
    -fx-font-weight: bold;
}

.scroll-pane {
    -fx-background-color: transparent;
}

.label {
    -fx-text-fill: black;
    -fx-font-weight: bold;
}

/* Light Theme */
.light-theme {
    -fx-background-color: #f4f4f4;
}

.light-theme .button {
    -fx-background-color: #e0e0e0;
    -fx-text-fill: black;
}

.light-theme .button:hover {
    -fx-background-color: #d0d0d0;
}

.light-theme .text-area {
    -fx-background-color: #ffffff;
    -fx-text-fill: black;
    -fx-border-color: #cccccc;
}

.light-theme .label {
    -fx-text-fill: black;
}

.light-theme #status-label {
    -fx-text-fill: #333333;
}

.light-theme .palette {
    -fx-background-color: #e8e8e8; /* Slightly lighter for distinction */
    -fx-border-color: #bbbbbb;
    -fx-border-width: 0 0 1 0;
}

.light-theme .palette-block-label {
    -fx-border-width: 1;
    -fx-border-radius: 4;
    -fx-background-radius: 4;
    -fx-padding: 6 10;
    -fx-text-fill: black;
    -fx-font-weight: bold;
    -fx-effect: dropshadow(gaussian, rgba(0,0,0,0.1), 5, 0, 0, 1); /* Subtle shadow */
}

.light-theme .palette-block-label:hover {
    -fx-border-width: 2px;
    -fx-padding: 5px 9px;
}

/* Specific palette label colors (matching block colors) */
.light-theme .palette-if-label {
    -fx-background-color: -fx-if-block-background;
    -fx-border-color: -fx-if-block-border;
}
.light-theme .palette-binaryexpression-label {
    -fx-background-color: -fx-binary-expression-block-background;
    -fx-border-color: -fx-binary-expression-block-border;
}
.light-theme .palette-identifier-label {
    -fx-background-color: -fx-identifier-block-background;
    -fx-border-color: -fx-identifier-block-border;
}
.light-theme .palette-literal-label {
    -fx-background-color: -fx-literal-block-background;
    -fx-border-color: -fx-literal-block-border;
}
.light-theme .palette-print-label {
    -fx-background-color: -fx-print-block-background;
    -fx-border-color: -fx-print-block-border;
}
.light-theme .palette-variable_declaration-label {
    -fx-background-color: -fx-variable-declaration-block-background;
    -fx-border-color: -fx-variable-declaration-block-border;
}
.light-theme .palette-declare_int-label {
    -fx-background-color: -fx-declare-int-block-background;
    -fx-border-color: -fx-declare-int-block-border;
}
.light-theme .palette-declare_double-label {
    -fx-background-color: -fx-declare-double-block-background;
    -fx-border-color: -fx-declare-double-block-border;
}
.light-theme .palette-declare_boolean-label {
    -fx-background-color: -fx-declare-boolean-block-background;
    -fx-border-color: -fx-declare-boolean-block-border;
}
.light-theme .palette-declare_string-label {
    -fx-background-color: -fx-declare-string-block-background;
    -fx-border-color: -fx-declare-string-block-border;
}


/* Block Styles (apply to both themes by default) */
.if-block {
    -fx-background-color: -fx-if-block-background;
    -fx-border-color: -fx-if-block-border;
    -fx-padding: 5;
    -fx-background-radius: 5;
    -fx-border-radius: 5;
    -fx-border-width: 1px;
}

.if-block:hover {
    -fx-border-width: 2px;
    -fx-padding: 4px;
}

.binary-expression-block {
    -fx-background-color: -fx-binary-expression-block-background;
    -fx-border-color: -fx-binary-expression-block-border;
    -fx-padding: 5;
    -fx-background-radius: 5;
    -fx-border-radius: 5;
    -fx-border-width: 1px;
}

.binary-expression-block:hover {
    -fx-border-width: 2px;
    -fx-padding: 4px;
}

.identifier-block {
    -fx-background-color: -fx-identifier-block-background;
    -fx-border-color: -fx-identifier-block-border;
    -fx-padding: 5;
    -fx-background-radius: 5;
    -fx-border-radius: 5;
    -fx-border-width: 1px;
}

.identifier-block:hover {
    -fx-border-width: 2px;
    -fx-padding: 4px;
}

.literal-block {
    -fx-background-color: -fx-literal-block-background;
    -fx-border-color: -fx-literal-block-border;
    -fx-padding: 5;
    -fx-background-radius: 5;
    -fx-border-radius: 5;
    -fx-border-width: 1px;
}

.literal-block:hover {
    -fx-border-width: 2px;
    -fx-padding: 4px;
}

.print-block {
    -fx-background-color: -fx-print-block-background;
    -fx-border-color: -fx-print-block-border;
    -fx-padding: 5;
    -fx-background-radius: 5;
    -fx-border-radius: 5;
    -fx-border-width: 1px;
}

.print-block:hover {
    -fx-border-width: 2px;
    -fx-padding: 4px;
}

.variable-declaration-block {
    -fx-background-color: -fx-variable-declaration-block-background;
    -fx-border-color: -fx-variable-declaration-block-border;
    -fx-padding: 5;
    -fx-background-radius: 5;
    -fx-border-radius: 5;
    -fx-border-width: 1px;
}

.variable-declaration-block:hover {
    -fx-border-width: 2px;
    -fx-padding: 4px;
}

/* Dark Theme specific overrides */
.dark-theme {
    -fx-background-color: #2b2b2b;
}

.dark-theme .button {
    -fx-background-color: #555555;
    -fx-text-fill: white;
}

.dark-theme .button:hover {
    -fx-background-color: #666666;
}

.dark-theme .text-area {
    -fx-background-color: #3c3f41;
    -fx-text-fill: #bbbbbb;
    -fx-border-color: #555555;
}

.dark-theme .text-area .content {
    -fx-background-color: #3c3f41;
}

.dark-theme .label {
    -fx-text-fill: white;
}

.dark-theme #status-label {
    -fx-text-fill: #aaaaaa;
}

.dark-theme .scroll-pane {
    -fx-background-color: #2b2b2b;
}

.dark-theme .palette {
    -fx-background-color: #222222 !important; /* Darker background for distinction */
    -fx-border-color: #444444;
    -fx-border-width: 0 0 1 0;
}

.dark-theme .palette-block-label {
    -fx-border-width: 1;
    -fx-border-radius: 4;
    -fx-background-radius: 4;
    -fx-padding: 6 10;
    -fx-text-fill: white;
    -fx-font-weight: bold;
    -fx-effect: dropshadow(gaussian, rgba(0,0,0,0.3), 5, 0, 0, 1); /* Subtle shadow */
}

.dark-theme .palette-block-label:hover {
    -fx-border-width: 2px;
    -fx-padding: 5px 9px;
}

/* Specific palette label colors (matching block colors) */
.dark-theme .palette-if-label {
    -fx-background-color: -fx-if-block-background;
    -fx-border-color: -fx-if-block-border;
}
.dark-theme .palette-binaryexpression-label {
    -fx-background-color: -fx-binary-expression-block-background;
    -fx-border-color: -fx-binary-expression-block-border;
}
.dark-theme .palette-identifier-label {
    -fx-background-color: -fx-identifier-block-background;
    -fx-border-color: -fx-identifier-block-border;
}
.dark-theme .palette-literal-label {
    -fx-background-color: -fx-literal-block-background;
    -fx-border-color: -fx-literal-block-border;
}
.dark-theme .palette-print-label {
    -fx-background-color: -fx-print-block-background;
    -fx-border-color: -fx-print-block-border;
}
.dark-theme .palette-variable_declaration-label {
    -fx-background-color: -fx-variable-declaration-block-background;
    -fx-border-color: -fx-variable-declaration-block-border;
}
.dark-theme .palette-declare_int-label {
    -fx-background-color: -fx-declare-int-block-background;
    -fx-border-color: -fx-declare-int-block-border;
}
.dark-theme .palette-declare_double-label {
    -fx-background-color: -fx-declare-double-block-background;
    -fx-border-color: -fx-declare-double-block-border;
}
.dark-theme .palette-declare_boolean-label {
    -fx-background-color: -fx-declare-boolean-block-background;
    -fx-border-color: -fx-declare-boolean-block-border;
}
.dark-theme .palette-declare_string-label {
    -fx-background-color: -fx-declare-string-block-background;
    -fx-border-color: -fx-declare-string-block-border;
}

/* Block Text Bolder and Bigger & Always Black */
/* General text within blocks */
.if-block .label,
.binary-expression-block .label,
.identifier-block .text,
.literal-block .text-field,
.print-block .text,
.variable-declaration-block .text,
.main-block-header {
    -fx-font-size: 1.1em; /* Slightly bigger */
    -fx-font-weight: bold; /* Bolder */
    -fx-text-fill: black; /* Always black */
}

/* Override for dark theme labels that are NOT inside blocks (e.g., status label) */
.dark-theme .label {
    -fx-text-fill: white;
}

/* Ensure text fields in literal blocks are black in light theme */
.light-theme .literal-block .text-field {
    -fx-text-fill: black;
}

/* Literal Block TextField in Dark Theme */
.dark-theme .literal-block .text-field {
    -fx-background-color: #4e4e4e; /* Darker background for TextField */
    -fx-text-fill: white; /* Changed to white */
    -fx-prompt-text-fill: #aaaaaa; /* Slightly darker for prompt text */
    -fx-highlight-fill: #007bff; /* Highlight color */
    -fx-highlight-text-fill: white;
    -fx-control-inner-background: #4e4e4e; /* For the actual editable area */
}

/* Body Block Separator */
.body-block-separator {
    -fx-min-height: 8;
    -fx-background-color: transparent; /* Light theme default */
}

.body-block {
    -fx-padding: 5px;
    -fx-background-radius: 5px;
}

.if-body {
    -fx-background-color: -fx-if-body-background !important;
}

.main-block .body-block {
    -fx-background-color: -fx-main-body-background;
}

.body-block.empty-body-drop-hover {
    -fx-background-color: yellow;
}

.dark-theme .body-block-separator {
    -fx-background-color: #444444; /* Dark gray for dark theme */
}

/* Main Block Styles */
.main-block {
    -fx-background-color: #8B0000;
    -fx-border-color: #B22222;
    -fx-border-width: 1;
    -fx-border-radius: 5;
    -fx-background-radius: 5;
}

.main-block-header {
    -fx-font-weight: bold;
    -fx-text-fill: black; /* Light theme default */
}

.dark-theme .main-block {
    -fx-background-color: #8B0000;
    -fx-border-color: #B22222;
}

.dark-theme .main-block-header {
    -fx-text-fill: #bbbbbb;
}

/* Context Menu Dark Theme */
.dark-theme .context-menu {
    -fx-background-color: #444;
    -fx-border-color: #666;
    -fx-border-width: 1px;
}

.dark-theme .menu-item .label {
    -fx-text-fill: white;
}

.dark-theme .menu-item:focused {
    -fx-background-color: #555;
}

.dark-theme .menu-item:focused .label {
    -fx-text-fill: white;
}

/* Block Text Color and Font Weight Override for Dark Theme */
.dark-theme .if-block .label,
.dark-theme .binary-expression-block .label,
.dark-theme .identifier-block .text,
.dark-theme .print-block .text,
.dark-theme .variable-declaration-block .text,
.dark-theme .main-block-header {
    -fx-text-fill: black;
    -fx-font-weight: bold;
}

.error-block {
    -fx-border-color: red !important;
    -fx-border-width: 2px !important;
    -fx-border-style: dashed !important;
}

/* Style for the blinking effect on an error block */
.error-block-blink {
    -fx-border-color: #FF0000 !important; /* Bright solid red */
    -fx-border-width: 3px !important;
    -fx-border-style: solid !important;
    -fx-effect: dropshadow(gaussian, #FF4444, 10, 0.5, 0, 0);
}

/* Styles for the new Error List View */
.error-cell {
    -fx-text-fill: #D32F2F; /* Red text for errors */
    -fx-font-weight: bold;
}

.warning-cell {
    -fx-text-fill: #FBC02D; /* Amber text for warnings */
}

.error-cell:selected, .warning-cell:selected {
    -fx-background-color: -fx-selection-bar;
    -fx-text-fill: -fx-selection-bar-text;
}

/* Interactive Type Label */
.type-label {
    -fx-background-color: #FFD700; /* Gold/Yellow */
    -fx-text-fill: #333333; /* Dark gray text */
    -fx-font-weight: bold;
    -fx-padding: 3 7 3 7;
    -fx-border-radius: 4;
    -fx-background-radius: 4;
    -fx-border-color: #FFA500; /* Orange border */
    -fx-border-width: 2; /* Thicker border */
    -fx-effect: dropshadow(gaussian, rgba(0,0,0,0.1), 3, 0, 0, 1); /* Subtle shadow always */
}

.type-label:hover {
    -fx-background-color: #FFC107; /* Slightly darker yellow on hover */
    -fx-border-color: #FF8C00; /* Darker orange on hover */
    -fx-effect: dropshadow(gaussian, rgba(0,0,0,0.3), 8, 0, 0, 1); /* More pronounced shadow on hover */
}

.dark-theme .type-label {
    -fx-background-color: #B8860B; /* Dark goldenrod */
    -fx-text-fill: #EEEEEE; /* Light gray text */
    -fx-border-color: #DAA520; /* Goldenrod border */
    -fx-border-width: 2;
    -fx-effect: dropshadow(gaussian, rgba(255,255,0,0.1), 3, 0, 0, 1);
}

.dark-theme .type-label:hover {
    -fx-background-color: #DAA520; /* Goldenrod on hover */
    -fx-border-color: #FFD700; /* Gold on hover */
    -fx-effect: dropshadow(gaussian, rgba(255,255,0,0.3), 8, 0, 0, 1);
}


